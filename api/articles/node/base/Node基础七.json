{"title":"Node基础七","uid":"9cc987ed6425e4445f09c1cfe9b13abf","slug":"node/base/Node基础七","date":"2022-10-01T04:27:50.000Z","updated":"2022-10-23T13:51:52.589Z","comments":true,"path":"api/articles/node/base/Node基础七.json","keywords":"chriswood blogs sharing","cover":[],"content":"<h2 id=\"七-脚手架开发\"><a href=\"#七-脚手架开发\" class=\"headerlink\" title=\"七.脚手架开发\"></a>七.脚手架开发</h2><p>目前前端工程化开发过程中，我们会使用各种各样的脚手架，vue-cli、create-react-app，当然也包括webpack、gulp、rollup、vite等工具。</p>\n<p>这些工具是怎么开发出来的呢？当我们执行一个命令时，它们做了什么事情？是怎么样完成的一系列操作？</p>\n<p>这里我开发了一个coderwhy的脚手架：一个帮助你快速搭建和开发前端项目的CLI。</p>\n<p>文档内容分成两部分：</p>\n<p>第一部分：coderwhy使用说明；</p>\n<p>第二部分：coderwhy脚手架开发过程；</p>\n<p>如何安装？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm install coderwhy -g</code></pre>\n\n<h3 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h3><h3 id=\"一-创建项目\"><a href=\"#一-创建项目\" class=\"headerlink\" title=\"一. 创建项目\"></a>一. 创建项目</h3><p>目前支持Vue，后期会支持React，Angular考虑中~</p>\n<p>vue项目模块已经帮你配置：</p>\n<ul>\n<li>常用的目录结构（你可以在此基础上修改）</li>\n<li>vue.config.js（其中配置了别名，你可以自行修改和配置更多）</li>\n<li>axios（网络请求axios的安装以及二次封装）</li>\n<li>vue-router（router的安装和配置，另外有路由的动态加载，后面详细说明）</li>\n<li>vuex（vuex的安装和配置，另外有动态加载子模块，后面详细说明）</li>\n</ul>\n<p>创建项目</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">coderwhy create your_project_name</code></pre>\n\n<p>自动拉取项目模板、安装项目依赖、打开浏览器 <code>http://localhost:8080/</code>、自动启动项目</p>\n<h3 id=\"二-项目开发\"><a href=\"#二-项目开发\" class=\"headerlink\" title=\"二. 项目开发\"></a>二. 项目开发</h3><p>项目开发目前提供三个功能：</p>\n<ul>\n<li>创建Vue组件</li>\n<li>创建Vue页面，并配置路由</li>\n<li>创建Vuex子模块</li>\n</ul>\n<h4 id=\"2-1-创建Vue组件：\"><a href=\"#2-1-创建Vue组件：\" class=\"headerlink\" title=\"2.1. 创建Vue组件：\"></a>2.1. 创建Vue组件：</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">coderwhy addcpn YourComponentName # 例如coderwhy add NavBar，默认会存放到src&#x2F;components文件夹中\ncoderwhy addcpn YourComponentName -d src&#x2F;pages&#x2F;home # 也可以指定存放的具体文件夹</code></pre>\n\n<h4 id=\"2-2-创建Vue页面，并配置路由\"><a href=\"#2-2-创建Vue页面，并配置路由\" class=\"headerlink\" title=\"2.2. 创建Vue页面，并配置路由\"></a>2.2. 创建Vue页面，并配置路由</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">coderwhy addpage YourPageName # 例如coderwhy addpage Home，默认会放到src&#x2F;pages&#x2F;home&#x2F;Home.vue中，并且会创建src&#x2F;page&#x2F;home&#x2F;router.js\ncoderwhy addpage YourPageName -d src&#x2F;views # 也可以指定文件夹，但需要手动集成路由</code></pre>\n\n<p>为什么会创建router.js文件：</p>\n<ul>\n<li><code>router.js</code>文件是路由的其中一个配置；</li>\n<li>创建该文件中 <code>src/router/index.js</code>中会自动加载到路由的 <code>routes</code>配置中，不需要手动配置了（如果是自己配置的文件夹需要手动配置）</li>\n</ul>\n<p><code>src/router/index.js</code>中已经完成如下操作：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 动态加载pages中所有的路由文件\nconst files &#x3D; require.context(&#39;@&#x2F;pages&#39;, true, &#x2F;router\\.js$&#x2F;);\nconst routes &#x3D; files.keys().map(key &#x3D;&gt; &#123;\n  const page &#x3D; require(&#39;@&#x2F;pages&#39; + key.replace(&#39;.&#39;, &#39;&#39;));\n  return page.default;\n&#125;)</code></pre>\n\n<h4 id=\"2-3-创建Vuex子模块\"><a href=\"#2-3-创建Vuex子模块\" class=\"headerlink\" title=\"2.3. 创建Vuex子模块\"></a>2.3. 创建Vuex子模块</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">coderwhy addstore YourVuexChildModuleName # 例如coderwhy addstore home，默认会放到src&#x2F;store&#x2F;modules&#x2F;home&#x2F;index.js和types.js\ncoderwhy addstore YourVuexChildModuleName -d src&#x2F;vuex&#x2F;modules # 也可以指定文件夹</code></pre>\n\n<p>创建完成后，不需要手动配置，已经动态将所有子模块集成进去：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 动态加载modules\nconst modules &#x3D; &#123;&#125;\nconst files &#x3D; require.context(&#39;.&#x2F;&#39;, true, &#x2F;index\\.js$&#x2F;);\nfiles.keys().filter(key &#x3D;&gt; &#123;\n  if (key &#x3D;&#x3D;&#x3D; &#39;.&#x2F;index.js&#39;) return false;\n  return true\n&#125;).map(key &#x3D;&gt; &#123;  \n  &#x2F;&#x2F; 获取名字\n  const modulePath &#x3D; key.replace(&#39;.&#x2F;modules&#x2F;&#39;, &#39;&#39;);\n  const moduleName &#x3D; modulePath.replace(&#39;&#x2F;index.js&#39;, &#39;&#39;);\n  const module &#x3D; require(&#96;$&#123;key&#125;&#96;);\n\n  modules[&#96;$&#123;moduleName&#125;&#96;] &#x3D; module.default;\n&#125;)</code></pre>\n\n<h2 id=\"脚手架开发过程\"><a href=\"#脚手架开发过程\" class=\"headerlink\" title=\"脚手架开发过程\"></a>脚手架开发过程</h2><h3 id=\"一-创建文件\"><a href=\"#一-创建文件\" class=\"headerlink\" title=\"一. 创建文件\"></a>一. 创建文件</h3><p>创建index.js</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(&quot;Hello Coderwhy&quot;)</code></pre>\n\n<p>创建package.json</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n  &quot;name&quot;: &quot;coderwhy&quot;,\n  &quot;version&quot;: &quot;1.1.0&quot;,\n  &quot;description&quot;: &quot;CLI front-end development tools&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;bin&quot;: &#123;\n    &quot;coderwhy&quot;: &quot;index.js&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [\n    &quot;vue&quot;,\n    &quot;react&quot;,\n    &quot;CLI&quot;,\n    &quot;component&quot;\n  ],\n  &quot;author&quot;: &quot;coderwhy&quot;,\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;,\n  &quot;repository&quot;: &#123;\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;chalk&quot;: &quot;^4.1.0&quot;,\n    &quot;commander&quot;: &quot;^6.1.0&quot;,\n    &quot;download-git-repo&quot;: &quot;^3.0.2&quot;,\n    &quot;ejs&quot;: &quot;^3.1.5&quot;,\n    &quot;open&quot;: &quot;^7.3.0&quot;\n  &#125;\n&#125;</code></pre>\n\n<p>最终的目录结构：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">├── LICENSE\n├── index.js\n├── lib\n│   ├── config\n│   │   └── repo_config.js\n│   ├── core\n│   │   ├── actions.js\n│   │   ├── create.js\n│   │   └── help.js\n│   ├── template\n│   │   ├── component.vue.ejs\n│   │   ├── vue-router.js.ejs\n│   │   ├── vue-store.js.ejs\n│   │   └── vue-types.js.ejs\n│   └── utils\n│       ├── file.js\n│       ├── log.js\n│       └── terminal.js\n├── package-lock.json\n├── package.json\n└── readme.md</code></pre>\n\n<h3 id=\"二-创建coderwhy的命令\"><a href=\"#二-创建coderwhy的命令\" class=\"headerlink\" title=\"二. 创建coderwhy的命令\"></a>二. 创建coderwhy的命令</h3><p>自动在你的环境变量中查找node</p>\n<p>注意：必须放在第一行</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#!&#x2F;usr&#x2F;bin&#x2F;env node</code></pre>\n\n<p>修改package.json</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;bin&quot;: &#123;\n  &quot;coderwhy&quot;: &quot;index.js&quot;\n&#125;</code></pre>\n\n<p>执行npm link</p>\n<h3 id=\"三-commander用法\"><a href=\"#三-commander用法\" class=\"headerlink\" title=\"三. commander用法\"></a>三. commander用法</h3><h4 id=\"3-1-定义版本号\"><a href=\"#3-1-定义版本号\" class=\"headerlink\" title=\"3.1. 定义版本号\"></a>3.1. 定义版本号</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">#!&#x2F;usr&#x2F;bin&#x2F;env node\nconst cmd &#x3D; require(&#39;commander&#39;);\n&#x2F;&#x2F; 定义显示模块的版本号\ncmd.version(require(&#39;.&#x2F;package.json&#39;).version);\n&#x2F;&#x2F; 解析终端指令\ncmd.parse(process.argv);</code></pre>\n\n<h4 id=\"3-2-给help增加其他选项\"><a href=\"#3-2-给help增加其他选项\" class=\"headerlink\" title=\"3.2. 给help增加其他选项\"></a>3.2. 给help增加其他选项</h4><p>添加单个选项</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">program.option(&#39;-s --src &lt;src&gt;&#39;, &#39;a source folder&#39;);\nprogram.option(&#39;-d --dest &lt;dest&gt;&#39;, &#39;a destination folder&#39;);\nprogram.option(&#39;-f --framework &lt;framework&gt;&#39;, &#39;your framework name&#39;);</code></pre>\n\n<p>监听help指令</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">program.on(&#39;--help&#39;, function() &#123;\n  console.log(&quot;&quot;);\n  console.log(&quot;usage&quot;);\n  console.log(&quot;   coderwhy -v&quot;);\n  console.log(&quot;   coderwhy -version&quot;);\n&#125;)</code></pre>\n\n<h3 id=\"四-创建项目指令\"><a href=\"#四-创建项目指令\" class=\"headerlink\" title=\"四. 创建项目指令\"></a>四. 创建项目指令</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 创建命令\nprogram\n  .command(&#39;create &lt;project&gt; [otherArgs...]&#39;)\n  .description(&#39;clone a repository into a newly created directory&#39;)\n  .action((project, otherArgs) &#x3D;&gt; &#123;\n    console.log(project);\n    console.log(otherArgs);\n   &#x2F;&#x2F; 调用封装的函数\n   createProject(project, otherArgs)\n  &#125;)</code></pre>\n\n<p>在actions中封装创建过程：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const downloadRepo &#x3D; promisify(require(&#39;download-git-repo&#39;));\n\nconst createProject &#x3D; async (project, otherArg) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 1.提示信息\n  console.log(&#39;coderwhy helps you create your project, please wait a moment~&#39;);\n\n  &#x2F;&#x2F; 2.clone项目从仓库\n  await downloadRepo(repoConfig.vueGitRepo, project, &#123; clone: true &#125;);\n\n  &#x2F;&#x2F; 3.执行终端命令npm install\n  &#x2F;&#x2F; terminal.exec(&#39;npm install&#39;, &#123;cwd: &#96;.&#x2F;$&#123;project&#125;&#96;&#125;);\n  const npm &#x3D; process.platform &#x3D;&#x3D;&#x3D; &#39;win32&#39; ? &#39;npm.cmd&#39; : &#39;npm&#39;;\n  await terminal.spawn(npm, [&#39;install&#39;], &#123; cwd: &#96;.&#x2F;$&#123;project&#125;&#96; &#125;);\n\n  &#x2F;&#x2F; 4.打开浏览器\n  open(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;&#39;);\n\n  &#x2F;&#x2F; 5.运行项目\n  await terminal.spawn(npm, [&#39;run&#39;, &#39;serve&#39;], &#123; cwd: &#96;.&#x2F;$&#123;project&#125;&#96; &#125;);\n&#125;</code></pre>\n\n<p>配置的Git地址如下：</p>\n<ul>\n<li>后续会开发一个设置自己地址的指令</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const vueGitRepo &#x3D; &quot;direct:https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;hy-vue-temp.git&quot;;\n\nmodule.exports &#x3D; &#123;\n  vueGitRepo\n&#125;</code></pre>\n\n<p>封装执行终端命令的过程：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const &#123; spawn, exec &#125; &#x3D; require(&#39;child_process&#39;);\n\nconst spawnCommand &#x3D; (...args) &#x3D;&gt; &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    const childProcess &#x3D; spawn(...args);\n    childProcess.stdout.pipe(process.stdout);\n    childProcess.stderr.pipe(process.stderr);\n    childProcess.on(&#39;close&#39;, () &#x3D;&gt; &#123;\n      resolve();\n    &#125;);\n  &#125;)\n&#125;</code></pre>\n\n<h4 id=\"process和child-process使用\"><a href=\"#process和child-process使用\" class=\"headerlink\" title=\"process和child_process使用\"></a><strong>process和child_process使用</strong></h4><h5 id=\"process\"><a href=\"#process\" class=\"headerlink\" title=\"process\"></a>process</h5><p>在Node.js中每个应用程序都是一个进程类的实例对象。使用process对象代表应用程序,这是一个全局对象，可以通过它来获取Node.jsy应用程序以及运行该程序的用户、环境等各种信息的属性、方法和事件</p>\n<p>进程中几个重要的属性</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">stdin 标准输入可读流\nstdout 标准输入可写流\nstderr 标准错误输出流\nargv 终端输入参数数组\nenv 操作系统环境信息\npid 应用程序进程id</code></pre>\n\n<p>进程方法</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">process.memoryUsage() 查看内存使用信息\nprocess.nextTick() 当前eventloop执行完毕执行回调函数\nprocess.chdir() chdir方法用于修改Node.js应用程序中使用的当前工作目录\nprocess.cwd() 进程当前工作目录\nprocess.kill() 杀死进程\nprocess.uncaughtException() 当应用程序抛出一个未被捕获的异常时触发进程对象的uncaughtException事件</code></pre>\n\n<h5 id=\"child-process\"><a href=\"#child-process\" class=\"headerlink\" title=\"child_process\"></a>child_process</h5><p>在Node.js中，提供了一个child_process模块,通过它可以开启多个子进程，在多个子进程之间可以共享内存空间，可以通过子进程的互相通信来实现信息的交换,child_process模块给予node任意创建子进程的能力，node官方文档对于child_proces模块给出了四种方法，映射到操作系统其实都是创建子进程。但对于开发者而已，这几种方法的api有点不同</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">child_process.exec(command[, options][, callback]) 启动子进程来执行shell命令,可以通过回调参数来获取脚本shell执行结果\nchild_process.execfile(file[, args][, options][, callback]) 与exec类型不同的是，它执行的不是shell命令而是一个可执行文件\nchild_process.spawn(command[, args][, options])仅仅执行一个shell命令，不需要获取执行结果\\\nchild_process.fork(modulePath[, args][, options]) 可以用node执行的.js文件，也不需要获取执行结果。fork出来的子进程一定是node进程</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;exec用法:\n&#x2F;&#x2F;执行shell脚本, 使用管道符也是可以的\n&#x2F;&#x2F;exec也是可以执行文件的，只不过不能传参数\n&#x2F;&#x2F;适合开销比较小的任务\nconst cp &#x3D; require(&#39;child_process&#39;)\ncp.exec(&#39;ls -al|grep node_modules&#39;, &#123; \n  timeout: 0, &#x2F;&#x2F; 超时时间\n  cwd: process.cwd(), &#x2F;&#x2F; 可以改变当前的执行路径\n  &#125;, function (err, stdout, stderr) &#123;\n  &#x2F;&#x2F; 执行结果\n&#125;)\n\n&#x2F;&#x2F;execFile用法:\n&#x2F;&#x2F;可以执行文件，也可以执行语句，可传参\n&#x2F;&#x2F;适合开销比较小的任务\n&#x2F;&#x2F; 执行文件,参数\ncp.execFile(&#39;ls&#39;, [&#39;-al&#39;], function (err, stdout, std,err) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 执行结果\n&#125;)\n&#x2F;&#x2F; 让execFile执行ls -al|grep node_modules这种语句\n&#x2F;&#x2F;test.shell:\n  ls -al|grep node_modules\n  echo $1 &#x2F;&#x2F; 打印参数\n  echo $2\n&#x2F;&#x2F;index.js:\ncp.execFile(path.resolve(__dirname, &#39;test.shell&#39;), [&#39;-al&#39;, &#39;bl&#39;], \nfunction(err,   stdout, stderr) &#123;\n&#125;)\n\n&#x2F;&#x2F;fork用法\n&#x2F;&#x2F;用node执行, 耗时操作且用node实现，如下载文件\n\n&#x2F;&#x2F; cp.fork(模块路径)\n&#x2F;&#x2F; 和require一样把文件执行起来\nconst child &#x3D; cp.fork(path.resolve(__dirname, &#39;child_process_demo&#39;))\nconsole.log(process.pid)\n&#x2F;&#x2F; 主进程向子进程通信\nchild.send(&#39;hello child_process&#39;, () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; child.disconnent() &#x2F;&#x2F; 如果不断开，两边会出现等待的情况\n&#125;)\n&#x2F;&#x2F; 子进程向主进程通信\nchild.on(&#39;message&#39;, msg &#x3D;&gt; &#123;\n  \n&#125;)\n\n&#x2F;&#x2F; child_process_demo.js:\nconsole.log(&#39;aaa&#39;, process.pid)\nprocess.on(&#39;message&#39;, msg &#x3D;&gt; &#123;\n  console.log(msg)\n  &#x2F;&#x2F; 很容易出现死循环\n&#125;)\nprocess.send(&#39;send msg to parent&#39;)\n&#x2F;&#x2F; 进程不一样,完全独立，本质也是调用spawn\n\n\n&#x2F;&#x2F;spawn 用法\n&#x2F;&#x2F;spawn: 流式的，没有回调，适合耗时任务(比如：npm install), 需要不断打印日志(不断给用户输出日志\ncp.spawn(file, args, options) &#x2F;&#x2F; 不支持回调, exec,execFile底层都是spwan\nconst childProcess &#x3D; cp.spawn(path.resolve(__dirname, &#39;test.shell&#39;), [&#39;-al&#39;, &#39;-bl&#39;], &#123;\n  cwd: path.resolve(&#39;..&#39;),\n&#125;) &#x2F;&#x2F; 返回的是子进程\nconsole.log(childProcess.pid, childProcess.pid)\n&#x2F;&#x2F; 监听成功\nchildProcess.stdout.on(&#39;data&#39;, function(chunk) &#123;\n  console.log(chunk.toString())\n&#125;)\n&#x2F;&#x2F; 监听失败\nchildProcess.stderr.on(&#39;data&#39;, function(chunk) &#123;\n  console.log(chunk.toString())\n&#125;)\n\nconst code &#x3D; &#96;require(&#39;$&#123;rootFile&#125;&#39;).call(null, $&#123;JSON.stringify(args)&#125;)&#96;\n &#x2F;&#x2F; cp.spawn(&#39;cmd&#39;, [&#39;&#x2F;c&#39;, &#39;node&#39;, &#39;-e&#39;, code]) &#x2F;&#x2F; win下是这种结构\n const childProcess &#x3D; spawn(&#39;node&#39;, [&#39;-e&#39;, code], &#123;\n   cwd: process.cwd(), &#x2F;&#x2F; 当前执行未知的cwd\n   stdio: &#39;inherit&#39;, &#x2F;&#x2F; 默认是pipe,pipe必须通过on来接收信息，inherit不需要，实时反馈\n &#125;)\n childProcess.on(&#39;error&#39;, e &#x3D;&gt; &#123;\n   log.error(e.message)\n   process.exit(1)\n &#125;)\nchildProcess.on(&#39;exit&#39;, e &#x3D;&gt; &#123;\n  log.verbose(&#39;命令执行成功&#39;, e)\n  process.exit(e)\n&#125;)</code></pre>\n\n\n\n<h3 id=\"五-添加组件指令\"><a href=\"#五-添加组件指令\" class=\"headerlink\" title=\"五. 添加组件指令\"></a>五. 添加组件指令</h3><h4 id=\"5-1-封装ejs模板\"><a href=\"#5-1-封装ejs模板\" class=\"headerlink\" title=\"5.1. 封装ejs模板\"></a>5.1. 封装ejs模板</h4><p>组件模块如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;%_ if(data) &#123; _%&gt;\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&lt;%&#x3D; data.lowerName %&gt;&quot;&gt;\n    &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n  export default &#123;\n    name: &quot;&lt;%&#x3D; data.name %&gt;&quot;,\n    components: &#123;\n\n    &#125;,\n    mixins: [],\n    props: &#123;\n\n    &#125;,\n    data: function() &#123;\n      return &#123;\n        message: &quot;Hello &lt;%&#x3D; data.name %&gt;&quot;\n      &#125;\n    &#125;,\n    created: function() &#123;\n\n    &#125;,\n    mounted: function() &#123;\n\n    &#125;,\n    computed: &#123;\n\n    &#125;,\n    methods: &#123;\n\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n  .&lt;%&#x3D; data.lowerName %&gt; &#123;\n    \n  &#125;\n&lt;&#x2F;style&gt;\n\n&lt;%_ &#125; _%&gt;</code></pre>\n\n<p>路由模板：</p>\n<ul>\n<li>组件模板，直接使用上面的即可</li>\n<li>router.js模板</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;%_ if (data) &#123; _%&gt;\n&#x2F;&#x2F; 普通加载路由\n&#x2F;&#x2F; import &lt;%&#x3D; data.name %&gt; from &#39;.&#x2F;&lt;%&#x3D; data.name %&gt;.vue&#39;\n&#x2F;&#x2F; 懒加载路由\nconst &lt;%&#x3D; data.name %&gt; &#x3D; () &#x3D;&gt; import(&#39;.&#x2F;&lt;%&#x3D; data.name %&gt;.vue&#39;)\nexport default &#123;\n  path: &#39;&#x2F;&lt;%&#x3D; data.lowerName %&gt;&#39;,\n  name: &#39;&lt;%&#x3D; data.name %&gt;&#39;,\n  component: &lt;%&#x3D; data.name %&gt;,\n  children: [\n  ]\n&#125;\n&lt;%_ &#125; _%&gt;</code></pre>\n\n<p>vuex模块的模板</p>\n<ul>\n<li>index.js模板</li>\n<li>types.js模板</li>\n</ul>\n<p>index.js模块</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import * as types from &#39;.&#x2F;types.js&#39;\nexport default &#123;\n  namespaced: true,\n  state: &#123;\n  &#125;,\n  mutations: &#123;\n  &#125;,\n  actions: &#123;\n  &#125;,\n  getters: &#123;\n  &#125;\n&#125;</code></pre>\n\n<p>types.js模块</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">export &#123;\n  \n&#125;</code></pre>\n\n<h4 id=\"5-2-封装ejs解析\"><a href=\"#5-2-封装ejs解析\" class=\"headerlink\" title=\"5.2. 封装ejs解析\"></a>5.2. 封装ejs解析</h4><p>封装ejs的编译过程：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const ejsCompile &#x3D; (templatePath, data&#x3D;&#123;&#125;, options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    ejs.renderFile(templatePath, &#123;data&#125;, options, (err, str) &#x3D;&gt; &#123;\n      if (err) &#123;\n        reject(err);\n        return;\n      &#125;\n      resolve(str);\n    &#125;)\n  &#125;)\n&#125;</code></pre>\n\n<p>封装创建文件夹的过程：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const mkdirSync &#x3D; (dirname) &#x3D;&gt; &#123;\n  if (fs.existsSync(dirname)) &#123;\n    return true\n  &#125; else &#123;\n    &#x2F;&#x2F; 不存在,判断父亲文件夹是否存在？\n    if (mkdirSync(path.dirname(dirname))) &#123;\n      &#x2F;&#x2F; 存在父亲文件，就直接新建该文件\n      fs.mkdirSync(dirname)\n      return true\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p>封装写入文件的过程：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const writeFile &#x3D; (path, content) &#x3D;&gt; &#123;\n  if (fs.existsSync(path)) &#123;\n    log.error(&quot;the file already exists~&quot;)\n    return;\n  &#125;\n  return fs.promises.writeFile(path, content);\n&#125;</code></pre>\n\n<p>封装ejs到文件的转化过程：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const handleEjsToFile &#x3D; async (name, dest, template, filename) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 1.获取模块引擎的路径\n  const templatePath &#x3D; path.resolve(__dirname, template);\n  const result &#x3D; await ejsCompile(templatePath, &#123;name, lowerName: name.toLowerCase()&#125;);\n\n  &#x2F;&#x2F; 2.写入文件中\n  &#x2F;&#x2F; 判断文件不存在,那么就创建文件\n  mkdirSync(dest);\n  const targetPath &#x3D; path.resolve(dest, filename);\n  writeFile(targetPath, result);\n&#125;</code></pre>\n\n<h4 id=\"5-3-创建添加指令\"><a href=\"#5-3-创建添加指令\" class=\"headerlink\" title=\"5.3. 创建添加指令\"></a>5.3. 创建添加指令</h4><p>添加指令</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">program\n  .command(&#39;addcpn &lt;name&gt;&#39;)\n  .description(&#39;add vue component, 例如: coderwhy addcpn NavBar [-d src&#x2F;components]&#39;)\n  .action(name &#x3D;&gt; addComponent(name, program.dest || &#39;src&#x2F;components&#39;))\n\nprogram\n  .command(&#39;addpage &lt;name&gt;&#39;)\n  .description(&#39;add vue page, 例如: coderwhy addpage Home [-d dest]&#39;)\n  .action(name &#x3D;&gt; &#123;\n  addPage(name, program.dest || &#96;src&#x2F;pages&#x2F;$&#123;name.toLowerCase()&#125;&#96;)\n&#125;)\n\nprogram\n  .command(&#39;addstore &lt;name&gt;&#39;)\n  .description(&#39;add vue store, 例如: coderwhy addstore favor [-d dest]&#39;)\n  .action(name &#x3D;&gt; &#123;\n  addStore(name, program.dest || &#96;src&#x2F;store&#x2F;modules&#x2F;$&#123;name.toLowerCase()&#125;&#96;)\n&#125;)</code></pre>\n\n<p>封装对应的action</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const addComponent &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;component.vue.ejs&#39;, &#96;$&#123;name&#125;.vue&#96;);\n&#125;\n\nconst addPage &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  addComponent(name, dest);\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-router.js.ejs&#39;, &#39;router.js&#39;)\n&#125;\n\nconst addStore &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-store.js.ejs&#39;, &#39;index.js&#39;)\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-types.js.ejs&#39;, &#39;types.js&#39;)\n&#125;</code></pre>\n\n<h3 id=\"六-发布工具\"><a href=\"#六-发布工具\" class=\"headerlink\" title=\"六. 发布工具\"></a>六. 发布工具</h3><p>注册npm账号：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/\">https://www.npmjs.com/</a></li>\n<li>选择sign up</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuvsfCKCtp2lQ6qFNLhNLWZicFXVpMZmib38NiaDoibicwJyAY4TJOGiaGHtMicVRibkb1zkwYFtAZsPgKma1Q/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">sign up注册</p>\n<p>在命令行登录：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm login\n# 输入账号、密码、邮箱</code></pre>\n\n<p>修改好package.json文件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;keywords&quot;: [\n  &quot;vue&quot;,\n  &quot;react&quot;,\n  &quot;CLI&quot;,\n  &quot;component&quot;\n],\n&quot;author&quot;: &quot;coderwhy&quot;,\n&quot;license&quot;: &quot;MIT&quot;,\n&quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;,\n&quot;repository&quot;: &#123;\n  &quot;type&quot;: &quot;git&quot;,\n  &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;\n&#125;,</code></pre>\n\n<p>发布到npm registry中</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm publish</code></pre>\n\n<p>更新registry</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 1.修改版本号(最好符合semver规范)\n# 2.重新发布</code></pre>\n\n<p>删除发布的包：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm unpublish</code></pre>\n\n<p>过期发布的包：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm deprecate</code></pre>\n","text":"七.脚手架开发目前前端工程化开发过程中，我们会使用各种各样的脚手架，vue-cli、create-react-app，当然也包括webpack、gulp、rollup、vite等工具。 这些工具是怎么开发出来的呢？当我们执行一个命令时，它们做了什么事情？是怎么样完成的一系列操作？...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%83-%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">七.脚手架开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">使用说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">一. 创建项目</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">二. 项目开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E5%88%9B%E5%BB%BAVue%E7%BB%84%E4%BB%B6%EF%BC%9A\"><span class=\"toc-text\">2.1. 创建Vue组件：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E5%88%9B%E5%BB%BAVue%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%B9%B6%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">2.2. 创建Vue页面，并配置路由</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E5%88%9B%E5%BB%BAVuex%E5%AD%90%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">2.3. 创建Vuex子模块</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">脚手架开发过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">一. 创建文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E5%88%9B%E5%BB%BAcoderwhy%E7%9A%84%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">二. 创建coderwhy的命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89-commander%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">三. commander用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E5%AE%9A%E4%B9%89%E7%89%88%E6%9C%AC%E5%8F%B7\"><span class=\"toc-text\">3.1. 定义版本号</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E7%BB%99help%E5%A2%9E%E5%8A%A0%E5%85%B6%E4%BB%96%E9%80%89%E9%A1%B9\"><span class=\"toc-text\">3.2. 给help增加其他选项</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">四. 创建项目指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#process%E5%92%8Cchild-process%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">process和child_process使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#process\"><span class=\"toc-text\">process</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#child-process\"><span class=\"toc-text\">child_process</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94-%E6%B7%BB%E5%8A%A0%E7%BB%84%E4%BB%B6%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">五. 添加组件指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-%E5%B0%81%E8%A3%85ejs%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">5.1. 封装ejs模板</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-%E5%B0%81%E8%A3%85ejs%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">5.2. 封装ejs解析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-3-%E5%88%9B%E5%BB%BA%E6%B7%BB%E5%8A%A0%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">5.3. 创建添加指令</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD-%E5%8F%91%E5%B8%83%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">六. 发布工具</span></a></li></ol></li></ol>","author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Node基础八","uid":"adefcce4d4f2d80811a82b2ac8c91417","slug":"node/base/Node基础八","date":"2022-10-01T04:28:50.000Z","updated":"2022-10-23T13:51:52.589Z","comments":true,"path":"api/articles/node/base/Node基础八.json","keywords":"chriswood blogs sharing","cover":[],"text":"八. 深入事件循环事件循环是什么？事实上我把事件循环理解成我们编写的JavaScript和浏览器或者Node之间的一个桥梁。 浏览器的事件循环是一个我们编写的JavaScript代码和浏览器API调用(setTimeout&#x2F;AJAX&#x2F;监听事件等)的一个桥梁, ...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Node基础六","uid":"2625758c12baaaa025e1a25440bca02f","slug":"node/base/Node基础六","date":"2022-10-01T04:26:50.000Z","updated":"2022-10-23T13:51:52.589Z","comments":true,"path":"api/articles/node/base/Node基础六.json","keywords":"chriswood blogs sharing","cover":[],"text":"六.Buffer的使用1.1. 数据的二进制计算机中所有的内容：文字、数字、图片、音频、视频最终都会使用二进制来表示。 JavaScript可以直接去处理非常直观的数据：比如字符串，我们通常展示给用户的也是这些内容。 不对啊，JavaScript不是也可以处理图片吗？ 事实上在网...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}