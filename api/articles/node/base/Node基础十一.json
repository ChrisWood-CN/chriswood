{"title":"Node基础十一","uid":"52153482f8bb5490978c774dade2918c","slug":"node/base/Node基础十一","date":"2022-10-01T04:31:50.000Z","updated":"2023-02-08T04:57:08.161Z","comments":true,"path":"api/articles/node/base/Node基础十一.json","keywords":"chriswood blogs sharing","cover":[],"content":"<h2 id=\"十一-koa开发web服务器\"><a href=\"#十一-koa开发web服务器\" class=\"headerlink\" title=\"十一.koa开发web服务器\"></a>十一.koa开发web服务器</h2><h2 id=\"Koa初体验\"><a href=\"#Koa初体验\" class=\"headerlink\" title=\"Koa初体验\"></a>Koa初体验</h2><h3 id=\"1-1-认识Koa\"><a href=\"#1-1-认识Koa\" class=\"headerlink\" title=\"1.1. 认识Koa\"></a>1.1. 认识Koa</h3><p>前面我们已经学习了express，另外一个非常流行的Node Web服务器框架就是Koa。</p>\n<p>Koa官方的介绍：</p>\n<ul>\n<li>koa：next generation web framework for node.js；</li>\n<li>koa：node.js的下一代web框架；</li>\n</ul>\n<p>事实上，koa是express同一个团队开发的一个新的Web框架：</p>\n<ul>\n<li>目前团队的核心开发者TJ的主要精力也在维护Koa，express已经交给团队维护了；</li>\n<li>Koa旨在为Web应用程序和API提供更小、更丰富和更强大的能力；</li>\n<li>相对于express具有更强的异步处理能力（后续我们再对比）；</li>\n<li>Koa的核心代码只有1600+行，是一个更加轻量级的框架，我们可以根据需要安装和使用中间件；</li>\n</ul>\n<h3 id=\"1-2-koa初体验\"><a href=\"#1-2-koa初体验\" class=\"headerlink\" title=\"1.2. koa初体验\"></a>1.2. koa初体验</h3><p>因为学习过了express，它们的基本开发模式是比较相似的。</p>\n<p>我们来体验一下koa的Web服务器：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(&quot;middleware 01&quot;);\n  next();\n&#125;)\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(&quot;middleware 02&quot;);\n  ctx.response.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动成功~&quot;);\n&#125;);</code></pre>\n\n<p>koa注册的中间件提供了两个参数：</p>\n<ul>\n<li><p>ctx：上下文（Context）对象；</p>\n</li>\n<li><ul>\n<li>koa并没有像express一样，将req和res分开，而是将它们作为ctx的属性；</li>\n</ul>\n</li>\n<li><p>ctx代表依次请求的上下文对象；</p>\n</li>\n<li><p><code>ctx.request</code>：获取请求对象；</p>\n</li>\n<li><p><code>ctx.response</code>：获取响应对象；</p>\n</li>\n<li><p>next：本质上是一个dispatch，类似于之前的next；</p>\n</li>\n<li><ul>\n<li>后续我们学习Koa的源码，来看一下它是一个怎么样的函数；</li>\n</ul>\n</li>\n</ul>\n<p>koa通过创建的app对象，注册中间件只能通过use方法：</p>\n<ul>\n<li>Koa并没有提供methods的方式来注册中间件；</li>\n<li>也没有提供path中间件来匹配路径；</li>\n</ul>\n<p>但是真实开发中我们如何将路径和method分离呢？</p>\n<ul>\n<li>方式一：根据request自己来判断；</li>\n<li>方式二：使用第三方路由中间件；</li>\n</ul>\n<p>方式一：根据request自己判断</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">app.use((ctx, next) &#x3D;&gt; &#123;\n  if (ctx.request.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;users&#39;) &#123;\n    if (ctx.request.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      ctx.response.body &#x3D; &quot;Create User Success~&quot;;\n    &#125; else &#123;\n      ctx.response.body &#x3D; &quot;Users List~&quot;;\n    &#125;\n  &#125; else &#123;\n    ctx.response.body &#x3D; &quot;Other Request Response&quot;;\n  &#125;\n&#125;)</code></pre>\n\n<p>整个代码的逻辑是非常复杂和混乱的，真实开发中我们会使用路由。</p>\n<h3 id=\"1-3-路由的使用\"><a href=\"#1-3-路由的使用\" class=\"headerlink\" title=\"1.3. 路由的使用\"></a>1.3. 路由的使用</h3><p>koa官方并没有给我们提供路由的库，我们可以选择第三方库：koa-router</p>\n<h4 id=\"1-3-1-安装koa-router\"><a href=\"#1-3-1-安装koa-router\" class=\"headerlink\" title=\"1.3.1. 安装koa-router\"></a>1.3.1. 安装koa-router</h4><p>因为是第三方的库，所以我们需要单独下项目中安装：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm install koa-router</code></pre>\n\n<h4 id=\"1-3-2-koa-router基本使用\"><a href=\"#1-3-2-koa-router基本使用\" class=\"headerlink\" title=\"1.3.2. koa-router基本使用\"></a>1.3.2. koa-router基本使用</h4><p>我们可以先封装一个 <code>user.router.js</code> 的文件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const Router &#x3D; require(&#39;koa-router&#39;);\n\nconst userRouter &#x3D; new Router();\n\nuserRouter.get(&#39;&#x2F;users&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;user list~&quot;;\n&#125;);\n\nuserRouter.post(&#39;&#x2F;users&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;create user info~&quot;;\n&#125;);\n\nmodule.exports &#x3D; userRouter;</code></pre>\n\n<p>在app中将<code>router.routes()</code>注册为中间件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">app.use(userRouter.routes());\napp.use(userRouter.allowedMethods());</code></pre>\n\n<p>注意：<code>allowedMethods</code>用于判断<code>某一个method</code>是否支持：</p>\n<ul>\n<li>如果我们请求 get，那么是正常的请求，因为我们有实现get；</li>\n<li>如果我们请求 put、delete、patch，那么就自动报错：<code>Method Not Allowed</code>，状态码：405；</li>\n<li>如果我们请求 link、copy、lock，那么就自动报错：<code>Not Implemented</code>，状态码：501；</li>\n</ul>\n<h4 id=\"1-3-3-router的前缀\"><a href=\"#1-3-3-router的前缀\" class=\"headerlink\" title=\"1.3.3. router的前缀\"></a>1.3.3. router的前缀</h4><p>通常一个路由对象是对一组相似路径的封装，那么路径的前缀都是一直的，所以我们可以直接在创建Router时，添加前缀：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const userRouter &#x3D; new Router(&#123;prefix: &#39;&#x2F;users&#39;&#125;);\n\nuserRouter.get(&#39;&#x2F;&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;user list~&quot;;\n&#125;);\n\nuserRouter.post(&#39;&#x2F;&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;create user info~&quot;;\n&#125;);\n\nmodule.exports &#x3D; userRouter;</code></pre>\n\n<h3 id=\"1-4-请求解析\"><a href=\"#1-4-请求解析\" class=\"headerlink\" title=\"1.4. 请求解析\"></a>1.4. 请求解析</h3><p>客户端传递到服务器参数的方法常见的是5种：</p>\n<ul>\n<li>方式一：通过get请求中的URL的params；</li>\n<li>方式二：通过get请求中的URL的query；</li>\n<li>方式三：通过post请求中的body的json格式；</li>\n<li>方式四：通过post请求中的body的x-www-form-urlencoded格式；</li>\n<li>方式五：通过post请求中的form-data格式；</li>\n</ul>\n<h4 id=\"1-4-1-方式一：params\"><a href=\"#1-4-1-方式一：params\" class=\"headerlink\" title=\"1.4.1. 方式一：params\"></a>1.4.1. 方式一：params</h4><p>请求地址：<a href=\"http://localhost:8000/users/123\">http://localhost:8000/users/123</a></p>\n<p>获取params：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const userRouter &#x3D; new Router(&#123;prefix: &quot;&#x2F;users&quot;&#125;)\n\nuserRouter.get(&quot;&#x2F;:id&quot;, (ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.params.id);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)</code></pre>\n\n<h4 id=\"1-4-2-方式二：query\"><a href=\"#1-4-2-方式二：query\" class=\"headerlink\" title=\"1.4.2. 方式二：query\"></a>1.4.2. 方式二：query</h4><p>请求地址：<a href=\"http://localhost:8000/login?username=why&amp;password=123\">http://localhost:8000/login?username=why&amp;password=123</a></p>\n<p>获取query：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">app.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.query);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)</code></pre>\n\n<h4 id=\"1-4-3-方式三：json\"><a href=\"#1-4-3-方式三：json\" class=\"headerlink\" title=\"1.4.3. 方式三：json\"></a>1.4.3. 方式三：json</h4><p>请求地址：<a href=\"http://localhost:8000/login\">http://localhost:8000/login</a></p>\n<p>body是json格式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n    &quot;username&quot;: &quot;coderwhy&quot;,\n    &quot;password&quot;: &quot;123&quot;\n&#125;</code></pre>\n\n<p>获取json数据：</p>\n<ul>\n<li>安装依赖：<code>npm install koa-bodyparser</code>;</li>\n<li>使用 <code>koa-bodyparser</code>的中间件；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">app.use(bodyParser());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)</code></pre>\n\n<h4 id=\"1-4-4-方式四：x-www-form-urlencoded\"><a href=\"#1-4-4-方式四：x-www-form-urlencoded\" class=\"headerlink\" title=\"1.4.4. 方式四：x-www-form-urlencoded\"></a>1.4.4. 方式四：x-www-form-urlencoded</h4><p>请求地址：<a href=\"http://localhost:8000/login\">http://localhost:8000/login</a></p>\n<p>body是x-www-form-urlencoded格式：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXusUoicD7NHXV5rLv2RQouhMqM41ZibicHx6BfUYLjkQic0jIVBjkwr5gib3vPBhIUBZlLicjUwruFLAfqnQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">x-www-form-urlencoded</p>\n<p>获取json数据：(和json是一致的)</p>\n<ul>\n<li>安装依赖：<code>npm install koa-bodyparser</code>;</li>\n<li>使用 <code>koa-bodyparser</code>的中间件；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">app.use(bodyParser());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)</code></pre>\n\n<h4 id=\"1-4-5-方式五：form-data\"><a href=\"#1-4-5-方式五：form-data\" class=\"headerlink\" title=\"1.4.5. 方式五：form-data\"></a>1.4.5. 方式五：form-data</h4><p>请求地址：<a href=\"http://localhost:8000/login\">http://localhost:8000/login</a></p>\n<p>body是form-data格式：</p>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\">form-data</p>\n<p>解析body中的数据，我们需要使用multer</p>\n<ul>\n<li>安装依赖：<code>npm install koa-multer</code>;</li>\n<li>使用 <code>multer</code>中间件；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const upload &#x3D; multer(&#123;\n&#125;);\n\napp.use(upload.any());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.req.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;);</code></pre>\n\n<p>我们知道multer还可以实现文件的上传：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const storage &#x3D; multer.diskStorage(&#123;\n  destination: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, &quot;.&#x2F;uploads&#x2F;&quot;)\n  &#125;,\n  filename: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, Date.now() + path.extname(file.originalname))\n  &#125;\n&#125;)\n\nconst upload &#x3D; multer(&#123;\n  storage\n&#125;);\n\nconst fileRouter &#x3D; new Router();\n\nfileRouter.post(&quot;&#x2F;upload&quot;, upload.single(&#39;avatar&#39;), (ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.req.file);\n&#125;)\n\napp.use(fileRouter.routes());</code></pre>\n\n<h3 id=\"1-5-响应方式\"><a href=\"#1-5-响应方式\" class=\"headerlink\" title=\"1.5. 响应方式\"></a>1.5. 响应方式</h3><p><strong>输出结果：body</strong></p>\n<p>将响应主体设置为以下之一：</p>\n<ul>\n<li><code>string</code> ：字符串数据</li>\n<li><code>Buffer</code> ：Buffer数据</li>\n<li><code>Stream</code> ：流数据</li>\n<li><code>Object</code>|| <code>Array</code>：对象或者数组</li>\n<li><code>null</code> ：不输出任何内容</li>\n</ul>\n<p>如果<code>response.status</code>尚未设置，Koa会自动将状态设置为<code>200</code>或<code>204</code>。</p>\n<p>比较常见的输出方式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ctx.response.body &#x3D; &quot;Hello World&quot;;\nctx.body &#x3D; &#123;\n  name: &quot;why&quot;,\n  age: 18,\n  height: 1.88\n&#125;;\nctx.body &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</code></pre>\n\n<p>疑惑：<code>ctx.response.body</code>和<code>ctx.body</code>之间的区别：</p>\n<ul>\n<li>事实上，我们访问ctx.body时，本质上是访问ctx.response.body；</li>\n<li>我们可以看到源码中，我们访问 proto（这里就是ctx），其实是访问proto中的response的属性；</li>\n</ul>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\">image-20201104155927483</p>\n<p><strong>请求状态：status</strong></p>\n<p>请求状态我们可以直接给ctx设置，或者给ctx.response设置也是一样的效果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ctx.status &#x3D; 201;\nctx.response.status &#x3D; 204;</code></pre>\n\n<h3 id=\"1-6-错误处理\"><a href=\"#1-6-错误处理\" class=\"headerlink\" title=\"1.6. 错误处理\"></a>1.6. 错误处理</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">const Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  ctx.app.emit(&#39;error&#39;, new Error(&quot;哈哈哈&quot;), ctx);\n&#125;)\n\napp.on(&#39;error&#39;, (err, ctx) &#x3D;&gt; &#123;\n  console.log(err.message);\n  ctx.response.body &#x3D; &quot;哈哈哈&quot;;\n&#125;)\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;错误处理服务启动成功~&quot;);\n&#125;)</code></pre>\n\n<h3 id=\"1-7-静态服务器\"><a href=\"#1-7-静态服务器\" class=\"headerlink\" title=\"1.7. 静态服务器\"></a>1.7. 静态服务器</h3><p>koa并没有内置部署相关的功能，所以我们需要使用第三方库：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm install koa-static</code></pre>\n\n<p>部署的过程类似于express：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const Koa &#x3D; require(&#39;koa&#39;);\nconst static &#x3D; require(&#39;koa-static&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use(static(&#39;.&#x2F;build&#39;));\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;静态服务器启动成功~&quot;);\n&#125;);</code></pre>\n\n<h3 id=\"1-8-源码解析\"><a href=\"#1-8-源码解析\" class=\"headerlink\" title=\"1.8. 源码解析\"></a>1.8. 源码解析</h3><p>视频里面有讲解，这里不再截图</p>\n<h2 id=\"二-和express对比\"><a href=\"#二-和express对比\" class=\"headerlink\" title=\"二. 和express对比\"></a>二. 和express对比</h2><p>在学习了两个框架之后，我们应该已经可以发现koa和express的区别：</p>\n<p>从架构设计上来说：</p>\n<ul>\n<li><p>express是完整和强大的，其中帮助我们内置了非常多好用的功能；</p>\n</li>\n<li><p>koa是简洁和自由的，它只包含最新的功能，并不会对我们使用其他中间件进行任何的限制。</p>\n</li>\n<li><ul>\n<li>甚至是在app中连最基本的get、post都没有给我们提供；</li>\n</ul>\n</li>\n<li><p>我们需要通过自己或者路由来判断请求方式或者其他功能；</p>\n</li>\n</ul>\n<p>因为express和koa框架他们的核心其实都是中间件：</p>\n<ul>\n<li>但是他们的中间件事实上，它们的中间件的执行机制是不同的，特别是针对某个中间件中包含异步操作时；</li>\n<li>所以，接下来，我们再来研究一下express和koa中间件的执行顺序问题；</li>\n</ul>\n<p>我通过一个需求来演示所有的过程：</p>\n<ul>\n<li><p>假如有三个中间件会在一次请求中匹配到，并且按照顺序执行；</p>\n</li>\n<li><p>我希望最终实现的方案是：</p>\n</li>\n<li><ul>\n<li>注意：是middleware1中；</li>\n</ul>\n</li>\n<li><p>在middleware1中，在req.message中添加一个字符串 <code>aaa</code>；</p>\n</li>\n<li><p>在middleware2中，在req.message中添加一个 字符串<code>bbb</code>；</p>\n</li>\n<li><p>在middleware3中，在req.message中添加一个 字符串<code>ccc</code>；</p>\n</li>\n<li><p>当所有内容添加结束后，在middleware1中，通过res返回最终的结果；</p>\n</li>\n</ul>\n<h3 id=\"2-1-同步执行顺序\"><a href=\"#2-1-同步执行顺序\" class=\"headerlink\" title=\"2.1. 同步执行顺序\"></a>2.1. 同步执行顺序</h3><p>假如我们获取的所有数据，是可以同步获取的；</p>\n<p><strong>我们先通过express实现这个过程：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\n\nconst middleware1 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;ccc&#39;;\n&#125;\n\napp.use(middleware1, middleware2, middleware3);\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;启动成功~&quot;);\n&#125;)</code></pre>\n\n<p>最终的结果是：<code>aaabbbccc</code>，没问题；</p>\n<p><strong>我们再通过koa实现这个过程：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\nconst middleware1 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  next();\n  console.log(&quot;aaaa&quot;);\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  console.log(&quot;bbbb&quot;);\n  next();\n&#125;\n\nconst middleware3 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;ccc&#39;;\n&#125;\n\napp.use(middleware1);\napp.use(middleware2);\napp.use(middleware3);\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;启动成功~&quot;);\n&#125;)</code></pre>\n\n<p>最终的结果也是：<code>aaabbbccc</code>，也没问题；</p>\n<h3 id=\"2-2-异步执行顺序\"><a href=\"#2-2-异步执行顺序\" class=\"headerlink\" title=\"2.2. 异步执行顺序\"></a>2.2. 异步执行顺序</h3><p>但是，如果我们最后的ccc中的结果，是需要异步操作才能获取到的，是否会产生问题呢？</p>\n<h4 id=\"2-2-1-express中遇到异步操作\"><a href=\"#2-2-1-express中遇到异步操作\" class=\"headerlink\" title=\"2.2.1. express中遇到异步操作\"></a>2.2.1. express中遇到异步操作</h4><p><strong>express有异步操作（没有在next前，加async、await）：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const middleware1 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  req.message &#x3D; req.message + result.data.lrc.lyric;\n  console.log(req.message);\n&#125;</code></pre>\n\n<p>最终的结果<code>aaabbb</code>，是不正确。</p>\n<p><strong>express有异步操作（有在next前，加async、await）：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const middleware1 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  await next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  await next();\n&#125;\n\nconst middleware3 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  req.message &#x3D; req.message + result.data.lrc.lyric;\n  console.log(req.message);\n&#125;</code></pre>\n\n<p>最终的结果也是<code>aaabbb</code>，也是不正确。</p>\n<p>为什么呢？</p>\n<ul>\n<li>原因是本质上的next()和异步没有任何关系；</li>\n<li>它本身就是一个同步函数的调用，所以它不会等到你异步有结果之后，再继续执行后续的操作；</li>\n</ul>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\">image-20201106175205300</p>\n<h4 id=\"2-2-2-koa中遇到异步操作\"><a href=\"#2-2-2-koa中遇到异步操作\" class=\"headerlink\" title=\"2.2.2. koa中遇到异步操作\"></a>2.2.2. koa中遇到异步操作</h4><p><strong>koa有异步操作（没有在next前，加async、await）：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const middleware1 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  next();\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  ctx.message &#x3D; ctx.message + result.data.lrc.lyric;\n&#125;</code></pre>\n\n<p>最终的结果也是<code>aaabbb</code>，也是不正确。</p>\n<ul>\n<li>这是因为虽然next函数是一个返回promise的异步操作，但是在前面不加await的情况，是不同等待结果的返回，就会继续向后执行了；</li>\n</ul>\n<p><strong>koa有异步操作（有在next前，加async、await）：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const middleware1 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  await next();\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  await next();\n&#125;\n\nconst middleware3 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  ctx.message &#x3D; ctx.message + result.data.lrc.lyric;\n&#125;</code></pre>\n\n<p>最终的结果是<code>aaabbb+歌词信息</code>，是正确。</p>\n<ul>\n<li>这是因为，当我们在koa中的next前面加await时，它会等到后续有一个确定结果时，在执行后续的代码；</li>\n</ul>\n","text":"十一.koa开发web服务器Koa初体验1.1. 认识Koa前面我们已经学习了express，另外一个非常流行的Node Web服务器框架就是Koa。 Koa官方的介绍： koa：next generation web framework for node.js； koa：nod...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%80-koa%E5%BC%80%E5%8F%91web%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span class=\"toc-text\">十一.koa开发web服务器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Koa%E5%88%9D%E4%BD%93%E9%AA%8C\"><span class=\"toc-text\">Koa初体验</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E8%AE%A4%E8%AF%86Koa\"><span class=\"toc-text\">1.1. 认识Koa</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-koa%E5%88%9D%E4%BD%93%E9%AA%8C\"><span class=\"toc-text\">1.2. koa初体验</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.3. 路由的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-1-%E5%AE%89%E8%A3%85koa-router\"><span class=\"toc-text\">1.3.1. 安装koa-router</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-2-koa-router%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.3.2. koa-router基本使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-3-router%E7%9A%84%E5%89%8D%E7%BC%80\"><span class=\"toc-text\">1.3.3. router的前缀</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">1.4. 请求解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-1-%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9Aparams\"><span class=\"toc-text\">1.4.1. 方式一：params</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-2-%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Aquery\"><span class=\"toc-text\">1.4.2. 方式二：query</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-3-%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9Ajson\"><span class=\"toc-text\">1.4.3. 方式三：json</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-4-%E6%96%B9%E5%BC%8F%E5%9B%9B%EF%BC%9Ax-www-form-urlencoded\"><span class=\"toc-text\">1.4.4. 方式四：x-www-form-urlencoded</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-5-%E6%96%B9%E5%BC%8F%E4%BA%94%EF%BC%9Aform-data\"><span class=\"toc-text\">1.4.5. 方式五：form-data</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-%E5%93%8D%E5%BA%94%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">1.5. 响应方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\"><span class=\"toc-text\">1.6. 错误处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-7-%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span class=\"toc-text\">1.7. 静态服务器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-8-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">1.8. 源码解析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E5%92%8Cexpress%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">二. 和express对比</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">2.1. 同步执行顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">2.2. 异步执行顺序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-1-express%E4%B8%AD%E9%81%87%E5%88%B0%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">2.2.1. express中遇到异步操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-2-koa%E4%B8%AD%E9%81%87%E5%88%B0%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">2.2.2. koa中遇到异步操作</span></a></li></ol></li></ol></li></ol>","author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/chriswoodcn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Node基础十二","uid":"c5c39a45409b6c5284d037b63eb17322","slug":"node/base/Node基础十二","date":"2022-10-01T04:32:50.000Z","updated":"2023-02-08T04:57:08.165Z","comments":true,"path":"api/articles/node/base/Node基础十二.json","keywords":"chriswood blogs sharing","cover":[],"text":"十二.数据库MySQL认识数据库1.1. 为什么要使用数据库任何的软件系统都需要存放大量的数据，这些数据通常是非常复杂和庞大的： 比如用户信息包括姓名、年龄、性别、地址、身份证号、出生日期等等； 比如商品信息包括商品的名称、描述、价格（原价）、分类标签、商品图片等等； 比如歌曲信...","link":"","photos":[],"count_time":{"symbolsCount":"39k","symbolsTime":"35 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/chriswoodcn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Node基础十","uid":"c2943d2fce9c96d8a973d43b491afc6a","slug":"node/base/Node基础十","date":"2022-10-01T04:30:50.000Z","updated":"2023-02-08T04:57:08.161Z","comments":true,"path":"api/articles/node/base/Node基础十.json","keywords":"chriswood blogs sharing","cover":[],"text":"十.express开发web服务器Express初体验1.1. 认识Web框架前面我们已经学习了使用http内置模块来搭建Web服务器，为什么还要使用框架？ 原生http在进行很多处理时，会较为复杂； 有URL判断、Method判断、参数处理、逻辑代码处理等，都需要我们自己来处理...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/chriswoodcn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}