{"title":"Node基础九","uid":"b171402bc406b8e8ddf1dcd5f712137e","slug":"node/base/Node基础九","date":"2022-10-01T04:29:50.000Z","updated":"2023-02-06T07:58:50.038Z","comments":true,"path":"api/articles/node/base/Node基础九.json","keywords":"chriswood blogs sharing","cover":[],"content":"<h2 id=\"九-http开发web服务器\"><a href=\"#九-http开发web服务器\" class=\"headerlink\" title=\"九.http开发web服务器\"></a>九.http开发web服务器</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>什么是Web服务器？</p>\n<p>当应用程序（客户端）需要某一个资源时，可以向一个台服务器，通过Http请求获取到这个资源；提供服务器的这个服务器，就是一个Web服务器；</p></blockquote>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuvfXvFoaXOVJ29jk0SkBGbYZYwgaPR9na9Lym9T8nLzn8aiazAgKTX01Vh9MBr7aEohYhaV4THKdeg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">Web服务器</p>\n<p>目前有很多开源的Web服务器：Nginx、Apache（静态）、Apache Tomcat（静态、动态）、Node.js</p>\n<h2 id=\"一-Http模板基本使用\"><a href=\"#一-Http模板基本使用\" class=\"headerlink\" title=\"一. Http模板基本使用\"></a>一. Http模板基本使用</h2><h3 id=\"1-1-如何创建服务\"><a href=\"#1-1-如何创建服务\" class=\"headerlink\" title=\"1.1. 如何创建服务\"></a>1.1. 如何创建服务</h3><h4 id=\"1-1-1-Web服务器初体验\"><a href=\"#1-1-1-Web服务器初体验\" class=\"headerlink\" title=\"1.1.1. Web服务器初体验\"></a>1.1.1. Web服务器初体验</h4><p>创建一个Web服务器的初体验：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const http &#x3D; require(&#39;http&#39;);\n\nconst HTTP_PORT &#x3D; 8000;\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello World&quot;);\n&#125;);\n\nserver.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&#96;🚀服务器在$&#123;HTTP_PORT&#125;启动~&#96;)\n&#125;)</code></pre>\n\n<h4 id=\"1-1-2-创建服务器\"><a href=\"#1-1-2-创建服务器\" class=\"headerlink\" title=\"1.1.2. 创建服务器\"></a>1.1.2. 创建服务器</h4><p>创建服务器对象，我们是通过 <code>createServer</code> 来完成的</p>\n<ul>\n<li><code>http.createServer</code>会返回服务器的对象；</li>\n<li>底层其实使用直接 new Server 对象。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function createServer(opts, requestListener) &#123;\n  return new Server(opts, requestListener);\n&#125;</code></pre>\n\n<p>那么，当然，我们也可以自己来创建这个对象：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const server2 &#x3D; new http.Server((req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Server2&quot;);\n&#125;);\n\nserver2.listen(9000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动成功~&quot;);\n&#125;)</code></pre>\n\n<p>上面我们已经看到，创建Server时会传入一个回调函数，这个回调函数在被调用时会传入两个参数：</p>\n<ul>\n<li>req：request请求对象，包含请求相关的信息；</li>\n<li>res：response响应对象，包含我们要发送给客户端的信息；</li>\n</ul>\n<h4 id=\"1-1-3-监听端口和主机\"><a href=\"#1-1-3-监听端口和主机\" class=\"headerlink\" title=\"1.1.3. 监听端口和主机\"></a>1.1.3. 监听端口和主机</h4><p><strong>Server</strong>通过listen方法来开启服务器，并且在某一个主机和端口上监听网络请求：</p>\n<ul>\n<li>也就是当我们通过 <code>ip:port</code>的方式发送到我们监听的Web服务器上时；</li>\n<li>我们就可以对其进行相关的处理；</li>\n</ul>\n<p><code>listen</code>函数有三个参数：</p>\n<ul>\n<li><p>端口port: 可以不传, 系统会默认分配端, 后续项目中我们会写入到环境变量中；</p>\n</li>\n<li><p>主机host: 通常可以传入localhost、ip地址127.0.0.1、或者ip地址0.0.0.0，默认是0.0.0.0；</p>\n</li>\n<li><ul>\n<li>监听IPV4上所有的地址，再根据端口找到不同的应用程序；</li>\n</ul>\n</li>\n<li><p>比如我们监听 <code>0.0.0.0</code>时，在同一个网段下的主机中，通过ip地址是可以访问的；</p>\n</li>\n<li><p>正常的数据库包经常 应用层 - 传输层 - 网络层 - 数据链路层 - 物理层 ；</p>\n</li>\n<li><p>而回环地址，是在网络层直接就被获取到了，是不会经常数据链路层和物理层的；</p>\n</li>\n<li><p>比如我们监听 <code>127.0.0.1</code>时，在同一个网段下的主机中，通过ip地址是不能访问的；</p>\n</li>\n<li><p>localhost：本质上是一个域名，通常情况下会被解析成127.0.0.1；</p>\n</li>\n<li><p>127.0.0.1：回环地址（Loop Back Address），表达的意思其实是我们主机自己发出去的包，直接被自己接收；</p>\n</li>\n<li><p>0.0.0.0：</p>\n</li>\n<li><p>回调函数：服务器启动成功时的回调函数；</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server.listen(() &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动~🚀&quot;);\n&#125;)</code></pre>\n\n<h3 id=\"1-2-request请求对象\"><a href=\"#1-2-request请求对象\" class=\"headerlink\" title=\"1.2. request请求对象\"></a>1.2. request请求对象</h3><p>在向服务器发送请求时，我们会携带很多信息，比如：</p>\n<ul>\n<li>本次请求的URL，服务器需要根据不同的URL进行不同的处理；</li>\n<li>本次请求的请求方式，比如GET、POST请求传入的参数和处理的方式是不同的；</li>\n<li>本次请求的headers中也会携带一些信息，比如客户端信息、接受数据的格式、支持的编码格式等；</li>\n<li>等等…</li>\n</ul>\n<p>这些信息，Node会帮助我们封装到一个request的对象中，我们可以直接来处理这个request对象：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; request对象\n  console.log(req.url);\n  console.log(req.method);\n  console.log(req.headers);\n\n  res.end(&quot;Hello World&quot;);\n&#125;);</code></pre>\n\n<h4 id=\"1-2-1-URL的处理\"><a href=\"#1-2-1-URL的处理\" class=\"headerlink\" title=\"1.2.1. URL的处理\"></a>1.2.1. URL的处理</h4><p>客户端在发送请求时，会请求不同的数据，那么会传入不同的请求地址：</p>\n<ul>\n<li>比如 <code>http://localhost:8000/login</code>；</li>\n<li>比如 <code>http://localhost:8000/products</code>;</li>\n</ul>\n<p>服务器端需要根据不同的请求地址，作出不同的响应：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  const url &#x3D; req.url;\n  console.log(url);\n\n  if (url &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n    res.end(&quot;welcome Back~&quot;);\n  &#125; else if (url &#x3D;&#x3D;&#x3D; &#39;&#x2F;products&#39;) &#123;\n    res.end(&quot;products&quot;);\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);</code></pre>\n\n<p>那么如果用户发送的地址中还携带一些额外的参数呢？</p>\n<ul>\n<li><code>http://localhost:8000/login?name=why&amp;password=123</code>;</li>\n<li>这个时候，url的值是 <code>/login?name=why&amp;password=123</code>；</li>\n</ul>\n<p>我们如何对它进行解析呢？</p>\n<ul>\n<li>使用内置模块url；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const url &#x3D; require(&#39;url&#39;);\n\n&#x2F;&#x2F; 解析请求\nconst parseInfo &#x3D; url.parse(req.url);\nconsole.log(parseInfo);</code></pre>\n\n<p>解析结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Url &#123;\n  protocol: null,\n  slashes: null,\n  auth: null,\n  host: null,\n  port: null,\n  hostname: null,\n  hash: null,\n  search: &#39;?name&#x3D;why&amp;password&#x3D;123&#39;,\n  query: &#39;name&#x3D;why&amp;password&#x3D;123&#39;,\n  pathname: &#39;&#x2F;login&#39;,\n  path: &#39;&#x2F;login?name&#x3D;why&amp;password&#x3D;123&#39;,\n  href: &#39;&#x2F;login?name&#x3D;why&amp;password&#x3D;123&#39;\n&#125;</code></pre>\n\n<p>我们会发现 <code>pathname</code>就是我们想要的结果。</p>\n<p>但是 <code>query</code> 信息如何可以获取呢？</p>\n<ul>\n<li>方式一：截取字符串；</li>\n<li>方式二：使用querystring内置模块；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const &#123; pathname, query &#125; &#x3D; url.parse(req.url);\nconst queryObj &#x3D; qs.parse(query);\nconsole.log(queryObj.name);\nconsole.log(queryObj.password);</code></pre>\n\n<h4 id=\"1-2-2-Method的处理\"><a href=\"#1-2-2-Method的处理\" class=\"headerlink\" title=\"1.2.2. Method的处理\"></a>1.2.2. Method的处理</h4><p>在Restful规范（设计风格）中，我们对于数据的增删改查应该通过不同的请求方式：</p>\n<ul>\n<li>GET：查询数据；</li>\n<li>POST：新建数据；</li>\n<li>PATCH：更新数据；</li>\n<li>DELETE：删除数据；</li>\n</ul>\n<p>所以，我们可以通过判断不同的请求方式进行不同的处理。</p>\n<p>比如创建一个用户：</p>\n<ul>\n<li>请求接口为 <code>/users</code>；</li>\n<li>请求方式为 <code>POST</code>请求；</li>\n<li>携带数据 <code>username</code>和<code>password</code>；</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuvfXvFoaXOVJ29jk0SkBGbYIR7ichuI44mbZLhDTDgrc8qLB2tvOBBicPRHmnIX5iazgYQHZT2Kq8HeA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">创建用户请求</p>\n<p>在我们程序中如何进行判断以及获取对应的数据呢？</p>\n<ul>\n<li>这里我们需要判断接口是 <code>/users</code>，并且请求方式是POST方法去获取传入的数据；</li>\n<li>获取这种body携带的数据，我们需要通过监听req的 <code>data</code>事件来获取；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">if (req.url.indexOf(&#39;&#x2F;users&#39;) !&#x3D;&#x3D; -1) &#123;\n  if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n  \n    &#x2F;&#x2F; 可以设置编码，也可以在下方通过 data.toString() 获取字符串格式\n    req.setEncoding(&#39;utf-8&#39;);\n\n    req.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n      const &#123;username, password&#125; &#x3D; JSON.parse(data);\n      console.log(username, password);\n    &#125;);\n\n    res.end(&quot;create user success&quot;);\n  &#125; else &#123;\n    res.end(&quot;users list&quot;);\n  &#125;\n&#125; else &#123;\n  res.end(&quot;error message&quot;);\n&#125;</code></pre>\n\n<p>将JSON字符串格式转成对象类型，通过<code>JSON.parse</code>方法即可。</p>\n<h4 id=\"1-2-3-header属性\"><a href=\"#1-2-3-header属性\" class=\"headerlink\" title=\"1.2.3. header属性\"></a>1.2.3. header属性</h4><p>在request对象的header中也包含很多有用的信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  console.log(req.headers);\n\n  res.end(&quot;Hello Header&quot;);\n&#125;);</code></pre>\n\n<p>浏览器会默认传递过来一些信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n  &#39;content-type&#39;: &#39;application&#x2F;json&#39;,\n  &#39;user-agent&#39;: &#39;PostmanRuntime&#x2F;7.26.5&#39;,\n  accept: &#39;*&#x2F;*&#39;,\n  &#39;postman-token&#39;: &#39;afe4b8fe-67e3-49cc-bd6f-f61c95c4367b&#39;,\n  host: &#39;localhost:8000&#39;,\n  &#39;accept-encoding&#39;: &#39;gzip, deflate, br&#39;,\n  connection: &#39;keep-alive&#39;,\n  &#39;content-length&#39;: &#39;48&#39;\n&#125;</code></pre>\n\n<p><code>content-type</code>是这次请求携带的数据的类型：</p>\n<ul>\n<li><code>application/json</code>表示是一个json类型；</li>\n<li><code>text/plain</code>表示是文本类型；</li>\n<li><code>application/xml</code>表示是xml类型；</li>\n<li><code>multipart/form-data</code>表示是上传文件；</li>\n</ul>\n<p><code>content-length</code>：</p>\n<ul>\n<li>文件的大小和长度</li>\n</ul>\n<p><code>keep-alive</code>：</p>\n<ul>\n<li><p>http是基于TCP协议的，但是通常在进行一次请求和响应结束后会立刻中断；</p>\n</li>\n<li><p>在http1.0中，如果想要继续保持连接：</p>\n</li>\n<li><ul>\n<li>浏览器需要在请求头中添加 <code>connection: keep-alive</code>；</li>\n</ul>\n</li>\n<li><p>服务器需要在响应头中添加 <code>connection:keey-alive</code>；</p>\n</li>\n<li><p>当客户端再次放请求时，就会使用同一个连接，直接一方中断连接；</p>\n</li>\n<li><p>在http1.1中，所有连接默认是 <code>connection: keep-alive</code>的；</p>\n</li>\n<li><ul>\n<li>不同的Web服务器会有不同的保持 <code>keep-alive</code>的时间；</li>\n</ul>\n</li>\n<li><p>Node中默认是5s中；</p>\n</li>\n</ul>\n<p><code>accept-encoding</code>：</p>\n<ul>\n<li>告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip编码，对应 <code>.gz</code>文件；</li>\n</ul>\n<p><code>accept</code>：</p>\n<ul>\n<li>告知服务器，客户端可接受文件的格式类型；</li>\n</ul>\n<p><code>user-agent</code>：</p>\n<ul>\n<li>客户端相关的信息；</li>\n</ul>\n<h3 id=\"1-3-响应对象response\"><a href=\"#1-3-响应对象response\" class=\"headerlink\" title=\"1.3. 响应对象response\"></a>1.3. 响应对象response</h3><h4 id=\"1-3-1-返回响应结果\"><a href=\"#1-3-1-返回响应结果\" class=\"headerlink\" title=\"1.3.1. 返回响应结果\"></a>1.3.1. 返回响应结果</h4><p>如果我们希望给客户端响应的结果数据，可以通过两种方式：</p>\n<ul>\n<li>Write方法：这种方式是直接写出数据，但是并没有关闭流；</li>\n<li>end方法：这种方式是写出最后的数据，并且写出后会关闭流；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const http &#x3D; require(&#39;http&#39;);\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n\n  &#x2F;&#x2F; 响应数据的方式有两个:\n  res.write(&quot;Hello World&quot;);\n  res.write(&quot;Hello Response&quot;);\n  res.end(&quot;message end&quot;);\n&#125;);\n\nserver.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动🚀~&quot;)\n&#125;);</code></pre>\n\n<p>如果我们没有调用 <code>end</code>和<code>close</code>，客户端将会一直等待结果，所以客户端在发送网络请求时，都会设置超时时间。</p>\n<h4 id=\"1-3-2-返回状态码\"><a href=\"#1-3-2-返回状态码\" class=\"headerlink\" title=\"1.3.2. 返回状态码\"></a>1.3.2. 返回状态码</h4><p>Http状态码（Http Status Code）是用来表示Http响应状态的数字代码：</p>\n<ul>\n<li>Http状态码非常多，可以根据不同的情况，给客户端返回不同的状态码；</li>\n<li>常见的状态码是下面这些（后续项目中，也会用到其中的状态码）；</li>\n</ul>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\">状态码</p>\n<p>设置状态码常见的有两种方式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">res.statusCode &#x3D; 400;\nres.writeHead(200);</code></pre>\n\n<h4 id=\"1-3-3-响应头文件\"><a href=\"#1-3-3-响应头文件\" class=\"headerlink\" title=\"1.3.3. 响应头文件\"></a>1.3.3. 响应头文件</h4><p>返回头部信息，主要有两种方式：</p>\n<ul>\n<li><code>res.setHeader</code>：一次写入一个头部信息；</li>\n<li><code>res.writeHead</code>：同时写入header和status；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">res.setHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;utf8&quot;);\n\nres.writeHead(200, &#123;\n  &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;utf8&quot;\n&#125;)</code></pre>\n\n<p>Header设置 <code>Content-Type</code>有什么作用呢？</p>\n<ul>\n<li>默认客户端接收到的是字符串，客户端会按照自己默认的方式进行处理；</li>\n</ul>\n<p>比如，我们返回的是一段HTML，但是没有指定格式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">res.end(&#39;&lt;h2&gt;Hello World&lt;&#x2F;h2&gt;&#39;)</code></pre>\n\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuvfXvFoaXOVJ29jk0SkBGbYhcq8kxyag70Du07GP25EmvgUP9YebEKic6MQJxbCxNsdibsib4Jf3Y3vA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">image-20201030154312050</p>\n<p>但是，如果我们指定了格式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">res.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html;charset&#x3D;utf8&quot;);\nres.end(&#39;&lt;h2&gt;Hello World&lt;&#x2F;h2&gt;&#39;)</code></pre>\n\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuvfXvFoaXOVJ29jk0SkBGbYCc4y2GKPr3Sib3iaaUc8zliajHdxhHD78dPdRia52t5F9XfJx9WTMcnxicw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">image-20201030154404172</p>\n<p>如果我们希望返回一段JSON数据，应该怎么做呢？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">res.writeHead(200, &#123;\n  &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;utf8&quot;\n&#125;)\n\nconst data &#x3D; &#123;\n  name: &quot;王红元&quot;,\n  age: 18,\n  height: 1.88\n&#125;;\n\nres.end(JSON.stringify(data));</code></pre>\n\n<h2 id=\"二-Web其他补充\"><a href=\"#二-Web其他补充\" class=\"headerlink\" title=\"二. Web其他补充\"></a>二. Web其他补充</h2><h3 id=\"2-1-文件上传的使用\"><a href=\"#2-1-文件上传的使用\" class=\"headerlink\" title=\"2.1. 文件上传的使用\"></a>2.1. 文件上传的使用</h3><p>如果是一个很大的文件需要上传到服务器端，服务器端进行保存应该如何操作呢？</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;upload&#39;) &#123;\n    if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      const fileWriter &#x3D; fs.createWriteStream(&#39;.&#x2F;foo.png&#39;);\n      req.pipe(fileWriter);\n\n      const fileSize &#x3D; req.headers[&#39;content-length&#39;];\n      let curSize &#x3D; 0;\n      console.log(fileSize);\n\n      req.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n        curSize +&#x3D; data.length;\n        console.log(curSize);\n        res.write(&#96;文件上传进度: $&#123;curSize&#x2F;fileSize * 100&#125;%\\n&#96;);\n      &#125;);\n\n      req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n        res.end(&quot;文件上传完成~&quot;);\n      &#125;)\n    &#125;\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);</code></pre>\n\n<p>这个时候我们发现文件上传成功了，但是文件却打不开：</p>\n<ul>\n<li>这是因为我们写入的数据，里面包含一些特殊的信息；</li>\n<li>这些信息打开的软件并不能很好的解析；</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;upload&#39;) &#123;\n    if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      &#x2F;&#x2F; 图片文件必须设置为二进制的\n      req.setEncoding(&#39;binary&#39;);\n\n      &#x2F;&#x2F; 获取content-type中的boundary的值\n      var boundary &#x3D; req.headers[&#39;content-type&#39;].split(&#39;; &#39;)[1].replace(&#39;boundary&#x3D;&#39;,&#39;&#39;);\n      \n      &#x2F;&#x2F; 记录当前数据的信息\n      const fileSize &#x3D; req.headers[&#39;content-length&#39;];\n      let curSize &#x3D; 0;\n      let body &#x3D; &#39;&#39;;\n\n      &#x2F;&#x2F; 监听当前的数据\n      req.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n        curSize +&#x3D; data.length;\n        res.write(&#96;文件上传进度: $&#123;curSize&#x2F;fileSize * 100&#125;%\\n&#96;);\n        body +&#x3D; data;\n      &#125;);\n\n      &#x2F;&#x2F; 数据结构\n      req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 切割数据\n        const payload &#x3D; qs.parse(body, &quot;\\r\\n&quot;, &quot;:&quot;);\n        &#x2F;&#x2F; 获取最后的类型(image&#x2F;png)\n        const fileType &#x3D; payload[&quot;Content-Type&quot;].substring(1);\n        &#x2F;&#x2F; 获取要截取的长度\n        const fileTypePosition &#x3D; body.indexOf(fileType) + fileType.length;\n        let binaryData &#x3D; body.substring(fileTypePosition);\n        binaryData &#x3D; binaryData.replace(&#x2F;^\\s\\s*&#x2F;, &#39;&#39;);\n\n        &#x2F;&#x2F; binaryData &#x3D; binaryData.replaceAll(&#39;\\r\\n&#39;, &#39;&#39;);\n        const finalData &#x3D; binaryData.substring(0, binaryData.indexOf(&#39;--&#39;+boundary+&#39;--&#39;));\n\n        fs.writeFile(&#39;.&#x2F;boo.png&#39;, finalData, &#39;binary&#39;, (err) &#x3D;&gt; &#123;\n          console.log(err);\n          res.end(&quot;文件上传完成~&quot;);\n        &#125;)\n      &#125;)\n    &#125;\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);</code></pre>\n\n<h3 id=\"2-2-http发送网络请求\"><a href=\"#2-2-http发送网络请求\" class=\"headerlink\" title=\"2.2. http发送网络请求\"></a>2.2. http发送网络请求</h3><p>axios库可以在浏览器中使用，也可以在Node中使用：</p>\n<ul>\n<li>在浏览器中，axios使用的是封装xhr；</li>\n<li>在Node中，使用的是http内置模块；</li>\n</ul>\n<p>所以http模块是可以在Node中直接发送网络请求的。</p>\n<p>发送get请求：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">http.get(&quot;http:&#x2F;&#x2F;localhost:8000&quot;, (res) &#x3D;&gt; &#123;\n  res.on(&#39;data&#39;, data &#x3D;&gt; &#123;\n    console.log(data.toString());\n    console.log(JSON.parse(data.toString()));\n  &#125;)\n&#125;);</code></pre>\n\n<p>发送post请求：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const req &#x3D; http.request(&#123;\n  method: &#39;POST&#39;,\n  hostname: &quot;localhost&quot;,\n  port: 8000\n&#125;, (res) &#x3D;&gt; &#123;\n  res.on(&#39;data&#39;, data &#x3D;&gt; &#123;\n    console.log(data.toString());\n    console.log(JSON.parse(data.toString()));\n  &#125;)\n&#125;)\n\nreq.on(&#39;error&#39;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\n\nreq.end();</code></pre>\n","text":"九.http开发web服务器 什么是Web服务器？ 当应用程序（客户端）需要某一个资源时，可以向一个台服务器，通过Http请求获取到这个资源；提供服务器的这个服务器，就是一个Web服务器； Web服务器 目前有很多开源的Web服务器：Nginx、Apache（静态）、Apache...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%9D-http%E5%BC%80%E5%8F%91web%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span class=\"toc-text\">九.http开发web服务器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80-Http%E6%A8%A1%E6%9D%BF%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">一. Http模板基本使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">1.1. 如何创建服务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-1-Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E4%BD%93%E9%AA%8C\"><span class=\"toc-text\">1.1.1. Web服务器初体验</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-2-%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span class=\"toc-text\">1.1.2. 创建服务器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-3-%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E5%92%8C%E4%B8%BB%E6%9C%BA\"><span class=\"toc-text\">1.1.3. 监听端口和主机</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-request%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1.2. request请求对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-1-URL%E7%9A%84%E5%A4%84%E7%90%86\"><span class=\"toc-text\">1.2.1. URL的处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-2-Method%E7%9A%84%E5%A4%84%E7%90%86\"><span class=\"toc-text\">1.2.2. Method的处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-3-header%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">1.2.3. header属性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1response\"><span class=\"toc-text\">1.3. 响应对象response</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-1-%E8%BF%94%E5%9B%9E%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">1.3.1. 返回响应结果</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-2-%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">1.3.2. 返回状态码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-3-%E5%93%8D%E5%BA%94%E5%A4%B4%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">1.3.3. 响应头文件</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C-Web%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">二. Web其他补充</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.1. 文件上传的使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-http%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">2.2. http发送网络请求</span></a></li></ol></li></ol>","author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Node基础十","uid":"c2943d2fce9c96d8a973d43b491afc6a","slug":"node/base/Node基础十","date":"2022-10-01T04:30:50.000Z","updated":"2023-02-06T07:58:50.038Z","comments":true,"path":"api/articles/node/base/Node基础十.json","keywords":"chriswood blogs sharing","cover":[],"text":"十.express开发web服务器Express初体验1.1. 认识Web框架前面我们已经学习了使用http内置模块来搭建Web服务器，为什么还要使用框架？ 原生http在进行很多处理时，会较为复杂； 有URL判断、Method判断、参数处理、逻辑代码处理等，都需要我们自己来处理...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Node基础八","uid":"adefcce4d4f2d80811a82b2ac8c91417","slug":"node/base/Node基础八","date":"2022-10-01T04:28:50.000Z","updated":"2023-02-06T07:58:50.038Z","comments":true,"path":"api/articles/node/base/Node基础八.json","keywords":"chriswood blogs sharing","cover":[],"text":"八. 深入事件循环事件循环是什么？事实上我把事件循环理解成我们编写的JavaScript和浏览器或者Node之间的一个桥梁。 浏览器的事件循环是一个我们编写的JavaScript代码和浏览器API调用(setTimeout&#x2F;AJAX&#x2F;监听事件等)的一个桥梁, ...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}