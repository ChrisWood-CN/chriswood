{"title":"Node基础二","uid":"a6a1fb5bcb751ccc4e9548f88f960a7a","slug":"node/base/Node基础二","date":"2022-10-01T04:06:20.000Z","updated":"2022-10-23T11:40:19.006Z","comments":true,"path":"api/articles/node/base/Node基础二.json","keywords":"chriswood blogs sharing","cover":[],"content":"<h2 id=\"二-node基础\"><a href=\"#二-node基础\" class=\"headerlink\" title=\"二.node基础\"></a>二.node基础</h2><h3 id=\"1-1-JavaScript文件执行\"><a href=\"#1-1-JavaScript文件执行\" class=\"headerlink\" title=\"1.1. JavaScript文件执行\"></a>1.1. JavaScript文件执行</h3><p>如果我们编写一个js文件，里面存放JavaScript代码，如何来执行它呢？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 1.直接打印一段文字\nconsole.log(&quot;我是一段JavaScript代码&quot;);\n\n&#x2F;&#x2F; 2.定义一个函数, 调用这个函数\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nconst result &#x3D; sum(20, 30);\nconsole.log(&quot;计算结果:&quot;, result);\n\n&#x2F;&#x2F; 3.执行定时器代码\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;2s后执行的代码&quot;);\n&#125;, 2000);</code></pre>\n\n<p>目前我们知道有两种方式可以执行：</p>\n<ul>\n<li>将代码交给浏览器执行；</li>\n<li>将代码载入到node环境中执行；</li>\n</ul>\n<p><strong>演练一：浏览器执行</strong></p>\n<p>如果我们希望把代码交给浏览器执行：</p>\n<ul>\n<li>需要通过让浏览器加载、解析html代码，所以我们需要创建一个html文件；</li>\n<li>在html中通过script标签，引入js文件；</li>\n<li>当浏览器遇到script标签时，就会根据src加载、执行JavaScript代码；</li>\n</ul>\n<p>index.html文件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script src&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutHOrSK1pdcFibeiaWpZ3rmMRlNL5icuqPZcTYuUQYWibfyZRXz2Cq0WqSLjUpxYE2AWP6SyyUnib0FeYQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">浏览器执行结果</p>\n<p><strong>演练二：Node执行</strong></p>\n<p>如果我们希望把js文件交给node执行：</p>\n<ul>\n<li>首先电脑上需要安装Node.js环境，安装过程中会自动配置环境变量；</li>\n<li>可以通过终端命令<code>node js文件</code>的方式来载入和执行对应的js文件；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">node index.js</code></pre>\n\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutHOrSK1pdcFibeiaWpZ3rmMRzR7meXTMFsdHTU1eFlyicnoB1VG3a1qKPibgDOUkbTFX3kneicL6tIqXw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">Node执行结果</p>\n<h3 id=\"1-2-Node的REPL\"><a href=\"#1-2-Node的REPL\" class=\"headerlink\" title=\"1.2. Node的REPL\"></a>1.2. Node的REPL</h3><p>什么是REPL呢？感觉挺高大上</p>\n<ul>\n<li><strong>REPL</strong>是<strong>Read-Eval-Print Loop</strong>的简称，翻译为<strong>“读取-求值-输出”循环</strong>；</li>\n<li>REPL是一个简单的，交互式的编程环境；</li>\n</ul>\n<p>事实上，我们浏览器的console就可以看成一个REPL：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutHOrSK1pdcFibeiaWpZ3rmMR8BuCVR5suuVk032TuLibVmfaib3KT0AUFNqx9zibcZe7Lxru8zjjia9LbQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">浏览器控台</p>\n<p>Node也给我们提供了一个REPL环境，我们可以在其中演练简单的代码：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutHOrSK1pdcFibeiaWpZ3rmMRg5C61IZdYw43ODX4OMcTlB9oKSO49mUrfyGfiaILQ50QG9YkQBIMhUQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">REPL演练</p>\n<h3 id=\"2-1-给node程序传递参数\"><a href=\"#2-1-给node程序传递参数\" class=\"headerlink\" title=\"2.1. 给node程序传递参数\"></a>2.1. 给node程序传递参数</h3><p>正常情况下执行一个node程序，直接跟上我们对应的文件即可：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">node index.js</code></pre>\n\n<p>但是，在某些情况下执行node程序的过程中，我们可能希望给node传递一些参数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">node index.js env&#x3D;development coderwhy</code></pre>\n\n<p>如果我们这样来使用程序，就意味着我们需要在程序中获取到传递的参数：</p>\n<ul>\n<li>获取参数其实是在<code>process</code>的内置对象中的；</li>\n</ul>\n<p>如果我们直接打印这个内置对象，它里面包含特别的信息：</p>\n<ul>\n<li>其他的一些信息，比如版本、操作系统等大家可以自行查看，后面用到一些其他的我们还会提到；</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutHOrSK1pdcFibeiaWpZ3rmMRdWHgg3yOGUCQaXfrHa7gNxSDXCjjgcsicKv2wjVSIHoMU0q5UrEiaWcw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">process对象</p>\n<p>现在，我们先找到其中的argv属性：</p>\n<ul>\n<li>我们发现它是一个数组，里面包含了我们需要的参数；</li>\n<li>你可能有个疑问，为什么叫argv呢？</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutHOrSK1pdcFibeiaWpZ3rmMRANq96ASLOyrFibKXET5ExBFG8otgsvibaVE21nKnn3S6VAibF9ADMyDrQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">argv属性</p>\n<p>在C&#x2F;C++程序中的main函数中，实际上可以获取到两个参数：</p>\n<ul>\n<li><p>argc：argument counter的缩写，传递参数的个数；</p>\n</li>\n<li><p>argv：argument vector的缩写，传入的具体参数。</p>\n</li>\n<li><ul>\n<li>vector翻译过来是矢量的意思，在程序中表示的是一种数据结构。</li>\n</ul>\n</li>\n<li><p>在C++、Java中都有这种数据结构，是一种数组结构；</p>\n</li>\n<li><p>在JavaScript中也是一个数组，里面存储一些参数信息；</p>\n</li>\n</ul>\n<p>我们可以在代码中，将这些参数信息遍历出来，使用：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 获取参数\nconsole.log(process.argv);\nprocess.argv.forEach(item &#x3D;&gt; &#123;\n  console.log(item);\n&#125;);\n\n&#x2F;&#x2F; 结果如下：\n&#x2F;&#x2F; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;02_给Node传递参数&#x2F;index.js\n&#x2F;&#x2F; ENV&#x3D;dev\n&#x2F;&#x2F; coderwhy</code></pre>\n\n<h3 id=\"2-2-node程序输出内容\"><a href=\"#2-2-node程序输出内容\" class=\"headerlink\" title=\"2.2. node程序输出内容\"></a>2.2. node程序输出内容</h3><p><strong>console.log</strong></p>\n<p>最常用的输入内容的方式：console.log</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(&quot;hello coderwhy&quot;);</code></pre>\n\n<p><strong>console.clear</strong></p>\n<p>清空控制台：console.clear</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console.clear</code></pre>\n\n<p><strong>console.trace</strong></p>\n<p>打印函数的调用栈：console.trace</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function test() &#123;\n  demo();\n&#125;\nfunction demo() &#123;\n  foo();\n&#125;\nfunction foo() &#123;\n  console.trace();\n&#125;\ntest();</code></pre>\n\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutHOrSK1pdcFibeiaWpZ3rmMRyGNr0G8ibXhF45uFd21ibbUUqt1Rps93MEZRUbZOrZnZ97mXLyV9QJxA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">console.trace结果</p>\n<p>还有一些其他的方法，其他的一些console方法，可以自己在下面学习研究一下。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutHOrSK1pdcFibeiaWpZ3rmMRVMicUFTWQeVPdJ97a7ZlRvfjCdh97lNLiaYiay6EOTwZoRT6dVs7cv41A/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">image-20201008163045395</p>\n<h3 id=\"3-1-常见的全局对象\"><a href=\"#3-1-常见的全局对象\" class=\"headerlink\" title=\"3.1. 常见的全局对象\"></a>3.1. 常见的全局对象</h3><p>Node中给我们提供了一些全局对象，方便我们进行一些操作：</p>\n<ul>\n<li>这些全局对象，我们并不需要从一开始全部一个个学习；</li>\n<li>某些全局对象并不常用，某些全局对象我们会在后续学习中讲到；</li>\n<li>比如module、exports、require()会在模块化中讲到；</li>\n<li>比如Buffer后续会专门讲到；</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutHOrSK1pdcFibeiaWpZ3rmMRXTARF9ib7YIxlbzKvpwib1CEVSibJQshOFQDEFaej1wO3m921N9spwpSw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">全局对象</p>\n<h3 id=\"3-2-特殊的全局对象\"><a href=\"#3-2-特殊的全局对象\" class=\"headerlink\" title=\"3.2. 特殊的全局对象\"></a>3.2. 特殊的全局对象</h3><p>为什么我称之为特殊的全局对象呢？</p>\n<ul>\n<li>这些全局对象可以在模块中任意使用，但是在命令行交互中是不可以使用的；</li>\n<li>包括：__dirname、__filename、exports、module、require()</li>\n</ul>\n<p><strong>__dirname</strong></p>\n<p>获取当前文件所在的路径：</p>\n<ul>\n<li>注意：不包括后面的文件名</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(__dirname);\n\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;03_常见的全局变量</code></pre>\n\n<p><strong>__filename</strong></p>\n<p>获取当前文件所在的路径和文件名称：</p>\n<ul>\n<li>注意：包括后面的文件名称</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(__filename);\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;03_常见的全局变量&#x2F;global对象.js</code></pre>\n\n<h3 id=\"3-3-常见的全局对象\"><a href=\"#3-3-常见的全局对象\" class=\"headerlink\" title=\"3.3. 常见的全局对象\"></a>3.3. 常见的全局对象</h3><p><strong>process对象</strong></p>\n<p>process提供了Node进程中相关的信息：</p>\n<ul>\n<li>比如Node的运行环境、参数信息等；</li>\n<li>后面在项目中，我也会讲解，如何将一些环境变量读取到 <code>process</code> 的 <code>env</code> 中；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(process);</code></pre>\n\n<p><strong>console对象</strong></p>\n<p>提供了简单的调试控制台，在前面讲解输入内容时已经学习过了。</p>\n<ul>\n<li>更加详细的查看官网文档：<a href=\"https://nodejs.org/api/console.html\">https://nodejs.org/api/console.html</a></li>\n</ul>\n<p><strong>定时器函数</strong></p>\n<p>在Node中使用定时器有好几种方式：</p>\n<ul>\n<li><p><code>setTimeout(callback, delay[, ...args])</code>：<code>callback</code>在<code>delay</code>毫秒后执行一次；</p>\n</li>\n<li><p><code>setInterval(callback, delay[, ...args])</code>：<code>callback</code>每<code>delay</code>毫秒重复执行一次；</p>\n</li>\n<li><p><code>setImmediate(callback[, ...args])</code>：<code>callback</code>I &#x2F; O事件后的回调的“立即”执行；</p>\n</li>\n<li><ul>\n<li>这里先不展开讨论它和<code>setTimeout(callback, 0)</code>之间的区别；</li>\n</ul>\n</li>\n<li><p>因为它涉及到事件循环的阶段问题，我会在后续详细讲解事件循环相关的知识；</p>\n</li>\n<li><p><code>process.nextTick(callback[, ...args])</code>：添加到下一次tick队列中；</p>\n</li>\n<li><ul>\n<li>具体的讲解，也放到事件循环中说明；</li>\n</ul>\n</li>\n</ul>\n<p>代码演练：</p>\n<ul>\n<li>暂时不用关心执行顺序问题，在后续事件循环中我会讲到；</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">setTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimtout&quot;);\n&#125;, 1000);\n\nsetInterval(() &#x3D;&gt; &#123;\n  console.log(&#39;setInterval&#39;);\n&#125;, 1000);\n\nsetImmediate(() &#x3D;&gt; &#123;\n  console.log(&quot;setImmediate&quot;);\n&#125;);\n\nprocess.nextTick(() &#x3D;&gt; &#123;\n  console.log(&quot;process.nextTick&quot;);\n&#125;);</code></pre>\n\n<p>当然，它们有对应的取消定时器的方法：</p>\n<ul>\n<li>clearTimeout(timeoutObject);</li>\n<li>clearInterval(intervalObject);</li>\n<li>clearImmediate(immediateObject)</li>\n</ul>\n<p><strong>global对象</strong></p>\n<p>global是一个全局对象，事实上前端我们提到的process、console、setTimeout等都有被放到global中：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(process);\nconsole.log(global.process);</code></pre>\n\n<p>为什么结果是一样的呢？</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutHOrSK1pdcFibeiaWpZ3rmMRF0kic1mxontL0K2Yg10mlCPG5RHSgWIqAXg8Njre0kRNtfOke81bchQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">Node的源码</p>\n<p>global中还有哪些属性呢？</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutHOrSK1pdcFibeiaWpZ3rmMR5XPKUUyx8cSDxqzRWOrk7kS0QMrL4zsK4Yy3HDuqc4ttI2eMa4fXLA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">global其他属性的查看</p>\n<p><strong>window和global的区别是什么？</strong></p>\n<p>在浏览器中，全局变量都是在window上的，比如有document、setInterval、setTimeout、alert、console等等</p>\n<p>在Node中，我们也有一个global属性，并且看起来它里面有很多其他对象。</p>\n<p>但是在浏览器中执行的JavaScript代码，如果我们在顶级范围内通过var定义的一个属性，默认会被添加到window对象上：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var name &#x3D; &#39;coderwhy&#39;;\nconsole.log(window.name); &#x2F;&#x2F; coderwhy</code></pre>\n\n<p>但是在node中，我们通过var定义一个变量，它只是在当前模块中有一个变量，不会放到全局中：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var name &#x3D; &#39;coderwhy&#39;;\nconsole.log(global.name); &#x2F;&#x2F; undefined</code></pre>\n","text":"二.node基础1.1. JavaScript文件执行如果我们编写一个js文件，里面存放JavaScript代码，如何来执行它呢？ &#x2F;&#x2F; 1.直接打印一段文字 console.log(&quot;我是一段JavaScript代码&quot;); &#x2F;&...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C-node%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">二.node基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-JavaScript%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">1.1. JavaScript文件执行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-Node%E7%9A%84REPL\"><span class=\"toc-text\">1.2. Node的REPL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E7%BB%99node%E7%A8%8B%E5%BA%8F%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2.1. 给node程序传递参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-node%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">2.2. node程序输出内容</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">3.1. 常见的全局对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E7%89%B9%E6%AE%8A%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">3.2. 特殊的全局对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">3.3. 常见的全局对象</span></a></li></ol></li></ol>","author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Node基础三","uid":"4d3281e0b26c044e36154a269947cf99","slug":"node/base/Node基础三","date":"2022-10-01T04:23:22.000Z","updated":"2022-10-23T11:40:19.006Z","comments":true,"path":"api/articles/node/base/Node基础三.json","keywords":"chriswood blogs sharing","cover":[],"text":"三 . 掌握前端模块化1.1. JavaScript设计缺陷那么，到底什么是模块化开发呢？ 事实上模块化开发最终的目的是将程序划分成一个个小的结构； 这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构； 这个结构可以将自己希望暴露的变量、函数、对象等导出给其结...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Node基础一","uid":"16ea75a74e45c427c7de22a19d8e1e05","slug":"node/base/Node基础一","date":"2022-09-30T15:33:43.000Z","updated":"2022-10-23T11:40:19.006Z","comments":true,"path":"api/articles/node/base/Node基础一.json","keywords":"chriswood blogs sharing","cover":[],"text":"一.JavaScript运行原理1.1. Atwood定律官方对Node.js的定义： Node.js是一个基于V8 JavaScript引擎的JavaScript运行时环境。 什么是JavaScript运行环境？ 为什么JavaScript需要特别的运行环境呢？ 什么又是Jav...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}