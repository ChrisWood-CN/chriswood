{"title":"Node基础八","uid":"adefcce4d4f2d80811a82b2ac8c91417","slug":"node/base/Node基础八","date":"2022-10-01T04:28:50.000Z","updated":"2023-06-30T03:22:38.672Z","comments":true,"path":"api/articles/node/base/Node基础八.json","keywords":"chriswood blogs sharing","cover":[],"content":"<h2 id=\"八-深入事件循环\"><a href=\"#八-深入事件循环\" class=\"headerlink\" title=\"八. 深入事件循环\"></a>八. 深入事件循环</h2><p>事件循环是什么？事实上我把事件循环理解成我们编写的JavaScript和浏览器或者Node之间的一个桥梁。</p>\n<p>浏览器的事件循环是一个我们编写的JavaScript代码和浏览器API调用(setTimeout&#x2F;AJAX&#x2F;监听事件等)的一个桥梁, 桥梁之间他们通过回调函数进行沟通。</p>\n<p>Node的事件循环是一个我们编写的JavaScript代码和系统调用（file system、network等）之间的一个桥梁, 桥梁之间他们通过回调函数进行沟通的.</p>\n<h2 id=\"浏览器的事件循环\"><a href=\"#浏览器的事件循环\" class=\"headerlink\" title=\"浏览器的事件循环\"></a>浏览器的事件循环</h2><h3 id=\"1-1-进程和线程\"><a href=\"#1-1-进程和线程\" class=\"headerlink\" title=\"1.1. 进程和线程\"></a>1.1. 进程和线程</h3><p>线程和进程是操作系统中的两个概念：</p>\n<ul>\n<li>进程（process）：计算机已经运行的程序；</li>\n<li>线程（thread）：操作系统能够运行运算调度的最小单位；</li>\n</ul>\n<p>听起来很抽象，我们直观一点解释：</p>\n<ul>\n<li>进程：我们可以认为，启动一个应用程序，就会默认启动一个进程（也可能是多个进程）；</li>\n<li>线程：每一个进程中，都会启动一个线程用来执行程序中的代码，这个线程被称之为主线程；</li>\n<li>所以我们也可以说进程是线程的容器；</li>\n</ul>\n<p>再用一个形象的例子解释：</p>\n<ul>\n<li>操作系统类似于一个工厂；</li>\n<li>工厂中里有很多车间，这个车间就是进程；</li>\n<li>每个车间可能有一个以上的工人在工厂，这个工人就是线程；</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutykVxmqElxsSRqd40pBa9XtUsUn5FSYN6W8GHnyUeVKj5mQBt8e4rOnoZWJE3mIkCL73XDfmsRAA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">操作系统、线程、进程</p>\n<p>操作系统是如何做到同时让多个进程（边听歌、边写代码、边查阅资料）同时工作呢？</p>\n<ul>\n<li>这是因为CPU的运算速度非常快，它可以快速的在多个进程之间迅速的切换；</li>\n<li>当我们的进程中的线程获取获取到时间片时，就可以快速执行我们编写的代码；</li>\n<li>对于用于来说是感受不到这种快速的切换的；</li>\n</ul>\n<p>你可以在Mac的活动监视器或者Windows的资源管理器中查看到很多进程：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutykVxmqElxsSRqd40pBa9XO1TDXZ8GcVxJO1XibKsVsmuWgVIicCeGK487v61ShLCNEkxjwgVGYLmQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">活动监视器</p>\n<h3 id=\"1-2-浏览器和JavaScript\"><a href=\"#1-2-浏览器和JavaScript\" class=\"headerlink\" title=\"1.2. 浏览器和JavaScript\"></a>1.2. 浏览器和JavaScript</h3><p>我们经常会说JavaScript是单线程的，但是JavaScript的线程应该有自己的容器进程：浏览器或者Node。</p>\n<p>浏览器是一个进程吗，它里面只有一个线程吗？</p>\n<ul>\n<li>目前多数的浏览器其实都是多进程的，当我们打开一个tab页面时就会开启一个新的进程，这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出；</li>\n<li>每个进程中又有很多的线程，其中包括执行JavaScript代码的线程；</li>\n</ul>\n<p>但是JavaScript的代码执行是在一个单独的线程中执行的：</p>\n<ul>\n<li>这就意味着JavaScript的代码，在同一个时刻只能做一件事；</li>\n<li>如果这件事是非常耗时的，就意味着当前的线程就会被阻塞；</li>\n</ul>\n<p>分析下面代码的执行过程：</p>\n<ul>\n<li>定义变量name；</li>\n<li>执行log函数，函数会被放入到调用栈中执行；</li>\n<li>调用bar()函数，被压入到调用栈中，但是执行未结束；</li>\n<li>bar因为调用了sum，sum函数被压入到调用栈中，获取到结果后出栈；</li>\n<li>bar获取到结果后出栈，获取到结果result；</li>\n<li>将log函数压入到调用栈，log被执行，并且出栈；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const name &#x3D; &quot;coderwhy&quot;;\n\n&#x2F;&#x2F; 1.将该函数放入到调用栈中被执行\nconsole.log(name);\n\n&#x2F;&#x2F; 2. 调用栈\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nfunction bar() &#123;\n  return sum(20, 30);\n&#125;\n\nconsole.log(bar());</code></pre>\n\n<h3 id=\"1-3-浏览器的事件循环\"><a href=\"#1-3-浏览器的事件循环\" class=\"headerlink\" title=\"1.3. 浏览器的事件循环\"></a>1.3. 浏览器的事件循环</h3><p>如果在执行JavaScript代码的过程中，有异步操作呢？</p>\n<ul>\n<li>中间我们插入了一个setTimeout的函数调用；</li>\n<li>这个函数被放到入调用栈中，执行会立即结束，并不会阻塞后续代码的执行；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const name &#x3D; &quot;coderwhy&quot;;\n\n&#x2F;&#x2F; 1.将该函数放入到调用栈中被执行\nconsole.log(name);\n\n&#x2F;&#x2F; 2.调用栈\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nfunction bar() &#123;\n  return sum(20, 30);\n&#125;\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;settimeout&quot;);\n&#125;, 1000);\n\nconst result &#x3D; bar();\n\nconsole.log(result);</code></pre>\n\n<p>那么，传入的一个函数（比如我们称之为timer函数），会在什么时候被执行呢？</p>\n<ul>\n<li>事实上，setTimeout是调用了web api，在合适的时机，会将timer函数加入到一个事件队列中；</li>\n<li>事件队列中的函数，会被放入到调用栈中，在调用栈中被执行；</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutykVxmqElxsSRqd40pBa9XicKiaaY5IS7ibrvzWL2g5xMuqBHjIJqml2TOueicHDAMlAmle9T8L9dZAg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">浏览器的事件循环</p>\n<h3 id=\"1-4-宏任务和微任务\"><a href=\"#1-4-宏任务和微任务\" class=\"headerlink\" title=\"1.4. 宏任务和微任务\"></a>1.4. 宏任务和微任务</h3><p>但是事件循环中并非只维护着一个队列，事实上是有两个队列：</p>\n<ul>\n<li>宏任务队列（macrotask queue）：ajax、setTimeout、setInterval、DOM监听、UI Rendering等</li>\n<li>微任务队列（microtask queue）：Promise的then回调、 Mutation Observer API、queueMicrotask()等</li>\n</ul>\n<p>那么事件循环对于两个队列的优先级是怎么样的呢？</p>\n<ul>\n<li><p>1.main script中的代码优先执行（编写的顶层script代码）；</p>\n</li>\n<li><p>2.在执行任何一个宏任务之前（不是队列，是一个宏任务），都会先查看微任务队列中是否有任务需要执行</p>\n</li>\n<li><ul>\n<li>也就是宏任务执行之前，必须保证微任务队列是空的；</li>\n</ul>\n</li>\n<li><p>如果不为空，那么就优先执行微任务队列中的任务（回调）；</p>\n</li>\n</ul>\n<p>我们来看一个面试题：执行结果如何？</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">setTimeout(function () &#123;\n  console.log(&quot;set1&quot;);\n\n  new Promise(function (resolve) &#123;\n    resolve();\n  &#125;).then(function () &#123;\n    new Promise(function (resolve) &#123;\n      resolve();\n    &#125;).then(function () &#123;\n      console.log(&quot;then4&quot;);\n    &#125;);\n    console.log(&quot;then2&quot;);\n  &#125;);\n&#125;);\n\nnew Promise(function (resolve) &#123;\n  console.log(&quot;pr1&quot;);\n  resolve();\n&#125;).then(function () &#123;\n  console.log(&quot;then1&quot;);\n&#125;);\n\nsetTimeout(function () &#123;\n  console.log(&quot;set2&quot;);\n&#125;);\n\nconsole.log(2);\n\nqueueMicrotask(() &#x3D;&gt; &#123;\n  console.log(&quot;queueMicrotask1&quot;)\n&#125;);\n\nnew Promise(function (resolve) &#123;\n  resolve();\n&#125;).then(function () &#123;\n  console.log(&quot;then3&quot;);\n&#125;);</code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">pr1\n2\nthen1\nqueueMicrotask1\nthen3\nset1\nthen2\nthen4\nset2</code></pre>\n\n<p>async、await是Promise的一个语法糖：</p>\n<ul>\n<li>我们可以将await关键字后面执行的代码，看做是包裹在<code>(resolve, reject) =&gt; &#123;函数执行&#125;</code>中的代码；</li>\n<li>await的下一条语句，可以看做是<code>then(res =&gt; &#123;函数执行&#125;)</code>中的代码；</li>\n</ul>\n<p>今日头条的面试题：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function async1 () &#123;\n  console.log(&#39;async1 start&#39;)\n  await async2();\n  console.log(&#39;async1 end&#39;)\n&#125;\n \nasync function async2 () &#123;\n  console.log(&#39;async2&#39;)\n&#125;\n\nconsole.log(&#39;script start&#39;)\n \nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout&#39;)\n&#125;, 0)\n \nasync1();\n \nnew Promise (function (resolve) &#123;\n  console.log(&#39;promise1&#39;)\n  resolve();\n&#125;).then (function () &#123;\n  console.log(&#39;promise2&#39;)\n&#125;)\n\nconsole.log(&#39;script end&#39;)</code></pre>\n\n<p>执行结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">script start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout</code></pre>\n\n<h2 id=\"Node的事件循环\"><a href=\"#Node的事件循环\" class=\"headerlink\" title=\"Node的事件循环\"></a>Node的事件循环</h2><h3 id=\"2-1-Node的事件循环\"><a href=\"#2-1-Node的事件循环\" class=\"headerlink\" title=\"2.1. Node的事件循环\"></a>2.1. Node的事件循环</h3><p>浏览器中的EventLoop是根据HTML5定义的规范来实现的，不同的浏览器可能会有不同的实现，而Node中是由libuv实现的。</p>\n<p>我们来看在很早就给大家展示的Node架构图：</p>\n<ul>\n<li>我们会发现libuv中主要维护了一个EventLoop和worker threads（线程池）；</li>\n<li>EventLoop负责调用系统的一些其他操作：文件的IO、Network、child-processes等</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutykVxmqElxsSRqd40pBa9XmLD9LsQGqIzemGdh5IOTUgR8YibDiciaRFzLdicz8YUkq2BIlSENicJ2Mdg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">Node的架构图</p>\n<p>libuv到底是什么呢？</p>\n<ul>\n<li>libuv is a multi-platform support library with a focus on asynchronous I&#x2F;O. It was primarily developed for use by Node.js, but it’s also used by Luvit, Julia, pyuv, and others.</li>\n<li>libuv是一个多平台的专注于异步IO的库，它最初是为Node开发的，但是现在也被使用到Luvit、Julia、pyuv等其他地方；</li>\n</ul>\n<p>libuv到底帮助我们做了什么事情呢？</p>\n<ul>\n<li>我们以文件操作为例，来讲解一下它内部的结构；</li>\n</ul>\n<h3 id=\"2-2-阻塞IO和非阻塞IO\"><a href=\"#2-2-阻塞IO和非阻塞IO\" class=\"headerlink\" title=\"2.2. 阻塞IO和非阻塞IO\"></a>2.2. 阻塞IO和非阻塞IO</h3><p>如果我们希望在程序中对一个文件进行操作，那么我们就需要打开这个文件：通过文件描述符。</p>\n<ul>\n<li>我们思考：JavaScript可以直接对一个文件进行操作吗？</li>\n<li>看起来是可以的，但是事实上我们任何程序中的文件操作都是需要进行系统调用（操作系统封装了文件系统）；</li>\n<li>事实上对文件的操作，是一个操作系统的IO操作（输入、输出）；</li>\n</ul>\n<p>操作系统为我们提供了<code>阻塞式调用</code>和<code>非阻塞式调用</code>：</p>\n<ul>\n<li><strong>阻塞式调用：</strong> 调用结果返回之前，当前线程处于阻塞态（阻塞态CPU是不会分配时间片的），调用线程只有在得到调用结果之后才会继续执行。</li>\n<li><strong>非阻塞式调用：</strong> 调用执行之后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。</li>\n</ul>\n<p>所以我们开发中的很多耗时操作，都可以基于这样的 <code>非阻塞式调用</code>：</p>\n<ul>\n<li>比如网络请求本身使用了Socket通信，而Socket本身提供了select模型，可以进行<code>非阻塞方式的工作</code>；</li>\n<li>比如文件读写的IO操作，我们可以使用操作系统提供的<code>基于事件的回调机制</code>；</li>\n</ul>\n<p>但是非阻塞IO也会存在一定的问题：我们并没有获取到需要读取（我们以读取为例）的结果</p>\n<ul>\n<li>那么就意味着为了可以知道是否读取到了完整的数据，我们需要频繁的去确定读取到的数据是否是完整的；</li>\n<li>这个过程我们称之为轮训操作；</li>\n</ul>\n<p>那么这个轮训的工作由谁来完成呢？</p>\n<ul>\n<li>如果我们的主线程频繁的去进行轮训的工作，那么必然会大大降低性能；</li>\n<li>并且开发中我们可能不只是一个文件的读写，可能是多个文件；</li>\n<li>而且可能是多个功能：网络的IO、数据库的IO、子进程调用；</li>\n</ul>\n<p>libuv提供了一个线程池（Thread Pool）：</p>\n<ul>\n<li>线程池会负责所有相关的操作，并且会通过轮训等方式等待结果；</li>\n<li>当获取到结果时，就可以将对应的回调放到事件循环（某一个事件队列）中；</li>\n<li>事件循环就可以负责接管后续的回调工作，告知JavaScript应用程序执行对应的回调函数；</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutykVxmqElxsSRqd40pBa9XDt5ov0ibB9QjGI59tGpFyK7uObjfffVTzm6m95Vpv1pLYOBib2iaeNPww/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">Event loop in node.js</p>\n<p>阻塞和非阻塞，同步和异步有什么区别？</p>\n<ul>\n<li><p>阻塞和非阻塞是对于被调用者来说的；</p>\n</li>\n<li><ul>\n<li>在我们这里就是系统调用，操作系统为我们提供了阻塞调用和非阻塞调用；</li>\n</ul>\n</li>\n<li><p>同步和异步是对于调用者来说的；</p>\n</li>\n<li><ul>\n<li>在我们这里就是自己的程序；</li>\n</ul>\n</li>\n<li><p>如果我们在发起调用之后，不会进行其他任何的操作，只是等待结果，这个过程就称之为同步调用；</p>\n</li>\n<li><p>如果我们再发起调用之后，并不会等待结果，继续完成其他的工作，等到有回调时再去执行，这个过程就是异步调用；</p>\n</li>\n</ul>\n<h3 id=\"2-3-Node事件循环的阶段\"><a href=\"#2-3-Node事件循环的阶段\" class=\"headerlink\" title=\"2.3. Node事件循环的阶段\"></a>2.3. Node事件循环的阶段</h3><p>我们最前面就强调过，事件循环像是一个桥梁，是连接着应用程序的JavaScript和系统调用之间的通道：</p>\n<ul>\n<li>无论是我们的文件IO、数据库、网络IO、定时器、子进程，在完成对应的操作后，都会将对应的结果和回调函数放到事件循环（任务队列）中；</li>\n<li>事件循环会不断的从任务队列中取出对应的事件（回调函数）来执行；</li>\n</ul>\n<p>但是一次完整的事件循环Tick分成很多个阶段：</p>\n<ul>\n<li><strong>定时器（Timers）</strong>：本阶段执行已经被 <code>setTimeout()</code> 和 <code>setInterval()</code> 的调度回调函数。</li>\n<li><strong>待定回调（Pending Callback）</strong>：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到ECONNREFUSED。</li>\n<li><strong>idle, prepare</strong>：仅系统内部使用。</li>\n<li><strong>轮询（Poll）</strong>：检索新的 I&#x2F;O 事件；执行与 I&#x2F;O 相关的回调；</li>\n<li><strong>检测</strong>：<code>setImmediate()</code> 回调函数在这里执行。</li>\n<li><strong>关闭的回调函数</strong>：一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code>。</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXutykVxmqElxsSRqd40pBa9XPV1Jwkricj1K4K44U8PQKJCHtC4JgyreAIK9n8icAibPmwQ7BSmY3Mtaw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">一次tick的事件循环阶段</p>\n<p>我们会发现从一次事件循环的Tick来说，Node的事件循环更复杂，它也分为微任务和宏任务：</p>\n<ul>\n<li>宏任务（macrotask）：setTimeout、setInterval、IO事件、setImmediate、close事件；</li>\n<li>微任务（microtask）：Promise的then回调、process.nextTick、queueMicrotask；</li>\n</ul>\n<p>但是，Node中的事件循环不只是 <code>微任务队列</code>和 <code>宏任务队列</code>：</p>\n<ul>\n<li><p>微任务队列：</p>\n</li>\n<li><ul>\n<li>next tick queue：process.nextTick；</li>\n</ul>\n</li>\n<li><p>other queue：Promise的then回调、queueMicrotask；</p>\n</li>\n<li><p>宏任务队列：</p>\n</li>\n<li><ul>\n<li>timer queue：setTimeout、setInterval；</li>\n</ul>\n</li>\n<li><p>poll queue：IO事件；</p>\n</li>\n<li><p>check queue：setImmediate；</p>\n</li>\n<li><p>close queue：close事件；</p>\n</li>\n</ul>\n<p>所以，在每一次事件循环的tick中，会按照如下顺序来执行代码：</p>\n<ul>\n<li>next tick microtask queue；</li>\n<li>other microtask queue；</li>\n<li>timer queue；</li>\n<li>poll queue；</li>\n<li>check queue；</li>\n<li>close queue；</li>\n</ul>\n<h3 id=\"2-4-Node代码执行面试\"><a href=\"#2-4-Node代码执行面试\" class=\"headerlink\" title=\"2.4. Node代码执行面试\"></a>2.4. Node代码执行面试</h3><p>面试题一：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">async function async1() &#123;\n  console.log(&#39;async1 start&#39;)\n  await async2()\n  console.log(&#39;async1 end&#39;)\n&#125;\n\nasync function async2() &#123;\n  console.log(&#39;async2&#39;)\n&#125;\n\nconsole.log(&#39;script start&#39;)\n\nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout0&#39;)\n&#125;, 0)\n\nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout2&#39;)\n&#125;, 300)\n\nsetImmediate(() &#x3D;&gt; console.log(&#39;setImmediate&#39;));\n\nprocess.nextTick(() &#x3D;&gt; console.log(&#39;nextTick1&#39;));\n\nasync1();\n\nprocess.nextTick(() &#x3D;&gt; console.log(&#39;nextTick2&#39;));\n\nnew Promise(function (resolve) &#123;\n  console.log(&#39;promise1&#39;)\n  resolve();\n  console.log(&#39;promise2&#39;)\n&#125;).then(function () &#123;\n  console.log(&#39;promise3&#39;)\n&#125;)\n\nconsole.log(&#39;script end&#39;)</code></pre>\n\n<p>执行结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">script start\nasync1 start\nasync2\npromise1\npromise2\nscript end\nnextTick\nasync1 end\npromise3\n\nsetTimeout0\nsetImmediate\nsetTimeout2</code></pre>\n\n<p>面试题二：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">setTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimeout&quot;);\n&#125;, 0);\n\nsetImmediate(() &#x3D;&gt; &#123;\n  console.log(&quot;setImmediate&quot;);\n&#125;);</code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">情况一：\nsetTimeout\nsetImmediate\n\n情况二：\nsetImmediate\nsetTimeout</code></pre>\n\n<p>为什么会出现不同的情况呢？</p>\n<ul>\n<li>在Node源码的deps&#x2F;uv&#x2F;src&#x2F;timer.c中141行，有一个 <code>uv__next_timeout</code>的函数；</li>\n<li>这个函数决定了，poll阶段要不要阻塞在这里；</li>\n<li>阻塞在这里的目的是当有异步IO被处理时，尽可能快的让代码被执行；</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">int uv__next_timeout(const uv_loop_t* loop) &#123;\n  const struct heap_node* heap_node;\n  const uv_timer_t* handle;\n  uint64_t diff;\n\n  &#x2F;&#x2F; 计算距离当前时间节点最小的计时器\n  heap_node &#x3D; heap_min(timer_heap(loop));\n  &#x2F;&#x2F; 如果为空, 那么返回-1,表示为阻塞状态\n  if (heap_node &#x3D;&#x3D; NULL)\n    return -1; &#x2F;* block indefinitely *&#x2F;\n\n  &#x2F;&#x2F; 如果计时器的时间小于当前loop的开始时间, 那么返回0\n  &#x2F;&#x2F; 继续执行后续阶段, 并且开启下一次tick\n  handle &#x3D; container_of(heap_node, uv_timer_t, heap_node);\n  if (handle-&gt;timeout &lt;&#x3D; loop-&gt;time)\n    return 0;\n\n  &#x2F;&#x2F; 如果不大于loop的开始时间, 那么会返回时间差\n  diff &#x3D; handle-&gt;timeout - loop-&gt;time;\n  if (diff &gt; INT_MAX)\n    diff &#x3D; INT_MAX;\n\n  return (int) diff;\n&#125;</code></pre>\n\n<p>和上面有什么关系呢？</p>\n<ul>\n<li><p>情况一：如果事件循环开启的时间(ms)是小于 <code>setTimeout</code>函数的执行时间的；</p>\n</li>\n<li><ul>\n<li>也就意味着先开启了event-loop，但是这个时候执行到timer阶段，并没有定时器的回调被放到入 timer queue中；</li>\n</ul>\n</li>\n<li><p>所以没有被执行，后续开启定时器和检测到有setImmediate时，就会跳过poll阶段，向后继续执行；</p>\n</li>\n<li><p>这个时候是先检测 <code>setImmediate</code>，第二次的tick中执行了timer中的 <code>setTimeout</code>；</p>\n</li>\n<li><p>情况二：如果事件循环开启的时间(ms)是大于 <code>setTimeout</code>函数的执行时间的；</p>\n</li>\n<li><ul>\n<li>这就意味着在第一次 tick中，已经准备好了timer queue；</li>\n</ul>\n</li>\n<li><p>所以会直接按照顺序执行即可；</p>\n</li>\n</ul>\n","text":"八. 深入事件循环事件循环是什么？事实上我把事件循环理解成我们编写的JavaScript和浏览器或者Node之间的一个桥梁。 浏览器的事件循环是一个我们编写的JavaScript代码和浏览器API调用(setTimeout&#x2F;AJAX&#x2F;监听事件等)的一个桥梁, ...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AB-%E6%B7%B1%E5%85%A5%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">八. 深入事件循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">浏览器的事件循环</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">1.1. 进程和线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8CJavaScript\"><span class=\"toc-text\">1.2. 浏览器和JavaScript</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">1.3. 浏览器的事件循环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">1.4. 宏任务和微任务</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">Node的事件循环</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">2.1. Node的事件循环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E9%98%BB%E5%A1%9EIO%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9EIO\"><span class=\"toc-text\">2.2. 阻塞IO和非阻塞IO</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-Node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">2.3. Node事件循环的阶段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-Node%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%9D%A2%E8%AF%95\"><span class=\"toc-text\">2.4. Node代码执行面试</span></a></li></ol></li></ol>","author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/chriswoodcn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Node基础九","uid":"b171402bc406b8e8ddf1dcd5f712137e","slug":"node/base/Node基础九","date":"2022-10-01T04:29:50.000Z","updated":"2023-06-30T03:22:38.672Z","comments":true,"path":"api/articles/node/base/Node基础九.json","keywords":"chriswood blogs sharing","cover":[],"text":"九.http开发web服务器 什么是Web服务器？ 当应用程序（客户端）需要某一个资源时，可以向一个台服务器，通过Http请求获取到这个资源；提供服务器的这个服务器，就是一个Web服务器； Web服务器 目前有很多开源的Web服务器：Nginx、Apache（静态）、Apache...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/chriswoodcn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Node基础七","uid":"9cc987ed6425e4445f09c1cfe9b13abf","slug":"node/base/Node基础七","date":"2022-10-01T04:27:50.000Z","updated":"2023-06-30T03:22:38.672Z","comments":true,"path":"api/articles/node/base/Node基础七.json","keywords":"chriswood blogs sharing","cover":[],"text":"七.脚手架开发目前前端工程化开发过程中，我们会使用各种各样的脚手架，vue-cli、create-react-app，当然也包括webpack、gulp、rollup、vite等工具。 这些工具是怎么开发出来的呢？当我们执行一个命令时，它们做了什么事情？是怎么样完成的一系列操作？...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/chriswoodcn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}