{"title":"Node基础四","uid":"e9d3cfba4c19a66c9a7d2ec6535dbb77","slug":"node/base/Node基础四","date":"2022-10-01T04:24:10.000Z","updated":"2022-10-24T14:25:11.508Z","comments":true,"path":"api/articles/node/base/Node基础四.json","keywords":"chriswood blogs sharing","cover":null,"content":"<h2 id=\"四-常用内置模块\"><a href=\"#四-常用内置模块\" class=\"headerlink\" title=\"四.常用内置模块\"></a>四.常用内置模块</h2><h3 id=\"1-1-认识path模块\"><a href=\"#1-1-认识path模块\" class=\"headerlink\" title=\"1.1. 认识path模块\"></a>1.1. 认识path模块</h3><p>path模块用于对路径和文件进行处理，提供了很多好用的方法。</p>\n<p>并且我们知道在Mac OS、Linux和window上的路径是不一样的</p>\n<ul>\n<li>window上会使用 <code>\\</code>或者 <code>\\\\</code> 来作为文件路径的分隔符，当然目前也支持 <code>/</code>；</li>\n<li>在Mac OS、Linux的Unix操作系统上使用 <code>/</code> 来作为文件路径的分隔符；</li>\n</ul>\n<p>那么如果我们在window上使用 <code>\\</code> 来作为分隔符开发了一个应用程序，要部署到Linux上面应该怎么办呢？</p>\n<ul>\n<li>显示路径会出现一些问题；</li>\n<li>所以为了屏蔽他们之间的差异，在开发中对于路径的操作我们可以使用 <code>path</code> 模块；</li>\n</ul>\n<h3 id=\"1-2-path常见的API\"><a href=\"#1-2-path常见的API\" class=\"headerlink\" title=\"1.2. path常见的API\"></a>1.2. path常见的API</h3><p><strong>从路径中获取信息</strong></p>\n<ul>\n<li>dirname：获取文件的父文件夹；</li>\n<li>basename：获取文件名；</li>\n<li>extname：获取文件扩展名；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const path &#x3D; require(&quot;path&quot;);\n\nconst myPath &#x3D; &#39;&#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;课堂&#x2F;PPT&#x2F;01_邂逅Node.pdf&#39;;\n\nconst dirname &#x3D; path.dirname(myPath);\nconst basename &#x3D; path.basename(myPath);\nconst extname &#x3D; path.extname(myPath);\n\nconsole.log(dirname); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;课堂&#x2F;PPT\nconsole.log(basename); &#x2F;&#x2F; 01_邂逅Node.pdf\nconsole.log(extname); &#x2F;&#x2F; .pdf</code></pre>\n\n<p><strong>路径的拼接</strong></p>\n<ul>\n<li>如果我们希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符；</li>\n<li>这个时候我们可以使用<code>path.join</code>函数；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(path.join(&#39;&#x2F;user&#39;, &#39;why&#39;, &#39;abc.txt&#39;));</code></pre>\n\n<p><strong>将文件和某个文件夹拼接</strong></p>\n<ul>\n<li><p>如果我们希望将某个文件和文件夹拼接，可以使用 <code>path.resolve</code>;</p>\n</li>\n<li><ul>\n<li><code>resolve</code>函数会判断我们拼接的路径前面是否有 <code>/</code>或<code>../</code>或<code>./</code>；</li>\n</ul>\n</li>\n<li><p>如果有表示是一个绝对路径，会返回对应的拼接路径；</p>\n</li>\n<li><p>如果没有，那么会和当前执行文件所在的文件夹进行路径的拼接</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">path.resolve(&#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;06_常见的内置模块&#x2F;02_文件路径&#x2F;abc.txt\npath.resolve(&#39;&#x2F;abc.txt&#39;); &#x2F;&#x2F; &#x2F;abc.txt\npath.resolve(&#39;&#x2F;User&#x2F;why&#39;, &#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;User&#x2F;why&#x2F;abc.txt\npath.resolve(&#39;User&#x2F;why&#39;, &#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;06_常见的内置模块&#x2F;02_文件路径&#x2F;User&#x2F;why&#x2F;abc.txt</code></pre>\n\n<p>resolve其实我们在webpack中也会使用：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const CracoLessPlugin &#x3D; require(&#39;craco-less&#39;);\nconst path &#x3D; require(&quot;path&quot;);\n\nconst resolve &#x3D; dir &#x3D;&gt; path.resolve(__dirname, dir);\n\nmodule.exports &#x3D; &#123;\n  plugins: [\n    &#123;\n      plugin: CracoLessPlugin,\n      options: &#123;\n        lessLoaderOptions: &#123;\n          lessOptions: &#123;\n            modifyVars: &#123; &#39;@primary-color&#39;: &#39;#1DA57A&#39; &#125;,\n            javascriptEnabled: true,\n          &#125;,\n        &#125;,\n      &#125;,\n    &#125;\n  ],\n  webpack: &#123;\n    alias: &#123;\n      &quot;@&quot;: resolve(&quot;src&quot;),\n      &quot;components&quot;: resolve(&quot;src&#x2F;components&quot;)\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"内置模块fs\"><a href=\"#内置模块fs\" class=\"headerlink\" title=\"内置模块fs\"></a>内置模块fs</h2><h3 id=\"1-1-认识fs模块\"><a href=\"#1-1-认识fs模块\" class=\"headerlink\" title=\"1.1. 认识fs模块\"></a>1.1. 认识fs模块</h3><p>fs是File System的缩写，表示文件系统。</p>\n<p>对于任何一个为服务器端服务的语言或者框架通常都会有自己的文件系统：</p>\n<ul>\n<li>因为服务器需要将各种数据、文件等放置到不同的地方；</li>\n<li>比如用户数据可能大多数是放到数据库中的（后面我们也会学习）；</li>\n<li>比如某些配置文件或者用户资源（图片、音视频）都是以文件的形式存在于操作系统上的；</li>\n</ul>\n<p>Node也有自己的文件系统操作模块，就是fs：</p>\n<ul>\n<li>借助于Node帮我们封装的文件系统，我们可以在任何的操作系统（window、Mac OS、Linux）上面直接去操作文件；</li>\n<li>这也是Node可以开发服务器的一大原因，也是它可以成为前端自动化脚本等热门工具的原因；</li>\n</ul>\n<p>Node文件系统的API非常的多：<a href=\"https://nodejs.org/dist/latest-v14.x/docs/api/fs.html\">https://nodejs.org/dist/latest-v14.x/docs/api/fs.html</a></p>\n<ul>\n<li>我们不可能，也没必要一个个去学习；</li>\n<li>这个更多的应该是作为一个API查询的手册，等用到的时候查询即可；</li>\n<li>学习阶段我们只需要学习最常用的即可；</li>\n</ul>\n<p>但是这些API大多数都提供三种操作方式：</p>\n<ul>\n<li>方式一：同步操作文件：代码会被阻塞，不会继续执行；</li>\n<li>方式二：异步回调函数操作文件：代码不会被阻塞，需要传入回调函数，当获取到结果时，回调函数被执行；</li>\n<li>方式三：异步Promise操作文件：代码不会被阻塞，通过 <code>fs.promises</code> 调用方法操作，会返回一个Promise，可以通过then、catch进行处理；</li>\n</ul>\n<p><strong>我们这里以获取一个文件的状态为例：</strong></p>\n<ul>\n<li>注意：都需要引入 <code>fs</code> 模块；</li>\n</ul>\n<p>方式一：同步操作文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 1.方式一: 同步读取文件\nconst state &#x3D; fs.statSync(&#39;..&#x2F;foo.txt&#39;);\nconsole.log(state);\n\nconsole.log(&#39;后续代码执行&#39;);</code></pre>\n\n<p>方式二：异步回调函数操作文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 2.方式二: 异步读取\nfs.stat(&quot;..&#x2F;foo.txt&quot;, (err, state) &#x3D;&gt; &#123;\n  if (err) &#123;\n    console.log(err);\n    return;\n  &#125;\n  console.log(state);\n&#125;)\nconsole.log(&quot;后续代码执行&quot;);</code></pre>\n\n<p>方式三：异步Promise操作文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 3.方式三: Promise方式\nfs.promises.stat(&quot;..&#x2F;foo.txt&quot;).then(state &#x3D;&gt; &#123;\n  console.log(state);\n&#125;).catch(err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\nconsole.log(&quot;后续代码执行&quot;);</code></pre>\n\n<p>后续代码演练中，我将以异步回调的方式演练：相对更通用一些；</p>\n<h3 id=\"1-2-文件描述符\"><a href=\"#1-2-文件描述符\" class=\"headerlink\" title=\"1.2. 文件描述符\"></a>1.2. 文件描述符</h3><p>文件描述符（File descriptors）是什么呢？</p>\n<p>在 POSIX 系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。</p>\n<ul>\n<li>每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。</li>\n<li>在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件。</li>\n<li>Windows 系统使用了一个虽然不同但概念上类似的机制来跟踪资源。</li>\n<li>为了简化用户的工作，Node.js 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符。</li>\n</ul>\n<p><code>fs.open()</code> 方法用于分配新的文件描述符。一旦被分配，则文件描述符可用于从文件读取数据、向文件写入数据、或请求关于文件的信息。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 获取文件描述符\nfs.open(&quot;..&#x2F;foo.txt&quot;, &#39;r&#39;, (err, fd) &#x3D;&gt; &#123;\n  console.log(fd);\n\n  fs.fstat(fd, (err, state) &#x3D;&gt; &#123;\n    console.log(state);\n  &#125;)\n&#125;)</code></pre>\n\n<h3 id=\"1-3-文件的读写\"><a href=\"#1-3-文件的读写\" class=\"headerlink\" title=\"1.3. 文件的读写\"></a>1.3. 文件的读写</h3><p>如果我们希望对文件的内容进行操作，这个时候可以使用文件的读写：</p>\n<ul>\n<li><code>fs.readFile(path[, options], callback)</code>：读取文件的内容；</li>\n<li><code>fs.writeFile(file, data[, options], callback)</code>：在文件中写入内容；</li>\n</ul>\n<p>文件写入：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">fs.writeFile(&#39;..&#x2F;foo.txt&#39;, content, &#123;&#125;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)</code></pre>\n\n<p>在上面的代码中，你会发现有一个大括号没有填写任何的内容，这个是写入时填写的option参数：</p>\n<ul>\n<li>flag：写入的方式。</li>\n<li>encoding：字符的编码；</li>\n</ul>\n<p>我们先来看flag：</p>\n<ul>\n<li><p>flag的值有很多：<a href=\"https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system_flags\">https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system_flags</a></p>\n</li>\n<li><ul>\n<li><code>w</code> 打开文件写入，默认值；</li>\n</ul>\n</li>\n<li><p><code>w+</code>打开文件进行读写，如果不存在则创建文件；</p>\n</li>\n<li><p><code>r+</code> 打开文件进行读写，如果不存在那么抛出异常；</p>\n</li>\n<li><p><code>r</code>打开文件读取，读取时的默认值；</p>\n</li>\n<li><p><code>a</code>打开要写入的文件，将流放在文件末尾。如果不存在则创建文件；</p>\n</li>\n<li><p><code>a+</code>打开文件以进行读写，将流放在文件末尾。如果不存在则创建文件</p>\n</li>\n</ul>\n<p>我们再来看看编码：</p>\n<ul>\n<li>我之前在简书上写过一篇关于字符编码的文章：<a href=\"https://www.jianshu.com/p/899e749be47c\">https://www.jianshu.com/p/899e749be47c</a></li>\n<li>目前基本用的都是UTF-8编码；</li>\n</ul>\n<p>文件读取：</p>\n<ul>\n<li>如果不填写encoding，返回的结果是Buffer；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">fs.readFile(&#39;..&#x2F;foo.txt&#39;, &#123;encoding: &#39;utf-8&#39;&#125;, (err, data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)</code></pre>\n\n<p>文件读取：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const fs &#x3D; require(&#39;fs&#39;);\n\nfs.readFile(&#39;..&#x2F;foo.txt&#39;, &#123;encoding: &#39;utf-8&#39;&#125;, (err, data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)</code></pre>\n\n<h3 id=\"1-4-文件夹操作\"><a href=\"#1-4-文件夹操作\" class=\"headerlink\" title=\"1.4. 文件夹操作\"></a>1.4. 文件夹操作</h3><p><strong>新建一个文件夹</strong></p>\n<p>使用<code>fs.mkdir()</code>或<code>fs.mkdirSync()</code>创建一个新文件夹：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const fs &#x3D; require(&#39;fs&#39;);\n\nconst dirname &#x3D; &#39;..&#x2F;why&#39;;\n\nif (!fs.existsSync(dirname)) &#123;\n  fs.mkdir(dirname, (err) &#x3D;&gt; &#123;\n    console.log(err);\n  &#125;)\n&#125;</code></pre>\n\n<p><strong>获取文件夹的内容</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 读取文件夹\nfunction readFolders(folder) &#123;\n  fs.readdir(folder, &#123;withFileTypes: true&#125; ,(err, files) &#x3D;&gt; &#123;\n    files.forEach(file &#x3D;&gt; &#123;\n      if (file.isDirectory()) &#123;\n        const newFolder &#x3D; path.resolve(dirname, file.name);\n        readFolders(newFolder);\n      &#125; else &#123;\n        console.log(file.name);\n      &#125;\n    &#125;)\n  &#125;)\n&#125;\n\nreadFolders(dirname);</code></pre>\n\n<p><strong>文件重命名</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">fs.rename(&#39;..&#x2F;why&#39;, &#39;..&#x2F;coder&#39;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)</code></pre>\n\n<h2 id=\"内置模块events\"><a href=\"#内置模块events\" class=\"headerlink\" title=\"内置模块events\"></a>内置模块events</h2><h3 id=\"3-1-基本使用\"><a href=\"#3-1-基本使用\" class=\"headerlink\" title=\"3.1. 基本使用\"></a>3.1. 基本使用</h3><p>Node中的核心API都是基于异步事件驱动的：</p>\n<ul>\n<li>在这个体系中，某些对象（发射器（Emitters））发出某一个事件；</li>\n<li>我们可以监听这个事件（监听器 Listeners），并且传入的回调函数，这个回调函数会在监听到事件时调用；</li>\n</ul>\n<p>发出事件和监听事件都是通过EventEmitter类来完成的，它们都属于events对象。</p>\n<ul>\n<li><code>emitter.on(eventName, listener)</code>：监听事件，也可以使用<code>addListener</code>；</li>\n<li><code>emitter.off(eventName, listener)</code>：移除事件监听，也可以使用<code>removeListener</code>；</li>\n<li><code>emitter.emit(eventName[, ...args])</code>：发出事件，可以携带一些参数；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const EventEmmiter &#x3D; require(&#39;events&#39;);\n\n&#x2F;&#x2F; 监听事件\nconst bus &#x3D; new EventEmmiter();\n\nfunction clickHanlde(args) &#123;\n  console.log(&quot;监听到click事件&quot;, args);\n&#125;\n\nbus.on(&quot;click&quot;, clickHanlde);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  bus.emit(&quot;click&quot;, &quot;coderwhy&quot;);\n  bus.off(&quot;click&quot;, clickHanlde);\n  bus.emit(&quot;click&quot;, &quot;kobe&quot;);\n&#125;, 2000);</code></pre>\n\n<h3 id=\"3-2-常见的属性\"><a href=\"#3-2-常见的属性\" class=\"headerlink\" title=\"3.2. 常见的属性\"></a>3.2. 常见的属性</h3><p>EventEmitter的实例有一些属性，可以记录一些信息：</p>\n<ul>\n<li><code>emitter.eventNames()</code>：返回当前 <code>EventEmitter对象</code>注册的事件字符串数组；</li>\n<li><code>emitter.getMaxListeners()</code>：返回当前 <code>EventEmitter对象</code>的最大监听器数量，可以通过<code>setMaxListeners()</code>来修改，默认是10；</li>\n<li><code>emitter.listenerCount(事件名称)</code>：返回当前 <code>EventEmitter对象</code>某一个事件名称，监听器的个数；</li>\n<li><code>emitter.listeners(事件名称)</code>：返回当前 <code>EventEmitter对象</code>某个事件监听器上所有的监听器数组；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(bus.eventNames());\nconsole.log(bus.getMaxListeners());\nconsole.log(bus.listenerCount(&quot;click&quot;));\nconsole.log(bus.listeners(&quot;click&quot;));</code></pre>\n\n<h3 id=\"3-3-方法的补充\"><a href=\"#3-3-方法的补充\" class=\"headerlink\" title=\"3.3. 方法的补充\"></a>3.3. 方法的补充</h3><p><code>emitter.once(eventName, listener)</code>：事件监听一次</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const EventEmitter &#x3D; require(&#39;events&#39;);\n\nconst emitter &#x3D; new EventEmitter();\n\nemitter.once(&#39;click&#39;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;监听到事件&quot;, args);\n&#125;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  emitter.emit(&#39;click&#39;, &#39;coderwhy&#39;);\n  emitter.emit(&#39;click&#39;, &#39;coderwhy&#39;);\n&#125;, 2000);</code></pre>\n\n<p><code>emitter.prependListener()</code>：将监听事件添加到最前面</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">emitter.on(&#39;click&#39;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;a监听到事件&quot;, args);\n&#125;)\n\n&#x2F;&#x2F; b监听事件会被放到前面\nemitter.prependListener(&quot;click&quot;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;b监听到事件&quot;, args);\n&#125;)</code></pre>\n\n<p><code>emitter.prependOnceListener()</code>：将监听事件添加到最前面，但是只监听一次</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">emitter.prependOnceListener(&quot;click&quot;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;c监听到事件&quot;, args);\n&#125;)</code></pre>\n\n<p><code>emitter.removeAllListeners([eventName])</code>：移除所有的监听器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 移除emitter上的所有事件监听\nemitter.removeAllListeners();\n&#x2F;&#x2F; 移除emitter上的click事件监听\nemitter.removeAllListeners(&quot;click&quot;);</code></pre>\n","text":"四.常用内置模块1.1. 认识path模块path模块用于对路径和文件进行处理，提供了很多好用的方法。 并且我们知道在Mac OS、Linux和window上的路径是不一样的 window上会使用 \\或者 \\\\ 来作为文件路径的分隔符，当然目前也支持 /； 在Mac OS、Lin...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B-%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">四.常用内置模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E8%AE%A4%E8%AF%86path%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">1.1. 认识path模块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-path%E5%B8%B8%E8%A7%81%E7%9A%84API\"><span class=\"toc-text\">1.2. path常见的API</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97fs\"><span class=\"toc-text\">内置模块fs</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E8%AE%A4%E8%AF%86fs%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">1.1. 认识fs模块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\"><span class=\"toc-text\">1.2. 文件描述符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99\"><span class=\"toc-text\">1.3. 文件的读写</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">1.4. 文件夹操作</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97events\"><span class=\"toc-text\">内置模块events</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">3.1. 基本使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">3.2. 常见的属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E6%96%B9%E6%B3%95%E7%9A%84%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">3.3. 方法的补充</span></a></li></ol></li></ol>","author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Node基础五","uid":"f31c41ff35acbf9aa56d10f7617b9f93","slug":"node/base/Node基础五","date":"2022-10-01T04:25:11.000Z","updated":"2022-10-24T14:25:11.508Z","comments":true,"path":"api/articles/node/base/Node基础五.json","keywords":"chriswood blogs sharing","cover":[],"text":"五.npm你不知道的细节1.1. 认识npm我们已经学习了在JavaScript中可以通过模块化的方式将代码划分成一个个小的结构： 在以后的开发中我们就可以通过模块化的方式来封装自己的代码，并且封装成一个工具； 这个工具我们可以让同事通过导入的方式来使用，甚至你可以分享给世界各地...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Node基础三","uid":"4d3281e0b26c044e36154a269947cf99","slug":"node/base/Node基础三","date":"2022-10-01T04:23:22.000Z","updated":"2022-10-24T14:25:11.508Z","comments":true,"path":"api/articles/node/base/Node基础三.json","keywords":"chriswood blogs sharing","cover":[],"text":"三 . 掌握前端模块化1.1. JavaScript设计缺陷那么，到底什么是模块化开发呢？ 事实上模块化开发最终的目的是将程序划分成一个个小的结构； 这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构； 这个结构可以将自己希望暴露的变量、函数、对象等导出给其结...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"Node","slug":"Node","count":12,"path":"api/categories/Node.json"}],"tags":[{"name":"Node Node基础系列","slug":"Node-Node基础系列","count":12,"path":"api/tags/Node-Node基础系列.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}