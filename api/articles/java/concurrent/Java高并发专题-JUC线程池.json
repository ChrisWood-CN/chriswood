{"title":"Java高并发专题-JUC线程池","uid":"ab71b7b05749a5527c735a9fb6d5af98","slug":"java/concurrent/Java高并发专题-JUC线程池","date":"2022-10-08T08:55:43.000Z","updated":"2022-10-23T11:40:19.006Z","comments":true,"path":"api/articles/java/concurrent/Java高并发专题-JUC线程池.json","keywords":"chriswood blogs sharing","cover":null,"content":"<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><h4 id=\"Executor框架接口\"><a href=\"#Executor框架接口\" class=\"headerlink\" title=\"Executor框架接口\"></a>Executor框架接口</h4><ul>\n<li>Executors.newCachedThreadPool() 创建缓存线程池<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThreadPoolExample1 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;</code></pre></li>\n<li>Executors.newFixedThreadPool(3) 创建定长线程池<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThreadPoolExample2 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(3);\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;</code></pre></li>\n<li>Executors.newSingleThreadExecutor() 创建单线程线程池<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThreadPoolExample3 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor();\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;</code></pre></li>\n<li>Executors.newScheduledThreadPool(1) 创建定长线程池，支持定时，周期性的任务执行<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThreadPoolExample4 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ScheduledExecutorService executorService &#x3D; Executors.newScheduledThreadPool(1);\n\n        executorService.scheduleAtFixedRate(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                log.warn(&quot;schedule run&quot;);\n            &#125;\n        &#125;, 1, 3, TimeUnit.SECONDS);\n        \n&#x2F;&#x2F;        executorService.shutdown();\n\n        Timer timer &#x3D; new Timer();\n        timer.schedule(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                log.warn(&quot;timer run&quot;);\n            &#125;\n        &#125;, new Date(), 5 * 1000);\n    &#125;\n&#125;</code></pre>\n前面三种线程池都是直接创建ThreadPoolExecutor类的对象。ScheduledThreadPool 因为要实现定时功能，创建的是 ScheduledThreadPoolExecutor 类的对象。但 ScheduledThreadPoolExecutor 也是继承自ThreadPoolExecutor 。<br>下面这个构造方法是参数最全的一个创建线程池的源码。<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial\n * parameters.\n *\n * @param corePoolSize 线程池中维持的线程数量。\n *                     当线程数量不超过这个数时，即使线程处于空闲状态也不会被销毁，会一直等待任务到来。\n *                     但是如果设置 allowCoreThreadTimeOut 为 true，corePoolSize 就不再有效了。\n * @param maximumPoolSize 线程池中线程的最大数量。\n * @param keepAliveTime 当线程数量超过了 corePoolSize 时，多余的线程销毁前等待的时间。\n * @param unit keepAliveTime 的时间单位\n * @param workQueue 用来管理待执行任务的队列。\n * @param threadFactory 创建线程的工厂。\n * @param handler RejectedExecutionHandler 接口的实现对象。用于处理任务被拒绝执行的情况。\n *                被拒绝的原因可能是所有线程正在执行任务而任务队列容量又满了\n *&#x2F;\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) &#123;\n    ...\n&#125;</code></pre></li>\n</ul>\n","text":"线程池Executor框架接口 Executors.newCachedThreadPool() 创建缓存线程池public class ThreadPoolExample1 &#123; public static void main(String[] args) &#123; ...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"Java高并发专题","slug":"Java高并发专题","count":1,"path":"api/categories/Java高并发专题.json"}],"tags":[{"name":"Java高并发专题","slug":"Java高并发专题","count":1,"path":"api/tags/Java高并发专题.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">线程池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Executor%E6%A1%86%E6%9E%B6%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">Executor框架接口</span></a></li></ol></li></ol>","author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"docker环境部署集群前后端分离项目","uid":"fd6db9879e8a7f6e92c3104daa24218a","slug":"docker/docker环境部署集群前后端分离项目","date":"2022-10-12T08:05:29.000Z","updated":"2022-10-23T11:40:19.006Z","comments":true,"path":"api/articles/docker/docker环境部署集群前后端分离项目.json","keywords":"chriswood blogs sharing","cover":null,"text":"docker环境部署集群前后端分离项目一、基础1.Docker虚拟机常用命令1.先更新软件包 scriptyum -y update 2.安装Docker虚拟机 scriptyum install -y docker 3.运行、重启、关闭Docker虚拟机 scriptservi...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"docker","slug":"docker","count":1,"path":"api/categories/docker.json"}],"tags":[{"name":"docker","slug":"docker","count":1,"path":"api/tags/docker.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"springboot配置文件","uid":"38ca70cafbfd87b7f0418630bd7d0ad1","slug":"springboot/springboot配置文件","date":"2022-10-08T07:55:43.000Z","updated":"2022-10-23T11:40:19.010Z","comments":true,"path":"api/articles/springboot/springboot配置文件.json","keywords":"chriswood blogs sharing","cover":null,"text":"springboot配置文件在springboot 项目中一般默认的配置文件是application.properties,但是实际项目中我们一般会使用application.yml文件 yml文件读取顺序存放目录SpringBoot配置文件默认可以放到以下目录中，可以自动读取到...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"springboot","slug":"springboot","count":1,"path":"api/categories/springboot.json"}],"tags":[{"name":"springboot","slug":"springboot","count":1,"path":"api/tags/springboot.json"}],"author":{"name":"ChrisWood","slug":"blog-author","avatar":"https://chriswood-blog.oss-cn-shanghai.aliyuncs.com/me/avatar.png","link":"/","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/ChrisWood-CN","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}