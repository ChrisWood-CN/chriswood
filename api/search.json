[{"id":"05c6b7bccc0f16753e9101299bf620c9","title":"docker镜像构建方式","content":"创建镜像的方法主要有三种：\n\n基于已有镜像的容器创建\n基于本地模板导入\n基于Dockerfile创建\n\n一、基于容器创建镜像基于已有容器构建镜像主要是通过docker commit命令来构建新的镜像，语法规则如下：\ndocker commit [OPTIONS] CONTAINER [REPOSITORY:TAG]\ndocker commit -m &quot;centos7+java8+zh&quot; -a &quot;chriswoodcn&quot; 4b40b9568be3 centos7_java8_zh:1.0.0\n# 上面-m选项指定了新镜像的提交信息，-a标注作者信息，4b40b9568be3是容器ID，centos7_java8_zh:1.0.0是指定的新镜像名称和版本。\n\n二、基于本地模板导入用户也可以从模板文件中导入镜像，主要使用docker import命令\n# 创造出一个模板，即 将容器导入到一个模板文件中\ndocker export 4b40b9568be3 &gt; &#x2F;root&#x2F;centos7_java8_zh.tar\n# 利用模板导入成镜像\ndocker import &#x2F;root&#x2F;centos7_java8_zh.tar chriswoodcn&#x2F;centos7_java8_zh:1.0\ndocker images\n# REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE\n# chriswoodcn&#x2F;centos7_java8_zh      1.0              498afccbfb2d        5 seconds ago          560MB\n\n三、基于Dockerfile构建基于Dockerfile构建镜像就目前而言是使用最为广泛的Dockerfile是由一组指令组成的文件，其每条指令对应Linux中的一条命令，Docker程序通过读取Dockerfile中的指令最终生成镜像。\n\n\n\n指令\n含义\n\n\n\nFROM 镜像名称\n指定新镜像基于的镜像，第一条指令必须为FROM指令\n\n\nMAINTAINER 名字\n镜像维护人信息\n\n\nRUN 命令\n在基于的镜像上执行命令，并提交到新镜像中，可以多条\n\n\nCMD[“要运行的程序”,”参数1”,”参数2”]\n指定启动容器时要执行的命令或者脚本  Dockerfile只能有一条CMD命令 不可以追加命令\n\n\nEXPOSE 端口号\n指定新镜像加载到docker时要开启的端口号\n\n\nENV 环境变量 变量值\n设置环境变量 后面可以使用 可以多个\n\n\nADD 源文件&#x2F;目录 目标文件&#x2F;目录\n将源文件复制到目标文件\n\n\nCOPY 源文件&#x2F;目录 目标文件&#x2F;目录\n将主机上的文件&#x2F;目录复制到目标地点\n\n\nVOLUME[“目录”]\n在容器中创建一个挂载点\n\n\nUSER 用户名&#x2F;UID\n指定运行容器时的用户\n\n\nWORKDIR 路径\n为后续的RUN、CMD、ENTRYPOINT指定工作目录\n\n\nONBUILD 命令\n指定所生成的镜像作为一个基础镜像时所要运行的命令\n\n\nHEALTHCHECK\n健康检查\n\n\nENTRYPOINT\n指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有其他传入值作为该命令的参数\n\n\n\nENTRYPOINT写法 \nexec 格式 -&gt; ENTRYPOINT [“executable”, “param1”, “param2”]\nshell 格式 -&gt; ENTRYPOINT command param1 param2\n\n\nCMD 和 ENTRYPOINT 区别CMD                   # 指定这个容器启动的时候要运行的命令，不可以追加命令\nENTRYPOINT            # 指定这个容器启动的时候要运行的命令，可以追加命令\n当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;\n#dockerfile\n#指定父镜像\nFROM centos:centos7\n#指定维护者信息\nMAINTAINER chriswoodcn \nRUN mkdir -p &#x2F;fitness&#x2F;server\nRUN mkdir -p &#x2F;fitness&#x2F;server&#x2F;logs\nRUN mkdir -p &#x2F;fitness&#x2F;server&#x2F;temp\n\nWORKDIR &#x2F;fitness&#x2F;server\n\nENV SERVER_PORT&#x3D;8080\nENV ACTIVE&#x3D;dev\n\nEXPOSE $&#123;SERVER_PORT&#125;\n\nADD .&#x2F;target&#x2F;fitness-admin.jar .&#x2F;app.jar\n\nENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;, &quot;-Dserver.port&#x3D;$&#123;SERVER_PORT&#125;&quot;,&quot;-jar&quot;,&quot;-Dspring.profiles.active&#x3D;$&#123;ACTIVE&#125;&quot;,&quot;-Dfile.encoding&#x3D;UTF-8&quot;,&quot;app.jar&quot;]\ndocker build -f dockerfile -t fitness-server:1.0.0 .\n\n四、将本地Docker镜像上传到Docker Hub上1.创建并登录https://hub.docker.com/\ndocker login --username&#x3D;chriswoodcn\n# 提示输入密码，正确输入密码后，提示Login Succeeded\n2.构建镜像\ndocker build -f centos7_java8_zh_dockerfile -t chriswoodcn&#x2F;centos7_java8_zh  .\n3.网页登录Docker Hub，创建仓库chriswoodcn&#x2F;centos7_java8_zh4.给镜像打标签\ndocker tag chriswoodcn&#x2F;centos7_java8_zh chriswoodcn&#x2F;centos7_java8_zh:1.1.0\n5.上传镜像到Docker Hub上\ndocker push chriswoodcn&#x2F;centos7_java8_zh:1.1.0\n","slug":"docker/docker镜像构建方式","date":"2023-02-08T03:04:06.000Z","categories_index":"docker","tags_index":"docker","author_index":"ChrisWood"},{"id":"6bb5feb5ebe53be9e2c2838a6f221b1e","title":"springboot日志配置","content":"默认日志 Logback默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。 spring-boot-starter其中包含了 spring-boot-starter-logging，该依赖内容就是 Spring Boot默认的日志框架 logback。\n\n\n\n\n\n\n\n\n\n日志级别从低到高分为 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL\n\n\n\n\n\n\n\n\n\n如果设置为 WARN ，则低于 WARN 的信息都不会输出。\n\n\n\n\n\n\n\n\n\nSpring Boot中默认配置ERROR、WARN和INFO级别的日志输出到控制台\n还可以通过启动您的应用程序 –debug 标志来启用“调试”模式。\n\n在运行命令后加入–debug标志，如\n\n$ java -jar springTest.jar --debug\n\n\n在application.properties中配置debug&#x3D;true\n\n\n\n\n\n\n\n\n\n\n该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是自己应用的日志并不会输出为DEBUG级别\n文件输出默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。\n\n在application.properties或application.yml配置。 这样只能配置简单的场景，保存路径、日志格式等，复杂的场景（区分 info 和 error 的日志、每天产生一个日志文件等）满足不了，只能自定义配置\n\nlogging:\n  level:\n    root: info #整个项目的日志级别为info\n    com.taotao: debug  #com.taotao包下所有class以debug级别输出\n    org.springframework: warn #org.springframework包下所有class以warn级别输出\n  pattern:\n    console: &quot;%d-%msg%n&quot;\n  path: .&#x2F;logs  #默认会在设置的 path 生成一个spring.log 文件\n  file: .&#x2F;logs&#x2F;test-log #指定文件名\n\n\n\n\n\n\n\n\n\n\n注：path file 二者不能同时使用，如若同时使用，则只有logging.file生效 默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO\n自定义日志配置根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载\n\nLogback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy\nLog4j：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml\nLog4j2：log4j2-spring.xml, log4j2.xml\nJDK (Java Util Logging)：logging.properties\n\n\n\n\n\n\n\n\n\n\nSpring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项（下面会提到）。 默认的命名规则，并且放在 src&#x2F;main&#x2F;resources 下面即可\n如果想完全掌控日志配置，但又不想用logback.xml作为Logback配置的名字，application.yml可以通过logging.config属性指定自定义的名字\nlogging:\n  config: classpath:log.xml\n\n根节点 configuration1.configuration有5个子节点 2.configuration属性\n\nscan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。\nscanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。\ndebug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n\n&lt;configuration&gt;\n    &lt;property name&#x3D;&quot;log.path&quot; value&#x3D;&quot;&#x2F;pethouse&#x2F;server&#x2F;log&quot;&#x2F;&gt;\n    &lt;include resource&#x3D;&quot;org&#x2F;springframework&#x2F;boot&#x2F;logging&#x2F;logback&#x2F;base.xml&quot;&#x2F;&gt;\n    &lt;!--  ...--&gt;\n&lt;&#x2F;configuration&gt;\n\n子节点一 root\n1.root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性\n2.level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。 默认是DEBUG。\n3.可以包含零个或多个元素，标识这个appender将会添加到这个loger\n\n    &lt;!-- 系统日志输出 --&gt;\n&lt;appender name&#x3D;&quot;file_info&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n    &lt;file&gt;$&#123;log.path&#125;&#x2F;sys-info.log&lt;&#x2F;file&gt;\n    &lt;!-- 循环政策：基于时间创建日志文件 --&gt;\n    &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;\n        &lt;!-- 日志文件名格式 --&gt;\n        &lt;fileNamePattern&gt;$&#123;log.path&#125;&#x2F;sys-info.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;fileNamePattern&gt;\n        &lt;!-- 日志最大的历史 60天 --&gt;\n        &lt;maxHistory&gt;60&lt;&#x2F;maxHistory&gt;\n    &lt;&#x2F;rollingPolicy&gt;\n    &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;\n        &lt;!-- 过滤的级别 --&gt;\n        &lt;level&gt;INFO&lt;&#x2F;level&gt;\n        &lt;!-- 匹配时的操作：接收（记录） --&gt;\n        &lt;onMatch&gt;ACCEPT&lt;&#x2F;onMatch&gt;\n        &lt;!-- 不匹配时的操作：拒绝（不记录） --&gt;\n        &lt;onMismatch&gt;DENY&lt;&#x2F;onMismatch&gt;\n    &lt;&#x2F;filter&gt;\n&lt;&#x2F;appender&gt;\n\n&lt;appender name&#x3D;&quot;file_error&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n  &lt;file&gt;$&#123;log.path&#125;&#x2F;sys-error.log&lt;&#x2F;file&gt;\n  &lt;!-- 循环政策：基于时间创建日志文件 --&gt;\n  &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;\n      &lt;!-- 日志文件名格式 --&gt;\n      &lt;fileNamePattern&gt;$&#123;log.path&#125;&#x2F;sys-error.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;fileNamePattern&gt;\n      &lt;!-- 日志最大的历史 60天 --&gt;\n      &lt;maxHistory&gt;60&lt;&#x2F;maxHistory&gt;\n  &lt;&#x2F;rollingPolicy&gt;\n  &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;\n      &lt;!-- 过滤的级别 --&gt;\n      &lt;level&gt;ERROR&lt;&#x2F;level&gt;\n      &lt;!-- 匹配时的操作：接收（记录） --&gt;\n      &lt;onMatch&gt;ACCEPT&lt;&#x2F;onMatch&gt;\n      &lt;!-- 不匹配时的操作：拒绝（不记录） --&gt;\n      &lt;onMismatch&gt;DENY&lt;&#x2F;onMismatch&gt;\n  &lt;&#x2F;filter&gt;\n&lt;&#x2F;appender&gt;\n\n&lt;!-- info异步输出 --&gt;\n&lt;appender name&#x3D;&quot;async_info&quot; class&#x3D;&quot;com.yomahub.tlog.core.enhance.logback.async.AspectLogbackAsyncAppender&quot;&gt;\n  &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;\n  &lt;discardingThreshold&gt;0&lt;&#x2F;discardingThreshold&gt;\n  &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;\n  &lt;queueSize&gt;512&lt;&#x2F;queueSize&gt;\n  &lt;!-- 添加附加的appender,最多只能添加一个 --&gt;\n  &lt;appender-ref ref&#x3D;&quot;file_info&quot;&#x2F;&gt;\n&lt;&#x2F;appender&gt;\n\n&lt;!-- error异步输出 --&gt;\n&lt;appender name&#x3D;&quot;async_error&quot; class&#x3D;&quot;com.yomahub.tlog.core.enhance.logback.async.AspectLogbackAsyncAppender&quot;&gt;\n  &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;\n  &lt;discardingThreshold&gt;0&lt;&#x2F;discardingThreshold&gt;\n  &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;\n  &lt;queueSize&gt;512&lt;&#x2F;queueSize&gt;\n  &lt;!-- 添加附加的appender,最多只能添加一个 --&gt;\n  &lt;appender-ref ref&#x3D;&quot;file_error&quot;&#x2F;&gt;\n&lt;&#x2F;appender&gt;\n&lt;root level&#x3D;&quot;info&quot;&gt;\n  &lt;appender-ref ref&#x3D;&quot;console&quot;&#x2F;&gt;\n  &lt;appender-ref ref&#x3D;&quot;async_info&quot;&#x2F;&gt;\n  &lt;appender-ref ref&#x3D;&quot;async_error&quot;&#x2F;&gt;\n  &lt;appender-ref ref&#x3D;&quot;file_console&quot;&#x2F;&gt;\n&lt;&#x2F;root&gt;\n\n子节点二 contextName 设置上下文名称\n1.每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用设置成其他名字，用于区分不同应用程序的记录。\n2.一旦设置，不能修改,可以通过%contextName来打印日志上下文名称，一般来说我们不用这个属性，可有可无。&lt;contextName&gt;pethouse-server&lt;&#x2F;contextName&gt;\n\n子节点三 property 设置变量\n1.用来定义变量值的标签， 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。\n2.通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量&lt;property name&#x3D;&quot;log.path&quot; value&#x3D;&quot;&#x2F;pethouse&#x2F;server&#x2F;log&quot;&#x2F;&gt;\n\n子节点四 appender\n1.appender用来格式化日志输出节点，有2个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。\n\n控制台输出 ConsoleAppender&lt;encoder&gt;表示对日志进行编码：\n%d&#123;HH: mm:ss.SSS&#125;——日志输出时间\n%thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用\n%-5level——日志级别，并且使用5个字符靠左对齐\n%logger&#123;36&#125;——日志输出者的名字\n%msg——日志消息\n%n——平台的换行符\nThresholdFilter为系统定义的拦截器，例如我们用ThresholdFilter来过滤掉ERROR级别以下的日志不输出到文件中。如果不用记得注释掉，不然你控制台会发现没日志\n\n&lt;configuration&gt;\n    &lt;contextName&gt;pethouse-server&lt;&#x2F;contextName&gt;\n    &lt;!-- 彩色日志 --&gt;\n    &lt;!-- 彩色日志依赖的渲染类 --&gt;\n    &lt;conversionRule conversionWord&#x3D;&quot;clr&quot; converterClass&#x3D;&quot;org.springframework.boot.logging.logback.ColorConverter&quot;&#x2F;&gt;\n    &lt;conversionRule conversionWord&#x3D;&quot;wex&quot;\n                    converterClass&#x3D;&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;&#x2F;&gt;\n    &lt;conversionRule conversionWord&#x3D;&quot;wEx&quot;\n                    converterClass&#x3D;&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;&#x2F;&gt;\n    &lt;!-- 彩色日志格式 --&gt;\n    &lt;property name&#x3D;&quot;CONSOLE_LOG_PATTERN&quot;\n              value&#x3D;&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;&#x2F;&gt;\n    &lt;!--输出到控制台 ConsoleAppender--&gt;\n    &lt;appender name&#x3D;&quot;consoleLog1&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n        &lt;!--展示格式 layout--&gt;\n        &lt;layout class&#x3D;&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;\n            &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;&#x2F;pattern&gt;\n        &lt;&#x2F;layout&gt;\n    &lt;&#x2F;appender&gt;\n    &lt;appender name&#x3D;&quot;consoleLog2&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;\n            &lt;level&gt;ERROR&lt;&#x2F;level&gt;\n        &lt;&#x2F;filter&gt;\n        &lt;encoder&gt;\n            &lt;Pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;&#x2F;Pattern&gt;\n            &lt;!-- 设置字符集 --&gt;\n            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;\n        &lt;&#x2F;encoder&gt;\n    &lt;&#x2F;appender&gt;\n    &lt;!--指定最基础的日志输出级别--&gt;\n    &lt;root level&#x3D;&quot;INFO&quot;&gt;\n        &lt;!--appender将会添加到这个loger--&gt;\n        &lt;appender-ref ref&#x3D;&quot;consoleLog1&quot;&#x2F;&gt;\n        &lt;appender-ref ref&#x3D;&quot;consoleLog2&quot;&#x2F;&gt;\n    &lt;&#x2F;root&gt;\n&lt;&#x2F;configuration&gt;\n\n输出到文件 RollingFileAppender另一种常见的日志输出到文件，随着应用的运行时间越来越长，日志也会增长的越来越多，将他们输出到同一个文件并非一个好办法。RollingFileAppender用于切分文件日志\n&lt;appender name&#x3D;&quot;fileInfoLog&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n    &lt;!--如果只是想要 Info 级别的日志，只是过滤 info 还是会输出 Error 日志，因为 Error 的级别高，\n    所以我们使用下面的策略，可以避免输出 Error 的日志--&gt;\n    &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;\n        &lt;!--过滤 Error--&gt;\n        &lt;level&gt;ERROR&lt;&#x2F;level&gt;\n        &lt;!--匹配到就禁止--&gt;\n        &lt;onMatch&gt;DENY&lt;&#x2F;onMatch&gt;\n        &lt;!--没有匹配到就允许--&gt;\n        &lt;onMismatch&gt;ACCEPT&lt;&#x2F;onMismatch&gt;\n    &lt;&#x2F;filter&gt;\n    &lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则\n        如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天\n        的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。\n    --&gt;\n    &lt;File&gt;$&#123;logback.logdir&#125;&#x2F;info.$&#123;logback.appname&#125;.log&lt;&#x2F;File&gt;\n    &lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;\n    &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;\n        &lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;\n        &lt;FileNamePattern&gt;$&#123;logback.logdir&#125;&#x2F;info.$&#123;logback.appname&#125;.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;FileNamePattern&gt;\n        &lt;!--只保留最近90天的日志--&gt;\n        &lt;maxHistory&gt;90&lt;&#x2F;maxHistory&gt;\n        &lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;\n        &lt;totalSizeCap&gt;1GB&lt;&#x2F;totalSizeCap&gt;\n    &lt;&#x2F;rollingPolicy&gt;\n    &lt;!--日志输出编码格式化--&gt;\n    &lt;encoder&gt;\n        &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;\n        &lt;pattern&gt;%d [%thread] %-5level %logger&#123;36&#125; %line - %msg%n&lt;&#x2F;pattern&gt;\n    &lt;&#x2F;encoder&gt;\n&lt;&#x2F;appender&gt;\n\n\n&lt;appender name&#x3D;&quot;fileErrorLog&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n&lt;!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter--&gt;\n&lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;\n    &lt;level&gt;Error&lt;&#x2F;level&gt;\n&lt;&#x2F;filter&gt;\n&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则\n    如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天\n    的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。\n--&gt;\n&lt;File&gt;$&#123;logback.logdir&#125;&#x2F;error.$&#123;logback.appname&#125;.log&lt;&#x2F;File&gt;\n&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;\n&lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;\n    &lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;\n    &lt;FileNamePattern&gt;$&#123;logback.logdir&#125;&#x2F;error.$&#123;logback.appname&#125;.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;FileNamePattern&gt;\n    &lt;!--只保留最近90天的日志--&gt;\n    &lt;maxHistory&gt;90&lt;&#x2F;maxHistory&gt;\n    &lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;\n    &lt;totalSizeCap&gt;1GB&lt;&#x2F;totalSizeCap&gt;\n&lt;&#x2F;rollingPolicy&gt;\n&lt;!--日志输出编码格式化--&gt;\n&lt;encoder&gt;\n    &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;\n    &lt;pattern&gt;%d [%thread] %-5level %logger&#123;36&#125; %line - %msg%n&lt;&#x2F;pattern&gt;\n&lt;&#x2F;encoder&gt;\n&lt;&#x2F;appender&gt;\n\n异步输出 AspectLogbackAsyncAppender基于以上两种基础输出做了一层异步处理的包装，每个AspectLogbackAsyncAppender最多只能包装一个appender\n&lt;appender name&#x3D;&quot;file_error&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n  &lt;file&gt;$&#123;log.path&#125;&#x2F;sys-error.log&lt;&#x2F;file&gt;\n  &lt;!-- 循环政策：基于时间创建日志文件 --&gt;\n  &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;\n      &lt;!-- 日志文件名格式 --&gt;\n      &lt;fileNamePattern&gt;$&#123;log.path&#125;&#x2F;sys-error.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;fileNamePattern&gt;\n      &lt;!-- 日志最大的历史 60天 --&gt;\n      &lt;maxHistory&gt;60&lt;&#x2F;maxHistory&gt;\n  &lt;&#x2F;rollingPolicy&gt;\n  &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;\n      &lt;!-- 过滤的级别 --&gt;\n      &lt;level&gt;ERROR&lt;&#x2F;level&gt;\n      &lt;!-- 匹配时的操作：接收（记录） --&gt;\n      &lt;onMatch&gt;ACCEPT&lt;&#x2F;onMatch&gt;\n      &lt;!-- 不匹配时的操作：拒绝（不记录） --&gt;\n      &lt;onMismatch&gt;DENY&lt;&#x2F;onMismatch&gt;\n  &lt;&#x2F;filter&gt;\n&lt;&#x2F;appender&gt;\n\n&lt;!-- error异步输出 --&gt;\n&lt;appender name&#x3D;&quot;async_error&quot; class&#x3D;&quot;com.yomahub.tlog.core.enhance.logback.async.AspectLogbackAsyncAppender&quot;&gt;\n  &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;\n  &lt;discardingThreshold&gt;0&lt;&#x2F;discardingThreshold&gt;\n  &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;\n  &lt;queueSize&gt;512&lt;&#x2F;queueSize&gt;\n  &lt;!-- 添加附加的appender,最多只能添加一个 --&gt;\n  &lt;appender-ref ref&#x3D;&quot;file_error&quot;&#x2F;&gt;\n&lt;&#x2F;appender&gt;\n\n子节点五 logger属性\nname:用来指定受此logger约束的某一个包或者具体的某一个类。\nlevel:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前logger将会继承上级的级别。\naddtivity:是否向上级logger传递打印信息。默认是true。\n\n&lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。\n&lt;logger&gt;仅有一个name属性，一个可选的level和一个可选的addtivity属性\n\n用法\n1.带有logger的配置，不指定级别，不指定appender，logback-spring.xml增加 logger 配置如下：\n\n&lt;!--控制com.taotao.pethouse.app.controller包下的所有类的日志的打印，--&gt;\n&lt;!--        没有设置打印级别，所以继承他的上级的日志级别“info”；--&gt;\n&lt;!--        没有设置addtivity，默认为true，将此loger的打印信息向上级传递；--&gt;\n&lt;!--        没有设置appender，此loger本身不打印任何信息。--&gt;\n&lt;logger name&#x3D;&quot;com.taotao.pethouse.app.controller&quot;&#x2F;&gt;\n        &lt;!--将级别为“info”及大于“info”的日志信息传递给root，本身并不打印--&gt;\n        &lt;!-- root接到下级传递的信息，交给已经配置好的名为“console”的appender处理，“console” appender 将信息打印到控制台--&gt;\n\n\n2.带有多个logger的配置，指定级别，指定appender\n\n&lt;!--控制com.taotao.pethouse.app.controller类的日志打印，打印级别为“WARN”;--&gt;\n&lt;!--additivity属性为false，表示此loger的打印信息不再向上级传递;--&gt;\n&lt;!--指定了名字为“console”的appender--&gt;\n&lt;logger name&#x3D;&quot;com.taotao.pethouse.app.controller&quot; level&#x3D;&quot;WARN&quot; additivity&#x3D;&quot;false&quot;&gt;\n    &lt;appender-ref ref&#x3D;&quot;console&quot;&#x2F;&gt;\n&lt;&#x2F;logger&gt;\n        &lt;!--级别为“WARN”及大于“WARN”的日志信息交给此logger指定的名为“console”的appender处理，在控制台中打出日志，不再向上级root传递打印信息--&gt;\n\n多环境日志输出1.logback-spring.xml增加springProfile标签配置\n\n&lt;configuration&gt;\n    &lt;!--    ...--&gt;\n    &lt;!--application.yml 传递参数，不能使用logback 自带的&lt;property&gt;标签 --&gt;\n    &lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;appname&quot; source&#x3D;&quot;logback.appname&quot;&#x2F;&gt;\n    &lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;logdir&quot; source&#x3D;&quot;logback.logdir&quot;&#x2F;&gt;\n\n    &lt;contextName&gt;$&#123;appname&#125;&lt;&#x2F;contextName&gt;\n\n    &lt;!--输出到控制台 ConsoleAppender--&gt;\n    &lt;appender name&#x3D;&quot;console&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n        &lt;!--展示格式 layout--&gt;\n        &lt;layout class&#x3D;&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;\n            &lt;pattern&gt;\n                &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;&#x2F;pattern&gt;\n            &lt;&#x2F;pattern&gt;\n        &lt;&#x2F;layout&gt;\n    &lt;&#x2F;appender&gt;\n\n    &lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;\n    &lt;springProfile name&#x3D;&quot;test,dev&quot;&gt;\n        &lt;logger name&#x3D;&quot;com.taotao.pethouse.app.controller&quot; level&#x3D;&quot;DEBUG&quot; additivity&#x3D;&quot;false&quot;&gt;\n            &lt;appender-ref ref&#x3D;&quot;console&quot;&#x2F;&gt;\n        &lt;&#x2F;logger&gt;\n    &lt;&#x2F;springProfile&gt;\n\n    &lt;!-- 生产环境. --&gt;\n    &lt;springProfile name&#x3D;&quot;prod&quot;&gt;\n        &lt;logger name&#x3D;&quot;com.taotao.pethouse.app.controller&quot; level&#x3D;&quot;INFO&quot; additivity&#x3D;&quot;false&quot;&gt;\n            &lt;appender-ref ref&#x3D;&quot;console&quot;&#x2F;&gt;\n        &lt;&#x2F;logger&gt;\n    &lt;&#x2F;springProfile&gt;\n&lt;&#x2F;configuration&gt;\n\n2.application.yml增加环境选择的配置active: dev；自定义日志路径\nspring:\n  profiles:\n    active: dev\nlogback:\n  logdir: .&#x2F;server&#x2F;log\n  appname: pethouse\n\n\n\n\n\n\n\n\n\n\n\n参考：https://blog.csdn.net/inke88/article/details/75007649#comments?utm_source&#x3D;tuicool&amp;utm_medium&#x3D;referral\n","slug":"springboot/springboot日志配置","date":"2023-02-07T06:59:47.000Z","categories_index":"springboot,springboot配置","tags_index":"springboot,springboot配置","author_index":"ChrisWood"},{"id":"f55822a9843defac7c7cd98d8f77df10","title":"docker部署hbase","content":"docker搭建hbase环境Linux系统：centos 7.6 Hbase：harisekhon&#x2F;hbase\nHbase1.拉取镜像 并部署启动\n方式一 手动分配所有端口\ndocker run -d -p 2181:2181 \\\n-p 8080:8080 -p 8085:8085 -p 9090:9090 -p 9095:9095 \\\n-p 16000:16000 -p 16010:16010 -p 16201:16201 -p 16301:16301  -p 16030:16030 -p 16020:16020 \\\n--name hbase harisekhon&#x2F;hbase\n\n方式二 系统自动映射端口（-P主机随机分配端口与宿主机上端口进行映射）\ndocker run -d --name hbase -P harisekhon&#x2F;hbase\n\n方式三 只映射web页面的端口（推荐）\ndocker run -d --name hbase -p 16010:16010 harisekhon&#x2F;hbase\n\n2181\tzookeeper\tzkCli.sh -server zookeeper1:2181\t客户端接入\n16000\tHBase Master\thbase-client-1.x.x.jar\tRegionServer接入\n16010\tHBase Master\thttp:&#x2F;&#x2F;namenode1:16010&#x2F;\t集群监控\n16020\tHBase RegionServer\t\t客户端接入\n16030\tHBase RegionServer\thttp:&#x2F;&#x2F;datanode1:16030&#x2F;\t节点监控\n\n打开网址： http://xxx.xxx.xxx.xxx:16010/master-status2.Host文件设置 如果在本地访问 Hbase网址，还需要在HOST文件中添加Hbase与域名的映射。\nxxx.xxx.xxx.xxx b0fbee058d4e\n\n3.环境变量 实际项目在开发环境利用Java来操作Hbase所以还需要在本地配置下Hadoop环境变量。\nHODOOP_HOME： D:\\Environment\\Hadoop\\2.10.1\nPATH： %HODOOP_HOME%\\bin\n\n4.hbase操作\ndocker exec -it hbase bash\ncd hbase-2.1.3&#x2F;bin\n\n\n进入hbase客户端\n\n.&#x2F;hbase shell\n\n\n创建命名空间\n\ncreate_namespace &#39;test&#39;\n\n\n查看命名空间\n\nlist_namespace\n\n\n\n\n\n\n\n\n\n\n注：HBase系统默认定义了两个默认的 namespace hbase：系统内建表，包括 namespace 和 meta 表 default：用户建表时未指定 namespace 的表都创建在此\n\n删除命名空间\n\ndrop_namespace &#39;test&#39;\n\n\n创建表\n\ncreate &#39;命名空间:表名&#39;，&#123;NAME &#x3D;&gt; ’列族名‘, &#39;列族属性&#39; &#x3D;&gt;  &#39;&#39;&#125;\ncreate &#39;test:user&#39;, &#123;NAME &#x3D;&gt; &#39;aaa&#39;, VERSIONS &#x3D;&gt; &#39;3&#39;, TTL &#x3D;&gt; &#39;2147483647&#39;, &#39;BLOOMFILTER&#39; &#x3D;&gt; &#39;ROW&#39;&#125;, \n\t\t\t\t\t&#123;NAME &#x3D;&gt; &#39;bbb&#39;, VERSIONS &#x3D;&gt; &#39;3&#39;, TTL &#x3D;&gt; &#39;2147483647&#39;, &#39;BLOOMFILTER&#39; &#x3D;&gt; &#39;ROW&#39;&#125;\n# 意思是，在 test 命名空间下创建 user 表，表中有两个列族，分别是列 aaa 和 bbb，版本有3个，存活时间 2147483647(s)，布隆过滤器过滤依据是 RowKey。\n\n\n查看表结构\n\ndesc &#39;命名空间:表名&#39;\n\n\n修改列族属性\n\nalter &#39;命名空间:表名&#39;, NAME &#x3D;&gt; &#39;列族名&#39;, 列族属性&#x3D;&gt; &#39;NewValue&#39;\n\n\n查看命名空间下的表\n\nlist_namespace_tables &#39;命名空间&#39;\n\n\n删除表\n\ndisable &#39;test:user&#39; # 删除前要先禁用表\ndrop &#39;test:user&#39; \t# 执行删除\n\n\n扫描数据（多行）\n\nscan &#39;命名空间:表名&#39;\n\n\n添加数据\n\nput ‘命名空间:表名’, &#39;RowKey&#39;, &#39;列族:列&#39;, &#39;具体值&#39;\n\nput &#39;test:user&#39;,&#39;1&#39;, &#39;aaa:name&#39;, &#39;zhangsan&#39;\nput &#39;test:user&#39;,&#39;1&#39;, &#39;bbb:phone&#39;, &#39;12345678919&#39;\n\nput &#39;test:user&#39;,&#39;2&#39;, &#39;aaa:name&#39;, &#39;lisi&#39; \n\n\n\n\n\n\n\n\n\n\n注：HBase 是列族式数据库，所以是在真正添加数据时才指定有哪些列\n\n\n\n\n\n\n\n\n\n在建表时设置了 Version&#x3D;3 ，aaa:name 可以保存三个值 put ‘test:user’,’1’, ‘b:name’, ‘wangwu’ put ‘test:user’,’1’, ‘b:name’, ‘zhaoliu’为什么添加后再 scan 看不到添加的数据呢？因为 scan 扫描多行，所以显示的是所有列的最新版本；要获取一个列列数据的所有版本要通过单列查询 get…\n\n获取数据（单行）\n\nget &#39;命名空间:表名&#39;, &#39;RowKey&#39; \t\t\t\t\t\t # 获取指定行键的数据\nget &#39;命名空间:表名&#39;, &#39;RowKey&#39;, &#123;COLUMN &#x3D;&gt; &#39;列族:列&#39;&#125;    # 获取指定行键的指定列的数据\nget &#39;命名空间:表名&#39;, &#39;RowKey&#39;, &#123;COLUMN &#x3D;&gt; &#39;列族:列&#39;, VERSIONS &#x3D;&gt; n&#125;   # 获取指定行键的指定列的数据，显示n个版本\n\nget &#39;test:user&#39;, &#39;1&#39;, &#123;COLUMN &#x3D;&gt; &#39;aaa:name&#39;, VERSIONS &#x3D;&gt; 3&#125; # 注：建表时设置的 3，即使你这写个 4，也只能返回三行数据\n\n\n更新数据\n\nput ‘命名空间:表名’, &#39;RowKey&#39;, &#39;列族:列&#39;, &#39;NewValue&#39; #更新其实就是追加（如果此时数据个数到达 Version 数了，那么前面最老的版本就会被淘汰）\n\n\n删除数据\ndelete &#39;命名空间:表名&#39;, &#39;RowKey&#39;, &#39;列族:列&#39;, 时间戳（注：如果不指定时间戳，则默认删除最新版本）\n\n\n\n\n\n\n\n\n\n已经有4条数据了 删除最新的一条 则之前三条会出来重点：HBase 的删除只是打上了删除了标记（墓碑标记），跟更新一样，并不是真正移除，过早的版本会在执行 Major Compaction 时真正删除\n\n清空表中数据\ntruncate&#96; &#39;命名空间:表名&#39; # 三步：1.禁用 2.删除 3.重建\n\n\n\n\n\n\n\n\n\n注：HBase 的脚本是.hsh，跟.sql一个意思。\n\n\n","slug":"docker/docker部署hbase","date":"2023-02-06T07:22:50.000Z","categories_index":"docker,hbase","tags_index":"docker,hbase","author_index":"ChrisWood"},{"id":"61a9c9a9f7385f264375e290c4106594","title":"kafka学习","content":"安装启动ZooKeeper（单机模式）1.下载解压镜像地址下载zookeeper，tar -zxvf 解压至&#x2F;opt2.配置环境变量\nvim &#x2F;etc&#x2F;profile\n\nexport ZOOKEEPER_HOME&#x3D;&#x2F;opt&#x2F;apache-zookeeper-3.8.1-bin\nexport PATH&#x3D;$ZOOKEEPER_HOME&#x2F;bin:$PATH\n\nsource &#x2F;etc&#x2F;profile\n3.修改ZooKeeper配置文件\ncd &#x2F;opt&#x2F;apache-zookeeper-3.8.1-bin&#x2F;conf\ncp zoo_sample.cfg zoo.cfg\n\nmkdir &#x2F;tmp&#x2F;zookeeper&#x2F;data\nmkdir &#x2F;tmp&#x2F;zookeeper&#x2F;log\n\nvim zoo.cfg\n\n# zookeeper服务器心跳时间 单位ms\ntickTime&#x3D;2000\n# 投票选举新leader的初始化时间\ninitLimit&#x3D;10\n#leader 与 follower心跳检测最大容忍时间，超过syncLimit*tickTime leader认为follower挂掉，从服务器列表中删除follower\nsyncLimit&#x3D;5\n# 数据目录\ndataDir&#x3D;&#x2F;tmp&#x2F;zookeeper&#x2F;data\n# 日志目录\ndataLogDir&#x3D;&#x2F;tmp&#x2F;zookeeper&#x2F;log\n# zookeeper对外服务端口\nclientPort&#x3D;2181\n4.创建myid文件并设置服务器编号\ncd &#x2F;tmp&#x2F;zookeeper&#x2F;data\nvim myid\n# 写入0 保存 退出\n5.启动Zookeeper服务，并查看Zookeeper的服务状态\nzkServer.sh start\nzkServer.sh status\n\n安装并启动Kafka（单机模式）1.下载解压镜像地址kafka，tar -zxvf 解压至&#x2F;opt2.配置环境变量\nvim &#x2F;etc&#x2F;profile\n\nexport KAFKA_HOME&#x3D;&#x2F;opt&#x2F;kafka_2.12-2.8.2\nexport PATH&#x3D;KAFKA_HOME&#x2F;bin:$PATH\n\nsource &#x2F;etc&#x2F;profile\n3.修改kafka配置文件\nmkdir &#x2F;tmp&#x2F;kafka&#x2F;log\ncd &#x2F;opt&#x2F;kafka_2.12-2.8.2&#x2F;config\n\nvim server.properties\n\nbroker.id&#x3D;0\nlisteners&#x3D;PLAINTEXT:&#x2F;&#x2F;localhost:9092\nlog.dirs&#x3D;&#x2F;tmp&#x2F;kafka&#x2F;log\nzookeeper.connect&#x3D;localhost:2181&#x2F;kafka\n","slug":"kafka/kafka学习","date":"2023-02-02T08:21:26.000Z","categories_index":"kafka,zookeeper","tags_index":"kafka,zookeeper","author_index":"ChrisWood"},{"id":"08e8e341bc5995ad32cb07dac198cc20","title":"docker部署kafka集群","content":"docker搭建Zookeeper单机+kafka集群环境Linux系统：centos 7.6Zookeeper：wurstmeister&#x2F;zookeeperKafka：wurstmeister&#x2F;kafka\nZookeeper单机docker pull wurstmeister&#x2F;zookeeper\n\ndocker run -d --name zookeeper -p 2181:2181 -t wurstmeister&#x2F;zookeeper\nKafka集群docker pull wurstmeister&#x2F;kafka\n\ndocker run -d --name kafka0 -p 9092:9092 \\\n-e KAFKA_BROKER_ID&#x3D;0 \\\n-e KAFKA_ZOOKEEPER_CONNECT&#x3D;124.221.83.80:2181 \\\n-e KAFKA_ADVERTISED_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;124.221.83.80:9092 \\\n-e KAFKA_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;0.0.0.0:9092 \\\n-t wurstmeister&#x2F;kafka\n\ndocker run -d --name kafka1 -p 9093:9093 \\\n-e KAFKA_BROKER_ID&#x3D;1 \\\n-e KAFKA_ZOOKEEPER_CONNECT&#x3D;124.221.83.80:2181 \\\n-e KAFKA_ADVERTISED_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;124.221.83.80:9093 \\\n-e KAFKA_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;0.0.0.0:9093 \\\n-t wurstmeister&#x2F;kafka\n\ndocker run -d --name kafka2 -p 9094:9094 \\\n-e KAFKA_BROKER_ID&#x3D;2 \\\n-e KAFKA_ZOOKEEPER_CONNECT&#x3D;124.221.83.80:2181 \\\n-e KAFKA_ADVERTISED_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;124.221.83.80:9094 \\\n-e KAFKA_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;0.0.0.0:9094 \\\n-t wurstmeister&#x2F;kafka\ndocker ps\n\nCONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS                                                                   NAMES\n3950fc28423e   wurstmeister&#x2F;kafka       &quot;start-kafka.sh&quot;         6 seconds ago    Up 5 seconds    0.0.0.0:9094-&gt;9094&#x2F;tcp, :::9094-&gt;9094&#x2F;tcp                               kafka2\n12cf92618c00   wurstmeister&#x2F;kafka       &quot;start-kafka.sh&quot;         8 seconds ago    Up 7 seconds    0.0.0.0:9093-&gt;9093&#x2F;tcp, :::9093-&gt;9093&#x2F;tcp                               kafka1\na525a115890b   wurstmeister&#x2F;kafka       &quot;start-kafka.sh&quot;         9 seconds ago    Up 7 seconds    0.0.0.0:9092-&gt;9092&#x2F;tcp, :::9092-&gt;9092&#x2F;tcp                               kafka0\nff862fe0f2ca   wurstmeister&#x2F;zookeeper   &quot;&#x2F;bin&#x2F;sh -c &#39;&#x2F;usr&#x2F;sb…&quot;   27 minutes ago   Up 27 minutes   22&#x2F;tcp, 2888&#x2F;tcp, 3888&#x2F;tcp, 0.0.0.0:2181-&gt;2181&#x2F;tcp, :::2181-&gt;2181&#x2F;tcp   zookeeper\n创建topic测试docker exec -it kafka0 bash\ncd opt&#x2F;kafka_2.13-2.8.1&#x2F;bin\nkafka-topics.sh --zookeeper 124.221.83.80:2181 --create --topic topic-demo --partitions 3 --replication-factor 1\nkafka-topics.sh --zookeeper 124.221.83.80:2181 --describe --topic topic-demo\n","slug":"docker/docker部署kafka集群","date":"2023-02-02T07:28:39.000Z","categories_index":"docker,kafka","tags_index":"docker,kafka","author_index":"ChrisWood"},{"id":"16f10664209103c56b5fcc131366977c","title":"近代史","content":"近代史重大纪念意义的历史事件\n中国共产主义青年团成立100周年（1922-2022）\n《在延安文艺座谈会上的讲话》《整顿党的作风》《反对党八股》发表80周年（1942-2022）\n邓小平南方谈话、十四大召开30周年（1992-2022）\n中美上海公报、中日邦交正常化50周年（1972-2022）\n中华民国临时政府成立；《中华民国临时约法》颁布110周年（1912-2022）\n中英《南京条约》180周年（1842-2022）\n\n第一章 反对外国侵略的斗争第一节 资本—帝国主义对中国的侵略及近代中国的性质一、鸦片战争前的中国和世界1.鸦片战争前的中国（封建社会4特征）\n经济：封建地主土地所有制经济占主导地位\n政治：高度中央集权的封建君主专制制度\n社会：族权和政权相结合的封建宗法等级制度\n文化：以儒家思想为核心\n\n2.鸦片战争前的世界（英国：资产阶级革命、工业革命）二、资本—帝国主义对中国的侵略1.资本—帝国主义对中国的侵略方式\n（1）军事侵略①发动侵略战争，屠杀中国人民②侵占中国领土，划分势力范围 （《瑷珲条约》，割去黑龙江以北60万平方公里领土 ）③勒索赔款，抢掠财富\n（2）政治控制①控制中国的内政、外交：领事裁判权②镇压中国人民的反抗③扶植、收买代理人\n（3）经济掠夺①控制中国的通商口岸 ②剥夺中国的关税自主权③实行商品倾销和资本输出（《马关条约》）④操纵中国的经济命脉\n（4）文化渗透①披着宗教外衣，进行侵略活动②为侵略中国制造舆论\n\n2.鸦片战争及其影响：领土领海司法关税主权\n（1）1842年《南京条约》（中国近代第一个不平等条约180周年）\n（2） 中美《望厦条约》、中法《黄埔条约》\n（3）英国侵占香港三个条约：《南京条约》、《北京条约》、《展拓香港界址专条》\n（4）鸦片战争对中国社会发展进程的影响（鸦片战争是中国近代史的开端）：社会性质、社会主要矛盾、革命任务变化\n认识中国近代一切社会问题和革命问题的最基  本依据——认识中国近代社会的性质，就是认  识近代中国的基本国情（半殖民地半封建社会）\n近代中国社会两个根本性变化\n独立的中国逐步变为半殖民地的中国\n封建的中国逐步变为半封建社会\n\n\n\n\n\n三、近代中国社会的半殖民地半封建性质1.中国逐步变成半殖民地的原因\n（1）鸦片战争以后，西方列强通过发动侵略战争，强迫中国签订一系列不平等条约，破坏中国的领土主权、领海主权、关税主权、司法主权等，中国已经丧失了完全独立的地位，在相当程度上被殖民地化了\n（2）西方列强侵略中国的目的，是要把它变成自己的殖民地。但是由于中国长期以来一直是一个统一的大国，特别是中国人民顽强、持久的反抗，同时也由于帝国主义列强间争夺中国的矛盾无法协调，使得它们中的任何一个国家都无法单独征服中国，也使得它们不可能共同瓜分中国\n（3）列强在中国不是实行直接殖民统治，而是通过其代理人对中国实行间接统治\n\n2.中国逐步变成半封建社会的原因\n（1）外国资本主义列强用武力打开中国的门户，把中国卷入世界资本主义经济体系和世界市场之中。一方面，破坏了中国自给自足的自然经济的基础，破坏了城市的手工业和农民的家庭手工业；另一方面，则促进了中国城乡商品经济的发展，给中国资本主义的产生造成了某些客观条件。\n（2）西方列强并不愿意中国成为独立的资本主义国家。中国民族资本主义经济虽然有些发展，但没有也不可能成为中国社会经济的主要形式。中国经济既不是完全的封建经济也不是完全的资本主义经济\n\n3.中国半殖民地半封建社会的基本特征\n（1）资本—帝国主义侵略势力不但逐步操纵了中国的财政和经济命脉，而且逐步控制了中国的政治，日益成为支配中国的决定性力量。\n（2）中国的封建势力日益衰败并同外国侵略势力勾结，成为资本—帝国主义压迫、奴役中国人民的社会基础和统治支柱\n（3）中国自然经济的基础虽然遭到破坏，但是封建剥削制度的根基即封建地主的土地所有制依然在广大地区内保持着，成为中国走向现代化和民主化的严重障碍。\n（4）中国新兴的民族资本主义经济虽然已经产生，并在政治、文化生活中起了一定的作用，但是在帝国主义和封建主义的压迫下，它的发展很缓慢，力量很软弱，而且它的大部分与外国资本—帝国主义和本国封建主义都有或多或少的联系。\n（5）由于近代中国处于资本—帝国主义列强的争夺和间接统治之下，加上中国地域广大，以及在地方性的农业经济的基础上形成的地方割据势力的存在，近代中国各地区经济、政治和文化的发展是极不平衡的。\n（6）在资本—帝国主义和封建主义的双重压迫下（后来还加上官僚资本主义），中国的广大人民尤其是农民日益贫困化以至大批地破产，过着饥寒交迫和毫无政治权利的生活\n\n4.社会阶级关系的变动\n（1）地主阶级本身发生了某些变化：有的附股外资企业；有的入股洋务企业；有的直接创办或参股民营企业，转化为资本家。\n（2）农民的分化：不少自耕农失去土地，向贫农或雇农转化；有些成为产业工人的后备军，其所形成的新的阶级无产阶级是中国民主革命的主力军\n（3）中国资产阶级的产生：主要是由一些买办、商人、地主、官僚投资新式企业转化而成。其主要是两个部分：一部分是官僚买办资本家，另一部分是民族资本家\n（4）近代中国诞生的工人阶级是中国新生产力的代表：它身受帝国主义、封建势力、资产阶级三重压迫，受剥削最深，革命性最强，而且它还有组织纪律性强、集中、团结、与广大农民有着天然联系等优点，因此是近代中国最革命的阶级。（旧社会产生的双生子：资产阶级、无产阶级）\n中国工人阶级同世界各国的工人阶级一样，与最先进的生产方式相联系，是新生产力的代表者，富于组织性、纪律性，自身特点如下：\n①深受帝国主义、封建势力、资产阶级压迫，革命性最强。\n②人数虽少,却相对集中（地域上集中在沿海沿江通商口岸城市、行业上主要集中在纺织、采矿、铁路、航运等行业），便于形成革命力量和传播先进思想。\n③大多来自破产农民，与农民有天然联系，便于结成工农联盟。\n\n\n\n四、近代中国的主要矛盾和历史任务1．近代中国的主要矛盾\n主要矛盾是帝国主义和中华民族的矛盾和封建主义和人民大众的矛盾，其中占支配地位的是民族矛盾。\n\n2．近代中国的历史任务\n两大历史任务，就是争取民族独立、人民解放（改变落后的生产关系，前提）和实现国家富强、人民富裕（发展生产力，最终目的和必然要求）。两个任务既相互区别又紧密联系\n\n第二节 抵御外国武装侵略，争取民族独立的斗争一、反抗外来侵略的斗争\n1．人民群众的反侵略斗争\n1841年5月，广州三元里人民的抗英斗争，是中国近代史上中国人民第一次大规模的反侵略武装斗争\n\n\n2．爱国官兵的反侵略斗争\n中法战争期间，法舰进犯台湾，被刘铭传指挥守军击退。1885年3月，在中越边境镇南关（今友谊关），老将冯子材大败法军，取得镇南关大捷。\n1894年中日甲午战争时，致远舰管带（舰长）邓世昌、经远舰管带林永升等，都以身殉国\n\n\n\n二、粉碎瓜分中国的图谋1.边疆危机和瓜分危机\n19世纪70至80年代，帝国主义列强从侵占中国周边邻国发展到蚕食中国边疆地区，使中国陷入“边疆危机”。英国从印度侵入西藏，又从缅甸入侵云南。法国则从越南侵犯广西。俄国从中亚入侵新疆。日本吞并琉球、侵犯中国台湾。\n德俄英法日等国与1898至1899年划分势力范围，掀起瓜分中国的狂潮——时局图\n\n2.义和团运动与列强瓜分中国图谋的破产\n其一，帝国主义列强之间的矛盾和互相制约。\n其二，帝国主义列强不能灭亡和瓜分中国，最根本的原因是中华民族进行的不屈不挠的反侵略斗争。\n义和团存在笼统排外主义的错误、蒙受封建统治者的欺骗、存在许多迷信落后的倾向，但在粉碎帝国主义列强瓜分中国的斗争中发挥了重大历史作用\n\n三、反侵略斗争的失败1.反侵略斗争失败的原因第一，社会制度的腐败是根本原因第二，经济技术的落后\n四、民族意识的觉醒1.林则徐、魏源提出“师夷长技以制夷”的主张\n林则徐是近代中国睁眼看世界的第一人。1841年，林则徐组织翻译了英国人慕瑞的《地理大全》，编成《四洲志》一书。书中叙述了世界五大洲30多个国家的地理、历史。\n魏源在1843年1月编成《海国图志》，提出了“师夷长技以制夷”的思想，主张学习外国先进的军事和科学技术，以期富国强兵\n\n2.早期的维新思想\n19世纪70年代以后，王韬、薛福成、马建忠、郑观应等人不仅主张学习西方的科学技术，同时也要求吸纳西方的政治、经济学说\n\n3.救亡图存和振兴中华\n中日甲午战争以后，当中华民族面临生死存亡的关头时，中国人才开始有了普遍的民族意识的觉醒。\n严复就写了《救亡决论》一文，响亮地喊出了“救亡”的口号\n孙中山喊出“振兴中华”口号鸦片战争后，先进的中国人开始睁眼看世界了，甲午战争后，中国人民的民族意识普遍觉醒\n\n考试重点1.资本—帝国主义列强对中国的侵略2.近代中国社会的半殖民地半封建性质3.近代中国的主要矛盾和历史任务4.民族意识的觉醒第二章 对国家出路的早期探索第一节 农民群众斗争风暴的起落一、太平天国农民战争1.太平天国农民战争爆发的原因2.金田起义和太平天国的建立\n1843年，洪秀全开始拜上帝，后撷取原始基督教教义中反映下层民众要求的平等思想和某些宗教仪式，从农民斗争的需要出发，加以改造，创立了拜上帝教，并利用它发动和组织群众。\n1851年1月，洪秀全率教众在广西省桂平县金田村发动起义，建号太平天国。\n1853年3月，占领南京，定为首都，改名天京，正式宣告太平天国农民政权的建立\n\n3．《天朝田亩制度》和《资政新篇》\n《天朝田亩制度》\n性质 最能体现太平天国社会理想和特色的纲领性文件\n内容  1.确立了平均分配土地的方案  2.规定了农、副产品的生产与分配制度\n评价：革命性  1.一个以解决土地问题为中心的比较完整的社会改革方案  2.从根本上否定了封建地主的土地所有制\n评价：空想性  1.它未能超出农民小生产者的狭隘眼界  2.具有不切实际的空想\n\n\n《资政新篇》是太平天国于1859年由干王洪仁玕颁布的社会改革发展方案\n政治：提倡学习西方资本主义法律、制度\n经济：发展近代工矿、交通等资本主义经济\n文教：学习近代教育和先进技术\n外交：主张自主平等外交政策\n《资政新篇》评价——先进的中国人最早提出的发展资本主义方案\n它是具有鲜明的资本主义色彩的方案，符合中国社  会发展方向，具有历史进步性\n它没有把发展资本主义与消灭封建剥削制度联系起  来，没有同农民斗争实践联系起来；既非农民斗争  实践产物，又缺乏实践的社会、经济和阶级基础，  因此，缺乏实践性。\n\n\n《天朝田亩制度》与《资政新篇 》比较\n相同之处：反对清王朝统治（具有反封建的进步  性），巩固其政权，都无法实行\n不同之处：\n《天朝田亩制度》是建立绝对平均主义的理想王国，违背历史发展规律，必然无法实行。\n《资政新篇》则要在中国建立和发展资本主义生产力和生产关系，符合历史发展方向，但缺乏实践基础，也无法实行\n\n\n\n\n\n4．从天京事变到太平天国败亡\n1856年9月，太平天国发生了自相残杀的天京事变。天京事变严重地削弱了太平天国的领导和军事力量，成为太平天国由盛转衰的分水岭。\n1864年6月，洪秀全病故。7月，天京被湘军攻破。太平天国起义失败\n\n二、农民斗争的意义和局限1．太平天国起义的历史意义\n第一，沉重打击了封建统治阶级，强烈撼动了清政府的统治根基。\n第二，是中国旧式农民战争的最高峰。它把千百年来农民对拥有土地的渴望在《天朝田亩制度》中比较完整地表达了出来。《资政新篇》则是中国近代历史上第一个比较系统的发展资本主义的方案，这反映了太平天国某些领导人在后期试图通过向外国学习来寻求出路的一种努力。因此，具有了不同于以往农民战争的新的历史特点。\n第三，还冲击了孔子和儒家经典的正统权威。\n第四，还有力地打击了外国侵略势力。\n第五，在19世纪中叶的亚洲民族解放运动中，时间最久、规模最大、影响最深的一次。\n太平天国起义具有了不同于以往农民战争新的历史特点\n第一，反封建同时反侵略\n第二，具有资本主义色彩\n第三，遭到中外反动势力的镇压\n\n\n\n2．太平天国农民斗争的局限性和教训\n客观原因：中外反动势力共同镇压\n根本原因：农民阶级局限性   \n小私有者的特点，决定了农民阶级的自私性；\n彼此间毫无联系，像一袋土豆，决定农民阶级的散漫性；\n没有任何多种多样的发展，决定了农民阶级的保守性；\n一家一户，自给自足，决定了农民阶级的狭隘性\n\n\n失败原因具体表现：\n（1）思想上：没有科学理论指导\n（2）组织上：没有坚强的领导核心\n（3）政治上：无法从根本上提出完整的、正确的政治纲领和社会改革方案；无法制止和克服领导集团自身腐败现象的滋生；也无法长期保持领导集团的团结。\n（4）军事上：军事战略上岀现了重大失误\n（5）文化上：未能正确对待儒学 \n（6）外交上：对于西方资本主义侵略缺乏理性的认识\n\n\n太平天国起义失败教训\n在半殖民地半封建的中国，农民具有伟大的革命潜力；但它自身不能担负起领导反帝反封建斗争取得胜利的重任。单纯的农民战争不可能完成争取民族独立和人民解放的历史任务。\n\n\n\n第二节 洋务运动的兴衰一、洋务事业的兴办\n时间：19世纪60-90年代一、洋务事业的兴办\n代表人物：奕䜣、曾国藩、李鸿章、左宗棠、张之洞\n\n1.目的：首先是为了购买和制造洋枪洋炮以镇压农民起义。其次，借此加强海防、边防，并乘机发展本集团的政治、经济、军事实力。\n2.指导思想：冯桂芬在《校邠庐抗议》：中学为体，西学为用\n3.洋务事业\n兴办近代企业\n军用工业：江南制造总局，是当时国内最大的兵工厂；福州船政局是当时国内最大的造船厂\n民用企业：如轮船招商局、开平矿务局、天津电报局等\n新式海陆军：从19世纪70年代到90年代，分别建成北洋水师、南洋水师、福建水师和广东水师\n新式学堂，派遣留学生：学堂形式主要有三种：一为翻译学堂，如京师同文馆；一为工艺学堂；一为军事学堂\n\n\n\n二、洋务运动的历史作用及其失败1.历史作用\n洋务派继承了魏源“师夷长技以制夷”的思想，提出“自强”、“求富”的主张，通过所掌握的国家权力集中力量优先发展军事工业，同时也试图“稍分洋商之利”，发展若干民用企业，在客观上对中国的早期工业和民族资本主义的发展起了某些促进作用。\n洋务运动时期，为了培养通晓洋务的人才，开办了一批新式学堂，派出了最早的官派留学生，这是中国近代教育的开始。\n洋务运动时期，伴随着资本主义生产方式的出现，传统的“重本抑末”、“重义轻利”、商为“四民”之末等观念都受到冲击，社会风气和价值观念开始变化，工商业者的地位上升\n\n2.失败原因：封建性；依赖性；腐朽性\n第三节 维新运动的兴起和夭折一、戊戌维新运动的开展1.维新派倡导救亡和变法的活动\n（1）维新派倡导维新的原因\n19世纪90年代以后，中国民族资本主义有了初步发展。新兴的民族资产阶级迫切要求挣脱外国资本主义和国内封建势力的压迫和束缚，为在中国发展资本主义开辟道路。\n甲午战争的惨败，造成了新的民族危机，激发了新的民族觉醒。代表民族资本主义发展要求的知识分子把向西方学习推进到一个新的高度，不但要求学习西方的科学技术，而且要求学习西方资本主义的政治制度和思想文化。\n在内忧外患的冲击和中西文化的碰撞过程中，人们逐步形成了一个共识，要救国，只有维新，要维新，只有学外国\n\n\n（2）维新派倡导的维新变法活动\n书 向皇帝上书 “公车上书”；著书立说 5本书；介绍外国变法的经验教训 3本书\n学 办学会 3个；设学堂 2个\n报 办报纸 3个\n\n\n\n2.维新派与守旧派的论战\n（1）要不要变法。\n（2）要不要兴民权、设议院，实行君主立宪。\n（3）要不要废八股、改科举和兴西学\n对维新派与守旧派的论战评价：维新派与守旧派的这场论战，实质上是资产阶级思想与封建主义思想在中国的第一次正面交锋。论战所涉及的领域十分广泛，进一步开阔了新型知识分子的眼界，解放了人们长期受到束缚的思想。通过论战，西方资产阶级社会政治学说在中国得到进一步的传播，戊戌变法运动的帷幕随之拉开\n\n3.百日维新\n正式开始标志：光绪皇帝于1898年6月11日颁布了“明定国是”谕旨，宣布开始变法，史称“戊戌变法”，又称“百日维新”。\n评价：“百日维新”期间颁布的各项政令大多是接受了维新派的建议而制定的，旨在开放一定程度的言论、出版、结社自由，使资产阶级享受一定程度的政治权利，促进资本主义工商业的发展，因此，戊戌维新是一场资产阶级性质的改良运动。但是，在光绪皇帝发布的新政诏令中，并没有采纳维新派多次提出的开国会等政治主张。这些政令和措施并未触及封建制度的根本，所要推行的是一种十分温和的改良方案\n\n二、戊戌维新运动的意义和教训1.戊戌维新运动的意义\n第一，戊戌维新运动是一次爱国救亡运动。\n第二，戊戌维新运动是一场资产阶级性质的政治改良运动。\n第三，戊戌维新运动更是一场思想启蒙运动。以维新运动为起点，资产阶级新文化开始打破封建文化独占文化阵地的局面。\n维新派在改革社会风习方面也提出了许多新的主张。\n\n2.戊戌维新运动失败的原因\n戊戌维新运动的失败，主要是由于维新派自身的局限和以慈禧太后为首的强大的守旧势力的反对。具体表现为：\n首先，民族资产阶级力量弱小。\n其次，维新派的局限性：\n一是不敢否定封建主义；\n二是对帝国主义抱有幻想；\n三是惧怕人民群众\n\n\n\n\n戊戌维新运动失败的教训：\n戊戌维新作为中国民族资产阶级登上政治舞台的第一次表演，这不但暴露了这个阶级的软弱性，而且再次暴露出清朝统治集团的腐朽与顽固，这也说明在半殖民地半封建的旧中国，企图通过统治者走自上而下的改良实现国家的独立、民主、富强是根本行不通的，必须用革命的手段，推翻帝国主义、封建主义联合统治的半殖民地半封建的社会制度\n\n\n\n考试重点1.太平天国农民斗争的意义和局限2.洋务事业及其失败原因3.戊戌维新运动的意义、失败原因与教训第三章 辛亥革命与君主专制制度的终结第一节 举起近代民族民主革命的旗帜一、辛亥革命爆发的历史条件\n什么是革命？ \n马克思主义：革命是用一种先进的社会制度代替落后的社会制度； 革命的手段是暴力行动。\n\n\n革命爆发的条件\n列宁：一是人民无法照旧生活下去；二是统治者无法照旧统治下去。\n\n\n辛亥革命爆发的历史条件\n1.民族危机加深，社会矛盾激化。\n2.清末“新政”的破产\n\n\n\n二、资产阶级革命派的活动1.组织准备\n1894年11月，孙中山到檀香山组建了第一个革命团体兴中会。\n1905年8月20日，孙中山和黄兴、宋教仁等人在日本东京成立中国同盟会。这是近代中国第一个领导资产阶级革命的全国性政党，它的成立标志着中国资产阶级民主革命进入了一个新的阶段\n\n2.宣传准备\n章炳麟发表了《驳康有为论革命书》；邹容写了《革命军》；陈天华写了《警世钟》、《猛回头》两本小册子\n\n3.理论准备\n三民主义：“驱除鞑虏，恢复中华，创立民国，平均地权”（民族主义、民权主义、民生主义）\n\n4.军事准备三、三民主义学说和资产阶级共和国方案\n民族主义\n民族主义，即民族革命，包括“驱除鞑虏，恢复中  华”两项内容。一是要以革命手段推翻清朝政府，  改变它一贯推行的民族歧视和民族压迫政策；二是  追求独立，建立“民族独立的国家”\n缺陷：没有从正面鲜明地提出反对帝国主义的主张\n\n\n民权主义\n民权主义即政治革命，内容是“创立民国”，建立  资产阶级民主共和国。\n缺陷：忽略广大工农群众在国家中的地位\n\n\n民生主义\n民生主义即社会革命，指的是“平均地权”。\n缺陷：没有正面触及封建土地所有制\n\n\n\n四、关于革命与改良的辩论\n1905年至1907年间，围绕中国究竟是采用革命手段还是改良方式这个问题，革命派与改良派分别以《民报》、《新民丛报》为主要舆论阵地，展开了一场大论战\n辩论的主要内容：\n一是要不要以革命手段推翻清王朝，这是双方论战的焦点；\n二是要不要推翻帝制，实行共和；\n三是要不要进行社会革命\n\n\n这场论战具有重大意义：通过这场论战划清了革命与改良的界限，传播了民主革命思想，促进了革命形势的发展\n\n第二节 辛亥革命与建立民国一、武昌起义与封建帝制的覆灭1.武装起义与保路风潮\n1906年12月，萍、浏、醴起义是同盟会成立后发动的第一次武装起义。\n1911年4月27日举行广州起义，黄兴率敢死队120余人在广州举行起义，革命党人大部牺牲。七十二烈士的遗骸被葬于黄花岗，故史称“黄花岗起义”\n\n2.武昌起义与各地响应\n1911年10月10，湖北新军中的共进会和文学社两个革命团体决定联合行动，在武昌举行武装起义。\n武昌起义掀起了辛亥革命的高潮，打开了清王朝统治的缺口。1912年2月12日，清帝被迫退位。在中国延续了两千多年的封建帝制终于覆灭\n\n二、中华民国的建立1.中华民国临时政府宣告成立\n1912年1月1日，孙中山在南京宣誓就职临时大总统，改国号为中华民国，定1912年为民国元年，并成立中华民国临时政府。南京临时政府是一个资产阶级共和国性质的革命政权。\n第一，资产阶级革命派在这个政权中占有领导和主体的地  位。\n第二，南京临时政府制定的各项政策措施，集中代表  和反映了中国民族资产阶级的愿望和利益，在相当程度上  也符合广大中国人民的利益\n\n\n南京临时政府的局限性\n在南京临时政府的《告友邦书》中，企图用承认清政府与列强所订的一切不平等条约和清政府所欠的一切外债，来换取列强承认中华民国\n南京临时政府没有提出任何可以满足农民土地要求的政策和措施\n\n\n\n2.《中华民国临时约法》\n性质：1912年3月临时参议院颁布，这是中国历史上第一部具有资产阶级共和国宪法性质的法典\n内容：中华民国之主权属于国民全体，内阁辅佐临时大总统（责任内阁制），三权分立，中华民国国民一律平等意义   \n《临时约法》以根本大法的形式废除了两千年来的封建君主专制制度，确认了资产阶级共和国的政治制度\n《临时约法》是革命的产物，带有鲜明的革命性、民主性\n\n\n\n三、辛亥革命的历史意义\n第一，辛亥革命推翻了封建势力的政治代表、帝国主义在中国的代理人——清王朝的统治，沉重打击了中外反动势力，使中国反动统治者在政治上乱了阵脚。\n第二，辛亥革命结束了统治中国两千多年的封建君主专制制度，建立了中国历史上第一个资产阶级共和政府，使民主共和的观念开始深入人心，并在中国形成了“敢有帝制自为者，天下共击之”的民主主义观念。\n第三，辛亥革命给人们带来一次思想上的解放。\n第四，辛亥革命促使社会经济、思想习惯和社会风俗等方面发生了新的积极变化。\n第五，辛亥革命不仅在一定程度上打击了帝国主义的侵略势力，而且推动了亚洲各国民族解放运动的高涨\n\n第三节 辛亥革命的失败一、封建军阀专制统治的形成1．袁世凯窃国，辛亥革命流产\n1912年2月12日，清帝退位。第二天，袁世凯致电临时政府，宣布“共和为最良国体”。同日，孙中山向参议院提出辞职咨文，但附以南京为首都、总统在南京就职、遵守约法三个条件，力图以此制约袁世凯。\n\n2．北洋军阀的专制统治\n袁世凯窃夺了辛亥革命的果实，建立起了代表大地主和买办资产阶级利益的北洋军阀反动统治。\n袁世凯当权时，北洋政府统治下的中国在形式上是统一的。在1916年袁世凯称帝败亡之后，连这种形式上的统一也维持不住了，中国陷入了军阀割据的局面。这种局面之所以形成，其深刻的原因\n一方面是由于中国主要是地方性的农业经济而没有形成统一的资本主义市场\n另一方面是由于帝国主义国家在中国采取划分势力范围的分裂剥削政策\n\n\n\n二、辛亥革命失败的原因和教训1.挽救共和的努力及其受挫\n1913年，孙中山毅然发动武装反袁的“二次革命”\n1914年，孙中山在日本组织中华革命党\n1915-1916年，护国运动\n1917-1918年，护法运动（护法运动的失败不仅是孙中山个人的失败，也标志着整个中国民族资产阶级领导的旧民主主义革命的终结）\n\n2.辛亥革命失败的原因和教训\n根本原因：在帝国主义时代，在半殖民地半封建的中国，资本主义的建国方案是行不通的\n主观原因\n首先，没有提出彻底的反帝反封建的革命纲领。\n其次，不能充分发动和依靠人民群众。\n最后，不能建立坚强的革命政党，作为团结一切革命力量的强有力的核心\n\n\n资产阶级革命派弱点和错误根源：中国民族资产阶级的软弱性和妥协性\n辛亥革命失败的教训：资产阶级共和国的方案没有能够救中国，先进的中国人需要进行新的探索，为中国谋求新的出路\n辛亥革命对中国共产党成立的影响\n辛亥革命为中国共产党的成立准备的客观社会条件。\n辛亥革命促进了民族资本的发展，为中国共产党成立准备了阶级基础；\n辛亥革命促进了新思想的传播，为中国共产党成立准备了理论基础；\n辛亥革命也为中国共产党成立准备了干部条件\n\n\n习近平在纪念辛亥革命110周年大会上的讲话\n1.历史背景：是近代以来中国社会矛盾激化和中国人民顽强斗争的必然结果\n2.性质：辛亥革命推翻了清朝政府，结束了在中国延续几千年的君主专制制度，近代以来中国发生的深刻社会变革由此拉开了序幕\n这是中国人民和中国先进分子为实现民族独立、人民  解放进行的一次伟大而艰辛探索\n\n\n3.意义：辛亥革命拉开了中国完全意义上的近代民族民主革命的序幕。辛亥革命极大促进了中华民族的思想解放，传播了民主共和的理念，打开了中国进步潮流的闸门，撼动了反动统治秩序的根基，在中华大地上建立起亚洲第一个共和制国家，以巨大的震撼力和深刻的影响力推动了中国社会变革，为实现中华民族伟大复兴探索了道路。辛亥革命永远是中华民族伟大复兴征程上一座巍然屹立的里程碑！\n4.失败的原因：由于历史进程和社会条件的制约，由于没有找到解决  中国前途命运问题的正确道路和领导力量，辛亥革命没有改变旧中国  半殖民地半封建的社会性质和中国人民的悲惨境遇，没有完成实现民族独立、  人民解放的历史任务。\n5.中国共产党人是孙中山先生革命事业最坚定的支持者、最忠诚的合作者、  最忠实的继承者\n6.辛亥革命的五点启示：\n第一，实现中华民族伟大复兴，必须有领导中国人民前进的坚强力量，这个坚强力量就是中国共产党。\n第二，实现中华民族伟大复兴，道路是最根本的问题。中国特色社会主义是实现中华民族伟大复兴的唯一正确道路。\n第三，实现中华民族伟大复兴，必须依靠中国人民自己的英勇奋斗来实现。\n第四，实现中华民族伟大复兴，中国人民和中华民族必须同舟共济，依靠团结战胜前进道路上一切风险挑战。\n第五，实现中华民族伟大复兴，不仅需要安定团结的国内环境，而且需要和平稳定的国际环境。\n\n\n\n\n\n考试重点1.资产阶级革命派的活动2.三民主义3.中华民国的建立4.辛亥革命的历史意义5.辛亥革命失败的原因和教训第四章 开天辟地的大事变第一节 新文化运动和五四运动一、新文化运动与思想解放的潮流1．新文化运动的兴起一、新文化运动与思想解放的潮流\n新文化运动是从1915年9月陈独秀在上海创办《青年》杂志（后改名《新青年》）开始的\n李大钊、鲁迅、胡适等参加编辑部并成为主要撰稿人。《新青年》杂志和北京大学成了新文化运动的主要阵地。\n近代中国的先进分子学习西方的历程\n学习先进技术（器物）\n学习西方的资本主义制度\n学习思想文化\n\n\n\n2.新文化运动的基本内容\n“四个提倡四个反对”：提倡民主，反对专制；提倡科学,反对迷信；提倡新道德,反对旧道德；提倡新文学,反对旧文学。\n基本口号：民主和科学\n民主，既指资产阶级的民主主义制度，也是指资产阶级的民主主义思想\n科学，狭义指自然科学，广义指社会科学而言\n\n\n\n3.五四以前新文化运动的历史意义\n（1）新文化运动是中国历史上一次前所未有的启蒙运动和空前深刻的思想解放运动\n（2）它在社会上掀起了一股生气勃勃的思想解放潮流，冲决了禁锢人们思想的闸门，从而为外国各种思想流派传入中国敞开了大门，激励着人们去探求救国救民的真理。\n\n4. 五四以前新文化运动的局限\n首先，新文化运动的倡导者批判孔学，是为了给中国发展资本主义扫清障碍。但是，由于资产阶级共和国的方案在中国行不通。\n其次，他们把改造国民性置于优先的地位。但是，离开改造产生封建思想的社会环境的革命实践，仅仅依靠少数人的呐喊，依靠有限的宣传手段，要根本改造由这种社会环境产生的思想、所造成的国民性，是不可能的。\n再次，那时的许多领导人物，还没有马克思主义的批判精神，他们使用的方法，一般地还是资产阶级的方法，表现为肯定和否定一切\n\n二、十月革命对中国的影响十月革命对中国的影响：三个认同\n第一，十月革命给予中国人的一个启示是：经济文化落后的国家也可以用社会主义思想指引自己走向解放之路。（道路认同）\n第二，十月革命诞生的社会主义俄国号召反对帝国主义，并以新的平等的态度对待中国，有力地推动了社会主义思想在中国的传播。（情感认同）\n第三，十月革命中俄国工人、农民和士兵群众的广泛发动并由此赢得胜利的事实，给予中国的先进分子以新的革命方法的启示，推动他们去研究这个革命所遵循的主义。（方法认同）\n\n历史和人民选择了马克思主义\n1.为了争取民族独立、人民解放，必须运用新的思想武器\n第一，在帝国主义时代，资本主义的制度矛盾已经比较充分地暴露出来\n第二，1914年至1918年的第一次世界大战，又以极端的方式进一步暴露了资本主义制度固有的不可克服的矛盾\n第三，中国人学习西方的努力屡遭失败的事实，更使他们对资产阶级共和国的方案  在中国的可行性产生了极大的疑问。这种对资产阶级民主主义的怀疑，推动他们去探索  挽救危亡的新途径\n\n\n2.十月革命后，中国先进分子经过比较、探求，选择了马克思主义\n第一，十月革命表明，经济文化落后的国家也可以用社会主义思想指引自己  走向解放之路。\n第二，十月革命诞生的社会主义新俄国号召反对帝国主义，并以新的平等的态度  对待中国，更有力地推动了社会主义思想在中国的传播。\n第三，十月革命中俄国工人、农民和士兵群众的广泛发动并由此赢得胜利的事实，  给予中国先进分子以新的革命方法的启示。在中国大地上率先举起马克思旗帜的是  李大钊\n\n\n\n三、五四运动与中国新民主主义革命的开端1.五四运动的发生和发展（背景）\n首先，新的社会力量的成长、壮大。\n其次，新文化运动掀起的思想解放的潮流。\n再次，俄国十月革命对中国的影响。\n\n2.导火线：巴黎和会上中国外交的失败3.新民主主义革命的开端\n五四运动是在新的社会历史条件下发生的，它具有以辛亥革命为代表的旧民主主义革命所不具备的一些特点。主要是：\n第一，表现了反帝反封建的彻底性。\n第二，是一次真正的群众运动。\n第三，促进了马克思主义在中国的传播及其与中国工人运动的结合。  为1921年中国共产党的成立作了思想上和干部上的准备。\n第四，发生在俄国十月革命之后，发生在无产阶级社会主义革命的新时代，  客观上就成为无产阶级社会主义世界革命的一部分。\n\n\n\n第二节 马克思主义进一步传播与中国共产党诞生一、中国早期马克思主义思想运动1.早期马克思主义者的队伍\n一是五四以前新文化运动的精神领袖。其代表为李大钊、陈独秀。\n二是五四爱国运动的左翼骨干，其代表为毛泽东、周恩来、蔡和森等。\n三是一部分原中国同盟会会员、辛亥革命时期的活动家如董必武、林祖涵、吴玉章等\n其中李大钊、陈独秀属于先驱者和擎旗人，毛泽东等五四运动的左翼骨干则是其主体部分\n\n2.早期马克思主义思想运动\n第一，重视对马克思主义基本理论的学习，从一开始就坚持了马克思主义的革命原则和正确方向，明确地同第二国际的社会民主主义划清界限。\n第二，注意从中国的实际出发，学习、运用马克思主义的理论去研究和解决中国面临的实际问题。\n第三，开始提出知识分子应当同劳动群众相结合的思想，主张知识分子“向农村去”、“到民间去”。\n\n3.新文化运动的发展\n五四以前的新文化运动主要是资产阶级民主主义的新文化反对封建主义的旧文化的斗争，那么，五四以后的新文化运动已经发展到了一个新阶段，马克思主义开始逐步地在思想文化领域中发挥指导作用\n\n二、马克思主义与中国工人运动的结合1．中国共产党的早期组织\n1920年8月，中国第一个共产党组织在上海建立，成员有陈独秀、李汉俊、李达等，会议推选陈独秀为书记。1920年10月，李大钊、张国焘等在北京成立共产党北京支部，李大钊任书记。\n\n2.中国共产党早期组织的活动\n其一，加强对马克思主义的研究和宣传。 1920年9月，《新青年》杂志成为上海共产主义小组的机关刊物，公开宣传马克思主义。11月，上海党的组织创办了半公开的《共产党》月刊。这个刊物第一次在中国树起共产主义的大旗，指明了中国革命的共产主义方向。\n其二，在工人中进行宣传和组织工作。各地共产党的早期组织创办了一批专门供工人阅读的进行马克思主义启蒙教育的刊物。如上海有《劳动界》、北京有《劳动音》和《工人月刊》、济南有《济南劳动月刊》等。同时，还创办了各种形式的工人学校，其中影响最大的，是邓中夏在北京长辛店、李启汉在沪西小沙渡分别开办的劳动补习学校。1920年11月，共产党早期组织领导的第一个工会——上海机器工会宣告成立。\n其三，建立社会主义青年团。\n其四，进行有关建党问题的研究和讨论。\n\n三、中国共产党的创建及其意义党成立的历史背景\n第一，中国共产党的成立是中国革命发展的客观要求。\n第二，中国工人阶级的成长壮大，为中国共产党的成立奠定了阶级基础。\n第三，马克思主义的传播为中国共产党的成立提供了思想条件。\n第四，五四运动促进了马克思主义与中国工人运动相结合，为中国共产党成立做了思想上和干部上的准备。\n\n1.中共一大\n大会确定党的名称为中国共产党（它从名称上宣示了自己的性质和最高理想；宣示了自己同背叛了马克思主义的第二国际的社会民主党划清界线的鲜明态度）。\n大会确定党的纲领：以无产阶级革命军队推翻资产阶级，采用无产阶级专政以达到阶级斗争的目的——消灭阶级， 废除资本私有制，以及联合第三国际等。\n决定首先集中精力组织工人。\n大会选举产生了由陈独秀、张国焘、李达组成的党的领导机构——中央局，陈独秀为书记\n\n2.中国共产党创建的历史特点\n优点：两个好思想基础好，接受的纯正的马列主义党的阶级基础好\n不足：三点不足人数少容易受到小资产阶级思想的影响（革命狂热性，革命失败容易动摇，容易犯左、右错误，毛泽东在延安整风有论述） 理论准备不足\n\n3.中国共产党成立的伟大意义\n①自从有了中国共产党，灾难深重的中国人民有了可以信赖的组织者和领导者，中国革命有了坚强的领导力量。\n②中国共产党的成立，中国革命有了科学的指导思想。\n③党所提出的纲领和奋斗目标，代表着中国社会发展的正确方向，代表着中国无产阶级和其他广大劳动人民的根本利益。\n④中国革命有了新的革命方法，并沟通了中国革命和世界无产阶级革命之间的联系。\n\n中国共产党成立100周年\n1.实现第一个百年奋斗目标实现了第一个百年奋斗目标，在中华大地上全面建成了小康社会，历史性地解决了绝对贫困问题，正在向着全面建成社会主义现代化强国的第二个百年奋斗目标迈进。\n2.一个主题：初心使命中国共产党一经诞生，就把为中国人民谋幸福、为中华民族谋复兴确立为自己的初心使命。一百年来，中国共产党团结带领*中国人民进行的一切奋斗、一切牺牲、一切创造，归结起来就是一个主题：实现中华民族伟大复兴\n3.历史贡献：四个伟大成就\n第一，创造了新民主主义革命的伟大成就。建立了人民当家作主的中华人民共和国，实现了民族独立、人民解放。新民主主义革命的胜利，彻底结束了旧中国半殖民地半封建社会的历史，为实现中华民族伟大复兴创造了根本社会条件。——救国大业\n第二，创造了社会主义革命和建设的伟大成就。消灭在中国延续几千年的封建剥削压迫制度，确立社会主义基本制度，实现了中华民族有史以来最为广泛而深刻的社会变革，为实现中华民族伟大复兴奠定了根本政治前提和制度基础。——兴国大业\n第三，创造了改革开放和社会主义现代化建设的伟大成就。实现新中国成立以来党的历史上具有深远意义的伟大转折，确立党在社会主义初级阶段的基本路线，坚定不移推进改革开放。为实现中华民族伟大复兴提供了充满新的活力的体制保证和快速发展的物质条件。——富国大业\n第四，创造了新时代中国特色社会主义的伟大成就。为实现中华民族伟大复兴提供了更为完善的制度保证、更为坚实的物质基础、更为主动的精神力量。——强国大业\n\n\n4.建党精神一百年前，中国共产党的先驱们创建了中国共产党，形成了坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，这是中国共产党的精神之源。思想、实践、精神、价值四个层面\n5.成立的历史意义——开天辟地的大事变\n深刻改变了近代以后中华民族发展的方向和进程，深刻改变了  中国人民和中华民族的前途和命运，深刻改变了世界发展的趋  势和格局。——三个深刻改变\n①中国革命有了坚强的领导力量\n②中国革命有了科学的指导思想：马克思主义中国化\n③党所提出的纲领和奋斗目标：反帝反封建的民主革命纲领\n④中国革命有了新的革命方法：群众路线中国革命的面貌从此焕然一新！\n\n\n6.党百年奋斗的历史意义\n①从根本上改变了中国人民的前途命运，中国人民对美好生活的向往不断变为现实；\n②开辟了实现中华民族伟大复兴的正确道路，创造了经济快速发展和社会长期稳定两大奇迹；\n③展示了马克思主义的强大生命力，马克思主义的科学性、真理性、人民性、实践性、开放性和时代性在中国得到充分彰显；\n④深刻影响了世界历史进程，拓展了发展中国家走向现代化的途径；\n⑤锻造了走在时代前列的中国共产党，党的执政能力和领导水平不断提高，中国共产党无愧为伟大光荣正确的党。\n\n\n7.历史经验：中国共产党为什么能？(可能选择分析题)\n第一，中国共产党有先进的理论作指导：马克思主义中国化\n第二，中国共产党以人民为中心：代表了中华民族和中国人民的根本利益\n第三，中国共产党从国情出发在实践中探索出适合中国的发展道路：坚持走中国特色社会主义道路，以发展为第一要务\n第四，中国共产党不忘初心牢记使命，不断加强自身建设\n\n\n8.以史为鉴开创未来：九个必须\n必须坚持中国共产党坚强领导\n必须团结带领中国人民不断为美好生活而奋斗\n必须继续推进马克思主义中国化\n必须坚持和发展中国特色社会主义\n必须不断推进党的建设新的伟大工程\n\n\n\n第三节 中国革命的新局面一、制定革命纲领，发动工农运动中国革命新局面的表现\n第一，制定反帝反封建的民主革命纲领。中共二大第一次提出了反帝反封建的民主革命纲领。中国共产党开始采取群众路线的革命方法，这是资产阶级、小资产阶级政党和政治派别没有也不可能采取的。\n第二，发动工农群众开展革命斗争。在中国共产党的领导、组织、推动下，从1922年1月香港海员罢工到1923年2月京汉铁路工人罢工，中国掀起了第一个工人运动的高潮。浙江萧山县衙前村成立了中国第一个农民协会。\n第三，实行国共合作，掀起大革命高潮。\n\n二、国共合作的形成与大革命的兴起1.国共合作的形成\n建立革命统一战线是中国革命发展的客观需要\n1924年1月，国民党一大在广州召开，新三民主义的政纲  同中共在民主革命阶段的纲领基本一致，因而成为国共合作的政治基础。  大会实际上确定了联俄、联共、扶助农工三大革命政策。 国民党一大的成功召开，标志着第一次国共合作的正式形成。\n\n\n\n2.大革命的准备与进行\n国共合作创办了黄埔陆军军官学校，为未来的革命战争准备了军事力量的骨干。\n1925年至1927年中国反帝反封建的革命，比之以往任何一次革命，包括辛亥革命和五四运动，群众的动员程度更为广泛，斗争的规模更加宏伟，革命的社会内涵更为深刻，因此被称作大革命\n\n3.大革命中的中国共产党\n在这场革命中，中国共产党起着独特的、不可代替的作用。\n大革命是在反对帝国主义、反对军阀的政治口号下进行的，而提出这个口号的，正是中国共产党。\n大革命是在以国共合作为基础的统一战线的组织形式下进行的。而中国共产党正是国共合作的倡导者和统一战线的组织者。\n大革命是近代中国历史上空前广泛而深刻的群众运动。而中国共产党正是人民群众的主要发动者和组织者。\n大革命的主要斗争形式是革命战争。共产党人不仅帮助和推动了国民革命军的建立，而且在军队中进行了卓有成效的政治工作，积极提高国民革命军的素质，增强它的凝聚力和战斗力；共产党员在战斗中更是身先士卒，起着先锋作用和表率作用\n\n三、大革命的意义、失败原因和教训1.大革命的失败\n“四一二”反革命政变、“七一五”反革命政变\n\n2.大革命失败的原因\n客观原因：是由于反革命力量的强大，大大超过了革命的力量；资产阶级发生严重的动摇、统一战线出现剧烈的分化，是由于蒋介石集团、汪精卫集团先后被帝国主义势力和地主阶级、买办资产阶级拉进反革命营垒里去了。\n主观原因\n中国共产党的中央领导机关在大革命的后期犯了以陈独秀为代表的右倾机会主义的错误。\n当时的中国共产党还处于幼年时期，在统一战线、武装斗争和党的建设三个基本问题上都没有经验。\n共产国际不了解中国的具体情况，对于中国革命作出了一些不切实际的指导\n\n\n\n3.大革命失败的经验教训\n首先，中国的民主革命必须建立包括工人、农民、小资产阶级和民族资产阶级的广泛的革命统一战线。在统一战线中必须坚持无产阶级的领导权，对资产阶级实行又联合又斗争的政策。\n其次，在中国民主革命中，无产阶级领导权的中心问题是农民问题。\n再次，中国革命的主要斗争形式是武装斗争，主要组织形式是军队，无产阶级要实现对革命的领导，必须建立和掌握革命的武装。\n最后，领导中国革命的中国共产党必须不断加强思想上、政治上和组织上的建设，善于把马克思主义普遍原理与中国革命具体实践相结合，制定和实行正确的政治路线和组织路线，这是革命胜利的根本保证\n\n4.大革命的意义\n首先，大革命沉重打击了帝国主义在华势力，基本推翻了北洋军阀统治。\n其次，大革命教育和锻炼了各革命阶级，当领导的工农大众经受了革命的洗礼，提高了政治觉悟，为后来共产党领导的土地革命的开展奠定了群众基础。\n再次，大革命提高了中国共产党在全国人民中的政治威望，党在马克思列宁主义指导下，制定民主革命纲领，发挥了党的政治优势和组织优势\n\n考试重点1.十月革命对中国的影响2.五四运动与新民主主义革命的开端3.中国共产党的创建及其意义4.中国革命的新局面第五章 中国革命的新道路第一节对革命新道路的艰苦探索一、国民党在全国统治的建立1.南京国民政府的成立\n1927年4月18日，南京国民政府成立。\n\n2.国民党政权的性质\n国民党实行的是代表地主阶级、买办性的大资产阶级利益的一党专政和军事独裁统治。\n对比：1912年中华民国临时政府宣告成立（南京临时政府）,是一个资产阶级共和国性质的革命政权\n\n二、土地革命战争的兴起1.大革命失败后的艰难环境2.开展武装反抗国民党反动统治的斗争：2次会议\n1927年7月中旬，中共中央临时政治局常委会决定了三件大事\n一是将党所掌握和影响的部队向南昌集中，准备起义；\n二是组织湘、鄂、赣、粤四省的农民，在秋收季节举行暴动；\n三是召集中央会议，讨论和决定新时期的方针和政策。\n\n\n八七会议：\n第一，彻底清算了大革命后期的陈独秀右倾机会主义错误。\n第二，确定了土地革命和武装反抗国民党反动统治的总方针。毛泽东在会上着重阐述了党必须依靠农民和掌握枪杆子的思想。\n第三，会议选出了以瞿秋白为首的中央临时政治局。\n八七会议开始了从大革命失败到土地革命战争兴起的历史性转折\n\n\n\n2.开展武装反抗国民党反动统治的斗争：3大起义\n南昌起义：打响了武装反抗国民党反动统治的第一枪。这是中国共产党独立领导革命战争、创建人民军队和武装夺取政权的开端\n秋收起义\n1927年9月9日秋收起义，打出了“工农革命军”的旗帜\n9.19文家市会议：工作重心转移从城市到农村\n9.29三湾改编\n第一，缩编，把原来的工农革命军第一军第一师缩编为一个团。\n第二，党的支部建在连上，从而确立了“党指挥枪”的原则。\n第三，连队建立士兵委员会的民主制度，实行官兵平等\n\n\n广州起义\n同年12月11日，张太雷和叶挺、叶剑英等领导了广州起义。\n总之，革命失败，得了惨痛的教训，于是有了南昌起义、  秋收起义和广州起义，进入了创造红军的新时期，开启了中国革命新纪元\n\n\n\n三、农村包围城市、武装夺取政权的道路1.对中国革命新道路的探索\n论证了红色政权能够长期存在并发展的主客观条件，提出了工农武装割据的思想\n①中国是一个半殖民地半封建的大国，政治经济发展极不平衡。（根本原因）\n②良好的群众基础。\n③全国革命形势的继续发展。（客观原因）\n④相当力量的正式红军的存在。\n⑤共产党组织的有力量和它的政策的不错误。（主观原因）\n\n\n赣南闽西：《星星之火，可以燎原》\n批评了看不到革命力量发展的悲观主义；\n明确指出红军、游击队和红色区域的建立和发展，是半殖民地中国在  无产阶级领导下农民斗争的最高形式，是促进全国革命高潮的最重要因素。\n实际形成（初步形成）以农村包围城市，然后夺取城市的思想\n\n\n没有调查就没有发言权\n坚持辩证唯物主义思想路线即坚持理论与实际相结合的原则的极端重要性\n为中国革命新道路提供哲学论证\n\n\n古田会议\n古田会议确立的原则和主要内容\n确立了思想建党、政治建军原则，规定红军是一个执行革命的政治任务的武装集团，  必须绝对服从共产党的领导，必须担负打仗、筹款和做群众工作的任务，必须加强  政治工作\n古田会议意义\n创造性地解决了在农村环境中、在党组织和军队以农民为主要成分的环境下，  如何从加强思想建设入手，保持党的无产阶级先锋队性质和建设党领导的新型  人民军队的问题，这是人民军队完全区别于一切旧军队的政治特质和根本优势，  对于中国革命新道路的开辟和坚持具有重要的意义\n\n\n党对军队绝对领导的根本原则和制度\n发端于南昌起义，奠基于三湾改编，定型于古田会议，是人民军队完全区别  于一切旧军队的政治特质和根本优势。\n农村包围城市、武装夺取政权理论的提出，标志着中国化的马克思主义  即毛泽东思想的初步形成\n\n\n\n2.反“围剿”战争与土地革命\n《井冈山土地法》1928年12月，毛泽东在井冈山主持制定中国共产党历史上第一个土地法，以立法的形式，首次肯定了广大农民以革命的手段获得土地的权利。由于缺乏经验，这个土地法关于没收一切土地归苏维埃政府所有、禁止土地买卖等方面的规定，并不适合中国农村的实际。\n《兴国土地法》1929年4月，毛泽东在兴国主持制定第二个土地法，将“没收一切土地”改为“没收一切公共土地及地主阶级的土地”，保护了中农的利益使之不受侵犯。\n土地革命总路线\n毛泽东还和邓子恢等一起制定了土地革命中的阶级路线和土地分配方法： 坚定地依靠贫农、雇农，联合中农，限制富农，保护中小工商业者， 消灭地主阶级；以乡为单位，按人口平分土地，在原耕地的基础上，实行抽多补少、 抽肥补瘦。\n至此，中国共产党就在中国历史上第一个制定了可以付诸实施的比较完整的 土地革命纲领和路线\n\n\n\n第二节中国革命在探索中曲折前进一、土地革命战争的发展及其挫折1.农村革命根据地的建设\n1931年11月，中华苏维埃第一次全国工农兵代表大会在江西省瑞金县叶坪村举行。大会通过了《中华苏维埃共和国宪法大纲》以及土地法令、劳动法等法律文件；选举产生了中华苏维埃共和国中央执行委员会；成立了临时中央政府，毛泽东当选为主席。\n中华苏维埃共和国实行工农兵代表大会制度\n苏维埃政府注重发展文化教育事业，提高工农群众的文化水平\n苏维埃政府认真加强廉洁从政的教育坚决开展反对贪污腐败的斗争\n\n\n\n2.土地革命战争的严重挫折\n第一次是1927年11月至1928年4月的“左”倾盲动错误，认为革命形势在不断高涨，盲目要求“创造总暴动的局面”。瞿秋白\n第二次是1930年6月至9月以李立三为代表的“左”倾冒险主义，错误地认为中国革命乃至世界革命进入高潮，盲目要求举行全国暴动和集中红军力量攻打武汉等中心城市。\n第三次是1931年1月至1935年1月以陈绍禹（王明）为代表的“左”倾教条主义\n“左”倾教条主义主要错误\n在革命性质和统一战线问题上，混淆民主革命与社会主义革命的界限，将反帝反封建与反资产阶级并列，将民族资产阶级视为中国革命最危险的敌人，一味排斥和打击中间势力。\n在革命道路问题上，继续坚持以城市为中心，将准备城市工人的总同盟罢工和武装起义作为中国共产党最主要的任务；指令根据地的红军采取“积极进攻的策略”，配合攻打中心城市。\n在土地革命问题上，提出坚决打击富农和“地主不分田，富农分坏田”的主张。\n在军事斗争问题上，实行进攻中的冒险主义、防御中的保守主义、退却中的逃跑主义。\n在党内斗争和组织问题上，推行宗派主义和“残酷斗争，无情打击”的方针\n\n\n\n3.在20世纪30年代前期、中期，中国共产党内屡次出现严重的“左”倾错误的原因\n第一，八七会议以后党内一直存在着的浓厚的“左”倾情绪始终没有得到认真的清理；\n第二，共产国际对中国共产党内部事务的错误干预和瞎指挥；\n第三，主要的原因在于，全党的马克思主义理论准备不足，理论素养不高，实践经验也很缺乏，对于中国的历史状况和社会状况、中国革命的特点、中国革命的规律不了解，对于马克思列宁主义的理论和中国革命的实践没有统一的理解，一句话，不善于把马克思列宁主义与中国实际全面地、正确地结合起来\n\n二、遵义会议与中国革命的历史性转折\n遵义会议\n遵义会议集中解决了当时具有决定意义的军事问题和组织问题。会议增选毛泽东为中央政治局常务委员，委托张闻天起草了《中央关于反对敌人五次“围剿”的总结的决议》（即遵义会议决议）。会后不久，中共中央政治局常务委员分工，根据毛泽东的提议，决定由张闻天代替博古负总的责任；博古任红军总政治部代理主任；并成立了由周恩来、毛泽****东、王稼祥组成的新的三人团，全权负责红军的军事行动\n遵义会议开始确立以毛泽东为代表的马克思主义的正确路线在中共中央的领导地位，从而在极其危急的情况下挽救了中国共产党、挽救了中国工农红军、挽救了中国革命，成为中国共产党历史上一个生死攸关的转折点\n常见错误：全党确立实事求是思想路线；军事上、组织上毛泽东负总责\n\n三、红军长征的胜利红军长征\n1936年10月，红二、四方面军先后同红一方面军在甘肃会宁、静宁将台堡（今属宁夏回族自治区）会师。至此，三大主力红军的长征胜利结束\n\n长征是宣言书、宣传队、播种机\n长征是宣言书：红军长征的胜利宣告了国民党反动派消灭中国共产党和红军图谋彻底失败，宣告了中国共产党和红军肩负着民族希望胜利实现了北上抗日的战略转移。\n长征是宣传队：长征在全国扩大了红军的影响，把革命真理传播到沿途广大地区，起到了“宣传队”的作用。\n长征又是播种机：红军长征沿途，不仅宣传革命真理，还撒播下革命的种子，为后来开展革命斗争创造了有利条件\n\n四、总结历史经验，迎接全民族抗日战争\n红军长征到达陕北以后，毛泽东、中共中央用很大的精力，去总结历史经验，加强共产党自身的思想理论建设。\n政治路线拨乱反正：1935年12月，毛泽东作了《论反对日本帝国主义的策略》的报告，阐明党的抗日民族统一战线的新政策，批判党内的关门主义和对于革命的急性病，系统地解决了党的政治路线上的问题。\n军事路线拨乱反正：1936年12月，他写了《中国革命战争的战略问题》这部著作，总结土地革命战争中党内在军事问题上的大争论，系统地说明了有关中国革命战争战略方面的诸问题。\n思想路线拨乱反正：1937年夏，他在延安抗日军政大学讲授《实践论》《矛盾论》，从马克思主义认识论的高度，总结中国共产党的历史经验，揭露和批评党内的主观主义尤其是教条主义错误\n\n考试重点1.土地革命战争的兴起2.农村包围城市、武装夺取政权的道路3.土地革命战争的发展及其挫折4.遵义会议与中国革命的历史性转折第六章 中华民族的抗日战争第一节 日本发动灭亡中国的侵略战争（了解）一、日本灭亡中国的计划及其实施1.从九一八事变到华北事变2.“卢沟桥事变”与日本的全面侵华战争\n二、残暴的殖民统治和中华民族的深重灾难第二节 中国人民奋起抗击日本侵略者一、中国共产党举起武装抗日的旗帜（了解）二、抗日救亡运动和共产党人与部分国民党人合作抗日（了解）三、停止内战，一致对外\n八一宣言：1935年8月1日，中共驻共产国际代表团起草了《为抗日救国告全体同胞书》，“停止内战、一致抗日”。\n一二·九运动： 华北事变后，一二·九运动促进了中华民族的觉醒，标志着中国人民抗日救亡运动新高潮的到来。\n\n四、西安事变\n西安事变的和平解决成为时局转换的枢纽，十年内战的局面由此结束，国内和平基本实现\n\n五、全民族抗战的开始\n抗日民族统一战线的形成\n1935年12月25日，中共中央在陕北瓦窑堡召开政治局扩大会议，  提出了建立抗日民族统一战线的方针。\n1937年9月22日，国民党中央通讯社发表《中国共产党为公布国共合作宣言》；  23日，蒋介石发表实际承认共产党合法地位的谈话。以国共两党第二次合作为  基础的抗日民族统一战线正式形成\n\n\n与第一次国民革命统一战线相比较，抗日民族统一战线具有一些新的特点\n广泛的民族性和复杂的阶级矛盾。它不仅包括工人、农民、小资产阶级、民族资产阶级，还包括以国民党蒋介石为代表的亲英美派大地主大资产阶级。\n国共双方有政权有军队的合作。国民党领导全国政权和军队；共产党领导局部政权和军队。\n没有正式的固定的组织形式和协商一致的具体的共同纲领。国共两党只能采取临时协商的特殊形式解决问题。\n抗日民族统一战线的巩固、发展和壮大，是夺取抗日战争最后胜利的根本保证。\n\n\n\n第三节 国民党与抗日的正面战场一、战略防御阶段的正面战场（了解）\n1937.7-1938.10，国民党军队在抗战初期对日作战比较积极努力，但是正面战场除了台儿庄战役取得大捷外，其他战役几乎都是以退却、失败而结束。\n失败客观原因、主观原因（片面抗战路线）\n\n二、战略相持阶段的正面战场（了解）\n1938年10月广州、武汉失守后，抗日战争进入相持阶段。\n日本对国民党政府采取以政治诱降为主、军事打击为辅的方针。\n国民党五届五中全会确定了“防共、限共、溶共、反共”的方针，标志国民党消极抗日、积极反共\n\n第四节 中国共产党成为抗日战争的中流砥柱一、全面抗战的路线和持久战的方针1.实行全面的全民族抗战的路线\n1937年8月，中国共产党在陕北洛川召开政治局扩大会议，制定了抗日救国十大纲领。会议强调，要打倒日本帝国主义，关键在于使已经发动的抗战成为全面的全民族的抗战\n\n2.采取持久的战略方针\n1938年，毛泽东发表《论持久战》的演讲，阐明了持久战的总方针。\n背景：针对“亡国论”、“速胜论”中日双方存在着互相矛盾的四个特点：敌强我弱、敌退步我进步、敌小我大、敌寡助我多助（第一个特点决定了日本的进攻能在中国横行一时，中国不能速胜；后三个特点决定了中国不会亡国，经过长期抗战，最后胜利属于中国）\n\n\n毛泽东还科学地预测了抗日战争的发展进程，即抗日战争将经过战略防御、战略相持、战略反攻三个阶段。其中，战略相持阶段，是中国抗日战争取得最后胜利的最关键的阶段\n意义：毛泽东阐明的持久战战略思想，揭示了抗日战争的发展规律和坚持抗战、争取抗战胜利必须实行的战略方针，对全国抗战的战略指导产生了积极的影响。\n\n二、敌后战场的开辟与游击战争的发展及其战略地位1.敌后战场的开辟和发展\n1937年平型关大捷是全民族抗战以来中国军队取得的第一次重大胜利，粉碎了日军不可战胜的神话。\n1937年11月，八路军又参加了忻口会战，是抗战初期华北战场上规模最大、最激烈的一次战役，也是国共两党军队合作抗日、配合最好的一次战役\n\n2.游击战争的战略地位和作用\n在抗日战争的初期和中期，游击战被提到了战略的地位，具有全局性的意义：\n第一，在战略防御阶段，从全局看，国民党正面战场的正规战是主要的，敌后的游击战是辅助的。\n第二，在战略相持阶段，敌后游击战争成为主要的抗日作战方式。\n第三，游击战还为人民军队进行战略反攻准备了条件\n\n\n\n三、坚持抗战、团结、进步的方针1.统一战线中的独立自主原则\n中国共产党在统一战线中坚持独立自主原则，既统一又独立。\n（1）共产党必须保持在思想上、政治上和组织上的独立性，放手发动群众，壮大人民力量；\n（2）必须坚持对人民军队的绝对领导，冲破国民党的限制和束缚，努力发展人民武装和抗日根据地；\n（3）必须对国民党采取又团结又斗争、以斗争求团结的方针。实质上就是力争中国共产党对抗日战争的领导权，使自己成为团结全民族抗战的中坚力量。这是把抗日战争引向胜利的中心一环。\n\n\n\n2.坚持抗战、团结、进步，反对妥协、分裂、倒退\n1939年7月，中国共产党明确提出“坚持抗战到底，反对中途妥协”、“巩固国内团结，反对内部分裂”、“力求全国进步，反对向后倒退”三大口号。\n\n3.巩固抗日民族统一战线的策略方针\n中国共产党制定了“发展进步势力，争取中间势力，孤立顽固势力”的策略总方针\n（1）进步势力主要是指工人、农民和城市小资产阶级。\n（2）中间势力主要是指民族资产阶级、开明绅士和地方实力派。\n争取中间势力需要一定的条件：  ①共产党要有充足的力量；  ②尊重他们的利益；  ③要同顽固派作坚决的斗争，并能一步一步地取得胜利\n\n\n（3）顽固势力是指大地主、大资产阶级的抗日派，即以蒋介石集团为代表  的国民党亲英美派\n他们采取两面政策，既主张抗日，又限共、溶共、反共并摧残进步势力。  为此，共产党必须以革命的两面政策来对付他们，即贯彻又联合又斗争的政策，  斗争不忘统一，统一不忘斗争,二者不可偏废，而以统一为主。同顽固派作斗争  时，应坚持有理、有利、有节的原则\n\n\n\n\n\n四、抗日民主根据地的建设1.三三制的民主政权建设\n三三制的民主政权建设加强政权建设，是抗日根据地建设的首要的、根本的任务。\n抗日民主政府在工作人员分配上实行“三三制”原则，即共产党员、非党的左派进步分子和不左不右的中间派各占1&#x2F;3。\n抗日民主政权普遍采取民主集中制，各级抗日民主政权机构的领导人都经过人民选举产生。\n抗日民主政权实行各民族平等团结、共同抗日的基本政策，在少数民族聚居地区试行民族区域自治。\n\n2.减租减息，发展生产\n减租减息，发展生产各地抗日民主政权十分重视根据地的经济建设。根据地内停止实行没收地主土地的政策，普遍实行减租减息政策（地租，按原来租额比例，减低25%;战前借贷，以15%为计息标准），以减轻农民所受的封建剥削，提高他们的抗日和生产的积极性；同时实行交租交息，以利于联合地主阶级抗日。（削弱封建剥削）\n1942年底，党中央提出了“发展经济，保障供给”的总方针。通过大生产运动，中国共产党领导的抗日根据地战胜了严重的物质困难，不仅粉碎了敌、伪、顽的封锁，改善了军民生活，给抗日战争的胜利奠定了雄厚的物质基础。\n\n五、推进大后方的抗日民主运动和进步文化工作1.抗日民主运动的开展2.抗战文化工作的开展\n六、中国共产党的自身建设1.马克思主义中国化命题的提出\n1937年11月，王明从莫斯科回到延安。他根据共产国际和苏联领导人关于中国抗战应该依靠国民党的指示精神，主张“一切经过统一战线”“一切服从统一战线”。\n1938年9月至11月，中国共产党在延安举行了扩大的六届六中全会。在这次全会上，毛泽东明确地提岀了“马克思主义的中国化”这个命题\n\n2.新民主主义革命理论的系统阐明\n标志着毛泽东思想得到多方面展开而达到成熟\n毛泽东：《〈共产党人〉发刊词》《中国革命和中国共产党》《新民主主义论》\n首先，中国半殖民地半封建社会的性质和主要特征，主要矛盾；\n其次，中国共产党在新民主主义阶段的基本纲领，政治上建立各革命阶级联合专政的新民主主义共和国，经济上建立国营经济，文化上发展民族的科学的大众的文化；\n最后，三大法宝：统一战线、武装斗争和党的建设\n\n3.延安整风运动和实事求是思想路线在全党的确立\n1942年2月，毛泽东先后作了《整顿党的作风》和《反对党八股》的讲演，整风运动在全党范围普遍展开。主要内容是：反对主观主义以整顿学风，反对宗派主义以整顿党风，反对党八股以整顿文风。反对主观主义以整顿学风是整风运动最主要的任务\n主观主义的实质是理论脱离实际，颠倒了认识和实践的关系，是实际工作中的唯心主义。当时它的主要表现形式是教条主义和经验主义，尤其教条主义是整风运动的重点\n整风运动是一场伟大的思想解放运动。一切从实际出发、理论联系实际、实事求是的马克思主义思想路线，在全党范围确立了起来\n\n4.中共七大\n1945年4月20日，中共扩大的六届七中全会通过了《关于若干历史问题的决议》，对党的若干重大的历史问题作岀结论，使全党尤其是党的高级干部对中国民主革命的基本问题的认识达到在马克思列宁主义基础上的一致。（1981年党的十一届六中全会通过的《关于建国以来党的若干历史问题的决议》）七大制定了党的政治路线，即“放手发动群众，壮大人民力量，在我党的领导下，打败日本侵略者，解放全国人民，建立一个新民主主义的中国”三大作风：理论和实践相结合、密切联系群众、批评和自我批评，将毛泽东思想规定为党的一切工作的指针\n\n第五节 抗日战争的胜利及其意义一、抗日战争的胜利\n1945年上半年，世界反法西斯战争进入最后阶段。4月，联合国制宪会议在美国旧金山举行，包括中国解放区代表董必武在内的中国代表团出席了会议。\n钓鱼岛是中国领土依据的文件：1941年《中国对日宣战布告》、1943年《开罗宣言》、1945年《波茨坦公告》、1945年《日本投降书》 \n1945年10月25日，中国政府在台湾举行受降仪式。根据波茨坦公告，被日本占领50年之久的台湾以及澎湖列岛由中国收回。这成为抗日战争取得完全胜利的重要标志。\n\n二、中国人民抗日战争在世界反法西斯战争中的地位\n1.世界反法西斯战争的东方主战场：最早最长最最艰苦最惨重\n2.世界反法西斯力量对中国的援助\n\n三、抗日战争胜利的原因和意义\n1.抗日战争胜利的原因\n中国人民抗日战争的胜利，是近代以来中国抗击外敌入侵的第一次完全胜利。\n第一，以爱国主义为核心的民族精神是中国人民抗日战争胜利的决定因素。\n第二，中国共产党的中流砥柱作用是中国人民抗日战争胜利的关键。\n第三，全民族抗战是中国人民抗日战争胜利的重要法宝。\n第四，中国人民抗日战争的胜利同世界所有爱好和平和正义的国家  和人民、国际组织以及各种反法西斯力量的同情和支持也是分不开  的。\n\n\n2.抗日战争胜利的意义\n中国人民抗日战争是20世纪中国和人类历史上的重大事件，  为中华民族由近代以来陷入深重危机走向伟大复兴确立了历  史转折点。\n第一，彻底粉碎了日本军国主义殖民奴役中国的图谋。\n第二，促进了中华民族的大团结，形成了伟大的抗战精神。\n第三，对世界各国夺取反法西斯战争的胜利、维护世界和平  的事业产生了巨大影响。\n第四，开辟了中华民族复兴的光明前景\n\n\n\n考试重点1.中国人民奋起抗击日本侵略者2.中国共产党成为抗战的中流砥柱\n政治上提出的全面抗战路线和持久战的战略思想与方针在思想与政治上为抗战提供了指导；\n军事上敌后战场逐步上升为抗战主战场；\n统一战线组织上力挽狂澜，克服统一战线出现严重危机，保证全国抗战的局面；\n抗日民主根据地建设，使其成为坚持抗战和争取抗战胜利的坚强阵地；\n推进大后方的抗日民主运动和文化工作；\n加强中国共产党自身建设，为党在抗日战争的坚强领导提供了保障，说明中国共产党在全国抗战中起到了中流砥柱的作用\n\n3.抗日战争的胜利及其意义第七章 为新中国而奋斗第一节从争取和平民主到进行自卫战争一、抗战胜利后的国际国内局势二、中国共产党争取和平民主的斗争1.重庆谈判\n为了争取和平民主，毛泽东不顾个人安危，于1945年8月28日偕周恩来、王若飞赴重庆与国民党当局进行谈判。10月10日，双方签署《政府与中共代表会谈纪要》，即“双十协定”，确认和平建国的基本方针，同意“长期合作，坚决避免内战”\n\n2.参加重庆政治协商会议\n1946年1月10日，国共双方下达停战令。同一天，政治协商会议（以下简称政协会议）在重庆开幕，出席会议的有国民党、共产党、民主同盟、青年党和无党派人士的代表38人。\n政协会议的上述协议及其他协议，还不是新民主主义性质的，但它有利于冲破蒋介石的独裁统治和实行民主政治，有利于和平建国，因而在相当程度上是有利于人民的。它激起了亿万善良的中国人对于实现和平、民主、团结、统一的热烈期望\n\n三、国民党发动内战和解放区军民的自卫战争1.全面内战爆发1946年6月26日，国民党军队以进攻中原解放区为起点，挑起了全国性的内战。\n2.以革命战争反对反革命战争人民解放军的战争所具有的爱国的正义的革命的性质，必然要获得全国人民的拥护。这就是战胜蒋介石的政治基础。\n3.以自卫战争粉碎国民党的军事进攻1946年6月至1947年6月一年的时间里，人民军队处于战略防御阶段，经过8个月的作战，歼敌71万人，粉碎了国民党军队的全面进攻。国民党军被迫改为对陕北、山东解放区的重点进攻\n四、两个中国之命运\n1921年至1949年新中国成立以前的时期，中国存在着三种主要的政治力量，他们分别提出了三种不同的建国方案。\n一是地主阶级和买办性的大资产阶级，他们是反动势力、民主革命的对象。其政治代表先是北洋政府，后是国民党政府。战后国民党主张继续实行大地主、大资产阶级的军事独裁统治。\n二是民族资产阶级，他们是中间势力，主张建立资产阶级共和国。\n三是工人、农民和城市小资产阶级，是进步势力、民主革命的主要力量，其政治代表是中国共产党。主张首先进行一场彻底的反帝反封建的新式资产阶级民主革命，即新民主主义革命，建立人民共和国，并经过人民共和国逐步到达社会主义和共产主义\n\n第二节国民党政府处在全民的包围中一、全国解放战争的胜利发展1.人民解放军转入战略进攻\n刘伯承、邓小平率领的晋冀鲁豫野战军主力，于1947年6月30日突破黄河天险，千里跃进大别山，人民解放战争战略进攻的序幕由此揭开。\n人民解放军的战略进攻，标志着中国革命已经发展到了一个历史的转折点。这是蒋介石二十年反革命统治由发展到灭亡的转折点，这是一百多年来帝国主义在中国的统治由发展到消灭的转折点。（两个转折点）\n\n2.提出“打倒蒋介石，解放全中国”的口号\n1947年10月10日，中国人民解放军总部发表宣言，提出“打倒蒋介石，解放全中国”的口号\n\n二、土地改革与农民的广泛发动1.从《五四指示》到《中国土地法大纲》\n1946年5月4日，中共中央发出《关于清算、减租及土地问题的指示》**(史称《五四指示》)。标志着解放区在农民土地问题上，开始由抗日战争时期的削弱封建剥削，向变革**封建土地关系、废除封建剥削制度的过渡。\n1947年7月至9月，中国共产党在河北省平山县召开全国土地会议，制定和通过了《中国土地法大纲》，明确规定“废除封建性及半封建性剥削的土地制度，实现耕者有其田的土地制度”。\n\n2.土地改革运动的热潮三、第二条战线的形成和发展\n在国民党统治区，以学生运动为先导的人民民主运动也迅速地发展起来，成为配合人民解放战争的第二条战线\n国民党统治区的政治经济危机\n学生运动的高涨\n人民民主运动的发展\n\n\n\n第三节中国共产党与民主党派的合作一、中国共产党与民主党派的团结合作（了解）二、第三条道路的幻灭第三条道路幻灭的原因\n从民族资产阶级自身来看，民族资本主义经济的特点决定了民族资产阶级没有勇气和能力去领导人民进行反帝反封建的革命斗争，不能为资产阶级共和国扫清障碍。\n从当时中国所处的时代条件来看，帝国主义列强不可能使中国成为一个独立、富强的资本主义国家。\n从中国的革命形势来看，国民党当局不允许任何阻止其一党专政的力量存在\n\n三、中国共产党领导的多党合作、政治协商格局的形成\n五一口号：1948年4月30日，中共中央在纪念五一国际劳动节的口号中提出：“各民主党派、各人民团体、各社会贤达迅速召开政治协商会议,讨论并实现召集人民代表大会，成立民主联合政府。”\n1949年1月22日，李济深、沈钧儒等民主党派的领导人和著名的无党派民主人士55人联合发表《对时局的意见》。这个政治声明表明，中国各民主党派和无党派民主人士自愿地接受了中国共产党的领导，决心走人民革命的道路，拥护建立人民民主的新中国。\n1949年中国人民政治协商会议的召开，标志着中国的新型政党制度——中国共产党领导的多党合作和政治协商制度的确立\n\n第四节创建人民民主专政的新中国一、南京国民党政权的覆灭（了解）二、人民政协与《共同纲领》1.筹建新中国\n1949年3月召开的中共七届二中全会，主要内容包括：\n第一，提出了迅速夺取全国胜利的方针，在国民党主力已经被消灭的情况下，解决剩下的100多万国民党军队的方式是天津式、北平式、绥远式3种。\n第二，说明了在全国胜利的局面下，采取乡村包围城市的工作方式已经完结，党的工作重心必须由乡村转移到城市。补充：党的工作重心三次转移：1927年文家市会议（城市转向农村）、1949七届二中全会（乡村转移到城市）、1978年党的十一届三中全会（阶级斗争转移到现代化建设）\n第三，规定了党在全国胜利后在政治、经济、外交方面应当采取的基本政策，指出了中国由农业国转变为工业国、由新民主主义社会转变为社会主义社会的总任务和主要途径\n第四，在这次会议上，毛泽东提出了“两个务必”的思想，即“务必使同志们继续地保持谦虚、谨慎、不骄、不躁的作风，务必使同志们继续地保持艰苦奋斗的作风”。\n\n2.人民政协会议的召开与《共同纲领》的制定\n1949年9月21日，中国人民政治协商会议第一届全体会议在北平中南海怀仁堂开幕，会议通过了《中国人民政治协商会议组织法》、《中华人民共和国中央人民政府组织法》和《中国人民政治协商会议共同纲领》，被认为是新中国奠基的3个历史性文件。\n《共同纲领》\n内容：中华人民共和国为新民主主义即人民民主主义的国家；中华人民共和国境内各民族一律平等，各少数民族聚居的地区应实行民族区域自治。\n《共同纲领》在当时是全国人民的大宪章，起着临时宪法的作用\n\n\n\n三、中国革命胜利的原因和基本经验1.中国革命胜利的原因\n第一，工人、农民、城市小资产阶级群众是民主革命的主要力量。\n第二，是由于有了中国工人阶级的先锋队中国共产党的领导。\n第三，中国共产党在革命过程中始终英勇地站在斗争的最前线。\n第四，中国革命之所以能够赢得胜利，同国际无产阶级和人民群众的支持也是分不开的。\n\n2.中国革命胜利的基本经验\n毛泽东指出：“统一战线、武装斗争、党的建设，是中国共产党在中国革命中战胜敌人的三个法宝，三个主要的法宝。”\n\n考试重点1.中国共产党争取和平民主的斗争2.两个中国之命运3.土地改革与农民的广泛发动4.七届二中全会5.中国革命胜利的原因和基本经验第八章 社会主义基本制度在中国的确立第一节 从新民主主义向社会主义过渡的开始一、中华人民共和国的成立及其伟大意义1.中华人民共和国成立的伟大意义\n第一，帝国主义列强压迫中国、奴役中国人民的历史从此结束，中华民族一洗近百年来蒙受的屈辱，开始以崭新的姿态自立于世界的民族之林。（民族独立）\n第二，本国封建主义、官僚资本主义统治的历史从此结束，长期以来受尽压迫和欺凌的广大中国人民在政治上翻了身，第一次成为新社会、新国家的主人。一个真正属于人民的共和国建立起来了。（人民解放）\n第三，军阀割据、战乱频仍、匪患不断的历史从此结束，国家基本统一，民族团结，社会政治局面趋向稳定，各族人民开始过上安居乐业的生活。人民可以集中力量从事经济文化等方面建设的时期开始到来了。\n第四，从根本上改变了中国社会的发展方向，为实现由新民主主义向社会主义的过渡，创造了条件。\n第五，中国共产党成为全国范围内的执政党\n\n2.中华人民共和国成立的标志\n中华人民共和国的成立，标志着中国的新民主主义革命取得基本的胜利。\n标志着半殖民地半封建社会的结束和新民主主义社会在全国范围内的建立。 \n标志着近代以来中国面临的第一项历史任务，即争取民族独立、人民解放这个历史任务基本完成。\n标志着社会主义革命阶段的开始\n\n二、完成民主革命的遗留任务和恢复国民经济\n新生的共和国面临着两大任务：\n一是继续完成新民主主义革命的遗留任务，彻底解决中国人民同三大敌人的矛盾；\n二是动员人民努力医治战争创伤，恢复破败的国民经济\n\n1.完成民主革命的遗留任务\n（1）在军事上，人民解放军继续追剿国民党的军事力量，实现了中国历史上长期以来从未有的统一；在政治上，普遍召开各级各届代表会议或人民代表会议，建立了在全国范围内从中央到地方的各级人民政权。\n（2）1950年至1953年春，在新解放区进行土改。\n（3）1950年4月30日，中央人民政府公布《中华人民共和国婚姻法》。\n（4）1950年至1951年在全国开展的镇压反革命运动\n\n2.恢复和发展国民经济\n1950年6月召开的中共七届三中全会，确定了当时全党和全国人民的中心任务是要在三年左右的时间内，争取国家财政经济状况的基本好转。\n\n3.加强党的自身建设\n1951年底到1952年10月，中国共产党在党政军机关开展“三反”即反贪污、反浪费、反官僚主义为核心的一场大规模的群众性政治运动。\n1952年初，在全国大中城市，开展了打击不法资本家的行贿、偷税漏税、盗骗国家财产、偷工减料、盗窃经济情报等不法行为的大规模的群众性政治运动，即“五反”运动\n\n三、抗美援朝战争\n抗美援朝战争是一场抗击美国侵略者的正义战争，打出了新中国的国威和人民军队的军威，创造了以弱胜强的范例，这场战争的胜利，不仅支援了朝鲜人民、保卫了中国的国家安全，而且为维护亚洲和世界的和平做出了重要贡献。\n这一胜利极大增强了中国人民的民族自信心和民族自豪感。\n全世界对新中国刮目相看，新中国的国际威望空前提高。从此，帝国主义不敢轻易做侵犯新中国的尝试，我国的经济建设和社会改革赢得了一个相对稳定的和平环境\n抗美援朝的意义\n经此一战，拼来了山河无恙、家国安宁，充分展示了中国人民不畏强暴的钢铁意志！——国家\n经此一战，打出了中国人民的精气神，充分展示了中国人民万众一心的顽强品格！——民族\n经此一战，让全世界对中国刮目相看，充分展示了中国人民维护世界和平的坚定决心！——人民\n经此一战，人民军队战斗力威震世界，充分展示了敢打必胜的血性铁骨！——军队\n经此一战，有力推动了世界和平与人类进步事业。再次证明正义必定战胜强权，和平发展是不可阻挡的历史潮流！——世界\n\n\n\n四、开始向社会主义过渡\n第一，没收官僚资本，确立社会主义国营经济的领导地位。没收官僚资本具有两重性质：它既具有民主革命的性质，又具有社会主义革命的性质\n没收官僚资本，具有两重性质：\n从反对帝国主义的附庸——中国的买办资产阶级——的意义上看，它具有民主革命的性质；\n从反对中国的大资产阶级的意义上看，它具有社会主义革命的性质\n\n\n第二，开始将资本主义纳入国家资本主义轨道。新中国在利用资本主义工商业的过程中，已经开始对它进行适当的限制，并把其中的大部分引上了初级形式的国家资本主义的道路\n第三，引导个体农民在土地改革后逐步走上互助合作的道路。\n\n第二节 社会主义道路:历史和人民的选择1.新中国成立后为进行现代化建设而进行的制度选择\n从世界历史看，实现国家工业化，主要有两条道路：一条是资本主义工业化道路；一条是社会主义工业化道路。资本主义工业化道路在中国行不通。\n\n2.提出过渡时期总路线的必要性\n一方面，随着民主革命遗留任务的彻底完成，国内的阶级关系和主要矛盾发生了深刻的变化。\n另一方面，随着国民经济的恢复和初步发展，中国社会的经济成分（即生产关系）发生了重要变化。\n过渡时期总路线：一化三改造\n\n3.实行社会主义改造的必要性和条件\n第一，社会主义性质的国营经济力量相对来说比较强大，它是实现国家工业化的主要基础。\n第二，资本主义经济力量弱小，技术设备落后，资金不足，发展困难，不可能成为中国工业起飞的基础。\n第三，对个体农业进行社会主义改造，是保证工业发展、实现国家工业化的一个必要条件。\n第四，当时的国际环境也促使中国选择社会主义\n\n第三节 有中国特点的向社会主义过渡的道路一、社会主义工业化与社会主义改造同时并举二、农业、手工业合作化运动的发展三、对资本主义工商业赎买政策的实施四、社会主义基本制度在中国的全面确立及其意义\n1956年底我国对农业、手工业和资本主义工商业的社会主义改造的基本完成，标志着中国历史上长达数千年的阶级剥削制度的结束，实现了由新民主主义向社会主义的转变，社会主义基本制度在我国初步确立，我国进入社会主义初级阶段\n新民主主义革命的胜利，社会主义基本制度的建立，为当代中国一切发展进步奠定了根本政治前提和制度基础\n\n考试重点1.中华人民共和国成立的标志、意义2.完成民主革命的遗留任务3.开始采取向社会主义过渡的步骤4.过渡时期总路线的提出5.社会主义改造的必要性和条件6.有中国特点的向社会主义过渡的道路第九章 社会主义建设在探索中曲折发展第一节 社会主义建设的初步探索（良好的开局）1.毛泽东提出马克思主义同中国实际的“第二次结合”2.中共八大路线的制定\n国内主要矛盾已经不再是工人阶级和资产阶级的矛盾，而是人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾；\n全国人民的主要任务是集中力量发展社会生产力；\n经济建设上，大会坚持既反保守又反冒进即在综合平衡中稳步前进的方针\n陈云提岀“三个主体、三个补充”的思想，即：国家经营和集体经营是主体，一定数量的个体经营为补充；计划生产是主体，一定范围的自由生产为补充；国家市场是主体，一定范围的自由市场为补充\n\n3.《论十大关系》的发表\n围绕一个基本方针，即：“一定要努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来，把我国建设成为一个强大的社会主义国家。\n标志：毛泽东为主要代表的中国共产党人开始探索中国自己的社会主义建设道路的标志\n\n《关于正确处理人民内部矛盾的问题》的发表\n第一，关于社会主义社会两类不同性质的社会矛盾。存在着敌我矛盾和人民内部矛盾。把正确处理人民内部矛盾作为国家政治生活的主题。解决人民内部矛盾用民主的方法，说服教育的方法；解决敌我矛盾用专政的方法\n在政治思想领域，实行团结-批评-团结的方针；\n在物质利益、分配方面，实行统筹兼顾、适当安排的方针；\n对科学文化领域里的矛盾，实行“百花齐放，百家争鸣”的方针；\n对于共产党和民主党派的矛盾，实行在坚持社会主义道路和党的  领导前提下的“长期共存，互相监督”的方针\n\n\n第二，关于社会主义社会的基本矛盾。基本的矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾。\n\n4.整风运动和反右派斗争\n1957年4月27日，中共中央下发《关于整风运动的指示》，决定在全党进行一次反对官僚主义、宗派主义和主观主义的整风运动\n\n第二节 探索中的严重曲折（不会考！！）一、“大跃进”及其纠正\n八字方针\n七千人大会\n\n二、文化大革命及其结束三、严重的曲折，深刻的教训第三节 建设的成就，探索的成果\n一、独立的、比较完整的工业体系和国民经济体系的建立（物质基础）\n二、人民生活水平的提高与文化、医疗、科技事业的发展\n三、国际地位的提高与国际环境的改善\n四、探索中形成的建设社会主义的若干重要原则 （理论准备）社会主义的发展阶段、社会主义现代化建设的战略目标和步骤、社会主义经济建设、社会主义民主政治建设方面等\n20世纪50年代外交成就\n1953年，提出和平共处五项原则（成为处理国与国关系的准则，最早同印度提出）\n1954年，参加日内瓦国际会议（第一次以世界五大国的身份参加）\n1955年，亚非万隆会议（求同存异）\n\n\n20世纪70年代外交成就\n1971年，26届联大恢复新中国五大常任理事国的合法席位\n1972年尼克松访华；1972年中日建交\n毛泽东“三个世界”理论提出\n\n\n\n考试重点1.《论十大关系》2.中共八大3.《关于正确处理人民内部矛盾的问题》4.八字方针、七千人大会5.建设的成就，探索的成果第十章 中国特色社会主义的开创与接续发展第一节 历史性的伟大转折和改革开放的起步一、关于真理标准问题的讨论\n真理标准问题的讨论是继五四运动和延安整风之后又一场马克思主义思想解放运动，其实质在于是不是坚持马列主义、毛泽东思想。\n讨论明确地解决了党的思想路线问题，继而影响了党的政治路线的制定和贯彻，成为拨乱反正和改革开放的思想先导，为党重新确立实事求是的思想路线，纠正长期以来的“左”倾错误，实现历史性的转折作了思想理论准备\n\n二、中共十一届三中全会的伟大转折\n1978年12月18日至22日，中共十一届三中全会在北京召开。全会冲破长期“左”的错误的严重束缚，彻底否定了“两个凡是”的错误方针，高度评价了关于真理标准问题的讨论，并且果断停止使用“以阶级斗争为纲”的口号，作出了把工作重点转移到社会主义现代化建设上来和实行改革开放的战略决策\n中共十一届三中全会是新中国成立以来党的历史上具有深远意义的伟大转折。全会结束了粉碎“四人帮”后党和国家工作在徘徊中前进的局面，标志着中国共产党重新确立了马克思主义的思想路线、政治路线、组织路线，开始了在思想、政治、组织等领域的全面拨乱反正。会后，从党的指导思想的确立和实际工作的领导来说，形成了以邓小平为核心的党的中央领导集体，揭开了改革开放的序幕。以这次全会为标志，中国进入了改革开放和社会主义现代化建设的历史新时期。\n\n三、农村改革的突破性进展\n我国的改革从经济体制的改革着手，经济体制的改革首先在农村取得突破性的进展\n中共十一届三中全会后，农业和农村经济的发展面临两大问题。一是“政社合一”的人民公社体制亟待改革；二是还有两亿多农民的温饱问题尚未解决-在中共中央的支持和推动下，以包产到户、包干到户为主要形式的家庭联产承包责任制，在全国各地逐渐推广开来。\n\n四、拨乱反正任务的胜利完成第二节 改革开放和现代化建设新局面的展开第三节 中国特色社会主义事业的跨世纪发展第四节 在新的历史起点上推进中国特色社会主义\n十二大到十七大\n十二大：“建设有中国特色的社会主义命题”的提出\n十三大\n社会主义初级阶段理论\n社会主义初级阶段基本路线\n大会制定了经济体制改革和政治体制改革的任务和目标\n“三步走”发展战略\n\n\n十四大：确立社会主义市场经济体制的改革目标\n十五大\n邓小平理论确立为党的指导思想\n确立党在社会主义初级阶段的基本纲领\n\n\n十六大：“三个代表”重要思想确立为党的指导思想\n大会从十个方面总结概括了党领导人民建设中国特色社会主义的基本经验\n大会明确了全面建设小康社会的奋斗目标\n\n\n十七大：科学发展观写入党章\n党和国家各项事业向前推进\n改革开放和现代化建设的巨大进展\n\n\n\n\n\n第十一章中国特色社会主义进入新时代中共十八大\n科学发展观确立为党的指导思想\n大会阐明中国特色社会主义的总依据是社会主义初级阶段，总布局是经济、政治、文化、社会、生态文明建设五位一体，总任务是实现社会主义现代化和中华民族伟大复兴\n全面建成小康社会\n中共十八大的召开，标志着中国已经进入全面建成小康社会的决定性阶段，开启了中国特色社会主义新时代\n\n中共十九大\n新矛盾：新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。\n新时代：中国特色社会主义进入新时代，这是我国发展新的历史方位。\n新思想：确立习近平新时代中国特色社会主义思想的历史地位。\n新征程：十九大到二十大，是“两个一百年”奋斗目标的历史交汇期。我们既要全面建成小康社会、实现第一个百年奋斗目标，又要乘势而上开启全面建设社会主义现代化国家的新征程，向第二个百年奋斗目标进军\n\n新中国发展的两个历史时期及其相互关系\n中国共产党领导人民进行社会主义建设，有改革开放前和改革开放后两个历史时期，这是两个相互联系又有重大区别的时期，但本质上都是中国共产党领导人民进行社会主义建设的实践探索\n改革开放前的实践探索为改革开放后的实践探索提供了宝贵经验、理论准备、物质基础。\n改革开放后的实践探索是对改革开放前的实践探索的坚持、改革和发展\n两个时期不能相互否定。“两个不能否定”有助于统一历史认识，坚定不移地走中国特色社会主义道路\n\n","slug":"master/Politics/近代史","date":"2022-10-29T14:08:50.000Z","categories_index":"考研政治","tags_index":"考研政治","author_index":"ChrisWood"},{"id":"ecf4d918a8a59daf742ceb61bc860e91","title":"思修法基","content":"思修法基绪论一、我们处于中国特色社会主义新时代二、时代新人要以民族复兴为己任\n1.做有理想有本领有担当的时代新人 要有崇高的理想信念，牢记使命，自信自励 要有高强的本领才干，勤奋学习，全面发展 要天下兴亡匹夫有责的担当精神，讲求奉献，实干进取\n2.提升思想道德素质与法治素养\n\n第一章 人生的青春之问（人生价值）第一节 人生观是对人生的总看法一、人的本质属性：社会属性二、人生观的主要内容：人生目的、人生态度、人生价值\n1.人生目的决定人生道路2.人生目的决定人生态度3.人生目的决定人生价值\n\n三、自我价值与社会价值的关系\n自我价值：自身物质精神需要的满足程度\n社会价值：贡献\n关系：自我价值——前提，社会价值——保障\n评价尺度：社会价值\n\n四、人生观与世界观：世界观决定人生观五、个人与社会的关系：\n最根本的个人利益与社会利益\n社会利益不是个人利益的简单相加，而是所有人利益的有机统一。\n社会利益体现了个人的根本利益和长远利益，是个人利益得以实现的前提和基础，保障个人利益的实现\n\n第二节 正确的人生观一、科学高尚的人生追求：服务人民、奉献社会二、积极进取的人生态度\n人生须认真、人生当务实、人生应乐观、人生要进取\n\n三、人生价值的评价与实现\n根本尺度：是否符合社会发展的客观规律、是否促进了历史的进步\n坚持能力大小与贡献须尽力相统一 坚持物质贡献与精神贡献相统一 坚持完善自身与贡献社会相统一 实现人生价值要从社会客观条件和个体自身条件出发\n\n第三节 创造有意义的人生一、辩证对待人生矛盾\n树立正确的幸福观、得失观、苦乐观、顺逆观、生死观、荣辱观\n幸福是靠努力奋斗出来的：\n首先，幸福是一个总体范畴：生活美好、家庭和睦、职业成功、行为正当、人格完善\n其次，幸福体现在物质与精神两个方面，离不开一定的物质条件\n再次，追求幸福不能损害社会和他人利益\n\n\n\n二、反对错误的人生观\n拜金主义、享乐主义、极端个人主义\n\n三、成就出彩人生\n与历史同向、与祖国同行、与人民同在社会实践是科学理论、创新思维的源泉，是检验治理的试金石，也是青年锻炼成长的有效途径\n\n第二章 坚定理想信念（理想信念）第一节 理想信念的内涵及重要性一、理想信念的内涵、特征\n理想\n理想是人们在实践中形成的、有实现可能性的、  对未来社会和自身发展目标的向往与追求，是世  界观、人生观和价值观在奋斗目标上的集中体现。\n类型：个人、社会理想，近期、长期理想，科学、  非科学理想，崇高、一般理想等\n理想具有超越性；理想具有实践性：社会实践的产物；  理想具有时代性\n\n\n信念\n信念和理想一样是人特有的一种精神现象。信念是人们在一定认识基础上确立的对某种思想或事物坚信不疑并身体力行的精神状态。信念是认知、情感和意志的有机统一体\n信念具有执着性；信念具有多样性：高层次信念决定低层次信念，低层次信念服从于高层次信念。信仰是最高层次的信念\n\n\n信念和理想相互依存：理想是信念所指对象，信念是理想实现的保障\n\n二、理想信念是精神之“钙”——意义\n1.理想信念昭示奋斗目标\n2.理想信念提供前进动力\n3.理想信念提高精神境界\n\n第二节 崇高的理想信念一、信仰马克思主义\n1.马克思主义体现了科学性和革命性的统一\n2.马克思主义具有鲜明的实践品格\n3.马克思主义具有持久的生命力\n\n二、胸怀共产主义伟大理想\n共产主义是现实运动和长远目标相统一的过程。\n共产主义远大理想的最终实现是一个漫长、艰辛的历史过程，需要一代又一代人付出艰苦的努力\n\n三、树立中国特色社会主义的共同理想\n崇高的理想，坚定的信念，永远是中国共产党人的政治灵魂\n1.中国特色社会主义是科学社会主义\n2.中国特色社会主义是中国共产党带领人民历经千辛万苦找到的实现中国梦的正确道路\n3.中国共产党的领导是中国特色社会主义最本质的特征\n\n第三节 在实现中国梦的实践中放飞青春梦想一、正确理解理想与现实的关系\n理想很丰满，现实很骨感\n一种错误认识是用理想来否定现实，另一种错误认识是用现实来否定理想\n\n\n理想和现实存在着对立的一面，二者的矛盾与冲突，属于“应然”和“实然”的矛盾。\n一方面，现实中包含着理想的因素；\n另一方面，理想中也包含着现实，在一定的条件下，理想就可以转化为现实。\n\n\n实现理想的长期性、艰巨性和曲折性。\n艰苦奋斗是实现理想的重要条件\n\n二、个人理想与社会理想的统一\n个人理想与社会理想的关系实质上是个人与社会关系在理想层面的反映\n1.个人理想以社会理想为指引：社会理想是最根本、最重要的，  而个人理想则从属于社会理想\n2.社会理想是对个人理想的凝练和升华\n\n\n\n三、为实现中国梦注入青春能量\n立志当高远 立志做大事 立志须躬行\n\n第三章 弘扬中国精神（中国精神）第一节 中国精神是兴国强国之魂一、重精神是中华民族的优秀传统\n首先，表现在对物质生活与精神生活相互关系的独到理解上\n其次，表现在中国古人对理想的不懈追求上\n再次，表现在对道德修养和道德教化的重视上\n另外，表现为对理想人格的推崇\n中国共产党是中华民族重精神优秀传统的忠实继承者和坚定弘扬者\n\n二、中国精神是民族精神和时代精神的统一（一）以爱国主义为核心的民族精神\n民族精神是一个民族在长期共同生活和社会实践中形成的，为本民族大多数成员所认同的价值取向、思维方式、道德规范、精神气质的总和，是一个民族赖以生存和发展的精神支柱。\n伟大创造精神、伟大奋斗精神、伟大团结精神、伟大梦想精神\n\n（二）以改革创新为核心的时代精神\n时代精神是一个国家和民族在新的历史条件下形成和发展的，是体现民族特质并顺应时代潮流的思想观念、价值取向、精神风貌和社会风尚的总和，是一种对社会发展具有积极影响和推动作用的集体意识\n改革创新精神是时代精神的核心，贯穿于改革开放的全部实践，体现在时代精神的各个方面。改革是破除社会发展障碍、激发社会发展活力的引擎，创新是民族进步的灵魂、国家兴旺发达的动力\n\n（三）民族精神与时代精神的辩证统一\n两者紧密关联，是民族赖以生存和发展的精神支柱。民族精神赋予中国精神以民族特征，是中华民族的精神独立性得以保持的重要保证；时代精神赋予中国精神以时代内涵，是中国精神引领时代前行、拥有鲜明时代性和强大生命力的重要根源\n\n三、实现中国梦必须弘扬中国精神\n凝聚中国力量的精神纽带\n激发创新创造的精神动力\n推进复兴伟业的精神定力\n\n第二节 爱国主义及其时代要求一、爱国主义的基本内涵\n爱国主义体现了人们对自己祖国的深厚感情，揭示了个人对祖国的依存关系，是人们对自己家园以及民族和文化的归属感、认同感、尊严感与荣誉感的统一。(注意不能选优越感)\n爱国主义是调节个人与祖国之间关系的道德要求、政治原则和法律规范，是中华民族精神的核心\n基本内涵\n①爱祖国的大好河山；\n②爱自己的骨肉同胞；\n③爱祖国的灿烂文化；\n④爱自己的国家，拥护国家的基本制度。\n爱国主义是历史的、具体的\n\n\n\n二、新时代的爱国主义\n1.坚持爱国主义和社会主义相统一\n2.维护祖国统一和民族团结\n3.尊重和传承中华民族历史和文化\n4.必须坚持立足民族又面向世界\n弘扬新时代的爱国主义，必须坚持立足民族，维护国家发展主体性；弘扬新时代的爱国主义，必须面向世界，构建人类命运共同体\n\n三、做忠诚爱国者\n1.维护和推进祖国统一：坚持一个中国原则，推进两岸交流合作，促进两岸同胞团结奋斗，反对“台独”分裂图谋\n2.促进民族团结：深化对党的民族理论和政策的认识，牢固树立正确的祖国观、民族观，筑牢中华民族共同体意识，尊重兄弟民族的传统文化、风俗习惯和宗教信仰，认清“藏独”、“疆独”的险恶用心和反动本质\n3.增强国家安全意识：确立总体国家安全观，增强国防意识，履行维护国家安全义务\n\n第三节 让改革创新成为青春远航的动力一、创新创造是中华民族最深沉的民族禀赋二、改革创新是时代要求\n改革创新是社会发展的重要动力，坚持改革创新是新时代的迫切要求创新始终是推动人类社会发展的第一动力。创新能力是当今国际竞争新优势的集中体现。改革创新是我国赢得未来的必然要求\n实施创新驱动发展战略，最根本的是要增强自主创新能力，最紧迫的是要破除体制机制障碍\n最大限度地解放和激发科技作为第一生产力所蕴含的巨大潜能，  打通从科技强到产业强、经济强、国家强的通道，让改革释放创新  活力，让一切创新源泉充分涌流\n\n\n\n三、做改革创新生力军1.树立改革创新的自觉意识\n第一，增强改革创新的责任感；\n第二，树立敢于突破陈规的意识；\n第三，树立大胆探索未知领域的信心。\n\n2.增强改革创新的能力本领\n第一，夯实创新基础\n第二，培养创新思维\n第三，投身创新实践\n\n第四章 践行社会主义核心价值观（核心价值）第一节 全体人民共同的价值追求一、社会主义核心价值观的基本内容\n1.社会主义核心价值观和社会主义核心价值体系：\n互为依存、相辅相成\n社会主义核心价值体系主要包括马克思主义指导思想、  中国特色社会主义共同理想、以爱国主义为核心的民族精神  和以改革创新为核心的时代精神、社会主义荣辱观\n社会主义核心价值观是社会主义核心价值体系的精神内核，  它体现了社会主义核心价值体系的根本性质和基本特征，反映  了社会主义核心价值体系的丰富内涵和实践要求，是社会主义  核心价值体系的高度凝练和集中表达\n\n\n2.社会主义核心价值观\n富强、民主、文明、和谐——国家  自由、平等、公正、法治——社会  爱国、敬业、诚信、友善——个人\n\n\n\n二、当代中国发展进步的精神指引\n2018年4月，十三届全国人大一次会议通过宪法修正案，把国家倡导社会主义核心价值观正式写入宪法，进一步凸显了社会主义核心价值观的重大意义。\n社会主义核心价值观是当代中国精神的集中体现。凝结着全体人民共同的价值追求。\n坚持和发展中国特色社会主义的价值遵循\n提高国家文化软实力的迫切要求\n增进社会团结和谐的最大公约数\n\n第二节 坚定价值观自信一、社会主义核心价值观的历史底蕴\n深深地根植于中华优秀传统文化，是社会主义核心价值观历史底蕴的集中体现\n中国传统优秀文化是涵养社会主义核心价值观的重要源泉，是中华民族的精神命脉\n培育和弘扬社会主义核心价值观，必须从中华优秀传统文化中吸取丰富营养，扬弃地继承，创新性发展并且传播到世界\n\n二、社会主义核心价值观的现实基础\n中国特色社会主义建设是社会主义核心价值观的实践根据\n社会主义核心价值观生成于中国特色社会主义建设实践，同时代主题相适应，是当代中国精神的集中体现，是中国特色社会主义本质规定的价值表达\n中国特色社会主义建设的成功经验是对社会主义核心价值观正确性、可信性的检验，同时也为其注入丰富、鲜活的时代内涵\n\n三、社会主义核心价值观的道义力量\n社会主义核心价值观以其先进性、人民性和真实性而居于人类社会的价值制高点，具有强大的道义力量\n先进性体现在它是社会主义制度所坚持和追求的核心价值观\n人民性体现在代表最广大人民的利益，反映其价值诉求，引导其为实现美好社会理想而奋斗\n真实性体现在社会主义制度为人民当家作主提供制度保障\n\n\n\n第三节 做社会主义核心价值观的积极践行者一、扣好人生的扣子二、勤学修德明辨笃实第五章 明大德守公德严私德（道德规范）第一节 道德及其变化发展\n道德是以善恶为评价方式，主要依靠社会舆论、传统习俗和内心信念来发挥作用的行为规范的总和。\n\n一、道德的起源\n1.劳动是道德起源的首要前提\n2.社会关系是道德赖以产生的客观条件\n3.人的自我意识是道德产生的主观条件\n\n二、道德的本质\n\n道德是反映社会经济关系的特殊意识形态：属于上层建筑的范畴\n\n\n其一，道德的性质和基本原则、规范反映了与之相应的  社会经济关系的性质和内容\n其二，道德随着社会经济关系的变化而变化\n其三，道德具有阶级性，同时具有普遍性\n其四，作为社会意识的道德一经产生，便有相对独立性\n\n\n\n道德是社会利益关系的特殊调节方式\n\n\n道德是一种调整人与人、人与社会、人与自然以及人与自身之间  关系的行为规范。道德与法律、政治规范不同在于用善恶标准评价，  依靠社会舆论、传统习俗、内心信念来维持，是一种非制度化、柔性  的规范\n\n\n\n道德是一种实践精神\n\n\n道德是一种旨在通过把握世界的善恶现象而规范  人们行为并通过实践活动体现出来的社会意识  道德把握世界的方式不是被动地反映世界，而是  从人的需要出发，从特定的价值出发来改造世界，  不是简单地再现或描述世界，而是对世界进行价  值评价。\n道德立足现实而追求理想，并以理想来改造现实\n\n\n\n三、道德的功能1.认识功能是指道德反映社会关系特别是反映社会经济关系的功效与能力2.规范功能是指在正确善恶观的指引下，规范社会成员的行为，并规范个人品德的养成，引导并促进入们崇德向善3.调节功能是指通过评价等方式，指导和纠正人们的行为和实践活动，协调社会关系和人际关系的功效与能力除了最基本的功能外还有导向功能、激励功能等\n四、道德的作用：反对道德万能论和道德无用论\n1.道德为经济基础的形成、巩固和发展服务，是一种重要的精神力量；\n2.道德对其他社会意识形态的存在有着重大的影响；\n3.道德通过调整人们之间的关系维护社会秩序和稳定；\n4.道德是提高人的精神境界、促进人的自我完善、推动人的全面发展的内在动力；\n在阶级社会中，道德是调节阶级矛盾和对立阶级之间开展阶级斗争的重要工具。\n\n五、道德的变化发展：螺旋式上升波浪式前进\n原始社会、奴隶社会、封建社会、资本主义社会、社会主义社会的道德\n道德进步的主要表现是：道德在社会生活中所起的作用越来越重要，对于促进社会和谐与人的全面自由发展的作用越来越突出；道德调控的范围不断扩大，调控的手段或方式不断丰富，更加科学合理；道德的发展和进步也成为衡量社会文明程度的重要尺度\n\n第二节 吸收借鉴优秀道德成果一、传承中华传统美德\n1.中华传统美德的基本精神\n①重视整体利益，强调责任奉献\n②推崇“仁爱”原则，注重以和为贵\n③提倡人伦价值，重视道德义务\n④追求精神境界，向往理想人格\n⑤强调道德修养，注重道德践履\n\n\n2.中华传统美德的创造性转化和创新性发展\n①加强对中华传统美德的挖掘和阐发\n②用中华传统美德滋养社会主义道德建设\n反对：全盘复古主义和历史虚无主义\n\n\n\n二、发扬中国革命道德\n1.中国革命道德的形成与发展\n中国革命道德，是指中国共产党人、人民军队、一切先进分子和人民群众在中国革命、建设、改革中所形成的优秀道德\n\n\n2.中国革命道德的主要内容\n为实现社会主义和共产主义理想而奋斗\n全心全意为人民服务\n始终把革命利益放在首位\n树立社会新风，建立新型人际关系\n修身自律，保持节操\n\n\n3.中国革命道德的当代价值\n有利于加强和巩固社会主义和共产主义的理想信念\n有利于培育和践行社会主义核心价值观\n有利于引导人们树立正确的道德观\n有利于培育良好的社会道德风尚\n\n\n\n三、借鉴人类文明优秀道德成果\n以我为主、为我所用，批判继承\n\n第三节 遵守公民道德准则一、社会主义道德的核心和原则（一）为人民服务是社会主义道德的核心- 1.为人民服务是社会主义经济基础和人际关系的客观要求\n- 2.为人民服务是社会主义市场经济健康发展的要求\n- 3.为人民服务是先进性要求和广泛性要求的统一\n- 4.为人民服务作为社会主义道德的核心，是社会主义道德区别\n和优越于其他社会形态道德的显著标志\n\n（二）集体主义是社会主义道德的原则\n1.集体主义强调国家利益、社会整体利益和个人利益的辩证统一\n2.集体主义强调国家利益、社会整体利益高于个人利益\n3.集体主义重视和保障个人的正当利益\n集体主义是社会主义道德的原则\n集体主义三个层次：  一是无私奉献、一心为公。  二是先公后私、先人后己。  三是顾全大局、遵纪守法、热爱祖国、诚实劳动，  这是对公民最基本的道德要求\n\n\n\n二、社会公德（一）公共生活与公共秩序\n活动范围的广泛性活动内容的开放性交往对象的复杂性活动方式的多样性\n有序的公共生活是社会生产生活的重要基础，是提高生活质量的基本保障，更是社会文明的重要标志\n\n（二）公共生活中的道德规范\n文明礼貌 助人为乐 爱护公物 保护环境\n遵纪守法：全体公民都必须遵循的基本行为准则\n\n（三）网络生活中的道德要求\n正确使用网络工具;健康进行网络交往;自觉避免沉迷网络;加强网络道德自律;积极引导网络舆论\n\n三、职业道德（一）职业生活中的道德规范\n爱岗敬业 诚实守信 办事公道 服务群众\n奉献社会：社会主义职业道德中最高层次的要求\n\n（二）树立正确的择业观和创业观(今年可能考)\n树立崇高的职业理想;服从社会发展的需要;做好充分的择业准备;培养创业的勇气和能力\n\n（三）自觉遵守职业道德\n学习职业道德规范\n提高职业道德意识\n提高践行职业道德的能力\n\n四、家庭美德（一）注重家庭、家教、家风- 1.注重家庭，家庭和睦则社会安定，家庭幸福则社\n\n会祥和，家庭文明则社会文明。    - 2.注重家教，家庭是人生的第一个课堂，父母是孩子的第一任老师。    - 3.注重家风，良好的家风，对家庭成员的个人修养产生着重要的作用，也对整个社会道德风尚的形成产生着重要的影响。\n（二）恋爱、婚姻家庭中的道德规范\n恋爱中的道德规范主要有:一是尊重人格平等，二是自觉承担责任，三是文明相亲相爱。家庭美德以尊老爱幼、男女平等、夫妻和睦、勤俭持家、邻里团结为主要内容\n\n（三）树立正确的恋爱观与婚姻观五、个人品德（一）个人品德及其作用\n个人品德是通过社会道德教育和个人自觉的道德修养所形成的稳定的心理状态和行为习惯\n1.个人品德对道德和法律作用的发挥具有重要推动作用\n2.个人品德是个体人格完善的重要标志\n3.个人品德是经济社会发展进程中重要的主体精神力量\n\n（二）掌握道德修养的正确方法\n学思并重 省察克治 慎独自律 知行合一 积善成德\n\n（三）锤炼高尚道德品格\n形成正确的道德认知和道德判断\n激发正向的道德认同和道德情感\n强化坚定的道德意志和道德信念\n\n第四节 向上向善、知行合一一、向道德模范学习二、参与志愿服务活动\n志愿服务的精神：奉献（最核心）、友爱、互助、进步\n\n三、引领社会风尚\n知荣辱、讲正气、做奉献、促和谐\n\n四、推动道德实践养成\n2019年10月颁布的《新时代公民道德建设实施纲要》要求  1.广泛开展弘扬时代新风活动  2.深化群众性创建活动  3.持续推进诚信建设  4.深入推进学雷锋志愿服务  5.广泛开展移风易俗行动  6.充分发挥礼仪礼节的教化作用  7.积极践行绿色生产生活方式  8.在对外交流交往中展示文明素养\n\n第六章 尊法学法守法用法（法治理念）第一节 社会主义法律的特征和运行一、法律的含义\n法律是由国家制定或认可并以国家强制力保证实施的，反映由特定社会物质生活条件所决定的统治阶级意志的规范体系。\n法律的历史发展：奴隶制、封建制、资本主义、社会主义法律\n法律所体现的统治阶级的意志具有整体性，并不是统治阶级意志的全部，仅仅是上升为国家意志的那部分\n\n二、我国社会主义法律的本质特征\n我国社会主义法律是中国特色社会主义制度的重要组成部分，是党领导人民当家作主的制度保障\n1.我国社会主义法律体现了党的主张和人民意志的统一\n2.我国社会主义法律具有科学性和先进性\n3.我国社会主义法律是中国特色社会主义建设的重要保障：经济、政治、文化、社会、生态文明\n\n三、我国社会主义法律的运行\n1.法律制定：是法律运行的起始性和关键性环节我国立法贯穿公正、公平、公开原则，坚持科学立法、民主立法、依法立法，表达人民的共同意志和诉求立法程序：法律案的提出、审议、表决、公布四个环节\n2.法律执行：行政执法行政执法坚持合法性、合理性、信赖保护、效率等基本原则\n3.法律适用：司法机关是指国家审判机关和检察机关。司法原则主要有：司法公正；公民在法律面前一律平等；以事实为依据，以法律为准绳；司法机关依法独立公正行使司法权等。\n4.法律遵守：依法行使权利、履行义务\n\n第二节 以宪法为核心的中国特色社会主义法律体系宪法\n实体法：宪法相关法、民法商法、行政法、经济法、社会法、刑法\n程序法：诉讼、非诉讼程序法\n\n一、宪法是国家的根本法\n1982年12月，五届全国人大五次会议通过了《中华人民共和国宪法》\n2018年3月，十三届全国人大一次会议通过了《中华人民共和国宪法修正案》\n\n（一）我国宪法的地位\n1.我国宪法是国家的根本法，是治国安邦的总章程，是党和人民意志的集中体现\n2.我国宪法是国家各项制度和法律法规的总依据\n3.我国宪法规定了国家的根本制度\n4.宪法的生命在于实施，宪法的权威也在于实施\n\n（二）我国宪法的基本原则\n1.党的领导原则\n2.人民主权原则\n3.尊重和保障人权原则\n4.社会主义法治原则\n5.民主集中制原则\n\n（三）我国宪法确立的制度\n国体和根本政治制度、基本政治制度、基本经济制度\n\n二、我国的实体法律部门（一）宪法相关法：与宪法相配套、直接保障宪法实施和国家\n政权运作等方面的法律规范\n\n（二）民法商法\n民法是调整平等主体的自然人、法人和非法人组织之间的人身关系和财产关系的法律规范，遵循民事主体地位平等、自愿、公平、诚信、公序良俗、有利于节约资源和保护生态环境等基本原则。商法是调整平等主体之间商事关系的法律规范，是与民法并列并互为补充的部门法。商法遵循民法的基本原则，同时秉承保障商事交易自由、等价有偿、便捷安全等原则。\n2020年5月28日，十三届全国人大三次会议审议通过了《中华人民共和国民法典》，这是新中国成立以来第一部以“法典”命名的法律，是新时代我国社会主义法治建设的重大成果。\n是一部体现我国社会主义性质、符合人民利益和愿望、顺应时代发展要求的民法典，\n是一部体现对生命健康、财产安全、交易便利、生活幸福、人格尊严等各方面权利平等保护的民法典，\n是一部具有鲜明中国特色、实践特色、时代特色的民法典\n\n\n地位\n民法典在中国特色社会主义法律体系中具有重要地位，是一部固根本、稳预期、利长远的基础性法律\n\n\n意义\n对推进全面依法治国、加快建设社会主义法治国家，\n对发展社会主义市场经济、巩固社会主义基本经济制度，\n对坚持以人民为中心的发展思想、依法维护人民权益、推  动我国人权事业发展，\n对推进国家治理体系和治理能力现代化，都具有重大意义。\n\n\n\n（三）行政法\n关于行政权的授予、行政权的行使以及对行政权监督的法律规范，调整的是行政机关与行政管理相对人之间因行政管理活动发生的关系，遵循职权法定、程序法定、公正公开、有效监督等原则\n\n（四）经济法国家从社会整体利益出发，对经济活动实行干预、管理或者调控的法律规范\n（五）社会法调整劳动关系、社会保障、社会福利和特殊群体权益保障等方面的法律规范，遵循公平和谐与国家适度干预原则\n（六）刑法规定犯罪与刑罚的法律规范。它通过规范国家刑罚权，惩罚犯罪，保护人民，维护社会秩序和公共安全，保障国家安全。我国刑法规定了罪刑法定、法律面前人人平等、罪刑相适应等基本原则\n三、我国的程序法律部门（一）诉讼法：刑事诉讼法、民事诉讼法、行政诉讼法。（二）非诉讼程序法\n仲裁法：自愿、仲裁独立、一裁终局等原则\n人民调解法：自愿平等、不违背法律法规和国家政策、尊重当事人权利等原则\n引渡法、海事诉讼特别程序法、劳动争议调解仲裁法、农村土地承包经营纠纷调解仲裁法等法律\n\n第三节 建设中国特色社会主义法治体系一、建设中国特色社会主义法治体系的重大意义1.习近平法治思想的主要内容及重大意义\n2020年11月，中央全面依法治国工作会议正式提出“习近平法治思想”并将习近平法治思想确立为全面依法治国的根本遵循和行动指南\n“十一个坚持”是：坚持党对全面依法治国的领导；坚持以人民为中心；坚持中国特色社会主义法治道路；坚持依宪治国、依宪执政；坚持在法治轨道上推进国家治理体系和治理能力现代化；坚持建设中国特色社会主义法治体系；坚持依法治国、依法执政、依法行政共同推进，法治国家法治政府、法治社会一体建设；坚持全面推进科学立法、严格执法、公正司法、全民守法；坚持统筹推进国内法治和涉外法治；坚持建设德才兼备的高素质法治工作队伍；坚持抓住领导干部这个“关键少数”。\n重大意义：习近平法治思想凝聚着中国共产党人在法治建设长期探素中形成的经验积累和智慧结晶，标志着我们党对共产党执政规律，社会主义建设规律、人类社会发展规律的认识达到了新高度，开辟了21世纪马克思主义法治理论和实践的新境界。习近平法治思想是习近平新时代中国特色社会主义思想的重要组成部分，是全面依法治国的根本遵循和行动指南。\n\n2.建设中国特色社会主义法治体系的重大意义\n全面依法治国，是国家治理的一场深刻革命。全面依法治国的总目标就是建设中国特色社会主义法治体系、建设社会主义法治国家。\n第一，中国特色社会主义的本质要求和重要保障\n第二，推进国家治理体系和治理能力现代化的重要举措\n第三，全面依法治国的总抓手\n\n\n\n二、建设中国特色社会主义法治体系的主要内容\n建设中国特色社会主义法治体系，就是在中国共产党领导下，坚持中国特色社会主义制度，贯彻中国特色社会主义法治理论，形成：完备的法律规范体系：中国特色社会主义法治体系的前提高效的法治实施体系：建设中国特色社会主义法治体系的重点严密的法治监督体系：以规范和约束公权力为重点有力的法治保障体系：政治和组织、人才和物质条件、法治意识和精神保障等完善的党内法规体系：党内制度及其运行、保障体系\n\n三、全面依法治国的基本格局\n“科学立法、严格执法、公正司法、全民守法”十六字方针，展现了全面依法治国的基本格局。推进全面依法治国，必须从立法、执法、司法、守法四个方面统筹推进\n\n第四节 坚持走中国特色社会主义法治道路\n走中国特色社会主义法治道路，必须坚持中国共产党的领导,坚持人民主体地位，坚持法律面前人人平等，坚持依法治国和以德治国相结合，坚持从中国实际出发\n一、坚持中国共产党的领导  党的领导是中国特色社会主义最本质的特征，是社会主义  法治最根本的保证。  坚持党的领导，是社会主义法治的根本要求，是全面依法  治国的题中应有之义。要把党的领导贯彻到依法治国全过  程和各方面，坚持党的领导、人民当家作主、依法治国有  机统一\n二、坚持人民主体地位  在社会主义法治国家，人民是依法治国的主体和力  量源泉，坚持人民主体地位是依法治国的基本原则\n三、坚持法律面前人人平等  平等享受权利、平等履行义务  违法必究，非歧视及无差别地对待\n四、坚持依法治国和以德治国相结合  法治和德治是治国理政不可或缺的两种方式，如车之两轮或  鸟之两翼。\n（一）正确认识法治和德治的地位。法治是治国理政的基本  方式，依法治国是基本方略，法治具有根本性、决定性和统  一性。德治是治国理政的重要方式。\n（二）正确认识法治和德治的作用\n（三）正确认识法治和德治的实现途径\n（四）推动法治和德治的相互促进\n\n\n五、坚持从中国实际出发：中国特色、实践特色、时代特色\n\n\n\n第五节 培养法治思维一、法治思维及其内涵（一）法治思维的含义与特征\n法治思维是指以法治价值和法治精神为导向，运用法律原则、法律规则、法律方法思考和处理问题的思维模式。\n第一，法治思维以法治价值和法治精神为指导，蕴含着公正、平等、民主、人权等法治理念，是一种正当性思维；\n第二，法治思维以法律原则和法律规则为依据来指导人们的社会行为，是一种规范性思维；\n第三，法治思维以法律手段与法律方法为依托分析问题、处理问题、解决纠纷，是一种可靠的逻辑思维；\n第四，法治思维是一种符合规律、尊重事实的科学思维\n法治与人治的区别：培养法治思维，必须抛弃人治思维。法治思维与\n人治思维的区别集中体现在四个方面：一是在依据上；  二是在方式上；三是在价值上；四是在标准上\n\n\n\n（二）法治思维的基本内容\n法治思维主要包括法律至上、权力制约、公平正义、权利保障、正当程序等内容。法律至上：法律的普遍适用性、优先适用性和不可违抗性权力制约：指国家机关的权力必须受到法律的规制和约束。权力制约分为权力由法定、有权必有责、用权受监督、违法受追究四项要求。公平正义：公平正义是指社会的政治利益、经济利益和其他利益在全体社会成员之间合理、公平分配和占有。一般来讲，公平正义主要包括权利公平、机会公平、规则公平和救济公平人权保障：指对公民权利的法律保障，具体包括公民权利的宪法保障（前提和基础）、立法保障（重要条件）、行政保护和司法保障（关键环节）。正当程序：程序的正当，表现在程序的合法性、中立性、参与性、公开性、时限性等方面\n\n二、尊重和维护法律权威（一）法律权威的含义\n法律权威是指法律在社会生活中的作用力、影响力和公信力，是法律应有的尊严和生命。\n法律是否具有权威，取决于四个基本要素: \n一是法律在国家和社会治理体系中的地位和作用\n二是法律本身的科学程度\n三是法律在实践中的实施程度\n四是法律被社会成员尊崇或信仰的程度\n法律权威源自人民的内心拥护和真诚信仰\n\n\n\n（二）尊重和维护法律权威的重要意义\n尊重和维护法律权威，对全面依法治国至关重要：\n1.社会主义法治观念的核心要求和建设社会主义法治国家的  前提条件\n2.对于推进国家治理体系和治理能力现代化、实现国家的长  治久安极为重要\n3.实现人民意志、维护人民利益、保障人民权利的基本途径\n4.维护个人合法权益的根本保障\n\n\n\n（三）尊重和维护法律权威的基本要求\n信仰法律、遵守法律、服从法律、维护法律\n\n三、怎样培养法治思维\n学习法律知识、参与法律实践、养成守法习惯、守住法律底线\n\n第六节 依法行使权利与履行义务一、法律权利与法律义务（一）法律权利的含义与特征\n法律权利是指反映一定的社会物质生活条件所制约的行为自由，是法律所允许的权利人为了满足自己的利益而采取的、由其他人的法律义务所保证的法律手段\n特征\n一是法律权利的内容、种类和实现程度受社会物质生活条件  的制约。\n二是法律权利的内容、分配和实现方式因社会制度和国家法  律的不同而存在差异。\n三是法律权利不仅由法律规定或认可，而且受法律维护或保  障，具有不可侵犯性。\n四是法律权利必须依法行使，不能不择手段地行使法律权利。\n\n\n\n（二）法律义务的含义与特征\n法律义务是指反映一定的社会物质生活条件所制约的社会责任，是保障法律所规定的义务人应该按照权利人要求从事一定行为或不行为以满足权利人利益的法律手段。法律义务的履行表现为两种形式：一种是作为，另一种是不作为\n特征\n第一，法律义务是历史的：时代发展变化\n第二，法律义务源于现实需要\n第三，法律义务必须依法设定\n第四，法律义务可能发生变化：特殊条件\n\n\n\n（三）法律权利与法律义务的关系\n1.法律权利和义务的辩证统一：硬币两面，不可分割相互依存\n首先，相互依存的关系  其次，目的与手段的关系  最后，具有复合性的关系\n\n\n2.法律权利和法律义务平等\n首先，法律面前人人平等被确立为基本原则  其次，具体设定上要平等  再次，实现要体现平等\n\n\n3.互利互赢\n\n二、依法行使法律权利（一）我国宪法法律规定的基本权利\n我国宪法法律规定了公民享有一系列权利，主要包括政治权利、人身权利、财产权利、社会经济权利、宗教信仰及文化权利等。政治权利：选举权利、表达权、民主管理权、监督权人身权利：生命健康权、人身自由权、人格尊严权、住宅安全权也称住宅不受侵犯权、通信自由权财产权：私有财产权、继承权社会经济权利：劳动权、休息权、社会保障权、物质帮助权宗教信仰及文化权利：宗教信仰自由、文化教育权等\n\n（二）行使法律权利的界限\n依法行使法律权利要求公民行使权利时应严格依据法律进行，以法律的相关规定为界限，超出这个边界就可能侵犯到他人的权利或者损害到国家、社会的利益\n\n三、依法履行法律义务\n义务法定，一方面是说义务的设定必须有法律依据，另一方面是说法定的义务应当履行，否则会承担不利的法律后果。\n\n（一）公民应履行的基本法律义务维护国家统一和民族团结、遵守宪法和法律、维护祖国安全、荣誉和利益、依法服兵役、依法纳税\n（二）违反法定义务应当承担的法律责任公民未能依法履行义务，根据情节轻重，应当承担相应的法律责任。具体的法律责任主要包括民事责任、行政责任和刑事责任\n答题思路\n意义类分析题目1.对国家民族的意义2.对社会的意义3.对社会主义制度和党的领导的意义4.对个人的意义（对历史的意义）\n\n如何做理性的爱国者（怎么做类型题答题思路）1.思想上高度重视，树立自觉的责任意识2.能力上 学习提升3.实践上 积极践行 落到实处4.学习先进模范人物事迹\n\n什么什么精神的实质？1.中华名族传统美德的体现2.体现了以爱国主义为核心的民族精神和以改革创新为核心的时代精神的中国精神3.新时期社会主义道德（社会公德 职业道德 家庭美德）4.个人品德的体现\n\n法律与道德结合题目\n\n道德\n1.传统美德\n2.职业道德\n3.公民道德\n4.社会主义核心价值观\n5.个人品德\n\n\n法律\n1.民商法基本原则\n2.法律精神角度\n\n\n\n\n\n","slug":"master/Politics/思修法基","date":"2022-10-25T11:59:59.000Z","categories_index":"考研政治","tags_index":"考研政治","author_index":"ChrisWood"},{"id":"520d9ef32d48d23e17dd506965fbbd26","title":"毛中特","content":"毛中特1 毛泽东思想及其历史地位一、毛泽东思想的形成和发展毛泽东思想形成发展的历史条件时代背景：帝国主义战争和无产阶级革命\n实践基础： 中共的革命实践和建设实践\n毛泽东思想形成发展的过程1.初步形成：农村包围城市、武装夺取政权的思想——土地革命战争时期 1927-1937年\n逐步开辟了农村包围城市、武装夺取政权的革命道路\n\n2.走向成熟——抗日战争时期\n新民主主义革命理论的系统阐述，标志着毛泽东思想得到多方面展开而趋于成熟。\n1945年党的七大将毛泽东思想写入党章，确立为党必须长期坚持的指导思想。\n\n3.继续发展——解放战争和新中国成立后\n主要观点：人民民主专政理论，社会主义革命和社会主义建设的理论\n\n二、毛泽东思想的主要内容和活的灵魂毛泽东思想的主要内容1. 新民主主义革命理论2. 社会主义革命和建设理论3. 革命军队建设和军事战略的理论\n毛泽东系统解决了如何把以农民为主要成分的革命军队建设成为一支无产阶级性质的、具有严格纪律的、同人民群众保持亲密联系的新型人民军队的问题\n规定了是党指挥枪的原则（党对军队绝对领导的根本原则和制度，发端于南昌起义，奠基于三湾改编，定型于古田会议）\n全心全意为人民服务是人民军队的唯一宗旨\n\n4. 政策和策略理论5. 思想政治工作和文化工作的理论6. 党的建设理论毛泽东思想活的灵魂党的十一届六中全会《关于建国以来党的若干历史问题的决议》实事求是：党的根本思想路线\n延安整风，对实事求是的科学含义做了马克思主义的界定。《改造我们的学习》指出：实事就是客观存在着的一切事物，是就是客观事物的内部联系，即规律性，求就是我们去研究\n经过延安整风和党的七大，实事求是的思想路线在全党得到了确立\n党的十一届三中全会，重新确立了实事求是的思想路线\n党的思想路线：一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理\n实事求是既是党的思想路线的核心，也是马克思主义中国化两大理论成果的精髓\n\n群众路线：党的根本工作路线\n群众路线本质上体现了马克思主义人民群众是历史创造者这一基本原理\n\n独立自主：党的根本政治原则三、毛泽东思想的历史地位1.马克思主义中国化第一个重大理论成果2.中国革命和建设的科学指南3.中国共产党和中国人民宝贵的精神财富考试重点1.毛泽东思想形成发展的过程2.毛泽东思想活的灵魂3.毛泽东思想的历史地位2 新民主主义革命理论新民主主义革命理论形成的依据近代中国国情1.近代中国社会性质：半殖民地半封建中国2.主要矛盾：帝国主义和中华民族的矛盾、封建主义和人民大众的矛盾3.根本任务：推翻帝国主义、封建主义和官僚资本主义的统治近代中国革命的时代特征近代中国的社会性质和主要矛盾决定了中国革命仍然是资产\n阶级民主革命\n从鸦片战争到辛亥革命期间：中国反帝反封建的斗争属于旧\n式民主主义革命\n十月革命后：中国资产阶级民主主义革命属于世界无产阶级\n社会主义革命的一部分\n五四运动后，新民主主义革命进入新阶段，中国革命两步走：\n    第一步：反帝反封建的新民主主义革命\n    第二步：社会主义革命\n\n第一：旧民主主义革命的失败\n第二：新民主主义革命的实践探索\n两次国共合作——统一战线理论\n建立巩固农村根据地——中国革命道路理论\n革命战争——人民军队和军事战略理论\n党由小到大由弱到强——党的建设理论\n\n\n\n总路线和基本纲领新民主主义革命的总路线\n1939年毛泽东在《中国革命和中国共产党》一文中，第一次提出新民主主义革命的科学概念和总路线的内容\n1948年《在晋绥干部会议上的讲话》完整表述总路线的内容：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命\n1.新民主主义革命的对象 帝国主义、封建主义和官僚资本主义\n不同时期中国革命的对象  国民大革命：帝国主义支持下的北洋军阀  土地革命：国民党新军阀  抗日战争：日本帝国主义  解放战争：国民党反动派\n\n\n2.新民主主义革命的动力\n无产阶级：最基本的动力  农民阶级：主力军——农民问题是中国革命的基本  问题，新民主主义革命就是中国共产党领导下的  农民革命、农民战争  城市小资产阶级：同盟者  民族资产阶级：动力之一\n关于民族资产阶级——两面性：  一方面——革命性  另一方面——软弱性、妥协性  对于民族资产阶级要又斗争又联合\n\n\n\n\n3.新民主主义革命的领导\n（1）领导权的重要性\n无产阶级的领导权是中国革命的中心问题，也是新民  主主义革命理论的核心问题\n区别新旧两种不同范畴的民主主义革命，根本的标志  是革命的领导权掌握在无产阶级手中还是掌握在资产  阶级手中\n无产阶级及其政党——中国共产党的领导，是中国革命  取得胜利的根本保证\n\n\n（2）领导权取得的条件\n率领被领导者（同盟者）向着共同敌人作坚决的  斗争，并取得胜利；\n对被领导者给以物质福利，至少不损害其利益，  同时对被领导者给以政治教育\n\n\n（3）领导权实现的关键：建立以工农联盟为基础  的广泛的统一战线    \n（4）坚持领导权的基本策略：无产阶级在同资产  阶级建立统一战线时，必须坚持独立自主的原则，  保持党在思想上、政治上和组织上的独立性，实行  又联合又斗争的方针\n（5）保证领导权的坚强支柱：强大的革命武装\n（6）实现领导权的根本保证：加强无产阶级政党  的建设\n\n\n4.新民主主义革命的性质和前途：\n新旧民主主义革命相比  革命阵线&#x2F;革命阵营：世界无产阶级社会主义革命的一部分  领导力量：无产阶级及其中国共产党  指导思想：马克思列宁主义  革命前途：社会主义\n革命性质由革命任务决定，革命阵营由领导阶级决定\n新民主主义革命与社会主义革命的比较 ：\n互相联系：毛泽东把新民主主义革命和社会主  义革命比喻为文章的上篇和下篇。民主革命是  社会主义革命的必要准备，社会主义革命是民  主革命的必然趋势。\n性质不同：新民主主义革命属于资产阶级民主主义革命，  建立无产阶级领导的各革命阶级联合专政性质不同的两个阶段，  只有完成前一个阶段的革命才能进行下一个阶段的革命。不能“毕其功于一役”，搞“无间断革命”（“一次革命论”）；也不能搞“二次革命”\n“一次革命论”  ，王明为代表的“左”倾教条主义错误 ，  主张民主革命和社会主义革命“毕其功于一役”（反帝反  封建反资产阶级），混淆了民主革命与社会主义革命的界  限。这种观点只看到两者的联系，忽视了两者的区别。\n“二次革命论”  ，割裂两个革命之间的衔接，只看到两者  的区别，没有看到两者的联系，要在两个阶段之间硬插一  个资产阶级专政和发展资本主义的阶段，犯“右倾”错误。\n\n\n\n\n\n\n\n新民主主义的基本纲领\n新民主主义的政治纲领国体：各革命阶级联合专政\n政体：人民代表大会制度\n人民当家主是国家制度的核心内容和基本准则\n新民主主义的经济纲领1.没收封建阶级的土地归农民所有\n（新民主主义革命的主要内容）\n2.没收官僚资产阶级的垄断资本归新民主主\n义的国家所有\n（具有双重性质，具有民主革命的性质；从反对中国的大资产阶\n级的意义上看，具有社会主义革命的性质）\n3.保护民族工商业\n（但这种保护不是无条件的，需要\n保护和发展的资本主义：有利于而不是有害于国计\n民生的私人资本主义经济，不能操纵国计民生的资\n本主义）\n（2个没收1个保护）\n3.新民主主义的文化纲领无产阶级领导的人民大众的反帝反封建的文化\n，即民族的科学的大众的文化\n\n新民主主义革命道路和基本经验新民主主义革命的道路1.提出：农村包围城市、武装夺取政权2.新民主主义革命道路形成的必然性\n具体国情：半殖民地半封建中国内无民主外无独立只有武装斗争、农业大国农民是同盟军和主力军\n特殊国情：可能性第一，社会政治经济发展不平衡第二，群众基础好第三，革命形势发展为革命根据地提供了客观条件第四，相当力量的正式红军的坚强后盾第五，党的领导是重要的主观条件\n\n3.新民主主义革命道路的内容和形式\n中国革命走农村包围城市、武装夺取政权的道路根本在于处理好土地革命、武装斗争、农村根据地建设三者之间的关系\n土地革命是基本内容\n武装斗争是主要形式和强有力保证\n农村革命根据地是战略阵地\n\n\n\n新民主主义革命的三大法宝统一战线\n必要性：首先，中共半殖民地半封建社会的阶级状况决定的，两头小中间大：无产阶级和地主大资产阶级都只占少数，最广大的农民、城市小资产阶级以及其他的中间阶级其次，中国革命的长期性、残酷性及其发展不平衡性决定的\n可能性：在半殖民地半封建的中国社会，诸多矛盾交织在一起，客观上为建立和发展统一战线提供了可能性\n两个联盟：工农联盟、工人与非劳动人民的联盟\n策略方针：发展进步势力、争取中间势力、孤立顽固势力\n最根本的经验：处理好与资产阶级的关系\n\n武装斗争 中国革命的特点和优点之一\n经验：党对军队的绝对领导、全心全意为人民服务、正确的战略战术\n\n党的建设 思想建设、组织建设、作风建设\n三大作风：理论联系实际、密切联系群众、批评与自我批评\n\n三大法宝之间的关系：\n统一战线和武装斗争是中国革命的两个特点，是战胜敌人的两个基本武器，党的组织是掌握这两个武器冲锋陷阵的战士\n\n新民主主义革命理论的意义\n马克思主义中国化的重要理论成果，开辟了马克思主义中国化的发展道路\n\n考试重点1.新民主主义革命的总路线2.新民主主义革命的基本纲领3.新民主主义革命的道路4.新民主主义革命的三大法宝3 社会主义改造理论从新民主主义到社会主义的转变新民主主义社会的性质和特点性质：新民主主义社会是一个过渡的社会形态经济、政治特点\n经济特点：五种经济成分、两种过渡、主要是三种经济\n社会主义性质的国营经济、半社会主义性质的  合作社经济、农民和手工业者的个体经济、私  人资本主义经济和国家资本主义经济\n\n\n政治特点\n新民主主义社会的阶级构成：  工人阶级、农民阶级、其他小资产阶级和民族  资产阶级是新民主主义社会基本的阶级力量\n新民主主义社会的主要矛盾  资本主义和社会主义两条道路、资产阶级和工  人阶级两个阶级的矛盾（民族资产阶级的两面性：又团结又改造）\n\n\n\n党过渡时期的总路线和理论依据\n1953年6月毛泽东在中央政治局会议上提出：“一化三改”社会主义工业化、对个体农业、手工业和资本主义工商业的社会主义改造\n提出过渡时期总路线的必要性\n第一，中国应当建立社会主义社会这个目标，这是中国共产党在成立之初就确定的了。\n第二，1949-1952年期间，在着重完成民主革命遗留任务的同时，社会主义革命的任务也开始实行了\n第三，随着民主革命遗留任务的彻底完成，国内的阶级关系和主要矛盾发生了深刻的变化。主要矛盾是工人阶级与民族资产阶级的矛盾。\n第四，随着国民经济的恢复和初步发展，中国社会的经济成分发生了重要变化\n\n\n\n社会主义改造道路和历史经验适合中国特点的社会主义改造道路1.农业的社会主义改造道路及其基本经验遵循自愿互利、典型示范和国家帮助的原则\n（互助组，社会主义萌芽；初级社，半社会主义性质；高级社，完全的社会主义性质）\n\n2.手工业的社会主义改造 积极领导、稳步前进的方针\n（手工业供销小组，社会主义萌芽；手工业供销合作社，半社会主义性质；手工业生产合作社，社会主义性质的集体经济组织）\n\n3.资本主义工商业的社会主义改造：和平赎买\n（初级形式的国家资本主义，企业具有了社会主义因素；个别企业的公私合营，半社会主义性质；全行业的公私合营，社会主义国营性质的企业）\n和平赎买方式改造资本主义工商业，原因：\n第一，民族资产阶级具有两面性（既有剥削工人取得利润的一面，又有拥护宪法、愿意接受社会主义改造的一面。）\n第二，中国共产党与民族资产阶级长期保持统一战线的关系。\n第三，我国已经有了以工人阶级为领导、工农联盟为基础的人民民主专政的国家政权，建立了强大的社会主义国营经济并掌握了国家的经济命脉，这就造成私人资本主义在政治上、经济上对社会主义的依赖。\n\n\n第一，初级形式的国家资本主义。私营工业中实行委托加工、计划订货、统购包销、经销代销等私营商业中采取委托经销、代销等形式四马分肥：国家所得税、企业公积金、工人福利费、资方红利\n第二，高级形式的国家资本主义：个别企业的公私合营，全行业的公私合营（定息）\n\n社会主义改造的历史经验1.坚持社会主义工业化建设与社会主义改造同时并举2.采取积极引导、逐步过渡的方式3.用和平方法进行改造社会主义制度在中国确立社会主义基本制度的确立及其理论根据1.社会主义基本制度的确立  1956年三大改造完成\n标志着数千年的阶级剥削制度的结束，标志着社会主义制度在我国确立，标志我国进入社会主义初级阶段，标志着我国完成了从新民主主义向社会主义的过渡\n\n社会主义改造带来的深刻变化\n社会经济制度和社会经济结构、阶级关系\n\n确立社会主义制度的重大意义1.极大地提高了工人阶级和广大劳动人民的积极性\n和创造性，极大地促进了我国社会生产力的发展\n2.使广大劳动人民真正成为国家的主人\n3.使占世界人口四分之一的东方大国进入了社会主\n义社会，这是世界社会主义运动史上又一个历史性\n的伟大胜利\n考试重点1.新民主主义社会的性质和特点2.党在过渡时期总路线的提出3.适合中国特点的社会主义改造道路4.确立社会主义基本制度的重大意义4 社会主义建设道路初步探索的理论成果\n初步探索的重要思想成果\n一、调动一切积极因素为社会主义事业服务的思想\n十大关系涉及生产力和生产关系、经济基础和上层建筑的关系\n基本方针：调动国内外一切积极因素，为社会主  义服务。\n标志：开始探索\n\n\n二、正确认识和处理社会主义社会矛盾的思想\n1957年2月毛泽东《关于正确处理人民内部矛盾的问题》的报告：  主要矛盾：人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾，  人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的 状况之间的矛盾\n敌我矛盾——专政的方法\n人民内部矛盾——民主的方法\n政治思想领域：团结——批评——团结，\n物质分配领域：统筹兼顾适当安排，\n人民群众与政府机关：民主集中制，\n科学文化领域：百花齐放百家争鸣\n党派之间：长期共存互相监督\n民族之间：民族平等团结互助\n\n\n三、走中国工业化道路的思想\n1.明确战略目标和战略步骤\n2.采取正确的经济建设方针：党的八大提出既反保守又反冒进在综合平衡中稳步前进\n3.发展科学技术与文化教育\n4.重视知识分子工作\n5.调整和完善所有制结构：陈云三个主体三个补充\n6.探索适合我国情况的经济体制和运行机制：两参一改三结合\n\n\n\n\n初步探索的意义和经验\n意义\n1.巩固和发展了我国的社会主义制度\n2.为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础、制度基础\n3.丰富了科学社会主义的理论和实践\n\n\n经验教训\n1.必须把马克思主义与中国实际相结合\n2.必须正确认识主要矛盾和根本任务，集中力量发展生产力\n3.必须从实际出发，不能急于求成\n4.必须发展社会主义民主，健全社会主义法制\n5.必须坚持党的民主集中制，加强执政党建设\n6.必须坚持对外开放，不能关起门来搞建设\n\n\n\n\n\n考试重点1.《论十大关系》2.《关于正确处理人民内部矛盾的问题》3.走工业化道路的思想5 邓小平理论（注意92年南方谈话 2022年）邓小平理论的形成形成条件1.时代背景：和平与发展成为时代主题2.历史根据：社会主义建设的经验教训3.现实依据：改革开放和现代化建设的实践邓小平理论的形成过程1978-1982年为基本理论命题提出的阶段\n1978年12月召开的党的十一届三中全会，重新确立了解放思想、实事求是的思想路线，确定把全党工作的着重点转移到社会主义现代化建设\n1981年党的十一届六中全会作出的《关于建国以来党的若干历史问题的决议》，决议在系统总结三十二年正反两方面经验的基础上，提出了适合我国情况的社会主义现代化建设正确道路的十点经验。这十点经验，成为邓小平理论的雏形\n\n1982-1987年为理论形成基本轮廓的时期\n1982年邓小平在党的十二大开幕词中明确指出：把马克思主义的普遍真理同我国的具体实际结合起来，走自己的道路，建设有中国特色的社会主义\n1987年召开的党的十三大，第一次比较系统地论述了我国社会主义初级阶段理论，明确概括和全面阐发了党的“一个中心、两个基本点”的基本路线，第一次对中国特色社会主义理论的主要内容作了系统概括，标志着邓小平理论的初步形成\n\n1987-1992年为理论走向成熟，确立体系的时期\n1992年邓小平南方谈话，提出了一系列重要论断，如社会主义本质；“三个有利于”标准；社会主义可以搞市场经济；邓小平理论也逐步走向成熟\n1992-1997邓小平理论丰富和发展\n\n1992-1997年为理论进一步丰富和发展的时期\n1997年党的十五大正式将邓小平理论确定为党的指导思想\n1999年的宪法修正案正式将邓小平理论载入宪法\n\n邓小平理论的基本问题和主要内容\n基本问题\n什么是社会主义、怎样建设社会主义，是邓小  平在领导改革开放和现代化建设这一新的革命过  程中，不断提出和反复和思考的首要的基本的理  论问题\n1992年初，邓小平在南方谈话中对社会主义本  质作了总结性理论概括：“社会主义的本质，是  解放生产力，发展生产力，消灭剥削，消除两极  分化，最终达到共同富裕\n\n\n主要内容\n邓小平理论贯穿解放思想、实事求是的思想路线  ，围绕着“什么是社会主义、怎样建设社会主义”  这个基本的理论问题，第一次比较系统地初步回答  了建设中国特色社会主义的一系列基本问题\n包括社会主义初级阶段理论，党的基本路线，  社会主义根本任务的理论，  “三步走”战略，改  革开放理论，社会主义市场经济理论，  “两手抓  ，两手都要硬”“一国两制”  、中国的问题关键  在于党等，形成了一个比较完备的科学体系\n1.解放思想、实事求是的思想路线\n2.社会主义初级阶段理论\n（1）我国处在社会主义初级阶段，是邓小平和我  们党对当代中国基本国情的科学判断\n十三大召开前夕，邓小平第一提出“社会主义初级阶段”  这一特定内涵的新概念，第一次把社会主义初级阶段作  为事关全局的基本国情加以把握\n社会主义初级阶段的科学含义  第一，我国已经是社会主义社会（社会性质）  第二，处在初级阶段 （发展程度）\n\n\n（2）十三大：初级阶段理论\n（3）十五大：基本特征\n（4）十九大：两个没有变\n两个没有变：处于并将长期处于社会主义初级阶段的基本国情没有变，  我国是世界上最大发展中国家的国际地位没有变\n\n\n\n\n3.基本路线\n目标：建设“富强、民主、文明的社会主义现代化国家\n基本途径：“一个中心、两个基本点”是基本路线最重要内容，  是实现社会主义现代化奋斗目标的基本途径\n以经济建设为中心 坚持四项基本原则 坚持改革开放\n四项基本原则，坚持社会主义道路，坚持人民民主专政，  坚持共产党的领导，坚持马列主义、毛泽东思想\n\n\n领导和依靠力量：领导和团结全国各族人民\n根本立足点：自力更生，艰苦创业是实现社会主义初级阶段  奋斗目标的根本立足点\n\n\n4.社会主义根本任务 发展生产力\n5.“三步走”战略\n第一步，从1981年到1990年实现国民生产总值比1980年翻一番，  解决人民的温饱问题\n第二步，从1991年到20世纪末，使国民生产总值再增长一倍，  人民生活达到小康水平\n第三步，到21世纪中叶，人均国民生产总值达到中等发达国家水平，  人民生活比较富裕，基本实现现代化\n\n\n6.改革开放理论\n7.社会主义市场经济理论\n8.“两手抓，两手都要硬”（物质精神）\n9.“一国两制”\n10.中国问题的关键在于党\n\n\n\n\n改革是第二次革命\n所谓第二次革命，是与中国共产党领导的第一次革命相对而言的。  中国共产党领的的第一次革命把一个半殖民地半封建的旧中国变  成了一个社会主义新中国；中国共产党领导的第二次革命，将把  一个经济文化落后的社会主义中国变成现代化的社会主义国家\n改革作为一次新的革命，不是也不允许否定和抛弃我们建立起来  的社会主义基本制度，它是社会主义制度的自我完善和发展。改  革不是一个阶级推翻另一个阶级那种原来意义上的革命，也不是  原有经济体制的细枝末节的修补，而是对体制的根本性变革。改  革同革命一样，就目的而言，都是为了解放生产力\n\n\n社会主义市场经济理论\n计划经济和市场经济不是划分社会制度的标志；都是经济手段,本身不具有制度属性。\n社会主义市场经济，特色、优势所在是坚持社会主义制度与市场经济的结合。基本特征：在所有制结构上，以公有制为主体、多种所有制经济共同发展；在分配制度上，以按劳分配为主体，多种分配方式并存；在宏观调控上，以实现最广大人民利益为出发点和归宿\n\n邓小平理论的历史地位马克思列宁主义、毛泽东思想的继承和发展中国特色社会主义理论体系的开篇之作改革开放和社会主义现代化建设的科学指南考试重点1.邓小平理论的主要内容2.邓小平理论的历史地位6 “三个代表”重要思想 (读一遍即可)“三个代表”重要思想的形成形成条件1.世情：“三个代表”重要思想是在对冷战结束后国际局势科学判断的基础上形成的2.党情：“三个代表”重要思想是在科学判断党的历史方位和总结历史经验的基础上提出来的3.国情：“三个代表”重要思想是在建设中国特色社会主义伟大实践基础上形成的三个代表”重要思想的形成过程1.2000年2月25日，江泽民在广东省考察工作时讲话，第一次\n提出并阐述“三个代表”重要思想。\n2.2001年7月1日，江泽民在庆祝中国共产党成立80周年大会\n上的讲话中全面阐述了“三个代表”要求的科学内涵和基本\n内容。\n3.2002年5月31日，江泽民在中共中央党校省部级干部进修班\n毕业典礼上深刻阐述了“三个代表”重要思想的内在联系、\n贯彻要求（完整理论体系内在的逻辑体系）。\n4.十六大将“三个代表”确立为党必须长期坚持的指导思想。\n“三个代表”重要思想的核心观点和主要内容核心观点始终代表中国先进生产力的发展要求 (基础和前提)\n始终代表中国先进文化的前进方向（思想保证，精神动力和智力支持）\n始终代表中国最广大人民的根本利益（出发点、归宿）\n主要内容1. 发展是党执政兴国的第一要务\n2. 建立社会主义市场经济体制\n3. 全面建设小康社会\n4. 建设社会主义政治文明\n5. 推进党的建设新的伟大工程\n历史地位1. 中国特色社会主义理论体系的接续发展 。\n2. 加强和改进党的建设，推进中国特色社会主义事\n业的强大理论武器。\n基本问题：建设什么样的党、怎样建设党\n\n贯彻“三个代表”重要思想，关键是坚持与时俱进，\n核心在保持党的先进性，本质在坚持执政为民\n\n“三个代表”重要思想是中国特色社会主义理论体\n系重要组成部分，是我们党必须长期坚持的指导思\n想。\n7 科学发展观科学发展观的形成科学发展观的形成条件第一，科学发展观是在深刻把握我国基本国情和新的阶\n段性特征的基础上形成和发展的；\n第二，科学发展观是在深入总结改革开放以来特别是党\n的十六大以来实践经验的基础上形成和发展的；\n第三，科学发展观是在深刻分析国际形势、顺应世界发\n展趋势、借鉴国外发展经验的基础上形成和发展的\n科学发展观的形成过程2007年，党的十七大对科学发展观的理论定位、理论\n依据、理论内涵作了全面阐述。\n2012年，十八大把科学发展观确定为党的指导思想。\n围绕“实现什么样的发展、怎样发展\n科学发展观的科学内涵和主要内容科学发展观的科学内涵科学发展观的第一要义是发展，核心是以人为本，\n基本要求是全面协调可持续，根本方法是统筹兼顾\n科学发展观的主要内容加快转变**经济**发展方式、发展社会主义民主**政治**、\n推进社会主义**文化**强国建设、构建社会主义和谐**社\n会**、推进**生态**文明建设、全面提高**党的建设**科学化\n水平\n精神实质：解放思想、实事求是、与时俱进、求真务实\n科学发展观的历史地位一、中国特色社会主义理论体系的接续发展。\n二、发展中国特色社会主义必须长期坚持的指\n导思想\n8 习近平新时代中国特色社会主义思想及其历史地位中国特色社会主义进入新时代新时代标志我国发展新的历史方位1.从发展阶段看，党的十八大以来，改革开放和社会主义现\n代化建设取得历史性成就，我国发展站到了新的历史起点上，\n中国特色社会主义进入新的发展阶段。党的理论创新实现了新\n飞跃，党的执政方式和执政方略有重大创新，发展理念和发展\n方式有重大转变，发展环境和发展条件有重大变化，发展水平\n和发展要求变得更高。\n2.从社会主要矛盾看，我国社会主要矛盾已经转化为人民日\n益增长的美好生活需要和不平衡不充分的发展之间的矛盾\n3.从奋斗目标看，党的十九大到二十大是“两个一百年”奋\n斗目标的历史交汇期，我们既要全面建成小康社会、实现\n第一个百年奋斗目标，又要乘势而上开启全面建设社会主\n义现代化国家新征程，向第二个百年奋斗目标进军\n4.从国际地位看，当代中国正处于从大国走向强国的关键时\n期，已不再是国际秩序的被动接受者，而是积极的参与者、\n建设者、引领者\n社会主要矛盾的变化\n主要矛盾：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾\n第一，经过改革开放40年的发展，我们生产力水平总体上显  著提高，很多方面进入世界前列。\n第二，人民生活水平显著提高，对美好生活的向往更加强烈，  不仅对物质文化生活提出了更高的要求，而且在民主、法治、  公平、正义、安全、环境等方面的要求日益增长。\n第三，影响满足人们美好生活的因素很多，但主要是发展的  不平衡不充分问题。\n\n\n两个没有变：\n历史阶段——仍处于并将长期处于社会主义初级阶段的基本国情没有变\n国际地位——世界上最大的发展中国家的国际地位没有变\n\n\n新时代的内涵和意义  -内涵  - 承前启后、继往开来、在新的历史条件下继续夺取中国特色  社会主义伟大胜利的时代——我们要走什么样的道路：历史性  - 决胜全面建成小康社会、进而全面建设社会主义现代化强国  的时代——我们要建设什么样的国家：实践性  - 全国各族人民团结奋斗、不断创造美好生活、逐步实现全体  人民共同富裕的时代——我们要实现什么样的发展：人民性  - 全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦  的时代——我们要达到什么样的目标：民族性  - 我国日益走近世界舞台中央、不断为人类作出更大贡献的时  代——我们要做出什么样的贡献：世界性\n意义\n近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的  伟大飞跃，迎来了实现中华民族伟大复兴的光明前景——历史意  义：从中华民族复兴的历史进程看\n科学社会主义在二十一世纪的中国焕发出强大生机活力，在世界  上高高举起了中国特色社会主义伟大旗帜——政治意义：从科学  社会主义发展进程看\n中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展  中国家走向现代化的途径，给世界上那些既希望加快发展又希望保  持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献  了中国智慧和中国方案。——世界意义：从人类文明进程看\n\n\n\n\n\n习近平新时代中国特色社会主义思想的主要内容习近平新时代中国特色社会主义思想的核心要义和丰富内涵1.核心要义：坚持和发展中国特色社会主义，是改革 开放以来我们党全部理论\n和实践的鲜明主题，也是习 近平新时代中国特色社会主义思想的核心要义。\n2.丰富内涵：8个明确\n明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华名族伟大复兴\n明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾\n明确中国特色社会主义事业总布局是五位一体，战略布局是四个全面\n明确全面深化改革总目标是完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化\n明确全面推进依法治国总目标是建设中国特色社会主义法治体系，建设社会主义法治国家\n明确党在新时代的强军目标是建设一直听党指挥、能打胜仗、作风优良的人民军队，把人名军队建设成为世界一流军队\n明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体\n明确中国特色社会主义最本质的特征是中国共产党的领导，中国特色社会主义制度的最大优势是中国共产党的领导，党是最高政治领导力量，提出新时代的建设总要求，突出政治建设在党的建设中的重要地位\n十四个坚持\n新时代坚持和发展中国特色社会主义的基本方略\n坚持党对一切工作的领导         坚持在发展中保障和改善民生\n坚持以人民为中心               坚持人与自然和谐共生\n坚持全面深化改革               坚持总体国家安全观\n坚持新发展理念                 坚持党对人民军队的绝对领导\n坚持人民当家做主               坚持一国两制和推进祖国统一\n坚持全面依法治国               坚持推动构建人类命运共同体\n坚持社会主义核心价值体系        坚持全面从严治党\n习近平新时代中国特色社会主义思想的历史地位\n马克思主义中国化的最新成果，党和人民实践经验和集体智慧的结晶，是中国精神的时代精华，国家政治生活和社会生活的根本指针， 是当代中国马克思主义、21世纪马克思主义，是对共产党执政规律、 社会主义建设规律、人类社会发展规律的重大理论创新\n马克思主义中国化最新成果：开辟了马克思主义新境界，开辟了中国特色社会主义  新境界，开辟了治国理政新境界，开辟了管党治党新境界\n新时代的精神旗帜：是党和人民实践经验和集体智慧的结晶；是中国特色社会主义理论体  系的重要组成部分\n实现中华民族伟大复兴的行动指南\n\n\n十九届六中全会通过了《中共中央关于党的百年奋斗重大成就和 历史经验的决议》——最重要的成果：总结党的百年奋斗重大成就 和历史经验 习近平新时代中国特色社会主义思想是当代中国马克思主义、二 十一世纪马克思主义，是中华文化和中国精神的时代精华，实现了马克思主义中国化新的飞跃\n第一，这一思想深刻回答了新时代的重大时代课题：实现了对中国特色社会主义  建设规律认识的新跃升，指明了中国式现代化道路的新图景，开辟了管党治党、  兴党强党的新境界——现实\n第二，这一思想提出了一系列原创性的治国理政新理念新思想新战略：  以全新视野深化了对共产党执政规律、社会主义建设规律、人类社会发  展规律的认识，是马克思主义中国化的最新成果——理论\n第三，这一思想是中华文化和中国精神的时代精华：是对中华优秀传统文化  进行创造性转化、创新性发展的典范——历史\n\n\n总体来讲，习近平新时代中国特色社会主义思想，是把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合 的重大理论成果，是党的十八大以来历史性成就和历史性变革的重要理论结晶，实现了马克思主义中国化的历史性飞跃和创造性升华。\n\n考试重点1.社会主要矛盾的变化2.新时代的内涵和意义3.习近平新时代中国特色社会主义思想的主要内容4.习近平新时代中国特色社会主义思想的历史地位9 坚持和发展中国特色社会主义的总任务第一节　实现中华民族伟大复兴的中国梦一、中华民族近代以来最伟大的梦想二、中国梦的科学内涵\n中国梦的本质是国家富强、民族振兴、人民幸福\n国家富强、民族振兴是人民幸福的基础和保障\n人民幸福是国家富强、民族振兴的题中之义和必然  要求\n人民幸福是国家富强、民族振兴的根本出发  点和落脚点\n\n\n人民是中国梦的主体，是中国梦的创造者和享有者\n中国梦是国家的梦、民族的梦，也是每一个中国人的梦\n中国梦与世界各国人民的美好梦想相通\n\n三、奋力实现中国梦\n中国梦实现的途径：走中国道路、弘扬中国精神、凝聚中国力量\n中国梦实现的条件：实干才能梦想成真；实现中国梦任重而道远，需要锲而不舍、驰而不息的艰苦努力；实现中国梦需要和平，只有和平才能实现梦想。\n\n第二节强国建的成战社略会安主排义现代化\n一、开启全面建设社会主义现代化强国的新征程\n第一个阶段，从2020年到2035年，在全面建成小康  社会的基础上，再奋斗15年，基本实现社会主义现代化\n第二个阶段，从2035年到本世纪中叶；在基本实现现  代化的基础上，再奋斗15年，把我国建成富强民主文明  和谐美丽的社会主义现代化强国\n\n\n\n考试重点1.中国梦的科学内涵2.奋力实现中国梦3.开启全面建设社会主义现代化强国的新征程10 “五位一体”总体布局第一节 建设现代化经济体系一、立足新发展阶段\n向第二个百年奋斗目标进军，这标志着我国进入了一个新发展阶段；新发展阶段是社会主义初级阶段中的一个阶段；新发展阶段是我们党带领人民迎来从站起来、富起来到强起来历史性跨越的新阶段，未来30年将是我们完成这个历史宏愿的新发展阶段\n进入新发展阶段、贯彻新发展理念、构建新发展格局，是由我国经济社会发展的理论逻辑、历史逻辑、现实逻辑决定的\n进入新发展阶段——发展的历史方位\n贯彻新发展理念——现代化建设的指导原则\n构建新发展格局——经济现代化的路径选择\n\n\n第一，从理论上看，人类社会必然走向共产主义，必然经历若干历史阶段。发展社会主义不仅是一个长期历史过程，而且是需要划分为不同历史阶段的过程。——理论依据\n第二，从历史依据来看，新发展阶段是我们党带领人民迎来从站起来、富起来到强起来历史性跨越的新阶段。今天，我们正在此前发展的基础上续写全面建设社会主义现代化国家新的历史。——历史依据\n第三，就现实依据来讲，我们已经拥有开启新征程、实现新的更高目标的雄厚物质基础。特别是全面建成小康社会取得伟大历史成果，为我国进入新发展阶段、朝着第二个百年奋斗目标进军奠定了坚实基础。——现实依据\n\n二、贯彻新发展理念1.新发展理念提出的背景 、意义\n党的十八届五中全会坚持以人民为中心的发展思想，鲜明提出了创新、协调、绿色、开放、共享的新发展理念。\n第一，新发展理念是引领我国发展全局深刻变革的科学指引，对推动我国经济实现高质量发展具有重大指导意义\n第二，新发展理念是针对我国经济发展进入新常态、世界经济复苏乏力形势提出的治本之策；是针对当前我国发展面临的突出问题和挑战提出的战略指引\n\n2.新发展理念的科学内涵\n创新是引领发展的第一动力：必须把创新摆在国家发展全局的核心位置\n协调是持续健康发展的内在要求：协调既是发展手段又是发展目标，同时还是评价发展的标准和尺度\n绿色是永续发展的必要条件\n开放是国家繁荣发展的必由之路\n共享是中国特色社会主义的本质要求：全民共享、全面共享、共建共享、渐进共享\n新发展理念是一个系统的理论体系，回答了关于发展的目的、动力、方式、路径等一系列理论和实践问题，阐明了我们党关于发展的政治立场、价值导向、发展模式、发展道路等重大政治问题\n\n3.如何理解新发展理念\n一是从根本宗旨把握新发展理念\n为人民谋幸福、为民族谋复兴，这既是我们党领导现代化建设的出发点和落脚点，也是新发展理念的“根”和“魂\n\n\n二是从问题导向把握新发展理念\n我国发展已经站在新的历史起点上，要根据新发展阶段的新要求，坚持问题导向，更加精准地贯彻新发展理念，举措要更加精准务实，切实解决好发展不平衡不充分的问题，真正实现高质量发展\n\n\n三是从忧患意识把握新发展理念\n增强忧患意识、坚持底线思维，随时准备应对更加复杂困难的局面。要坚持政治安全、人民安全、国家利益至上有机统一，既要敢于斗争，也要善于斗争，全面做强自己\n\n\n五大发展理念的关系相互贯通、相互促进，是具有内在联系的集合体，从整体上把握新发展理念，把新发展理念融入建设现代化经济体系中创新注重解决发展动力问题协调注重解决发展不平衡问题绿色注重解决人与自然的和谐问题开放注重解决发展内外联动问题共享注重解决社会公平正义问题更加突出发展的：创新性、整体性协调性、可持续性、内外联动性、包容性普惠性\n\n三、构建新发展格局\n党的十九届五中全会提出，要加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局\n1.内涵\n第一，从国内大循环与国内国际双循环的关系看，国内循环是基础，两者是统一体。\n第二，从供给和需求的关系看，要坚持深化供给侧结构性改革\n第三，从深化改革和推动发展的关系看，构建新发展格局必须全面深化改革。  构建新发展格局是发展问题，但本质上是改革问题\n\n\n2.意义\n第一，是与时俱进提升我国经济发展水平的战略抉择，也是塑造我国国际经济合作和竞争新优势的战略抉择\n第二，有效回应社会主要矛盾发展变化带来的新特征新要求，科学应对错综复杂的国际环境带来的新矛盾新挑战\n第三，党中央统筹中华民族伟大复兴战略全局和世界百年未有之大变局作出的战略谋划\n\n\n3.背景\n第一，这是适应我国经济发展阶段变化的主动选择。生产体系内部循环不畅和供求脱节现象显现，“卡脖子”问题突出，结构转换复杂性上升\n第二，这是应对错综复杂的国际环境变化的战略举措\n第三，这是发挥我国超大规模经济体优势的内在要求\n第四，这是我们党对经济发展客观规律的正确把握和实践运用，是长期战略，不是权宜之计\n\n\n4.如何构建(没有出过分析题)\n第一，坚持深化供给侧结构性改革这条主线，继续完成“三去一降一补”的重要任务，全面优化升级产业结构，扭住扩大内需战略基点，畅通国民经济循环\n第二，大力推动科技创新，打造经济发展新动能。构建新发展格局最本质的特征是实现高水平的自立自强\n第三，发挥全面深化改革在构建新发展格局中的关键作用。要围绕高水平自立自强、畅通经济循环、扩大内需、实行高水平对外开放、推动全面绿色转型深化改革\n\n\n新发展阶段、新发展理念、新发展格局之间的关系:进入新发展阶段贯彻新发展理念构建新发展格局是由我国经济社会发展的理论逻辑、历史逻辑、现实逻辑决定的。进入新发展阶段明确了我国发展的历史方位，贯彻新发展理念明确了我国现代化建设的指导原则，构建新发展格局明确了我国经济现代化的路径选择。把握新发展阶段是贯彻新发展理念、构建新发展格局的现实依据，贯彻新发展理念为把握新发展阶段、构建新发展格局提供了行动指南，构建新发展格局则是应对新发展阶段机遇和挑战、贯彻新发展理念的战略选择\n\n四、推动高质量发展\n党的十九大明确我国经济发展已由高速增长阶段转向高质量发展阶段\n\n1.意义\n发展是解决我国一切问题的基础和关键\n第一，推动高质量发展是保持经济持续健康发展的必然要求。\n第二，推动高质量发展是适应我国社会主要矛盾变化、全面建设社会主义现代化国家的必然选择。\n第三，推动高质量发展是遵循经济发展规律的内在要求\n\n2.深化供给侧结构性改革\n推进供给侧结构性改革是适应把握引领经济发展新常态的重大创新，是适应国际金融危机发生后综合国力竞争新形势的主动选择，是推动我国经济实现高质量发展的必然要求\n经济发展新常态：\n第一，增长速度要从高速向中高速转变\n第二，发展方式从规模速度型转向质量效益型\n第三，经济结构调整要从增量扩能为主转向调整存量、做优增量并举\n第四，发展动力要从主要依靠资源和低成本劳动力等要素投入转向创新驱动\n\n\n重点是解放和发展社会生产力，用改革的办法推进结构调整，减少无效和低端供给，扩大有效和中高端供给，增强供给结构对需求变化的适应性和灵活性，提高全要素生产率。简言之，就是去产能、去库存、去杠杆、降成本、补短板\n如何深化供给侧改革\n第一，推进增长动能转换，以加快发展先进制造业为重点全面提  升实体经济；\n第二，深化要素市场化配置改革，实现由以价取胜向以质取胜的  转变；\n第三，加大人力资本培育力度，更加注重调动和保护人的积极性；\n第四，持续推进“三去一降一补”，优化市场供求结构。坚持去  产能、去库存、去杠杆、降成本、补短板，优化存量资源配置，  扩大优质增量供给。\n\n\n\n五、使市场在资源配置中起决定作用、更好发挥政府作用\n1.党的十八届三中全会把市场在资源配置中的“基础性作用”修改为“决定性作用”。党的十九大再次强调“使市场在资源配置中起决定性作用”\n2.市场作用：资源配置中起决定性作用，并不是起全部作用，还要更好发挥政府作用，二者是有机统一的\n3.政府的职责和作用：保持宏观经济稳定，加强和优化公共服务，保障公平竞争，加强市场监管，维护市场秩序，推动可持续发展，促进共同富裕，弥补市场失灵\n4.必须坚持和完善我国社会主义基本经济制度\n第一，激发各类市场主体活力。毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展。\n第二，坚持按劳分配为主体、多种分配方式并存。\n第三，完善宏观经济治理。\n第四，建设高标准市场体系。\n第五，加快转变政府职能\n\n\n\n六、建设现代化经济体系的主要任务\n1.新时代我国经济发展的基本特征，是由高速增长阶段转向高质量发展阶段。\n推动高质量发展一是保持经济持续健康发展的必然要求；二是适应我国社会主要矛盾变化的必然要求；三是遵循经济规律发展的必然要求\n\n\n2.现代化经济体系的主要内容第一，建设创新引领、协同发展的产业体系第二，建设统一开放、竞争有序的市场体系第三，建设体现效率、促进公平的收入分配体系第四，建设彰显优势、协调联动的城乡区域发展体系第五，建设资源节约、环境友好的绿色发展体系第六，建设多元平衡、安全高效的全面开放体系第七，建设充分发挥市场作用、更好发挥政府作用的经济体制\n3.现代化经济体系的措施第一，大力发展实体经济，筑牢现代化经济体系的坚实基础。第二，加快实施创新驱动发展战略，强化现代化经济体系的战略支撑。第三，实施乡村振兴战略，夯实现代化经济体系的重要基础。第四，积极推动城乡区域协调发展。优化现代化经济体系的空间布局。第五，着力发展开放型经济，提高现代化经济体系的国际竞争力。第六，深化经济体制改革，完善现代化经济体系的制度保障\n\n第二节 发展社会主义民主政治一、坚持中国特色社会主义政治发展道路：人民当家作主\n1.人民当家作主是我们党矢志不渝的奋斗目标——国体人民当家作主是社会主义民主政治的本质和核心\n2.坚持中国特色社会主义政治发展道路\n第一，必须坚持党的领导、人民当 家作主和依法治国有机统一。党的领导是根本保证，人民当家作主是本质特征，依法治国是基本方略\n第二，必须积极稳妥推进政治体制改革。深化党和国家机构改革是关系全局的政治体制改革，是推进国家治理体系和治理能力现代化的一场深刻变革。\n第三，必须坚持正确政治方向。\n\n\n\n二、健全人民当家作主制度体系：人大制度、政协制度、民族区域自治制度、基层群众自治制度\n1.人民代表大会制度是我国根本政治制度\n人民代表大会制度是符合我国国情和实际、体现社会主义国家性质、保证人民当家作主、保障实现中华民族伟大复兴的好制度，是我们党领导人民在人类政治制度史上的伟大创造，是在我国政治发展史乃至世界政治发展史上具有重大意义的全新政治制度人民代表大会制度，坚持中国共产党领导，坚持马克思主义国家学说的基本原则，适应人民民主专政的国体，有效保证国家沿着社会主义道路前进人民代表大会制度，坚持国家一切权力属于人民，最大限度保障人民当家作主，把党的领导、人民当家作主、依法治国有机结合起来，有效保证国家治理跳出治乱兴衰的历史周期率\n人民代表大会制度是实现我国全过程人民民主的重要制度载体\n全过程人民民主的重大理念\n我国全过程人民民主不仅有完整的制度程序，而且有完整的参与实践。我国全过程人民民主实现了过程民主和成果民主、程序民主和实质民主、直接民主和间接民主、人民民主和国家意志相统一，是全链条、全方位、全覆盖的民主，是最广泛、最真实、最管用的社会主义民主\n\n\n2.基本政治制度：中国共产党领导的多党合作和政治协商制度、民族区域自治制度、基层群众自治制度\n中国共产党领导的多党合作和政治协商制度，首要前提和根本保证是中国共产党的领导；核心是多党合作\n人民政协聚焦党和国家中心任务，围绕团结和民主两大主题，把协商民主贯穿政治协商、民主监督（协商式监督）、参政议政全过程，重点监督党和国家重大方针政策和重要决策部署的贯彻落实\n民族区域自治的核心是保障少数民族当家做主，管理本民族、本地方事务的权利\n基层群众自治制度：改革开放以来，我国已经建立了基层民主自治体系，其主要内容有农村村民委员会、城市居民委员会、企业职工代表大会\n\n\n3.发挥社会主义协商民主重要作用（特有形式、独特优势）\n\n三、巩固和发展爱国统一战线\n长期共存、互相监督（《论十大关系》）\n长期共存、互相监督、肝胆相照、荣辱与共（党的十二大，新时期爱国主义统一战线的基本方针）\n\n四、坚持“一国两制”\n1.全面准确贯彻“一国两制”方针\n2.推进祖国统一\n习近平：《告台湾同胞书》（2019年）\n70年来，两岸关系不断取得突破性进展（“三通”、“九二共识”、“和平统一、一国两制”、巩固国际社会坚持一个中国原则的格局）\n第一，携手推动民族复兴，实现和平统一目标。\n第二，探索“两制”台湾方案，丰富和平统一实践。\n第三，坚持一个中国原则，维护和平统一前景。\n第四，深化两岸融合发展，夯实和平统一基础。\n第五，实现同胞心灵契合，增进和平统一认同，推进祖国统一\n\n\n\n第三节 推动社会主义文化繁荣兴盛一、坚持中国特色社会主义文化发展道路\n文化是一个国家、一个民族的灵魂。文化自信是更基础、更广泛、更深厚的自信，是一个国家、一个民族发展中更基本、更深沉、更持久的力量。坚定中国特色社会主义道路自信、理论自信、制度自信，说到底是坚定文化自信。\n发展中国特色社会主义文化，就是以马克思主义为指导，坚守中华文化立场，立足当代中国现实。\n中国特色社会是精神文明和物质文明全面发展的社会主义。\n文化是最需要创新的领域\n\n二、建设具有强大凝聚力和引领力的社会主义意识形态\n重要性：意识形态决定文化前进方向和发展道路。历史和现实表明，一个政权的瓦解往往是从思想领域开始的\n具体举措\n必须持续加强理论武装工作：把坚定“四个自信”作为建设社会主义意识形态的关键，把凝聚民心作为意识形态工作的出发点和落脚点\n必须坚持和加强党对意识形态工作的全面领导\n坚持以社会主义核心价值观引领文化建设制度\n坚持以马克思主义为指导，是当代中国哲学社会科学区别于其他其他哲学社会科学的根本标志\n新闻舆论处在意识形态斗争最前沿，必须把  政治方向摆在第一位，坚持党性原则\n\n\n\n三、培育和践行社会主义核心价值观\n1.二者关系\n社会主义核心价值体系由马克思主义指导思想、中国特色社会主义共同理想、以爱国主义为核心的民族精神和以改革创新为核心的时代精神、社会主义荣辱观四个方面内容构成\n\n\n2.培育和践行社会主义核心价值观的举措\n\n四、坚定文化自信，建设社会主义\n1.什么是文化强国高度文化素养的国民 发达的文化产业 强大的文化软实力\n2.如何建设文化强国\n第一，坚定文化自信，事关国运兴衰、事关文化安全、事关民族精神独立性的大问题。\n第二，推动中华优秀传统文化创造性转化、创新性发展。\n第三，健全人民文化权益保障制度。\n第四，大力发展文化事业和文化产业。\n第五，提高文化软实力。讲好中国故事是树立当代中国良好形象、提升国家文化软实力的重要战略任务。\n\n\n\n第四节 坚持在发展中保障和改善民生一、提高保障和改善民生水平:\n保障和改善民生是推动发展的根本目的\n第一，优先发展教育事业。\n第二，提高就业质量和人民收入水平。\n第三，加强社会保障体系建设。\n第四，实施健康中国战略。\n\n二、坚决打赢脱贫攻坚战\n措施：精准脱贫，实施“五个一批”工程，发展生产脱贫一批、异地搬迁脱贫一批、生态补偿脱贫一批、发展教育脱贫一批、社会保障兜底一批\n意义：从历史维度看，如期打赢脱贫攻坚战将在中华民族几千年历史发展中首次整体消除绝对贫困现象。从政治维度看，让贫困人口和贫困地区同全国一道进入全面小康社会是我们党的庄严承诺。从发展维度看，打赢脱贫攻坚战是我国发展必须完成的底线任务。从治理维度看，在脱贫攻坚战中不断完善的中国特色脱贫攻坚制度体系成为贫困治理的中国方案\n\n三、加强和创新社会治理四、坚持总体国家安全观\n总体国家安全观：坚持国家利益至上，人民安全为宗旨，以政治安全为根本，统筹外部安全和内部安全、国土安全和国民安全、传统安全和非传统安全、自身安全和共同安全，完善国家安全制度体系，加强国家安全能力建设，坚决维护国家主权、安全、发展利益\n措施：第一，完善国家安全体系。第二，健全公共安全体系。第三，推进平安中国建设。第四，加强国家安全能力建设。第五，加强国家安全教育\n\n五、建设美丽中国——生态1.坚持人与自然和谐共生\n生态文明的核心是坚持人与自然和谐共生\n尊重自然，是人与自然相处时应秉持的首要态度；顺应自然，是人与自然相处时应遵循的基本原则； 保护自然，是人与自然相处时应承担的重要责任\n\n2.形成人与自然和谐发展新格局\n第一，践行绿水青山就是金山银山的发展理念\n第二，把节约资源放在首位。\n第三，推动形成绿色发展方式和绿色生活方式\n\n3.加快生态文明体制改革\n实行最严格的生态环境保护制度。（健全源头预防、过程控制、损害赔偿、责任追究的生态环境保护体系）\n全面建立资源高效利用制度。（健全自然资源产权制度，落实资源有偿使用制度，实行资源总量管理和全面节约制度）\n健全生态保护和修复制度。\n严明生态环境保护责任制度\n\n考试重点  全章都是重点一、建设现代化经济体系——经济二、发展社会主义民主政治——政治三、推动社会主义文化繁荣发展——文化四、坚持在发展中保障和改善民生——社会五、建设美丽中国——生态11 “四个全面”战略布局一、全面建设社会主义现代化国家1.全面建成小康社会的内涵2.全面建成小康社会的目标要求3.全面推进乡村振兴\n第一，提高农业质量效益和竞争力\n第二，实施乡村建设行动\n第三，深化农村改革\n第四，实现巩固拓展脱贫攻坚成果同乡村振兴有效衔接\n\n扎实推进共同富裕——在中央财经委员会第十次会议上讲话（共同富裕可能会出分析题）\n共同富裕是社会主义的本质要求，是中国式现代化的重要特征\n共同富裕是全体人民共同富裕，是人民群众物质生活和精神生活都富裕，不是少数人的富裕，也不是整齐划一的平均主义\n促进共同富裕，要把握好以下原则：\n——鼓励勤劳创新致富\n——坚持基本经济制度：要立足社会主义初级阶段，坚持“两个毫不动摇”  要坚持公有制为主体、多种所有制经济共同发展，大力发挥公有制经济在  促进共同富裕中的重要作用，同时要促进非公有制经济健康发展、非公有制  经济人士健康成长\n——尽力而为量力而行\n——坚持循序渐进\n\n\n总的思路是，坚持以人民为中心的发展思想，在高质量发展中促进共同富裕，正确处理效率和公平的关系，构建初次分配、再分配、三次分配协调配套的基础性制度安排；加大税收、社保、转移支付等调节力度并提高精准性，扩大中等收入群体比重，增加低收入群体收入，合理调节高收入，取缔非法收入，形成中间大、两头小的橄榄型分配结构，促进社会公平正义，促进人的全面发展，使全体人民朝着共同富裕目标扎实迈进\n三次分配的地位与作用\n初次分配是最基础、最基本的，重在提高效率；按劳分配\n再分配的方式有税收、社会保障、转移支付（政府对家庭和个人的补助）等  政府通过改善公共服务，也能促进再分配的公平\n第三次分配是补充性的，不是主导地位，慈善性捐赠就是第三次分配的重要  方式\n\n\n\n\n\n二、全面深化改革1.坚定不移地全面深化改革：必要性\n全面深化改革，是顺应当今世界发展大势的必然选择\n全面深化改革，是解决中国现实问题的根本途径\n全面深化改革，关系党和人民事业前途命运，关系党的执政基础和执政地位\n\n如何改\n坚持党对改革的集中统一领导\n坚持改革沿着中国特色社会主义方向前进\n坚持改革往有利于维护社会公平正义、增进人民福祉方向前进\n坚持社会主义市场解决改革方向\n\n形成对外开放新格局\n第一，更广领域扩大外资市场准入。\n第二，更大力度加强知识产权保护国际合作。\n第三，更大规模增加商品和服务进口。\n第四，更加有效实施国际宏观经济政策协调。\n第五，更加重视对外开放政策贯彻落实。\n\n2.全面深化改革的总目标\n完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化\n前一句规定了根本方向，后一句规定了实现路径\n主要内容：经济体制、政治体制、文化体制、社会体制、生态文明体制、党的建设制度等\n\n3.全面深化改革要坚持正确的方法论注重系统性、整体性、协调性是全面深化改革的内在要求，\n也是推进改革的重要方法。\n加强顶层设计和摸着石头过河相结合，是富有中国特色、\n符合中国国情的改革方法。\n全面深化改革胆子要大，但步子一定要稳。\n改革发展稳定是我国社会主义现代化建设的三个重要支点：\n改革是动力，发展是关键，稳定是前提\n凡属重大改革都要于法有据。\n4.推动全面开放开放带来进步，封闭必然落后。开放是当代中国的鲜明标识。\n推动全面开放，要以“一带一路”为重点，坚持“引进来”\n和“走出去”并重，遵循共商共建共享原则，加强创新能力\n开放合作，形成陆海内外联动、东西双向互济的开放格局。\n建设更高水平开放型经济新体制。\n开放型经济的首要之义是反对保护主义\n三、全面依法治国\n1.全面依法治国方略的形成发展\n2.中国特色社会主义法治道路\n3.深化依法治国实践的重点任务\n全面依法治国，总目标是建设中国特色社会主义法治体系，建设社会主义法治国家\n\n全面从严治党1.新时代党的建设总要求\n四大考验、四大危险：\n执政考验、改革开放考验、市场经济考验、外部环境考验\n精神懈怠危险、能力不足危险、脱离群众危险、消极腐败危险\n\n\n根本方针：党要管党、全面从严治党“全面”是基础。“严”是关键。“治”是要害\n总体布局：政治建设、思想建设、组织建设、作风建设、纪律建设、制度建设\n目标：走在时代前列、人民衷心拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义政党新时代党的建设总要求：坚持和加强党的全面领导，坚持党要\n管党、全面从严治党，以加强党的长期执政能力建设、先进性\n和纯洁性建设为主线，以党的政治建设为统领，以坚定理想信\n念宗旨为根基，以调动全党积极性、主动性、创造性为着力点，\n全面推进党的政治建设、思想建设、组织建设、作风建设、纪\n律建设，把制度建设贯穿其中，深入推进反腐败斗争，不断提\n高党的建设质量，把党建设成为始终走在时代前列、人民衷心\n拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克\n思主义执政党\n\n2.把党的政治建设摆在首位3.全面从严治党永远在路上- 政治建设摆在首位、统领；政治建设的首要任务是\n\n保证全党服从中央，坚持党中央权威和集中统一领导；政治建设的有力抓手严格执行新形势下党内政治生活若干原则。    - 思想建设（基础性建设）首要任务是坚定理想信念\n考试重点1.全面建设社会主义现代化国家2.全面深化改革的总目标3.全面依法治国总目标（依法治国思修法基考）4.新时代党的建设总要求12 全面推进国防和军队现代化(了解为主)考试重点1.习近平强军思想\n习近平强军思想主要内容\n第一，强国必须强军\n第二，强军目标是建设听党指挥、能打胜仗、作风优良的世界一流军队\n第三，党对军队绝对领导是建军之本、强军之魂\n第四，创新发展军事战略，聚集能打仗打胜仗\n第五，作风优良是鲜明特色和政治优势\n第六，政治建军、改革强军、科技兴军、依法治军\n第七，改革是强军的必由之路\n第八，创新是引领发展的必由之路\n第九，构建中国特色军事法治体系\n第十，军民融合是兴国之举、强军之策\n\n\n党的领导是人民军队战无不胜的根本保证\n坚持党对军队绝对领导不是抽象原则要求，有  一整套制度作保证\n坚持党对军队的绝对领导，把党指挥枪的原则  落到实处\n\n\n\n3.建设世界一流军队4.推动军民融合\n军民融合\n既是兴国之举，又是强军之策。\n军政军民团结是实现富国和强军相统一的重要政治保障，是我党我军特有的政治优势\n\n\n\n13 中国特色大国外交(了解为主)一、当今世界的特点：和平与发展是时代主题\n政治多极化一超多强、经济全球化区域一体化、社会信息化、文化多元化、综合国力竞争、非传统安全问题突出（新冠、气候变化、反恐等）、逆全球化贸易保护主义抬头——百年来未有之大变局\n\n二、坚持独立自主和平外交政策：\n和平发展道路、构建人类命运共同体、引领全球治理体系改革、构建新型大国关系\n\n三、新型国际关系：相互尊重、公平正义、合作共赢\n要坚决维护国家核心利益\n要在和平共处五项原则基础上发展同世界各国的友好合作\n要加强涉外法律法规体系\n要积极参与全球治理体系改革和建设\n构建人类命运共同体：建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界\n政治上，相互尊重、平等协商\n安全上，对话解决争端、协商化解分歧\n经济上，同舟共济互利共赢\n文化上，尊重世界文明多样性\n生态上，合作应对气候变化，保护好地球家园\n\n\n\n四、促进一带一路国际合作\n目的是聚焦互联互通，深化务实合作，携手应对人类面临的各种风险挑战，实现互利共赢共同发展\n顺应经济全球化的历史潮流\n顺应全球治理体系变革的时代要求\n顺应各国人民过上更好日子的强烈愿望\n\n\n如何促进\n一是要坚持引进来和走出去并重，深化双向投资合作\n二是坚持共商共建共享原则\n三是加强创新能力开放合作\n四是把一带一路与构建人类命运共同体更加紧密\n结合起来。建成和平之路、繁荣之路、开放之路、创新之路、文明之路\n\n\n\n14 坚持和加强党的领导(了解为主)一、中国共产党的领导地位是历史的必然，是人民的选择。\n中国共产党是中国特色社会主义事业的坚强领导核心\n\n二、中国共产党领导是中国特色社会主义最本质的特征（理论逻辑、历史逻辑、实践逻辑所决定）\n是中国特色社会主义制度的最大优势（党是中国特色社会主义制度的创建者，党的领导是中国特色社会主义制度优势发挥的根本保障，党的优势是中国特色社会主义制度优势之源）\n\n三、新时代中国共产党的历史使命\n新时代中国共产党的历史使命，就是统揽伟大斗争、伟大工程（党的建设）、伟大事业（中国特色社会主义）、伟大梦想（中华民族伟大复兴），在全面建成小康社会的基础上全面建成社会主义现代化强国，实现中华民族伟大复兴\n四个伟大的关系。其中，起决定性作用的是党的建设伟大工程\n\n四、坚持党对一切工作的领导\n1.党是最高政治领导力量\n第一，这是马克思主义政党的基本要求\n第二，这是对党领导革命、建设和改革历史经验的深刻总结\n第三，这是推进伟大事业的根本保证\n\n\n2.确保党始终总揽全局、协调各方\n必须增强政治意识、大局意识、核心意识、看齐意识，自觉维护党中央权威和集中统一领导，自觉在思想上政治上行动上同党中央保持高度一致\n必须坚持和完善党的领导的体制机制\n必须坚持党的民主集中制原则\n\n\n3.全面增强党的执政本领\n增强学习本领\n增强政治领导本领\n增强改革创新本领\n增强科学发展本领\n增强依法执政本领\n增强群众工作本领\n增强狠抓落实本领\n增强驾驭风险本领\n\n\n\n","slug":"master/Politics/毛中特","date":"2022-10-23T11:35:25.000Z","categories_index":"考研政治","tags_index":"考研政治","author_index":"ChrisWood"},{"id":"0c2bac51f883840de61216bf9cb02da8","title":"马克思主义基本原理","content":"马克思主义基本原理导论（8&#x2F;1）第一章马克思主义的创立和发展什么是马克思主义\n马克思主义是由马克思、恩格斯创立并为后继者所不断发展的科学理论体系，是关于自然、社会人类思维发展一般规律的学说，是关于社会主义必然代替资本主义、最终实现共产主义的学说，是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说，是无产阶级政党和社会主义国家的指导思想，是指引人民创造美好生活的行动指南。\n马克思主义包括马克思主义哲学、马克思主义政治经济学和科学社会主义三个基本组成部分，马克思主义哲学是理论基础，政治经济学是主要内容，科学社会主义处于核心地位\n马克思主义基本原理 是马克思主义理论体系中最基本、最核心的内容\n基本：贯穿始终 理论前提\n\n马克思主义的创立\n马克思主义的产生\n1848年 共产党宣言的发表为标志\n\n\n1 经济社会根源 &gt; 资本主义经济的发展\n2 阶级基础 &gt; 现代无产阶级作为独立的政治力量登上历史舞台，无产阶级革命运动从自发走向自觉，迫切需要科学理论指导\n3-1直接理论渊源\n德国古典哲学 – 马克思主义哲学\n英国古典政治经济学 – 马克思主义政治经济学\n英法空想社会主义 – 科学社会主义\n\n\n3-2自然科学前提 &gt; 细胞学说 生物进化论 能量守恒和转化定律\n马恩 德法年鉴 完成了从唯心向唯物、革命民主向共产主义的转变，为创立马克思主义奠定了思想基础\n\n\n马克思恩格斯创立过程\n马克思 资本论第一卷 系统阐述了剩余价值学说\n马克思 法兰西内战、哥达纲领批判 进一步丰富了社会主义学说\n恩格斯 家庭私有制国家起源 发展了马克思主义\n\n\n\n马克思主义的发展\n列宁 使科学社会主义从理论开始变为现实\n中国化马克思主义\n毛泽东思想\n邓小平理论 三个代表重要思想 科学发展观\n习近平新时代中国特色社会主义思想\n\n\n\n马克思主义的鲜明特征科学性\n马克思主义是对自然、社会和人类思维发展本质和规律的正确反映。\n科学的世界观\n科学的方法论\n\n\n\n革命性\n马克思主义集中表现了彻底的批判精神和鲜明的无产阶级立场。\n\n实践性\n指马克思主义是从实践中来，到实践中去，在实践中接受检验，并随实践而不断发展的学说。实践性是马克思主义理论区别于其他理论的显著特征。\n\n人民性\n人民性是指人民至上是马克思主义的政治立场。马克思主义政党把人民放在心中最高位置，一切奋斗都致力于实现最广大人民的根本利益。\n\n发展性-发展性是指马克思主义是不断发展的学说，具有与时俱进的理论品质。\n开放性\n开放性是指马克思主义不断吸收人类历史上一切优秀思想文化成果而不断丰富自己。\n\n马克思主义的当代价值观察当代世界变化的认识工具指引当代中国发展的行动指南引领人类社会进步的科学真理考点1 马克思主义与马克思主义基本原理2 马克思主义的产生和发展3 马克思主义的本质特征4 马克思主义的当代价值备注:18 19 20 21 22每年考一分，单项选择题马克思主义哲学（80&#x2F;16-18）第二三四章导论哲学是系统化、理论化的世界观、又是方法论；哲学是对自然知识、社会知识和思维知识的概括和总结。马克思哲学体系\n两种根本对立的本体论  &gt;  唯物主义和唯心主义的对立\n两种根本对立的发展观  &gt;  辩证法与形而上学的对立\n两种根本对立的认识论 &gt; 反映论与先验论的对立\n两种根本对立的历史论 &gt; 唯物史观与唯心史观的对立\n\n辩证唯物主义（自然观）辩证唯物论 – 世界的本质 第二章第一节\n唯物唯心的区分标准\n世界的本原 物质和思维谁是第一性 &gt; 区分唯物唯心\n思维能否正确认识物质，即物质和思维有无同一性 &gt; 区分可知不可知（同一性：二者有没有联系有没有一致性）\n\n\n\n唯物主义又分朴素唯物主义  形而上学唯物主义 辩证唯物主义及历史唯物主义\n唯心主义又分为主观唯心和客观唯心\n\n\n物质及其存在形式\n物质观\n朴素唯物主义物质观  具体物质\n形而上学唯物主义物质观  原子\n辩证唯物主义物质观  客观实在性\n【备注】\n物质是标志客观实在的哲学范畴\n物质范畴是唯物主义哲学关于世界本原和统一性的最高抽象\n辩证唯物主义物质观的重大理论意义\n其一，坚持了唯物主义一元论，同唯心主义一元论和二元论划清了界限。\n其二，坚持了能动的反映论和可知论，批判了不可知论。\n其三，体现了唯物论和辩证法的统一，克服了形而上学唯物主义的缺陷。\n其四，体现了唯物主义自然观与唯物主义历史观的统一，为彻底的唯物主义奠定了理论基础。\n\n\n\n\n\n\n物质存在形态\n运动 物质的根本属性和存在方式\n运动是标志一切事物和现象的变化及其过程的哲学范\n物质与运动不可分割\n任何物质处于运动之中\n物质是运动的主体 承载者\n割裂物质和运动的关系必然导致 唯心主义或者形而上学唯物主义\n\n\n\n\n静止 运动是绝对的 静止是相对的；动中有静，静中有动\n静止是运动的特殊状态，在一定条件下暂时稳定和平衡状态的哲学范畴（2种状态：空间的相对位置暂时不变 事物的根本性质暂时不变）\n相对静止是物质存在和发展的必要条件；是人们认识和利用事物的前提；是理解和衡量运动的尺度\n\n\n时空观 时空是物质运动的存在形式\n时间 物质运动的持续性和顺序性 时间的特性是一维性\n空间 物质运动的广延性、伸张性 空间的特点三维性\n时空和物质运动的关系 形式和内容的关系\n时间和空间具有客观性\n时空是绝对和相对的统一\n时空是无限和有限的统一\n\n\n一切以时间、地点、条件为转移。具体问题具体分析\n\n\n\n\n\n\n意识观\n起源\n物质世界高度发展的产物（前提）\n一般反应-刺激感应-动物感觉和心理-人的意识\n\n\n社会劳动的产物\n劳动为意识的产生提供了客观需要和可能\n在劳动中人脑不断完善，并产生了语言\n语言是劳动中人脑产生的，是意识的物质外壳\n\n\n\n\n\n\n本质 \n人脑对物质世界的主观映像；\n意识是客观内容和主观形式的统一\n意识的内容是客观的：意识内容来自物质世界\n意识的形式是主观的：意识形式是主观世界特有的、不同主体之间的差别性、同一主体不同条件下的差别性\n\n\n\n\n\n\n物质与意识的辩证关系\n物质决定意识\n世界同一于物质原理内容\n其一，世界是统一的，即世界的本原是一个；\n其二，世界的统一性在于它的物质性，即世界统一的基础是物质\n其三，物质世界的统一性是多样性的统一，而不是单一的无差别的统一，坚持辩证法\n\n\n世界同一于物质原理的意义\n理论意义：马克思主义哲学基石\n实践意义：是我们从事一切工作的立足点，一切从实际出发是唯物主义一元论的根本要求\n\n\n\n\n意识对物质具有反作用（主观能动性和客观规律性的统一）\n意识能动性\n本质内涵 人类意识特有的能动地反映世界并通过实践能动地改造世界的能力和活动\n主要表现\n第一，意识活动具有目的性和计划性：\n第二，意识活动具有创造性；\n第三，意识具有指导实践改造客观世界的作用；\n第四，意识具有控制人的行为和生理活动的作用。\n\n\n\n\n客观规律\n定义 事物运动发展中的本质的必然的稳定的联系\n特点 规律是本质的联系、必然的联系、稳定的联系、客观的联系（客观 只能认识和利用）\n表现 自然规律和社会规律\n联系 自然规律和社会规律都具有不以人的意志为转移的客观性\n区别 自然规律是作为一种盲目的无意识的力量起作用；社会规律是通过抱有一定目的和意图的人的有意识的活动来实现的\n\n\n\n\n正确发挥主观能动性的条件\n从实际出发，努力认识和把握事物发展规律\n尊重客观规律是前提和基础\n发挥能动性是认识、利用的必要条件\n尊重和发挥是辩证统一的\n\n\n实践是发挥人的主观能动作用的基本途径\n主观能动作用的发挥，还依赖一定的物质条件和物质手段\n\n\n\n\n实践是自然存在和社会存在区分和统一的基础\n从实践出发理解社会生活的本质 实践是人的本质存在方式\n一方面，实践是使物质世界分化为自然界与人类社会的历史前提，又是使自然界与人类社会统一起来的现实基础。\n另一方面，实践是社会关系形成的基础，实践形成了社会生活的基本领域（物质生活、政治生活、精神生活领域），实践构成了社会发展的动力。\n\n\n社会生活的实践性\n第一，实践是社会关系形成的基础\n第二，实践形成了社会生活的基本领域\n第三，实践构成了社会发展的动\n\n\n\n\n备注\n决定和反作用关系  都具有前后关系\n三个统一 \n世界物质的统一性\n主观能动性和客观规律性的统一\n实践是自然存在和社会存在区分和统一的基础\n\n\n\n\n\n\n【备注】关键词关键句\n物质与意识 运动与静止 物质运动和时空 客观规律和主观能动性\n物质范畴是一切唯物主义哲学的理论基石\n世界的物质统一性是马哲的理论基石，是一切从实际出发的理论依据\n物质的唯一特性是客观实在性\n物质的根本属性和存在方式是运动\n意识产生过程中起决定作用的因素是社会劳动\n社会生活的本质是实践\n\n\n【备注】考点\n5.哲学的基本问题与基本派别\n6.物质范畴以及物质的根本属性和基本存在方式\n7.意识观：意识的起源于本质\n8.物质与意识的辩证关系\n9.世界的物质统一性原理\n10.主观能动性与客观规律性的统一\n11.实践是社会生活的本质\n\n\n\n唯物辩证法 – 世界的存在方式 第二章第二三节-    - 事物的联系和发展    - 唯物辩证法是认识和改造世界的根本方法    - 辩证法坚持用联系的、发展的观点看世界，认为发展的根本原因在于事物的内部矛盾    - 形而上学则坚持用孤立的、静止的观点看问题，否认事物内部矛盾的存在和作用\n\n两大特征 普遍联系与永恒发展\n\n联系\n定义：联系是指事物内部各要素之间和事物之间相互影响、相互制约和相互作用的关系。 世界的普遍联系是通过“中介”来实现。\n特点：\n客观性，事物本身固有的\n普遍性，内部 外部 中介\n多样性，事物是多样的\n条件性，条件是对事物存在和发展发生作用的诸要素的总和\n条件对事物的发展和人的活动具有支持或制约作用\n条件是可以改变的\n改变和创造条件必须符合客观规律\n\n\n\n\n意义：要求人们善于分析事物的具体联系，确立整体性、开放性观念\n\n\n发展\n实质是新事物的产生、旧事物的灭亡\n新事物必然战胜旧事物\n新事物是指符合客观规律和发展的前进方向、具有强大生命力和远大前途的事物\n新事物的结构和功能适合变化了的环境和条件\n新事物比旧事物优越\n在社会历史领域，新事物是符合广大人民群众的根本利益\n\n\n发展与过程 过程是指一切事物都有产生发展和转化为其他事物的历史\n要求我们用历史的观点看问题，把一切事物都如实的看作是变化、发展的过程\n\n\n\n\n\n\n五大环节\n\n内容与形式（要素与结构）\n定义 内容是构成事物一切要素的总和 形式是内容诸要素相互结合的结构和表现形式\n关系 相互依赖不可分割，相互作用相互依赖，内容决定形式，形式反作用于内容\n意义 重视内容作用，反对形式主义，善于运用形式，适时创造新形式\n\n\n本质与现象（内在联系与外在表现）\n定义 现象是指事物外部联系和表面特征；本质是事物的根本性质，是组成事物基本要素的内部联系\n区别 现象是感官感知 个性 丰富生动的 本质是思维能力把握 共性 普遍深刻的\n关系 任何事物都是现象和本质的统一体\n意义 透过现象看本质\n备注 现象包含真象 假象（歪曲表现事物的本质）  和错觉区分开，错觉是主观的\n\n\n原因与结果（前后相继。彼此制约）\n定义 事物或现象之间前后相继。彼此制约，即引起和被引起的关系\n关系 \n一个具体的因果联系中，二者不能混淆和颠倒。\n原因与结果相互依存，相互转化（一定条件下）\n原因和结果的关系不仅是客观普遍的，而且是复杂多样的（一因多果，同因异果与同果异因，多因多果与复合因果）\n\n\n意义 正确认识掌握事物的因果联系，增强实际工作中的自觉性、预测性和调控性\n\n\n必然与偶然（两种不同趋势）\n定义 必然性是指事物联系发展过程中一定发生、确定不移的趋势，偶然性是指非确定发生、不确认的趋势 必然性和偶然性同一个事物的2种不同趋势\n关系 必然性通过大量的偶然性表现出来，偶然性是必然性的表现形式和补充，在一定条件下可以相互转化\n意义 把握有利于事物发展的机遇，重视机遇的作用\n\n\n可能与现实（过去、现在与未来）\n定义\n可能性是指事物发展中潜在的东西，是包含在事物之中并预示着事物发展前途的种种趋势\n现实性是已经产生出来的，有内在依据、合乎必然性的存在\n可能性范畴\n区分可能和不可能   有没有客观依据\n区分现实的可能和抽象的可能   条件是否充分\n区分两种相反的可能  对现实的可能的定性分析\n区分可能性的程度  对现实的可能的定量分析\n\n\n\n\n关系 可能性是还没有成为现实的东西，现实性是已经实现了的可能，同时又孕育着新的可能，在一定条件下可以相互转化\n意义 立足于现实，发挥主观能动性，把有利的可能变成现实\n\n\n\n\n三大规律\n\n对立统一规律 事物发展的源泉和动力（核心）\n\n又叫矛盾规律\n矛盾是事物发展的源泉和的动力，矛盾具有普遍性和特殊性\n矛盾的同一性和斗争性及其在事物发展中的作用\n辩证矛盾是反映客观事物内部和事物之间既对立又统一关系的哲学范畴\n同一性和斗争性是矛盾的两个基本属性\n同一性 矛盾双方互相依存、互相贯通的性质和趋势\n斗争性 矛盾双方相互分离、相互排斥的性质和趋势\n关系 矛盾的同一性是相对的有条件的；斗争性是绝对的无条件的，同一是包含着差别对立的同一；斗争是统一体内部的斗争，一定条件下矛盾双方相互转化\n意义 同中求异 异种求同 一分为二看问题\n\n\n同一性和斗争性在事物发展中共同作用\n同一性的作用\n由于矛盾双方相互依存，互为存在的条件，矛盾双方可以利用对方的发展使自己获得发展\n由于矛盾双方相互包含，矛盾双方可以相互吸取有利于自身的因素而得到发展\n由于矛盾双方彼此相通，矛盾双方可以向着自己的对立面转化而得到发展，并规定着事物发展的方向\n\n\n斗争性的作用\n促进事物量变 推动矛盾双方力量对比发生变化\n完成事物质变 突破事物存在的限度，旧的矛盾统一体分解 新的矛盾统一体产生\n\n\n意义 事物的发展不仅相反相成 还表现为相辅相成 正确把握和谐的作用\n\n\n\n\n矛盾的普遍性和特殊性及其相互关系（5年内没有分析题，重视）\n普遍性 空间上无处不在，时间上无时不有 矛盾存在一切事物及每个事物发展过程中自始至终的矛盾运动\n在实际生活中，坚持矛盾分析法\n\n\n特殊性 每个事物所包含的矛盾及每个矛盾各个方面都有其特点\n具体表现\n不同事物的矛盾各有特点\n矛盾在同一事物不同发展过程和阶段各有特点\n不同矛盾不同方面各有不同性质、地位、作用\n根本矛盾（贯穿事物发展过程始终） 非根本矛盾\n主要矛盾（决定作用）和次要矛盾 主要方面（主导地位）和次要方面  矛盾的性质是由矛盾的主要方面决定的\n解决矛盾的形式的多样性\n一方克服另一方\n双方同归于尽\n双方形成协同运动的新形式\n双方融合成为一个新事物\n\n\n\n\n\n\n具体问题具体分析\n\n\n辩证关系\n区别 矛盾的普遍和特殊 是共性和个性 一般和个别的关系\n联系 普遍性从特殊性中概括出来；特殊性必然与普遍性相联系而存在；在一定条件下相互转化\n\n\n意义\n理论意义 是事物矛盾问题的精髓，是正确理解矛盾学说的关键\n实践意义 坚持马克思主义普遍真理与各国具体实践相结合的\n\n\n\n\n矛盾及其发展的不平衡性\n主次矛盾 支配地位、决定作用的是主要矛盾\n主要矛盾决定次要矛盾 次要影响主要 一定条件下相互转化\n\n\n主要方面 同一矛盾 主导地位的方面是主要方面\n主要方面支配次要方面 事物性质主要是由支配地位矛盾的主要方面决定 次要影响主要 一定条件下相互转化\n\n\n意义 两点论和重点论相结合 抓关键看主流\n\n\n总结\n矛盾的内涵 既对立又统一\n一 同中求异，异中求同（和而不同） 矛盾的基本属性 同一性和斗争性\n二 相辅相成与相反相成 同一性和斗争性的共同作用\n三 具体问题具体分析 普遍性和特殊性\n四 精髓原理 普遍性和特殊性的辩证关系，共性个性 \n五 不平衡性原理 主次矛盾 矛盾的主次方面\n\n\n\n\n质量互变规律 事物发展的形式或状态\n\n任何事物都呈现出量变质变两种形式，度是区分量变质变的尺度\n任何事物都是质和量的统一体\n质\n事物成为它自身并区别于其他事物的内在规定性\n质是认识的起点和基础\n\n\n量\n事物存在发展的规模、程度、速度以及其他构成空间上排列组合等可以用数量表示的规定性\n量是认识的深化和精确化\n\n\n度\n保持自己质的数量限度，是质和量的统一\n意义 坚持适度原则 防止过和不及\n\n\n\n\n量变质变及其辩证关系\n量变是事物数量的增减或场所变更\n质变是事物根本性质的变化\n区分的根本标志是事物的变化是否超出度\n辩证关系\n量变是质变的必要准备\n质变是量变的必然结果\n质变量变互相渗透的\n总的量变中有阶段性和局部性部分质变\n质变过程中包含着量的扩张，新质因素增长，旧质因素灭亡\n\n\n\n\n意义 既要有远大目标，又要注重量的积累\n\n\n\n\n否定之否定规律 事物发展的方向和道路\n\n辩证否定的实质是扬弃；任何事物的发展都是前进性和曲折性的统一\n肯定因素和否定因素（维持存在的因素 促成灭亡的因素）\n辩证的否定观\n否定是事物的自我否定，是事物内部矛盾运动的结果。\n否定是事物发展的环节。\n否定是新旧事物联系的环节。\n辩证否定的实质是“扬弃”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素。\n\n\n意义 对待一切事物采取科学分析的态度和方法 传统文化取弃 外国文化 不一概拒绝不全盘照搬\n事物发展前进性和曲折性的统一\n事物发展总趋势是前进的上升的，因为事物发展通过否荻定，每次否定都意味着一次扬弃\n道路迂回曲折 否定之否定阶段会重复肯定阶段某些特点，仿佛回到出发点，事物发展呈现出周期性\n意义 做好艰苦的努力 争取光明的前途\n\n\n\n\n\n\n四种辩证思维方法\n\n归纳与演绎\n分析与综合\n抽象与具体\n逻辑与历史相统一\n\n\n五大思维能力\n\n辩证思维\n唯物辩证法是认识和改造世界的根本方法\n唯物辩证法是客观辩证法和主观辩证法的统一，体现唯物主义、辩证法、认识论的统一\n客观辩证法 客观事物或客观存在的辩证法\n主观辩证法 人类认识和思维运动的辩证法\n主观辩证法是客观辩证法的反映 是反映与被反映 第二性和第一性的关系\n矛盾分析法在唯物辩证法中处于核心地位，是根本的认识方法\n联系  矛盾 重点  透过现象看本质\n\n\n历史思维\n战略思维\n底线思维\n创新思维\n\n\n习近平新时代中国特色社会主义思想对唯物辩证法的创造性运用和发展\n\n【备注】考点\n\n12.唯物辩证法两大特征\n13.唯物辩证法基本环节\n14.唯物辩证法实质和核心：对立统一规律\n15.质量互变规律\n16.否定之否定规律\n17.掌握辩证思维能力，增强辩证思维能力\n\n\n\n辩证唯物主义认识论 – 认识发展的一般规律 第三章\n认识的基础\n\n实践\n本质 人类能动地改造世界的客观物质性活动\n特点 直接现实性、自觉能动性、社会历史性\n基本结构\n主体 具备实践和认识能力，从事实践和认识活动的人\n客体 实践和认识活动指向的对象\n中介 各种形式的工具 手段 程序和方法\n主体和客体之间最基本的关系是实践关系（改造被改造），在此基础上才有认识关系（反映被反映） 价值关系（满足被满足）\n\n\n\n\n基本形式 物质生产实践（最基本的实践活动） 社会政治实践 科学文化实践\n\n\n认识的本质\n两条根本对立的认识路线\n唯物主义反映论：坚持“从物到感觉和思想“的认识路线\n唯心主义先验论：坚持“从感觉和思想到物“的认识路线\n\n\n直观反映论与能动反映论的对立\n旧唯物主义认识论 直观被动反映论\n第一，缺乏实践的观点；\n第二，缺乏辩证法的观点。\n\n\n辩证唯物主义认识论 能动革命反映论\n认识是主体在实践基础上对客体的能动反映。\n首先，反映具有摹写性。其次，反映具有创造性。最后，以实践为中介而实现的。\n\n\n\n\n即本质是 主体在实践基础上对客体的能动反映\n\n\n实践是认识的基础\n第一，实践是认识的唯一来源。 直接经验是源 间接经验是流\n第二，实践是认识发展的动力。\n实践的发展不断提出新课题\n实践为解决新问题提供必要经验材料，认识工具和技术手段，推动认识不断向深度和广度拓展\n实践推动人类思维水平不断提高\n\n\n第三，实践是认识的目的。\n第四，实践是检验认识的真理性的唯一标准。\n\n\n\n\n认识的运动规律\n\n两次飞跃\n第一次飞跃：在实践基础上从感性认识到理性认识的飞跃\n感性认识和理性认识的辩证关系\n感性认识 感官 外部联系 感觉、知觉、表象 初级阶段 直接性、形象性\n理性认识 思维 本质特征 概念、判断、推理 高级阶段间接性、抽象性\n感性认识和理性认识的辩证统一\n理性认识依赖于感性认识。\n感性认识有待于发展深化为理性认识。\n感性认识和理性认识相互渗透、有机统一。\n\n\n飞跃的条件\n必须尽可能获得十分丰富、合乎实际（全面、正确）的感性材料\n必须运用科学的思维方法对丰富的感性材料加以去粗取精、去伪存真、由此及彼、由表及里的改造（2去2由）\n\n\n理性因素和非理性因素在认识过程中共同起作用\n理性因素 人的理性思维能力，即认知  在认识活动中发挥指导作用、解释作用、预见作用\n非理性因素 人的情感、意志，以及以非逻辑形式出现的非理智、非认知的精神因素 在认识活动中起到动力作用、诱导作用、激发作用\n\n\n\n\n第二次飞跃 从认识到实践\n第二次飞跃比第一次飞跃更重要、意义更伟大\n第一，认识世界的目的是为了改造世界。\n第二，认识的真理性只有在实践中才能得到检验和发展。\n\n\n实现由认识向实践的飞跃，需要经过一定的中介环节，包括确定实践目的、形成实践理念、制定实践方案、进行中间实验、运用科学实践方法等。\n对人民群众进行组织和宣传，让理论为群众所掌握，并转化为改造世界的物质力量\n\n\n\n\n多次反复和无限发展\n认识发展的总过程：“实践、认识、再实践、再认识”，本质上体现了认识发展的一般规律\n认识过程之所以多次反复：受到主客观条件限制，往往不是一次完成\n从主观方面看，人们总是受到自己的认识能力和实践活动范围的限制\n从客观方面看，事物的各个侧面及其本质的暴露有一个过程；受到所处时代科学技术条件的限制\n\n\n认识过程之所以无限发展：因为物质世界及其发展是无限的，因而人们的认识运动永远不会终结\n\n\n一个原则：坚持主观和客观、认识和实践具体的历史的相统一的原则\n具体的统一 特定的时间、地点和条件下\n历史的统一 随着实践的不断发展而相应的变化发展\n\n\n\n\n认识的结果\n\n真理与谬误\n真理是人们对客观事物及其规律的正确反映。\n谬误是人们对客观事物及其规律的歪曲反映。\n真理和谬误又是相互联系的。真理和谬误相比较而存在，相斗争而发展。在一定条件下，真理和谬误相互转化。\n真理的客观性、绝对性和相对性\n本质特征：真理的客观性（真理问题上的唯物论问题）\n第一，真理的内容是客观的\n第二，检验真理的标准，即社会实践也是客观的\n\n\n真理的客观性决定了真理的一元性\n真理的绝对性和相对性及其辩证关系原理\n真理的绝对性也称为绝对真理，是指真理的无条件性、无限性\n真理的相对性也称为相对真理，是指真理的有条件性、有限性。\n第一，从认识的广度上看，有待于扩展。\n第二，从认识的深度上看，有待于深化。\n\n\n真理是一个从相对真理走向绝对真理，接近绝对真理的过程。绝对真理是通过相对真理表现出来的，在一定条件下相互转化。\n意义 正确对待马克思主义的态度是：一要坚持，二要发展。\n\n\n\n\n实践是检验真理的唯一标准\n实践是检验真理的唯一标准，这是由真理的本性和实践的特点所决定的。\n真理的本性是主观和客观相符合，实践是把主观与客观联结起来的“桥梁”。\n实践的直接现实性决定了只有实践才能成为检验真理的标准，实践具有直接现实性，不仅它本身是直接现实，而且它能够使理论成为现实\n\n\n实践标准的确定性和不确定性\n实践标准的确定性或绝对性：实践是检验真理的唯一和最终标准。\n实践标准的不确定性或相对性：任何实践都是一定社会历史条件下的实践，都要受到特定的社会历史条件的制约或影响。实践对认识的检验也要有一个多次反复的过程。\n\n\n\n\n\n\n真理与价值\n价值、价值评价、价值观\n价值：反映客体与主体需要之间满足和被满足关系的范畴\n价值的特点：客观性、主体性、社会历史性、多维性\n价值评价是一种关于价值现象的认识活动\n特点： \n第一，评价以主客体的价值关系为认识对象。一是知识性认识，追求的是“真”；一是评价性认识，追求的是“善和美”。\n第二，评价结果依主体的客观存在状态，包括主体的需要、特点以及其它规定性而转移的。\n第三，评价结果的正确与否依赖于相关的知识性认识。\n\n\n标准：只有与人民、人类整体的要求和利益相一致，才是正确的价值评价。\n功能：推动实践不断实现价值的精神驱动力量、规范性要素、导向要素。\n\n\n\n\n真理与价值在实践中的辩证统一\n真理原则：人们必须按照世界的本来面目去认识世界和改造世界，追求和服从真理。\n物的尺度 条件制约性 认识过程中的统一性\n\n\n价值原则：人们必须按照自己的需要去认识和改造世界，创造和实现价值。\n人的尺度 目的性和能动性 社会活动中的多样性\n\n\n意义 \n第一，成功的实践必然是以真理和价值的辩证统一为前提的。是合规律性和合目的性的统一。只有把“按科学规律办事”与“满足人的需要”结合起来的实践，才是成功的实践。\n第二，价值的形成和实现以坚持真理为前提，而真理又必然是具有价值的。\n第三，二者在实践和认识活动中是相互制约、相互引导、相互促进的。\n\n\n\n\n\n\n\n\n认识世界和改造世界\n\n认识世界与改造世界及其辩证关系\n\n认识世界与改造世界\n认识世界和改造世界是人类创造历史的两种基本活动。\n认识世界和改造世界的过程，既是认识和改造客观世界的过程，也是认识和改造主观世界的过程。改造客观世界，包括改造自然界和改造人类社会；改造主观世界，核心是改造世界观。\n改造客观世界与改造主观世界辩证统一，二者相辅相成、相互促进。\n\n\n从必然走向自由的过程\n自由是对必然的认识和对客观世界的改造。\n必然王国和自由王国是人类在客观世界面前所处的两种不同的社会活动状态。\n必然王国，人受物支配的社会状态；自由王国，人支配物的社会状态。\n自由是历史发展的产物。自由是有条件的：一是认识条件；二是实践条件\n认识必然和争取自由，是人类认识世界和改造世界的根本目标，是一个永无止境的历史性的过程\n\n\n\n\n\n\n一切从实际出发，实事求是\n\n实现理论创新和实践创新的良性互动\n\n实践创新为理论创新提供不竭的动力源泉，理论创新为实践创新提供科学的行动指南\n实践创新是理论创新的决定性因素。理论创新对实践的发展具有指导作用\n\n\n实践基础上的理论创新是社会发展和变革的先导\n理论创新与实践创新的良性互动，二者之间形成相互激发、共同促进的因果关系。\n\n\n\n\n考点\n\n18.实践是认识的基础\n19.认识运动的基本规律\n20.坚持整理，修正错误\n21.真理的客观性绝对性和相对性及其辩证关系原理\n22.检验真理与谬误的标准及其检验标准的确定性和不确定性的统一\n23.真实与价值在实践中的辩证统一\n24.认识世界和改造世界\n25.马克思主义认识论和党的思想路线\n\n\n\n历史唯物主义（历史观）- 人类社会发展的一般规律 第四章两种根本对立的历史观\n社会存在和社会意识的关系问题是划分两种历史观的标准\n历史唯物主义坚持社会存在决定社会意识，把社会历史发展的根源、动力和决定性力量归结为物质和经济因素的\n社会存在与社会意识辩证关系原理\n社会存在及其在社会发展中的作用\n社会存在\n本质内涵：社会生活的物质方面，是社会实践和物质生活各种条件的总和\n构成要素：包括地理环境、人口要素和物质资料的生产方式\n地理环境：人类生存和发展所依赖的各种自然条件的总和。自然地理环境提供了社会生活和生产资料的来源；自然地理环境的优劣对社会发展起促进或延缓的作用。\n正确处理人与自然之间的关系。合理调节人与自然之间的物质变换。坚持人与自然和谐共生。\n人口因素则是从事生产实践活动的有生命的个人的总和。人口的数量和质量等因素对生产发展和社会进步起加速或延缓的作用。适度的人口对社会发展起加速作用。\n自然地理环境和人口因素，人类社会产生和存在的必要条件，都不能决定社会的性质和社会形态的更替\n\n\n核心要素：其中，主要是指物质资料生产方式\n生产方式：是人们为了获取物质资料而改造自然的劳动方式，是生产力和生产关系的统一。它集中体现了人类社会的物质性。\n生产方式在社会发展中起决定作用\n生产方式是人类社会赖以存在和发展的基础。\n生产方式决定了社会的结构、性质和基本面貌，决定了整个社会生活\n生产方式的变化发展，最终决定着社会历史的变化发展，决定着社会形态的更替。\n\n\n\n\n\n\n社会意识及其构成\n社会意识 社会生活的精神方面 包括政治思想、法律思想、道德、宗教、艺术、哲学和科学在内的各种社会意识形式\n社会意识的构成\n按主体分 个人意识：个人独特实践经验的反映；群体意识：一定群体（家庭、民族、阶级）\n按水平（层次）分 低：社会心理（风俗习惯）高：社会意识形式（根据有无阶级性又分社会意识形态、非社会意识形态） 政治、法律、道德、宗教、艺术、哲学和科学\n\n\n\n\n社会存在与社会意识的关系\n社会存在决定社会意识，社会意识是社会存在的反映\n社会意识具有相对独立性，在社会存在决定社会意识的前提下，社会意识一旦产生，还具有自身的能动性和独特的发展规律。\n社会意识相对独立性的表现\n社会意识与社会存在发展的\n不完全同步性：社会意识既可能落后也可能超前于社会存在；\n不平衡性：有些经济上相对落后的国家，社会意识某些方面却可以领先于经济上先进的国家，反之也成立。\n\n\n社会意识\n横向：内部各种形式之间的相互影响\n纵向：各自具有的历史继承性。\n\n\n社会意识对社会存在具有能动的反作用。（相对独立性最突出、最重要的表现）\n\n\n\n\n这一原理理论意义和实践意义\n理论意义\n唯物史观对历史观基本问题的科学回答，宣告了唯心史观的彻底破产。\n两个划分 从社会生活的各种领域中划分出经济领域，从一切社会关系中划分出生产关系\n生产关系是其余一切关系的基本的、原始的关系\n\n\n两个归结：将一切社会关系归结于生产关系，将生产关系归结于生产力发展的髙度\n\n\n\n\n实践意义\n先进文化为社会发展提供 思想保证&#x2F;精神动力&#x2F;凝聚力量&#x2F;智力支持\n\n\n\n\n\n\n\n\n\n\n\n人类社会发展的基本规律\n生产力与生产关系的矛盾运动及其规律\n\n生产力\n\n人类征服自然和改造自然，获得物质生活资料的客观能力，揭示了人与自然的关系\n实体性因素： \n劳动者 主导作用，生产力的首要因素\n劳动资料 生产工具是标志生产力水平的客观尺度，是划分社会经济时期的物质标志\n劳动对象 指劳动者在生产过程中加工的一切对象\n\n\n渗透性因素：科学技术是第一生产力\n\n\n生产关系：是人们在物质生产过程中形成的人与人之间的经济关系。生产关系是人们全部社会关系中最本质、最基本的关系\n\n生产关系的构成\n生产资料所有制关系\n生产中人与人之间的关系\n产品的分配关系\n\n\n生产资料所有制关系是基本的方面，构成全部生产关系的基础（生产资料私有制、公有制）\n\n\n生产关系一定要适合生产力状况规律\n\n第一，生产力决定生产关系。\n第二，生产关系反作用于生产力。\n第三，生产力和生产关系的相互作用构成了二者的矛盾运动，生产关系对生产力是由基本适合到基本不适合，再到新的基础上的基本适合循环往复的过程，每一个矛盾运动过程都使社会发展到高一级的程度，表现出生产关系一定要适合生产力状况的趋势\n\n\n正确认识这一规律的意义\n\n理论意义：第一次科学地确立了生产力发展是“社会进步的最高标准”。\n实践意义：是马克思主义政党制定方针和政策的重要依据。\n\n\n\n\n经济基础与上层建筑的矛盾运动及其规律\n\n经济基础：与社会生产力一定发展阶段相适应的（占主导地位的）生产关系的总和。\n其实质是社会一定发展阶段上的基本经济制度\n与经济体制有内在联系\n\n\n上层建筑：建立在一定社会经济基础之上的政治法律制度及其设施，以及与之相应的社会意识形态的总和。\n政治上层建筑，包括政治法律制度及其设施，如军队、警察、法庭、监狱、政治机构等；\n观念上层建筑（思想上层建筑），即社会意识形态，如政治、法律、艺术、道德、宗教、哲学等。\n政治上层建筑居主导地位，国家政权是核心。\n国家是阶级矛盾矛盾不可调和的产物。\n其实质是一个阶级统治另一个阶级的暴力工具。\n\n\n\n\n经济基础与上层建筑的矛盾运动及其规律\n第一，经济基础决定上层建筑。\n第二，上层建筑对经济基础的反作用。\n服务方向有助于自身经济基础的建立并保护其发展\n服务方式通过对社会物质生活和精神生活的控制\n服务效果反作用的性质取决于它所服务的经济基础的性质\n\n\n第三，经济基础和上层建筑的相互作用构成了它们之间的矛盾运动，把社会形态不断从低级推向高级的发展阶段\n\n\n方法论意义：这一规律对于我们进行社会主义政治体制改革和建设社会主义精神文明具有重要的指导意义\n\n\n\n社会形态更替的一般规律及特殊形式\n社会形态：同生产力发展的一定阶段相适应的经济基础和上层建筑的统一体。经济基础是社会的“骨骼系统”，上层建筑是社会的“血肉系统”\n社会形态更替的统一性；根据生产关系的不同性质，社会形态依次更替为原始社会、奴隶社会、封建社会、资本主义社会和共产主义社会\n社会发展道路的多样性；各个国家和民族历史发展的特殊性\n社会形态更替的必然性与人们的历史选择性\n第一，社会发展的客观必然性构成了一定历史阶段社会发展的基本趋势，为人们的历史选择提供了基础、范围和可能性空间。\n第二，社会形态更替的过程也是一个合目的性与合规律性相统一的过程。\n人们的历史选择性，归根结底是人民群众的选择性。\n\n\n社会形态更替的前进性与曲折性\n\n社会历史发展的动力系统\n社会基本矛盾是社会发展的根本动力\n\n生产力和生产关系的矛盾、经济基础和上层建筑的矛盾构成人类社会的基本矛盾\n根本动力：\n第一，生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量\n第二，社会基本矛盾特别是生产力和生产关系的矛盾，是“一切历史冲突的根源”，决定着社会中其他矛盾的存在和发展。\n第三，社会基本矛盾具有不同的表现形式和解决方式，并从根本上影响和促进社会形态的变化和发展。无论是阶级斗争、社会革命还是改革，其根源都是社会基本矛盾\n\n\n社会主要矛盾在历史发展中的作用\n事物的性质主要的是由主要矛盾的主要方面决定的\n\n\n\n\n阶级斗争是阶级社会发展的直接动力\n\n阶级是一个历史范畴，也是一个经济范畴，还是一个社会范畴\n阶级是在一定社会生产关系中处于不同经济地位的社会集团，其中一个集团能够占有另一个集团的劳动\n阶级斗争的根源是物质利益的根本对立\n阶级斗争推动社会发展的作用，突出地表现在社会形态更替的质变过程中\n\n\n社会革命的实质、根源及作用\n\n广义 社会基本矛盾运动基础上的社会生活的全面变革\n狭义 社会革命主要是指社会形态的变更\n革命的根本问题是政权问题。社会基本矛盾尖锐化是革命的根源。\n\n\n改革的实质及改革在社会发展中的作用\n\n改革的实质\n改革是同一种社会形态发展过程中的量变，通过调整、变革不适合生产力发展要求的生产关系和上层建筑的某些部分和环节，实现社会形态的自我发展和自我完善*\n\n\n改革的作用\n改革在一定程度上解决社会基本矛盾，促进生产力的发展，推动社会进步的有效途径和手段\n\n\n\n\n科学技术在社会发展中的作用以及科学技术作用的两重性\n\n科学：对客观世界的认识，是反映客观事实和客观规律的知识体系及其相关活动。科学主要分为自然科学、社会科学和思维科学。\n技术：生产技术，即人类改造自然、进行生产的方法与手段。\n作用\n科学技术革命是推动经济和社会发展的强大杠杆\n第一，科学技术的发展极大地促进了社会生产方式的变革。\n改变了社会生产力的构成因素。劳动力结构向智能化发展；\n劳动方式由机械自动化走向智能自动化的根本性变革。\n改变了社会经济结构，特别是产业结构发生变革。\n\n\n第二，科学技术的发展推动了生活方式的变革。\n提高了人们的物质生活条件和精神生活质量，改变了人们的消费方式、活动方式、交往方式等，为人的全面发展创造了条件\n\n\n第三，科学技术的发展引起了思维方式的变革。\n通过影响思维主体、思维客体和思维工具，引起了思维方式的变革\n\n\n\n\n是人类社会进步的重要标志。\n\n\n科学技术社会作用具有两重性，其对积极作用是主要的、基本的方面\n一是对自然规律和人与自然关系认识不够，缺乏对消极后果强有力的控制手段；\n二是在一定程度上，与社会制度有关。\n\n\n\n\n\n人民群众及个人在历史发展中的作用\n两种历史观在历史创造者问题上的根本对立\n\n唯心史观与唯物史观表现为英雄史观与群众史观的根本对立\n\n\n唯物史观考察历史创造者的原则\n\n首先，唯物史观立足于现实的人及其本质来把握历史的创造者。\n从人的生存与发展的基础来看，劳动是最基本的实践活动，也是人类最基本的存在方式\n从人与人之间的关系来看，人的现实本质是一切社会关系的总和，人的本质属性是社会属性；人的本质属性表现在各种社会关系中。\n其次，唯物史观立足于整体的社会历史过程来探究谁是历史的创造者。\n再次，唯物史观从社会历史发展的必然性入手来考察和说明谁是历史的创造者。\n最后，唯物史观从人与历史关系的不同层次上考察谁是历史的创造者。人与历史的关系具有类与历史、群体与历史、个体与历史三层关系。\n\n\n人民群众在创造历史过程中的决定作用\n\n人民群众，推动社会历史发展的社会大多数成员的总和。\n人民群众本身也是个历史范畴；（不同阶段性质不同）\n劳动群众始终是人民群众最稳定的主体。\n\n\n人民群众是推动历史前进的决定力量\n是社会物质财富的创造者。\n是社会精神财富的创造者。\n是社会变革的决定力量。\n\n\n人民群众创造历史的制约性：\n创造活动总是受着一定历史时期的经济、政治和思想文化条件的制约\n\n\n群众观点：\n第一，坚信人民群众自己解放自己的观点。\n第二，全心全意为人民服务的观点。\n第三，一切向人民群众负责的观点。\n第四，虚心向人民群众学习的观点。\n\n\n群众路线：\n一切为了群众，一切依靠群众 是党的政治路线、组织路线；\n从群众中来，到群众中去 是党的领导方法和工作方法。\n一是领导和群众相结合，二是一般号召和个别指导相结合。\n\n\n\n\n个人在社会历史发展中的作用\n\n个人、历史人物、杰出人物、无产阶级领袖\n根据其在社会历史发展中作用的大小，个人可以区分为普通个人和历史人物。历史人物是指在社会历史发展中起过重大影响的人物\n历史人物依据其在历史发展中作用的性质，又可区分为正面的历史人物与反面的历史人物，前者被称之为杰出人物\n\n\n评价历史人物的科学方法\n第一，评价历史人物必须坚持历史分析方法。对历史人物的是非功过进行具体的、全面的考察。\n第二，在阶级社会里，评价历史人物必须坚持阶级分析方法。\n\n\n习近平关于运用历史唯物主义方法评价历史人物的论述\n无产阶级领袖不同于一般的杰出人物，他们所代表的是历史上最革命、最先进的阶级，他们在革命建设中发挥了重要作用；无产阶级领袖也会犯错误\n评价无产阶级领袖，同样应坚持历史分析方法和阶级分析\n\n\n\n\n\n考点\n26.两种根本对立的社会历史观：唯物史观与唯心史观的对立\n27.社会存在与社会意识辩证关系原理\n28.生产关系一定要适合生产力状况的规律\n29.上层建筑一定要适合经济基础状况的规律\n30.社会形态更替的一般规律及特殊形式\n31.社会历史发展的动力\n32.人民群众及个人在历史发展中的作用\n\n政治经济学（62&#x2F;3-6）第五六章资本主义的本质及规律商品经济和价值规律（劳动价值论）商品经济产生的历史条件\n商品经济是以交换为目的而进行生产的经济形式，是商品生产和商品流通的统一\n产生条件\n一是社会分工的出现，这是商品生产产生的前提条件；\n二是生产资料和劳动产品分属于不同的所有者，这是商品生产和商品经济产生的决定性条件。\n\n\n\n商品的二因素：价值和使用价值\n商品定义：商品是用来交换的能满足人们某种需要的劳动产品\n商品的使用价值和价值是商品的二因素\n使用价值 自然属性 有用性\n价值 社会属性（本质属性） 价格 交换价值外在表现\n\n\n\n劳动二重性：抽象劳动和具体劳动\n具体劳动：生产一定使用价值的具体形式的劳动，它是劳动的自然属性\n抽象劳动：撇开一切具体形式的无差别的一般人类劳动，它是劳动的社会属性。\n关系：二者是同一劳动的两个方面，它们在时间上和空间上是统一的。具体劳动是劳动的自然属性；而抽象劳动是劳动的社会属性。\n劳动的二重性决定了商品的二因素\n\n商品的价值量的决定以及与劳动生产率的关系（没考过，关注）\n商品的价值量，即凝结在商品中的劳动的量。\n商品的价值量大小取决于生产该商品所耗费的社会必要劳动时间。\n社会必要劳动时间：是在现有的社会正常的生产条件下，在社会平均的劳动熟练程度和劳动强度下制造某种使用价值所需要的劳动时间\n形成商品价值量的社会必要劳动时间，是以简单劳动为尺度来计量的。同类商品生产者的竞争中实现的。\n\n\n商品的价值量与生产商品所耗费的劳动时间成正比，与劳动生产率成反比\n影响劳动生产率的因素\n劳动者的平均熟练程度\n科学技术的发展程度及其在生产中的应用\n生产过程的社会结合\n生产资料的规模和效能以及自然条件\n\n\n\n价值形式的发展与货币的产生、本质和职能\n货币是固定充当一般等价物的特殊商品，它体现着商品生产者之间的社会关系。\n商品价值形式的发展 \n简单的或偶然的价值形式\n总和的或扩大的价值形式\n一般价值形式\n货币形式\n\n\n货币的职能 价值尺度（一手交钱，一手交货）、流通手段、贮藏手段、支付手段（赊购赊销、清偿债务、租金缴纳）、世界货币\n货币的作用\n随着货币的产生，商品内在的使用价值和价值的矛盾发展成为外在的商品和货币的矛盾\n货币的出现有利于解决商品交换的困难，促进了商品经济的发展\n货币的出现没有也不可能解决商品经济的基本矛盾，即私人劳动和社会劳动的矛盾，反而使矛盾更加扩大和加深了\n\n\n\n价值规律及其作用（5年内没考过，关注）\n内容：商品的价值量由生产商品的社会必要劳动时间决定；商品交换以商品的价值量为基础，实行等价交换\n形式：商品的价格围绕价值自发波动。（供求关系）\n作用：\n积极作用\n自发地调节生产资料和劳动力在社会各部门的分配比例\n自发地刺激社会生产力的发展\n自发地调节社会收入的分配\n\n\n消极作用\n可能导致垄断的发生，阻碍技术进步\n可能引起商品生产者两极分化\n可能出现社会生产的比例失调，造成社会资源的浪费\n\n\n\n\n\n马克思劳动价值论的意义以及科学认识马克思劳动价值论\n理论意义和现实意义\n第一，马克思的劳动价值论为剩余价值学说的创立奠定了基础；是“理解政治经济学的枢纽”。（2018&#x2F;4），马克思劳动价值论揭示了私有制条件下商品经济的基本矛盾，为从物与物的关系背后揭示人与人的关系提供了理论依据。\n第二，这对我们科学认识商品经济的本质，正确理解商品经济的运动规律及其影响，清除商品拜物教和货币拜物教观念，具有十分重要的理论意义和现实意义。\n第三，这一理论对于我国深化经济体制改革，完善社会主义市场经济体制，实现社会主义现代化建设的宏伟目标，具有重要的现实意义。\n\n\n科学认识马克思劳动价值论（没考过，关注）\n第一，深化对创造价值的劳动的认识，对生产性劳动作出新的界定。应充分肯定服务性劳动也是创造价值的劳动\n第二，深化对科技人员，经营管理人员在社会生产和价值创造中所起作用的认识。\n第三，深化对价值创造与价值分配关系的认识。价值创造属于生产领域的问题，而价值分配是属于分配领域的问题。价值创造是价值分配的前提和基础，但价值分配又不仅仅取决于价值创造，价值分配首先是由生产资料所有制关系决定的。\n\n\n\n资本主义经济制度的本质（剩余价值论）前资本主义社会形态的演进和更替\n前资本主义社会形态的演进和更替\n社会形态  生产工具\n原始社会  石器\n奴隶社会  金属工具\n封建社会  封建主占有土地等生产资料和不完全占有农民\n\n\n\n资本主义生产关系的产生\n资本主义生产关系产生的基本途径\n一是从小商品经济分化出来的；\n二是从商人和高利贷者转化而成。\n\n\n资本主义生产关系产生的经济条件：\n第一，大批自由劳动者存在，但他们没有生产资料和生活资料；\n第二，大量货币财富集中在少数人手中。\n\n\n\n资本原始积累\n资本原始积累的途径： （2017&#x2F;19）\n一是用暴力手段剥夺农民的土地。\n二是用暴力手段掠夺货币财富。\n\n\n资本原始积累的结果：\n小生产者被迫与生产资料相分离，转化为雇佣工人；\n小生产者的分散的生产资料转化为资本家集中的生产资料，转化为资本。\n\n\n资本原始积累的实质：资产阶级的发家史就是一部罪恶的掠夺史。\n\n资本主义生产方式的确立\n根本原因：封建生产关系同生产力的矛盾。\n政治条件：资产阶级大革命。\n生产力条件：大机器生产。\n\n资本主义所有制及其本质以及资本主义生产过程的两重性\n资本主义所有制及其本质：资本家与劳动者之间是资本雇佣劳动的关系。\n资本主义劳动过程的特点：\n第一，工人在资本家的监督和指挥下进行劳动；\n第二，劳动产品归资本家所有。\n\n\n资本主义生产过程的两重性：是劳动过程和价值增殖过程的统一。\n\n劳动力成为商品与货币转化为资本(剩余价值生产的前提)\n劳动力成为商品的条件\n劳动力是指人的劳动能力，是人的体力和脑力的总和。劳动力的使用即劳动。\n劳动力成为商品的条件：劳动者具有人身自由；劳动者丧失了生产资料。\n\n\n劳动力商品的特点\n劳动力的价值，是由维持和延续劳动力所必需的生活必需品的价值决定的。\n劳动力的使用价值，即劳动力商品的特殊性：\n劳动力商品的使用价值是价值的源泉，\n它在消费过程中能够创造新的价值，(-&gt;剩余价值)\n而且这个新的价值比劳动力本身的价值更大。\n\n\n\n\n货币转化为资本：劳动力成为商品为前提\n一旦货币购买的劳动力能够带来超过自身价值的价值，即带来剩余价值，货币也就变成了资本，它反映了资本家和雇佣工人之间剥削与被剥削关系\n\n\n\n生产剩余价值是资本主义生产方式的绝对规律\n剩余价值的实质\n雇佣工人创造的并被资本家无偿占有的超过劳动力价值的那部分价值，体现了资本家与雇佣工人之间剥削与被剥削的关系\n剩余价值的唯一来源是雇佣工人的剩余劳动\n价值增殖过程，即剩余价值的生产过程。\n在价值增殖过程中，雇佣工人的劳动分为必要劳动时间和剩余劳动时间，用于再生产劳动力的价值和无偿地为资本家生产剩余价值。\n\n\n\n\n资本、不变资本和可变资本的区分\n资本：可以带来剩余价值的价值。\n依据资本在价值增殖过程中所起的不同作用：\n不变资本（C）：是以生产资料形态存在的资本。—— 机器、厂房、原材料，等等\n可变资本（V）：用于购买劳动力的那部分资本。\n\n\n区分不变资本和可变资本的意义。\n一是揭示了剩余价值产生的真正来源，即剩余价值的真正源泉是可变资本。它表明，雇佣劳动者的剩余劳动是剩余价值产生的唯一源泉。\n二是为反映资本家对雇佣劳动的剥削程度提供了科学依据。资本家对工人的剥削程度，可以用剩余价值率表示。\n剩余价值率（m′）：&#x3D; 剩余价值（m）&#x2F;可变资本（v ）  &#x3D; 剩余劳动时间&#x2F;必要劳动时间\n\n\n\n\n剩余价值生产理论\n绝对剩余价值生产：是指在必要劳动时间不变的条件下，由于延长工作日，从而相应延长剩余劳动时间而进行的剩余价值生产\n相对剩余价值生产：是指在工作日长度不变的条件下，通过缩短必要劳动时间，而相对延长剩余劳动时间的方法生产的剩余价值。\n超额剩余价值：个别资本家提高劳动生产率，使自己商品的个别价值低于社会价值而得到的更多的剩余价值。\n超额剩余价值是暂时的，其必然导致整个社会劳动生产率的提高，为资本家阶级普遍带来相对剩余价值。\n\n\n生产自动化条件下剩余价值的来源\n生产自动化是资本家获取超额剩余价值的手段，技术和科学本身不能创造剩余价值\n雇佣工人的剩余劳动是剩余价值的唯一源泉\n\n\n\n\n资本积累理论（剩余价值积累理论）\n简单再生产：物质资料再生产和资本主义生产关系再生产的统一\n资本主义再生产的特点是扩大再生产\n2个源泉\n资本积累是资本主义扩大再生产的源泉\n剩余价值是资本积累的源泉。\n资本积累规模的大小取决于 资本家对工人的剥削程度；劳动生产率的高低；所用资本和所费资本之间的差额；资本家垫付资本的大小\n\n\n资本有机构成 由资本的技术构成决定并反映技术构成变化的资本价值构成\n资本技术构成（自然形式、物质形态、实物形态） （由生产的技术水平所决定的）生产资料与劳动力之间的比例\n资本价值构成：从价值形式看，不变资本与可变资本价值之间的比例。\n\n\n在资本主义生产过程中，资本有机构成的提高是一般趋势。\n生产唯一动机：通过改进技术、提高劳动生产率，追求更多的剩余价值。\n扩大生产规模：通过资本集聚和资本集中。\n资本集聚：个别资本家通过剩余价值资本化来增大资本的总量。\n资本集中：个别资本家通过结合而形成较大的资本。竞争和信用是资本集中最强有力的杠杆\n资本积累是资本集聚的基础，资本集聚是资本积累的直接结果\n\n\n\n\n资本有机构成提高—— 其结果不可避免地造成大量工人失业，形成相对过剩人口\n之所以是相对的，是由于它不为资本价值增殖所需要\n形式：流动的、潜伏的、停滞的过剩人口\n经常性的庞大的失业人口的存在，是资本主义的痼疾\n\n\n资本积累的历史趋势\n资本主义制度的必然灭亡和社会主义制度的必然胜利\n\n\n\n\n资本的循环周转与再生产(剩余价值流通理论)\n循环\n产业资本循环的三个阶段及三种职能形式\n第一阶段  购买阶段（生产资料和劳动力）  货币资本\n第二阶段  生产阶段（生产资料和劳动力按一定比例） 生产资本\n第三阶段  销售阶段（转化为货币资本） 商品资本\n\n\n产业资本连续循环的条件：\n产业资本的三种职能形式在空间上同时并存；在时间上继起。\n\n\n周转\n资本周转及其速度：资本周转越快，在一定时期内带来的剩余价值就越多。\n影响资本周转快慢的关键因素\n一是资本周转的时间；（没考过）\n资本周转时间\n生产时间 劳动时间 自然力作用时间 生产资料储备时间 正常停工时间\n流通时间 购买时间 销售时间\n\n\n\n\n二是生产资本的固定资本和流动资本的构成。加快流动资本的周转速度\n固定资本 一次投入、多次使用 价值多次逐渐收回\n流动资本 一次投入、一次使用 价值一次全部收回\n\n\n\n\n\n\n再生产\n社会再生产的核心问题是社会总产品的实现问题，即社会总产品的价值补偿和实物补偿问题\n前提：价值补偿，是指社会总产品各个组成部分的价值，如何通过商品的出售以货币形式收回，用以补偿生产过程消耗的预付的不变资本和可变资本，并且还要获得剩余价值，以便继续预付资本进行再生产。\n关键：实物补偿，是指社会总产品的各个组成部分通过出售转化为货币形式以后，如何重新买到新的生产资料和消费资料，补偿或替换消耗了的生产资料和消费资料。\n\n\n社会总产品的实现，是指社会总产品通过销售，取得货币，实现了价值和剩余价值。\n社会再生产的实现条件\n两大部类，在规模和结构上保持一定的比例关系\n第一部类（Ⅰ）由生产资料的部门所构成，其产品进入生产领域\n第二部类（Ⅱ），由生产消费资料的部门所构成，其产品进入生活消费资料\n两大部类失衡，严重后果导致经济危机的爆发\n\n\n\n\n\n\n\n\n工资与剩余价值的分配（剩余价值分配理论）\n工人的工资：是劳动力的价值或价格\n当剩余价值被看作是全都预付资本的产物或增加额时，便取得了利润的形态\n剩余价值是利润的本质，利润是剩余价值的转化形式。\n两者是内容和形式的关系\n\n\n利润形态歪曲了剩余价值的真正来源，掩盖了资本主义剥削的关系\n\n\n利润平均化\n不同生产部门的利润率是不同的，其结果必然是各部门的利润率趋于平均化\n利润转化为平均利润，价值也就转化为生产价格\n商品不再以价值而是以生产价格为基础进行交换，市场价格的变动不再以价值为中心，而是以生产价格为中心\n生产价格 &#x3D; （2017&#x2F;3）生产成本（不变资本+可变资本）+平均利润\n\n\n剩余价值的分配：产业资本(产业利润)、商业资本(商业利润)、银行资本(银行利润)、土地资本(地租)\n\n\n\n\n马克思剩余价值理论的意义\n剩余价值理论是马克思主义经济理论的基石\n由于唯物史观和剩余价值的发现，社会主义由空想变为科学\n\n\n\n资本主义的基本矛盾与经济危机\n资本主义的基本矛盾\n私人劳动与社会劳动的矛盾构成私有制商品经济的基本矛盾\n生产资料资本主义私人占有和生产社会化之间的矛盾，是资本主义的基本矛盾，是生产力和生产关系之间的矛盾在资本主义社会的具体体现\n资本主义越发展，生产社会化的程度越高，资本、生产资料、劳动产品就越来越集中在少数资本家手中，资本主义基本矛盾尖锐化不可避免\n\n\n资本主义经济危机的实质、根源、具体表现和周期性\n本质特征：生产相对过剩。\n相对于劳动人民有支付能力的需求来说社会生产的商品显得过剩，而不是与劳动人民的实际需要相比较的绝对过剩\n\n\n根本原因：资本主义的基本矛盾\n具体表现\n第一，生产无限扩大的趋势和劳动人民支付能力相对缩小的矛盾。\n第二，个别企业内部生产的有组织性和整个社会生产的无政府状态之间的矛盾。\n\n\n主要特点：呈现出“危机——萧条——复苏——高涨”周期性的特点。其中，危机阶段是基本阶段\n主要作用：既是资本主义基本矛盾尖锐化的产物，同时又是这一矛盾在资本主义范围内暂时的、强制性的解决生产和消费暂时平衡的形式\n\n\n\n资本主义的政治制度和意识形态（点到为止）资本主义政治制度及其本质\n资本主义国家的职能和本质\n资本主义国家的职能是以服务于资本主义制度和资产阶级利益为根本内容。\n资本主义国家的对内职能主要是政治统治的职能。此外，国家还具有社会公共管理职能。\n资本主义国家的对外职能主要表现为国际交往与维护国家安全和利益的职能。\n资本主义国家的本质是资产阶级进行政治统治的工具。\n\n\n资本主义政治制度\n资本主义政治制度包括民主与法制制度、政权组织形式、选举制度、政党制度等\n资本主义政治制度的本质是为资产阶级服务的，是服从于资产阶级进行统治和压迫需要的政治工具-资本主义政治制度的进步作用和局限性\n进步作用\n第一，资本主义政治制度在战胜封建社会，保护、促进、完善资本主义生产方式方- 面起着重要作用。\n第二，人们群众享有了比在封建社会专制主义条件下更多的社会政治自由，促进了- 人类的发展。\n第三，资本主义政治制度在其历史发展进程中，积累了相当丰富的政治统治和社会- 管理经验，对于社会进步具有积极意义。\n\n\n局限性\n第一，资本主义的民主是金钱操纵下的民主，实际是资产阶级精英统治下的民主；\n第二，法律名义上的平等掩盖着事实上的不平等；\n第三，资本主义国家的政党制是一种维护资产阶级统治的政治制度。\n第四，政党恶斗相互掣肘，决策效率低下，激化社会矛盾。\n\n\n\n\n\n资本主义意识形态及其本质\n资本主义意识形态是在反对封建专制主义和宗教神学中形成的\n资本主义意识形态的本质：\n资本主义意识形态是在资本主义国家中占统治地位的、反映了作为统治阶级的资产阶级的利益和要求的各种思想理论和观念的总和。\n\n\n对于资本主义的意识形态，应该历史地、辩证地来分析。\n\n考点33. 商品经济产生的历史条件34. 商品的二因素和生产商品的劳动二重性\n商品经济的产生：分工；分属不同的所有者（2121&#x2F;19）\n商品二因素：价值和使用价值(2013&#x2F;3、2012&#x2F;19)\n劳动二重性：抽象劳动和具体劳动\n\n35. 商品价值量的决定以及与劳动生产率的关系(2020&#x2F;3)36. 价值规律及其作用：商品经济的基本规律37. 马克思劳动价值论的意义以及科学认识马克思劳动价值论38. 前资本主义社会形态的演进与资本主义生产关系的产生39. 资本的原始积累与资本主义生产方式的确立40. 资本主义所有制的本质以及资本主义生产过程的特点41. 剩余价值生产的前提：劳动力成为商品与货币转化为资本42. 生产剩余价值是资本主义生产方式的绝对规律43. 资本积累理论：简单再生产与扩大再生产44. 资本的循环周转与再生产45. 工资与剩余价值的分配46. 马克思剩余价值理论的意义47. 资本主义基本矛盾的形成及其尖锐化与资本主义经济危机理论经济危机48. 资本主义的政治制度核心、本质、作用49. 资本主义意识形态的形成及其本质资本主义的发展及其趋势垄断资本主义的形成与发展垄断的形成：资本主义从自由竞争到垄断\n私人垄断资本主义\n资本主义发展的两个阶段：自由资本主义和垄断资本主义\n19世纪70年代以前。自由竞争阶段，主要依靠市场机制调节经济，政府对经济活动基本采取“自由放任”政策\n垄断资本主义发展的两种形式：私人垄断资本主义和国家垄断资本主义\n19世纪末20世纪初，垄断取代自由竞争在资本主义经济中占据统治地位\n\n\n生产集中与资本集中到一定阶段必然引起垄断\n垄断的目的：为了获得高额利润，对商品的生产和销售进行操纵与控制\n垄断产生的原因： 第一，获得高额利润；第二，避免两败俱伤；第三，生产高度集中，少数大企业自然占据垄断地位。  垄断组织：最简单的、初级的垄断组织形式是短期价格协定。常见的垄断组织有卡特尔、辛迪加、托拉斯和康采恩等\n\n\n垄断条件下的竞争：规模大、时间长、手段残酷、程度更加激烈，具有更大的破坏性\n垄断资本主义阶段存在竞争的主要原因：(没考过)\n一是垄断没有消除产生竞争的经济条件。\n二是垄断必须通过竞争来维持。\n三是不存在囊括一切部门、一切社会生产的绝对垄断。\n\n\n垄断条件下竞争的新特点\n自由资本主义  利润或超额利润  经济手段  经济领域、国内\n垄断资本主义  高额垄断利润  经济和非经济手段  各个领域、国外\n\n\n\n\n金融资本与金融寡头\n金融资本是由工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本。\n金融资本形成的主要途径包括金融联系、资本参与和人事参与\n\n\n金融寡头是指操纵国民经济命脉，并在实际上控制国家政权的少数垄断资本家或垄断资本家集团。\n在经济中的统治，主要是通过“参与制” ；\n在政治上对国家机器的控制主要是通过同政府的“个人联合” 。\n在文化上通过建立政策咨询机构，掌握新闻科教文化等上层建筑的各个领域，以左右国家的内政外交与社会生活。\n\n\n\n\n垄断资本的实质在于获取垄断利润\n垄断利润的来源\n第一，来自对本国无产阶级和其他劳动人民剥削的加强；\n第二，由于垄断资本可以通过垄断高价和垄断低价来控制市场，使得它能获得一些其他企业特别是非垄断企业的利润；\n第三，通过加强对其他国家劳动人民的剥削和掠夺从国外获取利润；\n第四，通过资本主义国家政权进行有利于垄断资本的再分配，从而将劳动人民创造的国民收入的一部分变成垄断资本的收入。\n\n\n垄断利润主要是通过垄断组织制定的垄断价格来实现的 垄断价格&#x3D;成本价格+平均利润+垄断利润\n包括垄断高价和垄断低价两种形式\n\n\n\n\n国家垄断资本主义\n国家垄断资本主义是国家政权和私人垄断资本融合在一起的垄断资本主义。\n国家垄断资本主义的主要形式、\n一是国家所有并直接经营的企业。\n二是国家与私人共有、合营企业。\n三是国家通过多种形式参与私人垄断资本的再生产过程，包括国家向私人垄断企业订货、提供补贴等。\n四是宏观调节。国家运用财政政策、货币政策等经济手段，对社会总供求进行调节。以实现经济快速增长、充分就业、物价稳定和国际收支平衡的基本目标。\n五是微观规制。国家运用法律手段规范市场秩序，限制垄断，保护竞争，维护社会公众的合法权益。微观规制主要有三种类型：反托拉斯法、公共事业规制、社会经济规制\n\n\n国家垄断资本主义对资本主义经济的发展产生了积极的作用。\n一定程度上有利于社会生产力的发展\n一定范围内突破了私人垄断资本的狭隘界限，适应了社会化大生产的要求，有利于缓解资本主义生产的无政府状态\n通过国家的收入再分配手段，使劳动人民生活水平有所改善和提高\n在国家垄断资本主义的参与和干预下，各主要资本主义国家的产业升级和优化，加快了这些国家的现代化进程\n\n\n金融垄断资本的发展\n20世纪70年代初，金融自由化与金融创新是金融垄断资本得以形成和壮大的重要制度条件\n金融化程度不断提高：金融业在国民经济中的地位大幅上升，导致金融资本急剧膨胀；制造业就业人数严重减少；虚拟经济越来越脱离实体经济\n金融垄断资本的发展：一方面，促进了资本主义的发展，另一方面，造成了经济过度虚拟化，导致金融危机频发发生\n\n\n垄断资本在世界范围的扩展及其后果\n垄断资本向世界范围扩展的经济动因：\n一是将国内过剩的资本输出，以在别国谋求高额利润；\n二是将部分非要害技术转移到国外，以取得在别国的垄断优势；\n三是争夺商品销售市场；\n四是确保原材料和能源的可靠来源。\n\n\n垄断资本向世界范围扩展的基本形式：\n借贷资本输出；生产资本输出；商品资本输出。\n从输出资本的来源看 ：私人资本输出和国家资本输出。\n\n\n后果\n资本输出国\n资本输出为其带来了巨额利润，带动和扩大了商品输出，大大改善了国际收支状况，对发展中国家的经济命脉形成控制。\n\n\n资本输入国\n积极作用：吸收了资金，引进了较为先进的机器设备和工艺技术，培训了技术和管理人才，利用外贸和技术办厂，促进经济发展，扩大就业、外贸等；\n不利影响：付出了较大的经济代价和环境资源代价，冲击本国民族工业，债务加重，加大对国际资本的依赖性。\n\n\n\n\n\n\n垄断资本国际化条件下的垄断组织\n各资本主义国家的垄断组织，通过订立协议建立起国际垄断资本的联盟，即国际垄断同盟，以便在世界范围形成垄断，并在经济上瓜分世界。而协议的订立、瓜分的结果又以经济实力为后盾和基础\n国家垄断资本主义的国际联盟，是国际垄断同盟的高级形式\n此外，国家垄断资本还建立起国际经济协调机制。国际货币基金组织、世界银行和世界贸易组织。\n\n\n垄断资本主义的基本特征和实质（列宁：帝国主义的基本特征）\n五大特征：\n（1）垄断组织在经济生活中起决定作用；\n（2）在金融资本的基础上形成金融寡头的统治；\n（3）资本输出有了特別重要的意义；\n（4）瓜分世界的资本家国际垄断同盟已经形成；\n（5）最大资本主义列强已把世界上的领土分割完毕。\n\n\n集中体现了垄断资本主义的实质：—— 垄断资本凭借垄断地位，获取高额垄断利润。\n\n\n\n\n\n经济全球化：表现、动因及其后果\n经济全球化是指在生产不断发展、科技加速进歩、社会分工和国际分工不断深化、生产的社会化和国际化程度不断提高的情况下，世界各国、各地区的经济活动越来越超出一国和地区的范围而相互联系、相互依赖的一体化过程\n表现\n国际分工进一步深化。\n贸易全球化。\n金融全球化。\n企业生产经营全球化。\n\n\n经济全球化的动因\n第一，科学技术的进步和生产力的发展为经济全球化提供了坚实的物质基础和根本的推动力。\n第二，跨国公司的发展为经济全球化提供了适宜的企业组织形式；\n第三，各国经济体制的变革，为国际资本的流动、国际贸易的扩大、国际生产的大规模进行提供了适宜的体制环境和政策条件。\n\n\n经济全球化的后果\n积极效应与消极后果：\n发达国家与发展中国家之间的差距扩大；\n环境恶化与经济全球化有可能同时发生；\n各国内部和国际社会都可能出现不同程度的治理危机；\n它既为一国经济竞争力的提高提供了条件，同时也存在着对别国形成依赖的危险。\n\n\n如何使经济全球化成为世界各国“双赢”的经济全球化、世界各国平等、公平、共存的经济全球化，是国际社会共同面临的重大课题\n\n\n\n正确认识当代资本主义的新变化第二次世界大战后资本主义变化的新特点\n当代资本主义经济政治新变化：表现\n之一：生产资料所有制的变化（2017&#x2F;4）\n资本主义早期个体资本所有制;19世纪末、20世纪初私人股份资本所有制;二战以后法人资本所有制（企业法人和结构法人）\n\n\n之二：劳资关系和分配关系的变化(2013&#x2F;20)\n随着社会生产力的发展和工人阶级反抗力量的不断壮大，资本家及其代理人开始采取一些缓和劳资关系的激励制度：\n诸如职工参与决策，终身雇佣，职工持股制度，促使工人自觉地服从资本家的意志。\n此外，社会福利制度的健全也在一定程度上保证劳动者维持最低生活水平，改善了劳动者的社会状况。\n\n\n之三：社会阶层、阶级结构的变化(2022&#x2F;4、2018&#x2F;20)\n一是资本家的地位和作用发生了很大的变化。资本所有权和经营权发生分离。\n二是高级职业经理成为大公司经营活动的实际控制者。（2022&#x2F;4）\n三是知识型和服务型劳动者的数量不断增加，劳动方式发生了新变化。\n\n\n之四：经济调节机制和经济危机形态的变（2014&#x2F;20）  二战后 国家干预不断增强  20世纪70年代 强化市场、弱化政府\n去工业化和产业空心化日趋严重，产业竞争力下降；\n经济高度金融化，虚拟经济与实体经济严重脱节；\n财政严重债务化，债务危机频繁爆发；\n两极分化和社会对立加剧；\n经济增长乏力，发展活力不足，周期性危机与结构性危机交织在一起；\n金融危机频发，全球经济屡受打击。\n\n\n之五：政治制度的变化\n首先，国家行政机构的权限不断加强。\n其次，政治制度出现多元化的趋势，公民权利有所扩大。\n再次，法制建设得到重视和加强。\n最后，改良主义政党在政治舞台上的影响日益扩大。\n\n\n\n\n新变化原因\n第一，科学技术革命和生产力的发展，是资本主义变化的根本推动力量。\n第二，工人阶级争取自身权力和利益斗争的作用，是推动资本主义变化的重要力量。\n第三，社会主义制度初步显示的优越性对资本主义产生了一定影响。\n第四，主张改良主义的政党对资本主义制度的改革，对资本主义的变化发挥了重要作用。\n\n\n新变化实质\n首先，当代资本主义发生的变化从根本上说是人类社会发展一般规律和资本主义经济规律作用的结果\n其次，当代资本主义发生的变化是在资本主义制度基本框架内的变化\n\n\n\n2008年国际金融危机以来资本主义的矛盾和冲突（没考过）\n第一，经济发展“失调”\n虚拟经济与实体经济发展失衡。\n福利风险增加。\n债务负担沉重。\n\n\n第二，政治体制“失灵”\n一是西式选举往往难以选贤。\n二是政党利益可能凌驾于国家利益之上。\n三是“民主陷阱”会阻碍国家治理。\n四是传统精英政治走向衰落。\n\n\n第三，社会融合机制“失效”\n一是社会极端思潮抬头。\n二是社会流动性退化。（阶层固化）\n三是社会矛盾激化。\n\n\n\n资本主义的历史地位和发展趋势资本主义的历史地位\n首先，资本主义将科学技术转变为强大的生产力。\n其次，资本追求剩余价值的内在动力和竞争的外在压力推动了社会生产力的迅速发展。（2022&#x2F;21）\n最后，资本主义的意识形态和政治制度作为上层建筑在保护、促进和完善资本主义生产方式方面起着重要作用，从而推动了社会生产力的迅速发展。\n\n资本主义为社会主义所代替的历史必然性\n资本主义的内在矛盾决定了资本主义必然被社会主义所代替\n首先，资本主义基本矛盾“包含着现代的一切冲突的萌芽”。\n其次，资本积累推动资本主义基本矛盾不断激化并最终否定资本主义自身。\n再次，国家垄断资本主义是资本社会化的更高形式，将成为社会主义的前奏。\n最后，无产阶级必将彻底推翻资本主义和资产阶级的统治，逐步建立消灭一切阶级、确保人人得以自由发展的联合体。\n\n\n从资本主义向社会主义过渡的复杂性和长期性\n首先，任何社会形态的存在都有相对稳定性，从产生到衰亡都要经过相当长的时间跨度。\n其次，资本主义发展的不平衡性决定了过渡的长期性。\n最后，当代资本主义的发展，还显示出生产关系对生产力容纳的空间，说明资本主义为社会主义所代替尚需长期的过程\n\n\n\n考点50. 私人垄断资本主义：从自由竞争资本主义到垄断资本主义51. 国家垄断资本主义：垄断资本主义的发展：国家垄断资本主义的形成、主要形式及作用52. 经济全球化：表现、动因及其后果（2016&#x2F;20）53. 第二次世界大战后资本主义经济政治新变化的表现和特点54. 2008年国际金融危机以来资本主义的矛盾与冲突55. 资本主义为社会主义所代替的历史必然性、复杂性和长期性科学社会主义（18&#x2F;1-2）第七八章考点56．空想社会主义的产生、发展和局限性以及科学社会主义的创立（2011&#x2F;20)（2016&#x2F;20）\n空想社会主义\n积极意义： 对资本主义制度的批判，包含许多击中要害的见解；对社会主义制度的描绘，闪烁着诸多天才的火花。\n局限性： 未能揭示资本主义必然灭亡的经济根源；看不到埋藏资本主义的力量；找不到通往理想社会的现实道路。\n\n\n科学社会主义的创立\n唯物史观和剩余价值学说是科学社会主义诞生的理论基础\n1848年2月《共产党宣言》的发表，标志着科学社会主义的诞生\n\n\n\n57．第一国际和巴黎公社（2021&#x2F;21）\n第一国际\n1864年，国际工人协会（第一国际）应运而生。马克思是第一国际的灵魂。第一国际促进了马克思主义的传播和与国际工人运动的结合，初步确立了马克思主义在工人运动中的指导地位\n马克思、恩格斯在指导建立无产阶级政党过程中，阐述了各国无产阶级政党相互关系的重要原则\n一是坚持无产阶级的国际联合 第一国际只是各国工人运动联络和合作中心，而不是指挥中心。\n二是坚持各国党的独立自主和完全平等\n\n\n\n\n巴黎公社（2021&#x2F;21）\n1871年3月18日至5月28日的巴黎工人起义，以及建立起来的巴黎公社，是无产阶级革命和无产阶级专政的第一次伟大尝试\n公社取消征兵制和常备军，以人民武装国民自卫军作为唯一的武装力量。\n特别是公社采取了两项重要措施，用以防止国家机关工作人员由社会公仆变为社会主人：\n一是规定所有公职人员无论职位高低，实行全面的选举制和撤换制；\n二是取消高薪制，规定任何工作人员年薪不得超过熟练工人的工薪水平。\n\n\n巴黎公社经验\n指出无产阶级革命取得成功并保持胜利果实的首要条件是要有革命的武装；\n必须打碎旧的国家机器，建立无产阶级的新型国家；\n无产阶级政权是为人民服务的机关；\n必须建立无产阶级政党，发挥党的政治领导作用。\n\n\n\n\n\n58. 十月革命胜利与第一个社会主义国家的建立 (11&#x2F;4）(14&#x2F;21)（17&#x2F;21）\n列宁是坚定的马克思主义者。1915年，他在《论欧洲联邦口号》一文中明确指出：“经济和政治发展的不平衡是资本主义的绝对规律。由此就应得出结论：社会主义可能首先在少数甚至在单独一个资本主义国家内获得胜利。”\n在这一理论的基础上，将这一理论付诸实践，在革命形势成熟的条件下，领导了俄国十月革命。1917年11月7日（俄历10月25日），取得了十月社会主义革命的胜利。\n十月革命实现了社会主义从理想到现实的伟大飞跃，开辟了人类历史的新纪元。它从根本上推翻了人剥削人、人压迫人的制度，建立起世界上第一个人民当家作主的社会主义国家\n十月革命的胜利，特别是列宁关于殖民地半殖民地民族解放的思想：\n极大地推动了受帝国主义、殖民主义欺凌压迫的国家人民的觉醒，\n促进了民族解放力量的崛起，\n有力推动了殖民地半殖民地国家的民族解放运动，\n加速了世界范围内帝国主义殖民体系的整体瓦解，\n深刻改变了国际力量对比和世界格局。\n\n\n列宁领导的苏维埃俄国对社会主义道路的探索（2020&#x2F;4）\n进一步巩固苏维埃政权时期\n战时共产主义时期  以余粮收集制和取消商品货币关系为主要特征\n新经济政策时期 以发展商品经济为主要特征的新经济政策\n新经济政策的主要内容：\n用粮食税制取代余粮收集制，允许私人自由贸易，恢复商品货币关系，允许私人小工业企业发展，采取一些国家资本主义的形式来发展生产。（2017&#x2F;21）（2014&#x2F;21）\n新经济政策表明，标志着列宁正在探索一条符合俄国国情的建设社会主义的道路。（2011&#x2F;4）\n新经济政策的实施，扭转了国家的严重危机，活跃了苏维埃的城乡经济，发展了生产，大大加强了苏维埃的社会主义经济基础，也改善了工人、农民和其他劳动者的物质文化生活。\n\n\n特别是实行新经济政策期间，列宁对苏维埃俄国如何建设社会主义进行了深刻的理论思考\n首先，把建设社会主义作为一个长期探索、不断实践的过程。\n其次，把大力发展生产力、提高劳动生产率放在首要地位。\n再次，在多种经济成分并存的条件下，利用商品、货币和市场发展经济。\n最后，利用资本主义建设社会主义。\n\n\n列宁晚年，在口授的《日记摘录》…等被人们称为“政治遗嘱”的文章和书信中，对十月革命以来所走过的道路进行了深入的思考，提出了建设社会主义的新构想\n用合作社的形式将农民引向社会主义道路；发展大工业，实现工业化和电气化；\n学习和利用资本主义一切有价值的东西；\n进行文化革命，大力发展文化教育事业；\n进行党和国家机构的改革，努力提高干部的素质和能力；\n必须反对官僚主义，健全社会主义民主和法制；\n维护党的团结，特别是党中央领导核心的团结等。\n\n\n\n\n\n59. 社会主义在苏联一国的实践（2020&#x2F;4）以及社会主义发展到多个国家\n苏联模式的形成及其作用\n苏联模式的优势：是在特定的历史条件下产生的，曾经促进了社会主义制度的巩固和发展，推动过社会生产力的高速度发展，确保了重工业，特别是国防工业的发展\n苏联模式的弊端：集中过多，管的过死，否定市场作用，严重束缚企业和劳动者积极性。\n\n\n中国革命的胜利，是继十月革命之后20世纪最重大的事件\n\n60．社会主义在中国焕发出强大生机活力(毛中特中考)\n俄国十月革命的胜利，给中国人民送来了马克思列宁主义。1921年7月，中国共产党成立，并成为中国社会主义运动的领导力量。党领导的中国社会主义事业经过了从新民主主义革命到社会主义革命、建设、改革的发展过程，在近百年的奋斗中不断发展壮大，在21世纪焕发出勃勃生机。\n中国共产党领导人民经过28年艰苦卓绝的革命斗争，于1949年10月1日成立了新中国。毛泽东提出要以苏联的经验教训为鉴戒，独立探索适合中国国情的社会主义建设道路。\n1978年12月，党的十一届三中全会重新确立了解放思想、实事求是的思想路线，作出了进行改革开放的重大决策，开创了社会主义建设新时期。\n党的十八大以来，中国特色社会主义进入新时代，意味着近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的伟大飞跃，迎来了实现中华民族伟大复兴的光明前景；意味着科学社会主义在21世纪的中国焕发出强大生机活力，在世界上高高举起了中国特色社会主义伟大旗帜；意味着中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献了中国智慧和中国方案。\n\n61. 科学社会主义一般原则：主要内容、正确把握（2019&#x2F;21）\n科学社会主义一般原则及其主要内容\n第一，人类社会发展规律和资本主义基本矛盾是“资本主义必然灭亡、社会  主义必然胜利”的根本依据\n马克思恩格斯在《共产党宣言》中指出：“资产阶级的灭亡和无产阶级的胜  利是同样不可避免的”。这就是我们常说的资本主义必然灭亡和社会主义必  然胜利的“两个必然”。\n马克思在1859年发表的《〈政治经济学批判〉序言》中提出：“无论哪一个  社会形态，在它所能容纳的全部生产力发挥出来以前，是决不会灭亡的；而  新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是  决不会出现的。”这就是人们通常所说的“两个决不会”\n忘记“两个必然”，则会动摇社会主义必胜的信念，丧失根本、迷失方向；  忽略“两个决不会”，则可能脱离实际，犯急躁冒进的错误\n\n\n第二，无产阶级是最先进最革命的阶级，肩负着推翻资本主义旧世界、建立社会主义和共产  主义新世界的历史使命。\n第三，无产阶级革命是无产阶级进行斗争的最高形式，以建立无产阶级专政的国家为目的。\n第四，社会主义社会要在生产资料公有制基础上组织生产，以满足全体社会成员的需要为生  产的根本目的。\n第五，社会主义社会要对社会生产进行有计划的指导和调节，实行按劳分配原则。\n第六，社会主义社会要合乎自然规律地改造和利用自然，努力实现人与自然的和谐共生。\n第七，社会主义社会必须坚持科学的理论指导，大力发展社会主义先进文化。\n第八，无产阶级政党是无产阶级的先锋队，社会主义事业必须始终坚持无产阶级政党的领导。\n第九，社会主义社会要大力解放和发展生产力，逐步消灭剥削和消除两极分化，实现共同富裕和社会全面进步，并最终向共产主义社会过渡。\n\n\n正确把握科学社会主义一般原则\n第一，必须始终坚持科学社会主义一般原则，反对任何背离科学社会主义一般原则的错误倾向。\n第二，要善于把科学社会主义一般原则与本国实际相结合，创造性地回答和解决革命、建设、改革中的重大问题。\n第三，紧跟时代和实践的发展，在不断总结新鲜经验中进一步丰富和发展科学社会主义一般原则。\n\n\n\n62．经济文化相对落后国家走向社会主义的长期性（2013&#x2F;21）\n第一，生产力发展状况的制约。\n第二，经济基础和上层建筑发展状况的制约。发展公有经济，改造小农经济，建立、巩固和完善社会主义的经济基础，成为无产阶级政权的艰巨任务。经济文化相对落后必然影响社会主义民主政治、文化建设。\n第三，国际环境的严峻挑战。社会主义制度有了长足进步之后，其进攻方式则往往转变为以“和平演变”为主。其主要手段，一是通过强硬的军事、政治压力和有限制的经济、科技的合作，迫使社会主义国家屈从其经济政治发展战略的要求，并达到促使社会主义国家改变制度的目的；二是通过强大的文化机器和文化产品进行文化渗透。\n第四，马克思主义执政党对社会主义发展道路的探索和对社会主义建设规律的认识，需要一个长期的过程。\n\n63．社会主义发展道路多样性的原因（2018&#x2F;21）\n第一，各个国家的生产力发展状况和社会发展阶段决定了社会主义发展道路的具有不同的特点；\n第二，历史文化传统的差异性是造成社会主义发展道路多样性的重要条件；\n第三，时代和实践的不断发展，是造成社会主义发展道路的多样性的现实原因。\n\n64. 努力探索适合本国国情的社会主义发展道路（重要）\n第一，探索社会主义道路，必须坚持对待马克思主义的科学态度。坚持马克思主义对于研究未来社会制度的科学方法。\n第二，探索社会主义发展道路，必须从当时当地的历史条件出发，坚持“走自己的路”。立足本国国情，走自己的路，是社会主义历史经验的总结，是马克思主义的一条基本原则。\n第三，探索社会主义发展道路，必须充分吸收人类一切文明成果。\n\n65. 社会主义在实践探索中开拓前进\n在实践中开拓前进是社会主义事业发展的必然要求。\n首先，社会主义是亿万人民群众的伟大实践。\n其次，社会主义实践是一个不断探索的过程。\n再次，实践探索中出现某种曲折并不改变社会主义的前进趋势。\n最后，推进社会主义实践发展必须有开拓奋进的精神状态。\n\n\n以自信担当、开拓奋进的姿态走向社会主义光明未来。\n首先，正确认识21世纪世界社会主义的形势。东欧剧变、苏联解体使世界社会主义进入低潮时期。但苏联、东欧社会主义的失败，只是苏联模式的失败，而不是社会主义本身的失败。\n其次，充分估计中国特色社会主义的成功实践对世界社会主义发展的意义。\n最后，坚定信心，振奋精神，以开拓奋进的姿态走向社会主义光明未来。\n\n\n\n66. 预见未来社会的方法论原则\n第一，在揭示人类社会发展一般规律的基础上指明社会发展的方向。\n第二，在剖析资本主义社会旧世界中阐发未来新世界的特点。\n第三，在社会主义社会发展中不断深化对未来共产主义社会的认识\n第四，立足于揭示未来社会的一般特征，而不可能对各种细节作具体描绘。\n\n67. 共产主义社会的基本特征\n第一，物质财富极大丰富，消费资料按需分配。\n第二，社会关系高度和谐，人们精神境界极大提高。\n第三，每个人自由而全面的发展，人类从必然王国向自由王国的飞跃。\n\n68. 实现共产主义是历史发展的必然\n共产主义理想的实现是历史规律的必然要求\n实现共产主义是人类最伟大的事业\n\n69. 实现共产主义是长期的历史过程（2019&#x2F;20）\n从理论上讲马克思主义所揭示的社会形态发展与更替的规律，是只有在漫长的历史过程中才能显现出来的规律性。从资本主义到共产主义的转变，是对整个社会的根本改造，必然是长期艰难的过程。\n实现共产主义必须经历许多历史阶段。社会主义是资本主义到共产主义的过渡阶段；社会主义本身也是一个长期的历史过程；从不发达的社会主义到发达的社会主义，再到共产主义，其历史过程一定是漫长的。\n\n70. 共产主义远大理想与中国特色社会主义共同理想\n坚持远大理想与共同理想的辩证统一。\n建设中国特色社会主义是中华民族走向共产主义的必由之路。我们的远大理想和最终目标是实现共产主义；中国特色社会主义共同理想是共产主义远大理想在我国社会主义初级阶段的现实体现，是实现共产主义远大理想的必经阶段。\n\n\n正确认识和把握共产主义远大理想与中国特色社会主义共同理想的关系\n从时间上看，最终理想与阶段性理想的关系。\n从层次上看，最高纲领与最低纲领的关系。\n从范围来看，全人类理想与全体中国人民理想的关系。\n\n\n\n","slug":"master/Politics/马克思主义基本原理","date":"2022-10-21T13:19:36.000Z","categories_index":"考研政治","tags_index":"考研政治","author_index":"ChrisWood"},{"id":"a2fa7d6a410e794ddee545d12d179c3a","title":"英语词根词缀整理","content":"ag ＝to do 做 做；代理；引导-ent n. ＝person 人\n\nagent ［ag ＝to do 做；-ent n. ＝person 人→“person who does 办事者”→］\nn. person who works for another person or organization 代理人／We need some sales agents in this city. 我们在本市需要一些代售商。\n\n∇agential ［agent; -i- ; -al a. ］a. 代理人的；起媒介作用的\n\n-ency n. ＝the quality or state 表性质或状态\n\nagency［ag＝to do 做；-ency n. ＝the quality or state 表性质或状态→“the ability or place of doing business 办事的能力或场所”→］\nn.① power or force which causes a result 力量；作用\nhuman agency 人力 \n② the office of an agent; service organization 代理处；机构\nI have booked the hotel through a local travel agency. 我已经通过当地的旅行社预定了宾馆。\n\n-enda（-a表复数）n.＝things 事情\n\nagenda［ag＝to do 做；-enda（-a表复数）n.＝things 事情→“things to be done 要办的事项”→］\n [əˈdʒendə] n.list of things to be discussed or decided upon 议事日程\nThe most important item on the agenda today is what you proposed. 你的提议是今天议事日程的首项。\n\n-ile a.＝able 能…的\n\nagile［ag＝to do 做；-ile a.＝able 能…的→“able to do 能干的”→］\n[ˈædʒl] a. able to do or move quickly or easily 敏捷的；灵活的\nThe actor is as agile as a monkey. 那个演员像猴子般灵活。\n\n∇agility［agil(e); -ity］[əˈdʒɪləti] n.敏捷；灵活\n\n-ate v.＝to make or cause 使…\n\nagitate［ag＝to drive or keep moving 驱使，使运动；-it-；-ate v.＝to make or cause 使…→“to cause to keep moving steadily 引起不断的动荡”→］\n [ˈædʒɪteɪt]  v.disturb 鼓动\nThe audience were agitated by his fiery speech. 听众被他的热情的演说所鼓动。\n\n∇agitation［agitat(e); -ion n.］n.鼓动；激动；不安\n\nagitator［agitat(e); -or n.］n.鼓动者；煽动者\nact＝to do 做act［act＝to do 做→“to do what is required 做要求之事”→］\nⅠv.① do sth required 行动，做某事／We must act at once. 我们必须立刻行动。\n② function 起作用／The brakes wouldn&#39;t act. 刹车失灵。\n③ take part in a play or film 演出，扮演／Who is acting Hamlet? 谁演哈姆雷特呢？→\nⅡn.\n ① sth done 行为／No act of kindness is ever wasted. 善有善报。\n ② process of doing 行为过程，行动／The thief was caught in the act. 那小偷是当场被捉的。\n\n∇actor［act v.; -or n.］n.男演员；行动者\n\nactress［act v.; -ress n.］n.女演员\n\nacting［act v.; -ing n.］n.行为\n\nre-act［re-; act v.］v.重做，再做；重演，再演\n\noveract［over-; act v.］v.演得过于夸张\n\n-ion n.＝process or result of 表过程或结果\n\naction［act＝to do 做；-ion n.＝process or result of 表过程或结果 →］n.\n ① process of doing, or deed 行动，活动\n Actions speak louder than words. 行动比言语更有力。\n ② result of doing, or effect 作用\n This experiment shows the action of an acid on metal. 该实验说明酸对金属的作用。\n ③ charge 诉讼\n If he doesn&#39;t pay us, we have to bring an action against him. 他如果不还债，我们只好起诉他。\n\n∇actionable［action 诉讼；-able a.］a.可控诉的\n\n-ive a.＝able to ~ 会…的\n\nactive［act＝to do 做；-ive a.＝able to ~ 会…的 →］\na.able to do 活跃的，积极的，能动的\nAlthough he is over 70, he is still active. 他虽然年过70，但依然很活跃。\n\n∇activate［activ(e); -ate v.］v.使活动\n\nactivism［activ(e); -ism n.］n.［哲］能动主义；积极，活跃\n\nactivist［activ(e); -ist n.］n.活动分子，积极分子\n\nactivity［activ(e); -ity n.］n.能动性；活跃；［复］活动\n\n-al a.＝the act or fact of 表行为或事实\n\nactual［act＝to do 做；-u-；-al a.＝the act or fact of 表行为或事实 →］\na.existing in fact；real 实际的；现实的\nThe actual amount of money was not known. 实际金额尚不得而知。\n\n∇actuality［actual; -ity n.］n.事实，现存情况；现实性\n\nactualize［actual; -ize v.］v.实行，使现实化\n\n-ate v.＝to make or cause 使\n\nactuate［act＝to do 做；-u-；-ate v.＝to make or cause 使…→］\nv. cause to do 驱动，激励／He was actuated by the best of motives. 驱使他行为的动机是非常善良的。\n\n∇actuation［actuat(e); -ion n.］n.驱动，激励；开动\n\nactuator［actuat(e); -or n.］n.［机］促动器；传动机构\n\nex-＝out 出\n\nexact［ex-＝out 出；act＝to drive 驱使→“to drive out；driven out 逼出来；逼出来的”→］\nⅠv.demand or obtain by force 强求，索取\nHe exacted obedience from the residents. 他强求居民服从他。→\nⅡa.correct and without mistake 准确的；精确的\nHe is extremely exact in conduct. 他的行为一丝不苟。\n\n∇exacting［exact v.; -ing a.］a.苛求的，严厉的；强索的\n\nexaction［exact v.; -ion n.］n.强索；勒索；榨取\n\nexactitude［exact a.; -i-; -tude n.］n.精确（性）；严格，严谨\n\nre-＝back 回返\n\nreact［re-＝back 回返；act＝to do 做 →］\nv.① do or act in reply 反应\nShe was slow to react. 她反应迟钝。\n② do against 反动，反作用\nThe villagers reacted against oppression by an uprising. 村民们举行暴动反抗压迫。\n\n∇reaction［react; -ion n.］n.反应；反作用；反动\n\nreactor［react; -or n.］n.引起反应的人或物；［原］反应堆\n\nreactive［react; -ive a.］a.反应的；反动的\n\nreactant［react; -ant n.］n.［化］反应物\n\ninter-＝between 在…之间；\n\ninteract［inter-＝between 在…之间；act＝to do 做→“to do between two things 在两者之间互动”→］\nv.have an effect on each other 互相作用，互相影响\nAll things are inter-related and interacted on each other. 一切事物都是既互相联系又互相影响的。\n\n∇interaction［interact; -ion n.］n.相互作用；相互\n\ninteractive［interact; -ive a.］a.互相作用的；［计］交互的\n\ntrans-＝across or through 穿过\n\ntransact［trans-＝across or through 穿过；act＝to drive 驱使→“to drive through 使通过”→］\nv.carry on；manage 执行，办理\nHe transacted some business at bank. 他在银行处理一些事务。\n\n∇transaction［transact; -ion n.］n.办理，处理；交易，业务\n\ntransactor［transact; -or n.］n.办事人；处理者\n\nam(at)［L］&#x3D; to love 爱常用词amiable和amateur分别来自同源异形根am 和amat 。am 是拉丁动词amare 的现在词干；amat 是这个动词的分词词干，意思都相当于to love（爱）。\nable a.＝capable of 可…的\n\namiable［am＝to love 爱；-i-；-able a.＝capable of 可…的→“capable of being loved 可爱的”→］\na.lovable, or kindly 可爱的；和蔼的\n\n-eur（-er）n.＝person 人\n\namateur［amat＝to love； -eur（-er）n.＝person 人→“person who does sth for loving it（rather than for money）因爱好（而不是金钱）从事某项活动者”→］\nn.person who practices an art, sport or science for his own pleasure（艺术、体育、科学等）业余爱好者\n\n∇amateurism［amateur; -ism n.］n.业余活动\n\namateurish［amateur; -ish a.］a.不老练的\n\namicable［amic（来自同根名词amicus）&#x3D; person one loves, or friend 亲爱者，朋友；-able a.＝able to be 能当…的→“able to be one&#39;s friend 能做朋友的”→］\n a.in a friendly spirit, or peaceable 友好的；和睦的\n\n∇amicability［amicab(le); -ility n.］n.友好；和睦\n\n-our n.＝the state or result of 表状态或结果\n\namour［am＝to love 爱；-our n.＝the state or result of 表状态或结果→“loving or the result of loving 恋爱或恋爱的结果”→］\nn.① love 恋爱 \n② love affair, especially discreditable one 不正当的男女关系，桃色事件\n\n∇amorous［amo(u)r; -ous a.］a.恋爱的；多情的\n\nen- v.＝to cause to be 使\n\nenamor［en- v.＝to cause to be 使；amo(u)r n.＝love 恋爱→“to cause to be in love 使恋爱”→］\nv.inflame with love; charm 使倾心；使迷恋\n\n∇enamored［enamor; -ed a.］a.倾心的\n\namatory［amat＝to love 爱；-ory a.＝related to 与…有关的→］\na. related to loving; expressing love 恋爱的；爱慕的\n\nen-表示相反；em是am的变体\nenemy\n\nanim ［L］&#x3D; life 生命anim 是常用词animal的词根，源于拉丁名词anima ，它包含有mind（思想）、spirit（精神）、soul（灵魂）、life（生存）等与生命现象有关的概念，可以看成英语基本词life（生命）的对等词。\nanimal［anim＝life 生命；-al n.＝thing characterized by 具有…特征的东西→“thing characterized by having life 有生命的东西”→］\nn.① any creature 动物\n② any creature other than man 除人以外的任何动物\n③ any creature other than a man, bird, fish or insect 兽类\n\n∇animalism［animal; -ism n.］n.动物性；兽欲\n\nanimalize［animal; -ize v.］v.使动物化\n\n-ate a.＝having 有…的\n\nanimate［anim＝life 生命；-ate a.＝having 有…的→“having life or spirits 有生命的，有精神的”→］\nⅠa.① living 有生命的\n② full of life or spirits 生气勃勃的\nⅡv.give life to, or make alive 使活跃\n\n∇animation［animat(e) v.; -ion n.］n.活跃；生气\n\nreanimate［re-; animate v.］v.使复活；激励\n\nanimosity［anim＝life, spirit 生命，精神；-osity（-ous＋-ity）n.＝the special state or quality 表特殊的状态或性质→“special spirit 特别的精神”→“strong feeling 强烈的感情”→］\nn.strong dislike; hatred 敌意；仇恨\n\nmagnanimity［magn＝great 大；anim＝spirit 精神；-ity n.＝the quality 表性质→“the greatness of spirit or mind 精神上的大度”→］\n[ˌmæɡnəˈnɪməti] n.the spirit of being unusually generous, or generosity 宽宏大量\n\n∇magnanimous［magn; anim; -ous a.］a.宽宏大量的\n\nequanimity［equ＝even 平衡的；anim＝spirit 精神；-ity n.＝the quality 表性质→“the spirit with an even quality 平稳的精神品质”→］\n[ˌekwəˈnɪməti] n.calmness or steadiness of mind 平静；沉着；镇定\n\n∇equanimous［equ; anim; -ous a.］a.沉着的；镇定的\n\nlonganimity［long（longus）&#x3D; long 长久的；anim＝spirit 精神；-ity n.＝the quality 表性质→“the spirit with the quality of enduring long 能长久忍耐的精神品质”→］\nn.endurance; forbearance 忍耐性；坚韧性\n\n∇longanimous［long; anim; -ous a.］a.坚韧的；忍耐的\n\nunanimous［un＝one 一；anim＝mind 思想；-ous a.＝having 有…的 →］\na. having one mind or sharing the same view 思想一致的；观点统一的\n\n∇unanimity［un; anim; -ity n.］n.全体一致；无异议\n\n\nann, enn［L］&#x3D; year 年词根ann 来自拉丁名词annus ，意思为year（年）；词根enn 是ann 在添加前缀时产生的音变异体。ann 在构词中常跟着连接字母-i- 或-u- 。\nvers＝to turn 转\n\nanniversary［ann＝year 年；-i-；vers＝to turn 转；-ary n.＝thing 物→“the day connected with the turning of a year 与时间周转一年相关的日子”→］\nn.the day of a year on which sth happened 周年纪念日\n\nannual［ann＝year 年；-u-；-al a.＝of …的→］\nⅠa.of one year； yearly 一年的；每年的\nⅡn.book or pamphlet issued once a year 年鉴；年刊\n\nannals［ann＝year 年；-al n.＝thing 物；-s表复数→“many things happened in a year 一年中发生的许多事情”→］\nn.（pl.）yearly records; historical records 编年史；历史记载\n\n∇annalist［annal(s); -ist n.］n.编年史作者\n\nper-＝through\n\nperennial［per-＝through 通；enn＝year 年；-i-；-al a.＝of …的→“of the time through a year 贯通一年时间的”→］\na.① lasting through the year 长年不断的\n② everlasting 长久的\n\n∇perenniality［perennial; -ity n.］n.常年性；长久性\n\nannuity［ann＝year 年；-u-；-ity n.＝thing connected with 与…有关的事物→“money connected with one year 按一年时间计算的钱”→］\nn.① yearly allowance or income 年金；年收入\n② investment insurance which pays interest sum yearly 年金保险投资\n\n∇annuitant［annuit(y); -ant n.］n.领受年金者\n\nsuperannuate［super-＝over 超；ann＝year or age 年，年龄；-u-； -ate v.＝to cause to be 使成为→“to cause sb to be over-aged 使某人成为超龄者”→］\nv. make to retire when one is over a certain age 因超过规定年龄而令其退休\n\nannu与enni还能与表示数目的前缀构成专门表示以“年”为单位的时间的派生词。以下是常见的几个\n\nsemiannual［semi-＝half 半；annu＝year 年；-al a.＝of …的→］\na of a half year 半年的；半年一度的\n\nbiannual［bi-＝two, twice 二，两次；annu＝year 年；-al a.＝of …的→］\n [baɪˈænjuəl]a.occurring twice a year 每年两度的\n\nbiennial［bi-＝two 二；enni＝year 年；-al a.＝of …的→“of two years 两年的”→］\n [baɪˈeniəl] a.lasting two years; once every two years 持续两年的；两年一度的\n\n∇biennium［bi-; enni; -um n.］n.两年时间\n\n词缀 \nco- ＝together \ncounter- ＝against\nretro- ＝backward\n\n","slug":"master/English/英语词根词缀整理","date":"2022-10-19T23:49:39.000Z","categories_index":"","tags_index":"英语","author_index":"ChrisWood"},{"id":"2daf5b5a74686be842f9f5c6d964e1fb","title":"Nginx日志按天切割","content":"Nginx日志按天切割Nginx默认的发布不支持对日志文件按日期或者按日志量来分割，此处实现的功能：在每天凌晨00:00把前⼀天的Nginx⽇志（access.log和error.log）分别重命名为access-yyyy-mm-dd.log和log-xxxx-xx-xx.log格式，例如：access-2022-10-18.log，error-2022-10-18.log\nLinux环境脚本vim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;auto_cut_log.sh\n#!&#x2F;bin&#x2F;bash\n#Nginx⽇志⽂件所在⽬录\nLOG_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;\n#获取昨天的⽇期\nYESTERDAY&#x3D;$(date -d &quot;yesterday&quot; +%Y-%m-%d)\n#nginx服务的pid⽂件路径\nPID&#x3D;&#x2F;run&#x2F;nginx.pid\n#分割⽇志\nmv $&#123;LOG_PATH&#125;access.log $&#123;LOG_PATH&#125;access-$&#123;YESTERDAY&#125;.log\nmv $&#123;LOG_PATH&#125;error.log $&#123;LOG_PATH&#125;error-$&#123;YESTERDAY&#125;.log\n#向Nginx主进程发送USR1信号，重新打开⽇志⽂件\nkill -USR1 &#96;cat $&#123;PID&#125;&#96;\n\n\n\n\n\n\n\n\n\n有关USR1的介绍：USR是User-defined的缩写，即用户定义的,USR1通常被用来告知应用程序重载配置文件\n增加脚本文件执行权限chmod +x &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;auto_cut_log.sh\n\n添加定时任务crontab -e\n00 00 * * * &#x2F;bin&#x2F;bash &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;auto_cut_log.sh\n\n\n\n\n\n\n\n\n\n参考链接：https://blog.csdn.net/klipse/article/details/125019896\n","slug":"nginx/Nginx日志按天切割","date":"2022-10-18T08:20:26.000Z","categories_index":"Nginx","tags_index":"Nginx","author_index":"ChrisWood"},{"id":"f608ca61f1cd18e3f4abde5dcaf441ba","title":"开发环境配置","content":"开发环境配置篇nodewindowsnvm for windows\n\nGitHub地址: https://github.com/coreybutler/nvm-windows/releases推荐使用nvm-setup.exe 自动创建环境变量NVM_HOME和NVM_SYMLINK\n配置nvm settings.txt文件# 增加镜像地址\nnode_mirror: https:&#x2F;&#x2F;npmmirror.com&#x2F;mirrors&#x2F;node&#x2F;\nnpm_mirror: https:&#x2F;&#x2F;npmmirror.com&#x2F;mirrors&#x2F;npm&#x2F;\n# 或者使用其他镜像\nnode_mirror: https:&#x2F;&#x2F;registry.npmjs.org&#x2F;mirrors&#x2F;node&#x2F;\nnpm_mirror: https:&#x2F;&#x2F;registry.npmjs.org&#x2F;mirrors&#x2F;npm&#x2F;\n3.nvm 常用命令推荐nvm -h,自己列出命令行,说明都很全# 查看node版本可用列表\nnvm ls available\n# 安装具体版本\nnvm install 16.18.0\n# 使用具体版本\nnvm use 14.6.0\n# 查看已安装版本\nnvm ls\n配置npm 全局安装文件夹跟全局缓存文件夹 \n\n\n\n\n\n\n\n\n成功安装node版本后，在nvm安装目录下创建”node_global”和“node_cache”两个文件夹默认情况是不用修改，但是如果你觉得放在C盘不好，\n\n\n# 设置全局模块的安装路径\nnpm config set prefix &quot;D:\\nvm\\node_global&quot;\n# 设置缓存到node_cache文件夹\nnpm config set cache &quot;D:\\nvm\\node_cache&quot;\n# 还要把node_global路径加入到系统环境变量path中，方便直接使用命令行运行\n\n\n\n\n\n\n\n\n\n参考文章：https://www.jianshu.com/p/685e36ac2668\npythonwindowspyenv-win\n\nGitHub地址: https://github.com/pyenv-win/pyenv-win推荐直接下载源码master分支的zip包\n解压后放到需要放的位置，pyenv-win-master重命名为.pyenv\n配置环境变量:\n\n\n系统环境变量 PYENV &#x2F;path&#x2F;to&#x2F;pyenv-win（eg:”E:\\develop.pyenv\\pyenv-win”）\nPATH %PYENV%\\bin %PYENV%\\shims\n\n\npyenv 常用命令\n\n\n修改源pyenv-win文件夹下.versions_cache.xmlhttps://www.python.org/ftp/python替换为https://npm.taobao.org/mirrors/python# 查看所有pyenv可以安装的版本\npyenv install --list\n# 安装\npyenv install 3.10.7\n# 查看pyenv下所有的python安装版本\npyenv versions\n# 跳转到对应版本\npyenv local 3.9.0\n#从查看当前对应版本\npyenv version\n\n\n\n\n\n\n\n\n\n参考文章：https://baijiahao.baidu.com/s?id=1742653008854467791&amp;wfr=spider&amp;for=pc\n\n\njavawindowsJEnv-for-Windows\n\nGitHub地址: https://github.com/FelixSelter/JEnv-for-Windows下载已经打了tag的版本\n解压后放到需要放的位置\n配置环境变量:\n\n\n系统环境变量 JENV_HOME &#x2F;path&#x2F;to&#x2F;JEnv-for-Windows（eg:”E:\\develop\\JEnv-for-Windows-2.0.3”）\nPATH %JENV_HOME%\n\n\nJEnv-for-Windows 常用命令# 首先需要手动增加java版本\njenv add &lt;name&gt; &lt;path&gt;\n# 移除版本\njenv remove &lt;name&gt;\n# 查看所有添加好的java环境\njenv list\n# 全局使用\njenv change jdk17\n# 临时使用\njenv use jdk8\n# 临时使用后释放\njenv use remove\n# 文件夹下始终使用\njenv local jdk15\n# 文件夹下释放\njenv local remove\n# 使用当前java环境下的其他命令\njenv link javac\n\n","slug":"common/开发环境配置","date":"2022-10-16T02:36:44.000Z","categories_index":"","tags_index":"python node java","author_index":"ChrisWood"},{"id":"fd6db9879e8a7f6e92c3104daa24218a","title":"docker环境部署集群前后端分离项目","content":"docker环境部署集群前后端分离项目一、基础1.Docker虚拟机常用命令1.先更新软件包\nscriptyum -y update\n2.安装Docker虚拟机\nscriptyum install -y docker\n3.运行、重启、关闭Docker虚拟机\nscriptservice docker start\nservice docker start\nservice docker stop\n4.搜索镜像\nscriptdocker search 镜像名称\n5.下载镜像\nscriptdocker pull 镜像名称\n6.查看镜像\nscriptdocker images\n7.删除镜像\nscriptdocker rmi 镜像名称\n8.运行容器\nscriptdocker run 启动参数  镜像名称\n9.查看容器列表\nscriptdocker ps -a\n10.停止、挂起、恢复容器\nscriptdocker stop 容器ID\ndocker pause 容器ID\ndocker unpase 容器ID\n11.查看容器信息\nscriptdocker inspect 容器ID\n12.删除容器\nscriptdocker rm 容器ID\n13.数据卷管理\nscriptdocker volume create 数据卷名称  #创建数据卷\ndocker volume rm 数据卷名称  #删除数据卷\ndocker volume inspect 数据卷名称  #查看数据卷\n14.网络管理\nscriptdocker network ls 查看网络信息\ndocker network create --subnet&#x3D;网段 网络名称\ndocker network rm 网络名称\n15.避免VM虚拟机挂起恢复之后，Docker虚拟机断网\nscriptvi &#x2F;etc&#x2F;sysctl.conf\n文件中添加net.ipv4.ip_forward=1这个配置\nscript#重启网络服务\nsystemctl  restart network\n16.查看容器启动日志\ndocker logs 容器id&#x2F;name\n2.PXC集群1.安装PXC镜像\nscriptdocker pull percona&#x2F;percona-xtradb-cluster\n# 镜像名称太长，修改一下\ndocker tag percona&#x2F;percona-xtradb-cluster pxc\n# 删除之前的\ndocker rmi percona&#x2F;percona-xtradb-cluster\n2.创建内部网络\nscriptdocker network create --subnet&#x3D;172.18.0.0&#x2F;16 net1\n# 查看net1网段：\ndocker inspect net1\n# 如果要删除使用删除命令\ndocker network rm net1\n3.创建数据卷\n\n\n\n\n\n\n\n\n\n因为pxc不支持映射目录，所以采用映射数据卷的方式。创建数据卷叫v1，这里5个节点，所以创建5个数据卷：\nscriptdocker volume create --name v1\ndocker volume create --name v2\ndocker volume create --name v3\ndocker volume create --name v4\ndocker volume create --name v5\n# 查看v1数据卷在宿主机的位置\ndocker inspect v1\n# 删除数据卷v1\ndocker volume rm v1\n4.创建备份数据卷（用于热备份数据）\nscriptdocker volume create --name backup\n5.创建5节点的PXC集群\n\n\n\n\n\n\n\n\n\n注意，每个MySQL容器创建之后，因为要执行PXC的初始化和加入集群等工作，耐心等待1分钟左右再用客户端连接MySQL。另外，必须第1个MySQL节点启动成功，用MySQL客户端能连接上之后，再去创建其他MySQL节点。\n\n\n\n\n\n\n\n\n\n命令参数说明：端口3306，密码123456，集群名称PXC，同步数据密码123456，映射数据目录到宿主机的v1数据卷，给予最高权限，名称叫node1，网段为net1，ip指定为172.18.0.2，运行的镜像是pxc。\nscript#创建第1个MySQL节点\ndocker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -e CLUSTER_NAME&#x3D;PXC -e XTRABACKUP_PASSWORD&#x3D;123456 -v v1:&#x2F;var&#x2F;lib&#x2F;mysql -v backup:&#x2F;data --privileged --name&#x3D;node1 --net&#x3D;net1 --ip 172.18.0.2 pxc\n#创建第2个MySQL节点\ndocker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -e CLUSTER_NAME&#x3D;PXC -e XTRABACKUP_PASSWORD&#x3D;123456 -e CLUSTER_JOIN&#x3D;node1 -v v2:&#x2F;var&#x2F;lib&#x2F;mysql --privileged --name&#x3D;node2 --net&#x3D;net1 --ip 172.18.0.3 pxc\n#创建第3个MySQL节点\ndocker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -e CLUSTER_NAME&#x3D;PXC -e XTRABACKUP_PASSWORD&#x3D;123456 -e CLUSTER_JOIN&#x3D;node1 -v v3:&#x2F;var&#x2F;lib&#x2F;mysql --privileged --name&#x3D;node3 --net&#x3D;net1 --ip 172.18.0.4 pxc\n#创建第4个MySQL节点\ndocker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -e CLUSTER_NAME&#x3D;PXC -e XTRABACKUP_PASSWORD&#x3D;123456 -e CLUSTER_JOIN&#x3D;node1 -v v4:&#x2F;var&#x2F;lib&#x2F;mysql --privileged --name&#x3D;node4 --net&#x3D;net1 --ip 172.18.0.5 pxc\n#创建第5个MySQL节点\ndocker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -e CLUSTER_NAME&#x3D;PXC -e XTRABACKUP_PASSWORD&#x3D;123456 -e CLUSTER_JOIN&#x3D;node1 -v v5:&#x2F;var&#x2F;lib&#x2F;mysql --privileged --name&#x3D;node5 --net&#x3D;net1 --ip 172.18.0.6 pxc\n\n\n\n\n\n\n\n\n\n验证PXC集群: navicat或者其他工具连接5个数据库节点,在DB1中新建一个数据库一张表并插入数据，提交后，看其它四个节点是否同步。\n6.安装Haproxy镜像\nscriptdocker pull haproxy\n7.宿主机上编写Haproxy配置文件\nscriptvi &#x2F;home&#x2F;soft&#x2F;haproxy&#x2F;haproxy.cfg \n#vi &#x2F;data&#x2F;software&#x2F;haproxy&#x2F;haproxy.cfg\n配置文件如下：\nscriptglobal\n\t#工作目录\n\tchroot &#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy\n\t#日志文件，使用rsyslog服务中local5日志设备（&#x2F;var&#x2F;log&#x2F;local5），等级info\n\tlog 127.0.0.1 local5 info\n\t#守护进程运行\n\tdaemon\n\ndefaults\n\tlog\tglobal\n\tmode\thttp\n\t#日志格式\n\toption\thttplog\n\t#日志中不记录负载均衡的心跳检测记录\n\toption\tdontlognull\n    #连接超时（毫秒）\n\ttimeout connect 5000\n    #客户端超时（毫秒）\n\ttimeout client  50000\n\t#服务器超时（毫秒）\n    timeout server  50000\n\n#监控界面\t\nlisten  admin_stats\n\t#监控界面的访问的IP和端口\n\tbind  0.0.0.0:8888\n\t#访问协议\n    mode        http\n\t#URI相对地址\n    stats uri   &#x2F;dbs\n\t#统计报告格式\n    stats realm     Global\\ statistics\n\t#登陆帐户信息\n    stats auth  admin:123456\n#数据库负载均衡\nlisten  proxy-mysql\n\t#访问的IP和端口\n\tbind  0.0.0.0:3306  \n    #网络协议\n\tmode  tcp\n\t#负载均衡算法（轮询算法）\n\t#轮询算法：roundrobin\n\t#权重算法：static-rr\n\t#最少连接算法：leastconn\n\t#请求源IP算法：source \n    balance  roundrobin\n\t#日志格式\n    option  tcplog\n\t#在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测\n    option  mysql-check user haproxy\n    server  MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000  \n    server  MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000  \n\tserver  MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000 \n\tserver  MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000\n\tserver  MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000\n\t#使用keepalive检测死链\n    option  tcpka  \n\n\n\n\n\n\n\n\n\n注意：1）、option部分，记得在MySQL创建一个没有权限的用户haproxy；CREATE USER ‘haproxy‘@’%’ IDENTIFIED BY ‘’;2）、server部分，记得这里3306是容器的端口，不是宿主机的端口。\n8.创建两个Haproxy容器\nscript#创建第1个Haproxy负载均衡服务器\ndocker run -it -d -p 4001:8888 -p 4002:3306 -v &#x2F;home&#x2F;soft&#x2F;haproxy:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy --name h1 --privileged --net&#x3D;net1 --ip 172.18.0.7 haproxy\n#进入h1容器，启动Haproxy\ndocker exec -it h1 bash\nhaproxy -f &#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg\n#创建第2个Haproxy负载均衡服务器\ndocker run -it -d -p 4003:8888 -p 4004:3306 -v &#x2F;home&#x2F;soft&#x2F;haproxy:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy --name h2 --privileged --net&#x3D;net1 --ip 172.18.0.8 haproxy\n#进入h2容器，启动Haproxy\ndocker exec -it h2 bash\nhaproxy -f &#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg\n9.Haproxy容器内安装Keepalived，设置虚拟IP\n\n\n\n\n\n\n\n\n\n注意事项：云主机不支持虚拟IP，另外很多公司的网络禁止创建虚拟IP（回家创建）,还有宿主机一定要关闭防火墙和SELINUX，很多同学因为这个而失败的，切记\nscript#进入h1容器\ndocker exec -it h1 bash\n#更新软件包\napt-get update\n#安装VIM\napt-get install vim\n#安装Keepalived\napt-get install keepalived\n#编辑Keepalived配置文件（参考下方配置文件）\nvim &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf\n#启动Keepalived\nservice keepalived start\n#宿主机执行ping命令\nping 172.18.0.201\n配置文件内容如下\nscriptvrrp_instance  VI_1 &#123;\n       state  MASTER\n       interface  eth0\n       virtual_router_id  51\n       priority  100\n       advert_int  1\n       authentication &#123;\n           auth_type  PASS\n           auth_pass  123456\n       &#125;\n       virtual_ipaddress &#123;\n           172.18.0.201\n       &#125;\n   &#125;\n","slug":"docker/docker环境部署集群前后端分离项目","date":"2022-10-12T08:05:29.000Z","categories_index":"docker","tags_index":"docker","author_index":"ChrisWood"},{"id":"ab71b7b05749a5527c735a9fb6d5af98","title":"Java高并发专题-JUC线程池","content":"线程池Executor框架接口\nExecutors.newCachedThreadPool() 创建缓存线程池public class ThreadPoolExample1 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;\nExecutors.newFixedThreadPool(3) 创建定长线程池public class ThreadPoolExample2 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(3);\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;\nExecutors.newSingleThreadExecutor() 创建单线程线程池public class ThreadPoolExample3 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor();\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;\nExecutors.newScheduledThreadPool(1) 创建定长线程池，支持定时，周期性的任务执行public class ThreadPoolExample4 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ScheduledExecutorService executorService &#x3D; Executors.newScheduledThreadPool(1);\n\n        executorService.scheduleAtFixedRate(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                log.warn(&quot;schedule run&quot;);\n            &#125;\n        &#125;, 1, 3, TimeUnit.SECONDS);\n        \n&#x2F;&#x2F;        executorService.shutdown();\n\n        Timer timer &#x3D; new Timer();\n        timer.schedule(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                log.warn(&quot;timer run&quot;);\n            &#125;\n        &#125;, new Date(), 5 * 1000);\n    &#125;\n&#125;\n前面三种线程池都是直接创建ThreadPoolExecutor类的对象。ScheduledThreadPool 因为要实现定时功能，创建的是 ScheduledThreadPoolExecutor 类的对象。但 ScheduledThreadPoolExecutor 也是继承自ThreadPoolExecutor 。下面这个构造方法是参数最全的一个创建线程池的源码。&#x2F;**\n * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial\n * parameters.\n *\n * @param corePoolSize 线程池中维持的线程数量。\n *                     当线程数量不超过这个数时，即使线程处于空闲状态也不会被销毁，会一直等待任务到来。\n *                     但是如果设置 allowCoreThreadTimeOut 为 true，corePoolSize 就不再有效了。\n * @param maximumPoolSize 线程池中线程的最大数量。\n * @param keepAliveTime 当线程数量超过了 corePoolSize 时，多余的线程销毁前等待的时间。\n * @param unit keepAliveTime 的时间单位\n * @param workQueue 用来管理待执行任务的队列。\n * @param threadFactory 创建线程的工厂。\n * @param handler RejectedExecutionHandler 接口的实现对象。用于处理任务被拒绝执行的情况。\n *                被拒绝的原因可能是所有线程正在执行任务而任务队列容量又满了\n *&#x2F;\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) &#123;\n    ...\n&#125;\n\n","slug":"java/concurrent/Java高并发专题-JUC线程池","date":"2022-10-08T08:55:43.000Z","categories_index":"Java高并发,JUC","tags_index":"Java高并发,JUC","author_index":"ChrisWood"},{"id":"38ca70cafbfd87b7f0418630bd7d0ad1","title":"springboot配置文件","content":"springboot配置文件在springboot 项目中一般默认的配置文件是application.properties,但是实际项目中我们一般会使用application.yml文件\nyml文件读取顺序存放目录SpringBoot配置文件默认可以放到以下目录中，可以自动读取到：\n\n项目根目录中config目录下\n项目根目录下\n项目resources目录中config目录下\n项目的resources目录下\n\n读取顺序在不同的目录中存在多个配置文件，它的读取顺序是： 1、config&#x2F;application.properties（项目根目录中config目录下） 2、config&#x2F;application.yml3、application.properties（项目根目录下） 4、application.yml 5、resources&#x2F;config&#x2F;application.properties（项目resources目录中config目录下）6、resources&#x2F;config&#x2F;application.yml 7、resources&#x2F;application.properties（项目的resources目录下） 8、resources&#x2F;application.yml\n\n\n\n\n\n\n\n\n\n注意：1、如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。2、如果同一个配置属性，在多个配置文件都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。3、创建SpringBoot项目时，一般的配置文件放置在“项目的resources目录下\nyml文件读取方式yml文件规则\nyml文件的好处，天然的树状结构，一目了然，实质上跟properties是差不多\n不支持tab缩进\n可以使用 “-小写字母” 或 “_小写字母”来 代替 “大写字母”,如 userName 与 user-name ,user_name 含义是一样的,key: value 格式书写 key,后面跟着冒号,再后面跟着一个空格,然后是值\n\n几种数据格式的表示方式1.普通的值（数字，字符串，布尔）key: value ,如:\nage: 18\nname: zhangsan\n\n\n\n\n\n\n\n\n\n\n注意：字符串默认不用加上单引号或者双引号；“”：双引号不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi‘’：单引号会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi\n2.对象、Map（属性和值）（键值对）person:\n  age: 18\n  name: mysgk\nmap:\n  name: 刘德华\n  age: 10\n\n3.数组（List、Set）hands:\n  - left\n  - right\nlist: 列表1,列表2,列表3\nset: [ 集合1,集合2,集合3 ]\n\n读取配置的方式1.@Value直接在对应的变量上添加@Value注解即可，此时配置的key可以不与变量名相同\nserver:\n  port: 8081\n\n@Value(&quot;$&#123;server.port&#125;&quot;)\npublic String serverPort;\n\n2.@ConfigurationProperties新增一个Student类，同时添加@ConfigurationProperties注解\nstudent:\n  name: 刘德华\n  age: 40\n\n@Data\n@ConfigurationProperties(prefix &#x3D; &quot;student&quot;)\npublic class Student &#123;    \n    String name;    \n    int age;\n&#125;\n\n3.@Environment用的很少，了解即可\ntest:\n  msg: aaa\n\n@Autowired\nprivate Environment env\n\npublic static void main() &#123;\n    System.out.println(env.getProperty(&quot;test.msg&quot;));\n&#125;\n","slug":"springboot/springboot配置文件","date":"2022-10-08T07:55:43.000Z","categories_index":"springboot,springboot配置","tags_index":"springboot,springboot配置","author_index":"ChrisWood"},{"id":"e92c64341ee2ef385eda6a1d1f832be9","title":"Mysql基础","content":"Mysql常见数据库\nMYSQL：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费。\nOracle：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。\nDB2 ：IBM公司的数据库产品,收费的。常应用在银行系统中.\nSQLServer：MicroSoft 公司收费的中型的数据库。C#、.net等语言常使用。\nSyBase：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。\nSQLite：嵌入式的小型数据库，应用在手机端。\n常用数据库：MYSQL，Oracle\nSQL语句SQL分类：\n数据定义语言：简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列等。关键字：create，alter，drop等\n数据操作语言：简称DML(Data Manipulation Language)，用来对数据库中表的记录进行更新。关键字：insert，delete，update等\n数据控制语言：简称DCL(Data Control Language)，用来定义数据库的访问权限和安全级别，及创建用户\n数据查询语言：简称DQL(Data Query Language)，用来查询数据库中表的记录。关键字：select，from，where等\nint（integer） 整数类型\nbigint （long） 整数类型\ndouble 小数类型\ndecimal（m,d） 指定整数位与小数位长度的小数类型\ndate 日期类型，格式为yyyy-MM-dd，包含年月日，不包含时分秒\ndatetime 日期类型，格式为 YYYY-MM-DD HH:MM:SS，包含年月日时分秒\ntimestamp 日期类型，时间戳\nvarchar（M） 文本类型， M为0~65535之间的整数\njson 8.0以上版本支持json数据类型\n\nDDL操作语言(3%)数据库操作：database\n#创建数据库\ncreate database 数据库名;\ncreate database 数据库名 character set 字符集;\n#查看所有数据库\nshow databases;\n#查看某个数据库的定义的信息\nshow create database 数据库名;\n#删除数据库\ndrop database 数据库名;\n#查看正在使用的数据库\nselect database();\n#切换数据库\nuse 数据库名;\n\n表操作：table\n#创建表\ncreate table 表名(\n字段名 类型(长度) [约束],##[ ]代表可以省略\n字段名 类型(长度) [约束],\n&#x2F;*约束 对某列数据进行限制\n主键约束--限制某列数据既不能为空也不能重复\n唯一约束--限制某列数据不能重复\n非空约束--限制某列数据不能为空\n*&#x2F;\n...\n字段名 类型(长度) [约束]\n);\nCREATE TABLE category (\ncid INT primary key, #分类ID\ncname VARCHAR(100) #分类名称\n);\n#查看数据库中的所有表\nshow tables;\n#查看表结构\ndesc 表名;\n#删除表\ndrop table 表名;\n#修改表结构格式\n&#x2F;*添加列*&#x2F;  alter table 表名 add 列名 类型(长度) [约束];\n&#x2F;*修改列的类型长度及约束*&#x2F;  alter table 表名 modify 列名 类型(长度) 约束;\n&#x2F;*修改列名*&#x2F; alter table 表名 change 旧列名 新列名 类型(长度) 约束;\n&#x2F;*删除列*&#x2F; alter table 表名 drop 列名;#列中数据一起删除\n&#x2F;*修改表名*&#x2F;rename table 表名 to 新表名;\n&#x2F;*修改表的字符集*&#x2F;alter table 表名 character set 字符集(了解);\n\nDML操作语言(7%)#插入表记录：insert\n-- 向表中插入某些字段\ninsert into 表 (字段1,字段2,字段3..) values (值1,值2,值3..);\n-- 向表中插入所有字段,字段的顺序为创建表时的顺序 \ninsert into 表 values (值1,值2,值3..);#数值类型外其他的字段类型的值必须使用引号(建议单引号)\ninsert into 表 values (值1,值2,值3..),(值1,值2,值3..); #批量插入\ninsert into 表 values [[值1,值2,值3..],[值1,值2,值3..]]; #批量插入\n-- 涉及自增的可以这样用,自增数值会自动覆盖null\ninsert into 表 values (null,值2,值3...);\n#更新表记录：update\nupdate 表名 set 字段名&#x3D;值,字段名&#x3D;值,...;\nupdate 表名 set 字段名&#x3D;值,字段名&#x3D;值,... where 条件;\n#删除符合条件记录：delete  from 表名 [where 条件] 逐行删除,不重置主键自增,再添加数据继续用之前的主键\n#删除表中所有记录: truncate table 表名  把表也删除,重新创建新表,会重置主键自增,重新开始\ndelete from 表名 [where 条件];\n\n扩展\nshow variables like &#39;character%&#39;; #查看所有mysql的编码\nset names gbk;#临时方案 当前窗口有效\n#安装目录下修改my.ini文件，重启服务所有地方生效。\n\nSQL约束主键约束\n#设置主键约束\nfirstname int PRIMARY KEY -- 1.创建表时，在字段描述处，声明指定字段为主键\nCONSTRAINT pk_personID PRIMARY KEY (firstname,lastname)\n-- 2.创建表时，在constraint约束区域，声明指定字段为主键  格式： [constraint 名称] primary key (字段列表)\n-- 关键字constraint可以省略，如果需要为主键命名，constraint不能省略，主键名称一般没用\n-- 字段列表需要使用小括号括住，如果有多字段需要使用逗号分隔。声明两个以上字段为主键，我们称为联合主键\nALTER TABLE persons ADD PRIMARY KEY (firstname,lastname)-- 3.创建表之后，通过修改表结构，声明指定字段为主键\n\n#删除主键约束\nALTER TABLE persons DROP PRIMARY KEY;#扩展 小bug 删除主键约束之后会保留非空约束\n\n自动增长列\n&#x2F;* auto_increment（自动增长列）关键字，自动增长列类型必须是整形，自动增长列必须为键(一般是主键)。*&#x2F;\np_id int PRIMARY KEY AUTO_INCREMENT,\n#扩展：默认AUTO_INCREMENT 的开始值是 1，如果希望修改起始值，请使用下列 SQL 语法\nALTER TABLE persons AUTO_INCREMENT&#x3D;100\n#删除方式：\n#delete 一条一条删除，不清空auto_increment记录数。\n#truncate 直接将表删除，重新建表，auto_increment将置为零，从新开始。\n\n非空约束\n# NOT NULL 约束强制列不接受 NULL 值\nid_p int NOT NULL,\nlastname varchar(255) NOT NULL\n\n唯一约束\n&#x2F;*UNIQUE约束唯一标识数据库表中的每条记录.UNIQUE和PRIMARY KEY约束均为列或列集合提供了唯一性的保\n证.PRIMARY KEY拥有自动定义的UNIQUE约束.!!每个表可以有多个UNIQU约束，但是每个表只能有一个PRIMARY KEY约束。*&#x2F;\nid_p int UNIQUE, -- 1.创建表时，在字段描述处声明唯一\nCONSTRAINT 名称 UNIQUE (id_p)-- 2.创建表时，在约束区域声明唯一\nALTER TABLE persons ADD [CONSTRAINT 名称] UNIQUE (id_p)-- 3.创建表后，修改表结构，声明字段唯一\n#如果值为null,则失去了unique约束的意义\n#删除唯一约束\nALTER TABLE persons DROP INDEX 字段名&#x2F;唯一约束名;\n\n默认约束\n#方式一,创建表,列数据类型后面 default &#39;默认值&#39;\ncity varchar(20) default &#39;北京&#39;\n#方式二,修改表结构\nalter table persons modify city varchar(20) default &#39;北京&#39;\n#删除默认约束\nalter table persons modify city varchar(20)\n\n数据库密码重置(扩展)\n停止mysql服务器运行输入services.msc 停止mysql服务\n\n在cmd下,输入mysqld –console –skip-grant-tables 启动服务器,出现一下页面,不要关闭该窗口\n\n新打开cmd,输入mysql -uroot 不需要密码\nuse mysql;\nupdate user set password&#x3D;password(&#39;abc&#39;) WHERE user&#x3D;&#39;root&#39;;#新密码为abc\n\n关闭两个cmd窗口\n\n\nSQL语句(DQL)简单查询语句\n&#x2F;* 格式一 查询指定的列 select 列名,列名 from 表名;\n*&#x2F;\nSELECT pid,pname FROM product;\n&#x2F;* 格式二 查询所有列的数据 \n select 列出所有列名 from 表名;\n select * from 表名 &#x2F;&#x2F;工作中很少用,查询数据多,效率慢\n*&#x2F;\nSELECT * FROM product;\n&#x2F;* 格式三 过滤重复的数据 \nselect distinct 字段1,字段二.. from 表名;\ndistinct关键字之后只有一个字段,就会过滤掉这个字段中重复的数据\ndistinct关键字之后又多个字段,多个字段同时满足才会过滤掉\n*&#x2F;\n-- 查询商品价格 过滤掉重复的价格\nSELECT DISTINCT price FROM product;\n-- 查询商品名称和价格 过滤掉名称和价格同时重复的数据\nSELECT DISTINCT pname,price FROM product;\n&#x2F;* 格式四 别名查询 \n1.给表起一个别名:多表查询时使用\n\tselect *|字段 from 表名 [as] 别名;\n2.给表中的字段起别名\n\tselect 字段1 [as] 别名,...字段n [as] 别名 from 表名;\n注意:别名只是对查询结果临时起一个名字,不会改变表中原有的名字;别名中如有特殊符号或者空格,必须用引号包裹起来\n*&#x2F;\nSELECT * FROM product AS p;\nSELECT pname AS 商品名称,price AS 商品价格 FROM product;\nSELECT pname  商品名称,price  &#39;商品 价格&#39; FROM product;\n&#x2F;*\n查询语句中可以直接进行数据计算\n*&#x2F;\nSELECT (1&#x3D;1+1);-- 2\n-- 查询商品名称和商品价格,把价格在查询时+10000\nSELECT pname  商品名称,price+10000  商品价格 FROM product;\n\n条件查询\n&#x2F;*\n比较运算符 &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;(!&#x3D;);between...and...显示在某一区间的值含头含尾;in(set)显示在in列表中的值;like&#39;_a%&#39;模糊查询,_代表一个字符%代表零个或多个任意字符;is null判断是否为空\n逻辑运算符 and or not\n*&#x2F;\n\n排序查询\n&#x2F;*通过order by语句，可以将查询出的结果进行排序。暂时放置在select语句的最后。\nSELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;\n#ASC 升序 (默认)\n#DESC 降序\n*&#x2F;\nSELECT * FROM product ORDER BY price DESC,category_id DESC;\n\n聚合查询\n&#x2F;*\n之前的查询都是横向查询，都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。\n五个聚合函数\ncount：统计指定列不为NULL的记录行数；\nsum：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；\nmax：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；\nmin：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；\navg：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；\n*&#x2F;\nSELECT count(*) FROM product\n\n分组查询\nSELECT 被份组的字段1,(求和,平均值,个数,最大,最小) FROM 表名 [where 条件 ]GROUP BY 被分组字段 HAVING 分组条件;\n#分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条件。\n&#x2F;*\nhaving与where的区别:\nhaving是在分组后对数据进行过滤\nwhere是在分组前对数据进行过滤\nhaving后面可以使用分组函数(统计函数)\nwhere后面不可以使用分组函数\n*&#x2F;\n\n分页查询\n在工作中不是把所有满足条件的数据全部查询出来,效率低下,对数据进行分页查询,\n&#x2F;*\n分页查询语句 关键字 limit\n格式: \n只要n条数据 select *|字段 from 表名 limit n;\nselect *|字段 from 表名 limit m n; m表示每页开始的行的索引(变化的) n表示每页的数量(不变的)\n注意:数据库行的索引从0开始,列的索引从1开始\n*&#x2F;\n\n多表操作一对多关系建表原则:从表使用主表的主键作为外键\n&#x2F;*\n外键约束的作用:保证数据的准确和完整\n主表中有的数据,从表可以有也可以没有\n主表中没有的数据,从表也不能有\n删除主表的数据,必须保证从表没有使用\n*&#x2F;\n#声明外键约束\nalter table 从表 add [constraint][外键名称] foreign key (从表外键字段名) references 主表 (主表的主键);\n#删除外键约束\nalter table 从表 drop foreign key 外键名称\n\n多对多关系需要创建一张中间表(商品主键–订单主键),中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键\n一对多操作多对多操作多表关系实战#实战1：省和市 \n&#x2F;*\n省和市实例\n*&#x2F;\nCREATE DATABASE day03;\nUSE day03;\n-- 创建主表\nCREATE TABLE province(\n  pid INT PRIMARY KEY AUTO_INCREMENT,\n  pname VARCHAR(20),\n  description VARCHAR(50)\n);\nINSERT INTO province(pname,description) VALUES (&#39;河北&#39;,&#39;雾霾&#39;),(&#39;内蒙古&#39;,&#39;草原&#39;),(&#39;广东&#39;,&#39;经济特区&#39;);\n-- 创建从表\nCREATE TABLE city(\n  cid INT PRIMARY KEY AUTO_INCREMENT,\n  cname VARCHAR(20),\n  description VARCHAR(50),\n-- 所属省份 外键\n  province_pid INT\n);\nALTER TABLE city ADD FOREIGN KEY (province_pid) REFERENCES province(pid);\nSHOW TABLES;\nINSERT INTO city VALUES (NULL,&#39;石家庄&#39;,&#39;雾霾之最&#39;,1),(NULL,&#39;承德&#39;,&#39;避暑山庄&#39;,1);\nINSERT INTO city VALUES (NULL,&#39;包头&#39;,&#39;草原钢城&#39;,2),(NULL,&#39;赤峰&#39;,&#39;红山文化&#39;,2);\nINSERT INTO city VALUES (NULL,&#39;深圳&#39;,&#39;经济特区&#39;,3),(NULL,&#39;东莞&#39;,&#39;服务行业&#39;,3);\n-- 城市表添加主表省份不存在的数据\nINSERT INTO city VALUES (NULL,&#39;澳门&#39;,&#39;博彩娱乐&#39;,4);-- 报错\n\n自关联的一对多关系(了解)本表的外键使用本表的主键,工作中很少用\n\n\n\n地区主键\n地区名称\n地区描述\n所属省份\n\n\n\n1\n河北\n雾霾\nnull\n\n\n2\n内蒙古\n草原\nnull\n\n\n3\n石家庄\n雾霾之最\n1\n\n\n4\n承德\n避暑山庄\n1\n\n\n5\n包头\n草原钢城\n2\n\n\n6\n赤峰\n红山文化\n2\n\n\n#实战2\n&#x2F;*\n用户和角色\n*&#x2F;\n创建用户表\n创建角色表\n创建中间表 添加外键(直接在创建表时声明或者alter table 从表名 add foreign key (从表字段名) references 主表(主表字段名))\n\n多表查询#交叉连接查询(很少用,有错误数据,笛卡尔积)\nselect * from 表A,表B\n#内连接查询,在交叉连接查询的基础上,使用外键约束作为查询条件\n&#x2F;*隐式内连接 ,不使用关键字 [inner] join on*&#x2F;\nselect * from 表A,表B where 表A.主键&#x3D;表B.外键;\n&#x2F;*显式内连接 ,使用关键字 [inner] join on    on的后面可继续写where条件*&#x2F;\nselect * from 表A  [inner] join 表B on 表A.主键&#x3D;表B.外键;\n#外连接,在交叉查询的基础上,使用外键约束作为查询条件\n&#x2F;*左外连接 ,使用关键字 left [outer] join on*&#x2F;\nselect * from 表A  left [outer] join 表B on 表A.主键&#x3D;表B.外键;\n-- 左外连接查询以左边表为主,左边有的数据右边没有就使用null代替,左边没有的数据,右边也不能出现\n&#x2F;*右外连接 ,使用关键字 right [outer] join on*&#x2F;\nselect * from 表A  right [outer] join 表B on 表A.主键&#x3D;表B.外键;\n-- 右外连接和左外连接相反\n\n#子查询 sql语句的嵌套\n&#x2F;*一条sql语句的查询结果,作为另一条sql语句的查询条件*&#x2F;\nselect * from 表B where 字段&#x3D;(select 字段 from 表A [where条件])\n&#x2F;*一条sql语句的查询结果,作为另一条sql语句的另一张表(隐式内连接查询,先过滤数据)*&#x2F;\nselect * from (select * from 表A [where条件]),表B where 表A.主键&#x3D;表B.外键\n\n事务操作事务指的是逻辑上的一组操作,组成这组操作的各个单元要么全都成功,要么全都失败事务作用：保证在一个事务中多次SQL操作要么全都成功,要么全都失败\nmysql事务操作 start transaction开启事务 commit提交事务 rollback回滚事务\n事务总结事务特性ACID\n原子性(Atomicity)指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生\n一致性(Consistency)事务前后数据的完整性必须保持一致\n隔离性(Isolation)事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。\n持久性(Durability)持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。\n\n并发访问问题\n脏读：一个事务读到了另一个事务未提交的数据\n不可重复读：一个事务读到了另一个事务已经提交(update)的数据。引发另一个事务，在事务中的多次查询结果不一致\n虚读 &#x2F;幻读：一个事务读到了另一个事务已经提交(insert)的数据。导致另一个事务，在事务中多次查询的结果不一致\n\n隔离级别(解决问题)数据库规范规定了4种隔离级别，分别用于描述两个事务并发的所有情况\n1.read uncommitted 读未提交，一个事务读到另一个事务没有提交的数据,可能存在脏读、不可重复读、虚读\n2.read committed 读已提交，一个事务读到另一个事务已经提交的数据，可能存在不可重复读、虚读\n3.repeatable read 可重复读，在一个事务中读到的数据始终保持一致，无论另一个事务是否提交，可能存在虚读\nserializable 串行化，同时只能执行一个事务，相当于事务中的单线程，三个问题都没有了\n安全性： serializable[8]&gt;repeatable read[4]&gt;read committed[2 ]&gt;read uncommitted[1]\n性能对比刚好和安全性相反\n常见数据库的默认隔离级别：MySql: repeatable read   Oracle: read committed\nmysql统计技巧-- 统计前六个月的数据\nSELECT month_table.monthValue as month, temp.countValue as count FROM\n(SELECT\n\tdate_format( @lastDay :&#x3D; last_day( date_add( @lastDay, INTERVAL 1 MONTH ) ), &#39;%Y-%m&#39; ) monthValue \nFROM\n\t( SELECT @lastDay :&#x3D; date_add( curdate( ), INTERVAL - 6 MONTH ) FROM mysql.help_topic LIMIT 6 ) a) month_table\nLEFT JOIN\n(select DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;) as monthValue, count(*) as countValue from sys_user u GROUP BY DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;)) temp ON temp.monthValue &#x3D; month_table.monthValue\nORDER BY month_table.monthValue\n-- 原理 1 制作前六个月的月份表\nSELECT\n\tdate_format( @lastDay :&#x3D; last_day( date_add( @lastDay, INTERVAL 1 MONTH ) ), &#39;%Y-%m&#39; ) monthValue \nFROM\n\t( SELECT @lastDay :&#x3D; date_add( curdate( ), INTERVAL - 6 MONTH ) FROM mysql.help_topic LIMIT 6 ) a\n-- 原理 2 制作目标表的按月分组的统计数据\nselect DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;) as monthValue, count(*) as countValue from sys_user u GROUP BY DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;)\n-- 使用外链接合并两张临时表，并查询出需要的字段\n\n-- 统计近30天的数据\n-- 1 生成30天的表\nSELECT\n\t\t@s :&#x3D; @s + 1 AS indexs,\n\t\tDATE_FORMAT( DATE( DATE_SUB( CURRENT_DATE, INTERVAL @s DAY ) ), &#39;%Y-%m-%d&#39; ) AS dates \n\tFROM\n\t\tmysql.help_topic,\n\t\t( SELECT @s :&#x3D; -1 ) temp  #不想包含当天，@s:&#x3D;0\n\tWHERE\n\t\t@s &lt; 30 \n\tORDER BY\n\t\tdates\n-- 制作目标表按天的统计数据\n-- 使用外链接合并两张临时表，并查询出需要的字段\n\nMySQL日期格式化MySQL日期格式化DATE_FORMAT()取值范围。\n值     含义\n%S、%s 秒        两位数字形式的秒（ 00,01, ..., 59）\n%I、%i 分       两位数字形式的分（ 00,01, ..., 59）\n%H    小时     24小时制，两位数形式小时（00,01, ...,23）\n%h    12小时制，两位数形式小时（00,01, ...,12）\n%k    24小时制，数形式小时（0,1, ...,23）\n%l    12小时制，数形式小时（0,1, ...,12）\n%T    24小时制，时间形式（HH:mm:ss）\n%r    12小时制，时间形式（hh:mm:ss AM 或 PM）\n%p    AM上午或PM下午 \n%W    周      一周中每一天的名称（Sunday,Monday, ...,Saturday）\n%a    一周中每一天名称的缩写（Sun,Mon, ...,Sat） \n%w     以数字形式标识周（0&#x3D;Sunday,1&#x3D;Monday, ...,6&#x3D;Saturday） \n%U    数字表示周数，星期天为周中第一天\n%u    数字表示周数，星期一为周中第一天\n%d     天     两位数字表示月中天数（01,02, ...,31）\n%e      数字表示月中天数（1,2, ...,31）\n%D    英文后缀表示月中天数（1st,2nd,3rd ...） \n%j    以三位数字表示年中天数（001,002, ...,366） \n%M     月  英文月名（January,February, ...,December） \n%b     英文缩写月名（Jan,Feb, ...,Dec） \n%m     两位数字表示月份（01,02, ...,12）\n%c     数字表示月份（1,2, ...,12） \n%Y    年     四位数字表示的年份（2015,2016...）\n%y      两位数字表示的年份（15,16...）\n%文字   文字输出       直接输出文字内容\n\n","slug":"mysql/base/Mysql基础","date":"2022-10-01T04:55:09.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"ChrisWood"},{"id":"c5c39a45409b6c5284d037b63eb17322","title":"Node基础十二","content":"十二.数据库MySQL认识数据库1.1. 为什么要使用数据库任何的软件系统都需要存放大量的数据，这些数据通常是非常复杂和庞大的：\n\n比如用户信息包括姓名、年龄、性别、地址、身份证号、出生日期等等；\n比如商品信息包括商品的名称、描述、价格（原价）、分类标签、商品图片等等；\n比如歌曲信息包括歌曲的名称、歌手、专辑、歌曲时长、歌词信息、封面图片等等；\n\n那么这些信息不能直接存储到文件中吗？可以，但是文件系统有很多的缺点：\n\n很难以合适的方式组织数据（多张表之前的关系合理组织）；\n并且对数据进行增删改查中的复杂操作（虽然一些简单确实可以），并且保证单操作的原子性；\n很难进行数据共享，比如一个数据库需要为多个程序服务，如何进行很好的数据共享；\n需要考虑如何进行数据的高效备份、迁移、恢复；\n等等…\n\n数据库通俗来讲就是一个存储数据的仓库，数据库本质上就是一个软件、一个程序。\n1.2. 常见的数据库有哪些？通常我们将数据划分成两类：\n\n关系型数据库：MySQL、Oracle、DB2、SQL Server、Postgre SQL等；\n\n\n关系型数据库通常我们会创建很多个二维数据表；\n\n\n数据表之间相互关联起来，形成一对一、一对多、多对对等关系；\n\n之后可以利用SQL语句在多张表中查询我们所需的数据；\n\n支持事物，对数据的访问更加的安全；\n\n非关系型数据库：MongoDB、Redis、Memcached、HBse等；\n\n\n非关系型数据库的英文其实是Not only SQL，也简称为NoSQL；\n\n\n相当而已非关系型数据库比较简单一些，存储数据也会更加自由（甚至我们可以直接将一个复杂的json对象直接塞入到数据库中）；\n\nNoSQL是基于Key-Value的对应关系，并且查询的过程中不需要经过SQL解析，所以性能更高；\n\nNoSQL通常不支持事物，需要在自己的程序中来保证一些原子性的操作；\n\n\n如何在开发中选择他们呢？具体的选择会根据不同的项目进行综合的分析，我这里给一点点建议：\n\n目前在公司进行后端开发（Node、Java、Go等），还是以关系型数据库为主；\n比较常用的用到非关系型数据库的，在爬取大量的数据进行存储时，会比较常见；\n\n我们的课程是开发自己的后端项目，所以我们以关系型数据库MySQL作为主要内容。\nMySQL的介绍：\n\nMySQL原本是一个开源的数据库，原开发者为瑞典的MySQL AB公司；\n在2008年被Sun公司收购；在2009年，Sun被Oracle收购；\n所以目前MySQL归属于Oracle；\n\nMySQL是一个关系型数据库，其实本质上就是一款软件、一个程序：\n\n这个程序中管理着多个数据库；\n每个数据库中可以有多张表；\n每个表中可以有多条数据；\n\n关系型数据库\n1.3. MySQL的下载和安装第一步：下载MySQL软件\n下载地址：https://dev.mysql.com/downloads/mysql/\n\n根据自己的操作系统下载即可；\n\n推荐大家直接下载安装版本，在安装过程中会配置一些环境变量；\n\n\nWindows推荐下载MSI的版本；\n\n\nMac推荐下载DMG的版本；\n\n这里我安装的是MySQL最新的版本：8.0.22（不再使用旧的MySQL5.x的版本）\n\n\nWindows：\n\n下载下面的，不需要联网安装；\n\nWindows下载的版本\nMac：\nMac下载的版本\n第二步：安装的过程\n安装的过程，基本没有太复杂的操作。\n有一个需要着重说明的是MySQL8，可以采用一种更新的、安全性更高的密码和加密方式：\n\n最新的加密方式有可能会被一些比较老的软件驱动不支持；\n所以要根据情况来选择，但是我这里选择最新的加密方式了；\n\nWindows的安装过程：\nServer Only\n执行\n安装一个依赖\n下一步\n配置端口号\n选择密码加密方式\n填写一个复杂的密码\n配置服务的名称\n应用所有配置\n完成即可\n第三步：启动mysql\n在Windows启动MySQL：\nimage-20201109171443817\n在Mac中启动MySQL是在系统偏好设置中：\nMac启动MySQL\n1.4. mysql的连接和操作打开终端，查看MySQL的安装：\n\n这里会显示找不到命令；\n\nmysql --version\n\n在Windows上配置环境变量：\nWindows上配置环境变量\n在Mac上配置环境变量：\n手动执行下面的终端命令，将MySQL配置到环境变量中：\n# 添加环境变量\nexport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin\n# 再次执行mysql版本\nmysql --version\n\n1.4.1. 终端连接数据库我们如果想要操作数据，需要先和数据建立一个连接，最直接的方式就是通过终端来连接；\n有两种方式来连接：\n\n两种方式的区别在于输入密码是直接输入，还是另起一行以密文的形式输入；\n\n# 方式一：\nmysql -uroot -pCoderwhy888.\n# 方式二：\nmysql -uroot -p\nEnter password: your password\n\n输入成功后，会进入到mysql的REPL（交互式的编程环境）：\nMySQL的REPL\n我们可以直接在REPL中对数据库进行操作。\n1.4.2. 终端操作数据库我们说过，一个数据库软件中，可以包含很多个数据库：\n\ninfomation_schema：信息数据库，其中包括MySQL在维护的其他数据库、表、列、访问权限等信息；\nperformance_schema：性能数据库，记录着MySQL Server数据库引擎在运行过程中的一些资源消耗相关的信息；\nmysql：用于存储数据库管理者的用户信息、权限信息以及一些日志信息等；\nsys：相当于是一个简易版的performance_schema，将数据汇总成更容易理解的形式；\n\n注意：这里我只是在终端简单演练数据库，并没有详细讲解每一个命令，也没有完全按照SQL格式规范；\n\n这些在后面会详细讲解的；\n\n查看所有的数据库：\nshow databases;\n\nimage-20201108165132702\n在终端直接创建一个属于自己的新的数据库coderhub（一般情况下一个新的项目会对应一个新的数据库）。\ncreate database coderhub;\n\n创建一个数据库\n使用我们创建的数据库coderhub：\nuse coderhub;\n\n在数据库中创建自己的表：\ncreate table user(\n\tname varchar(20),\n\tage int,\n\theight double\n);\n\n创建用户表\n在user表中插入自己的数据：\ninsert into user (name, age, height) values (&#39;why&#39;, 18, 1.88);\ninsert into user (name, age, height) values (&#39;kobe&#39;, 40, 1.98);\n\n插入两条数据\n查看user表中所有的数据：\nselect * from user;\n\n查询表中的数据\n1.5. GUI工具操作数据库我们会发现在终端操作数据库有很多不方便的地方：\n\n语句写出来没有高亮，并且不会有任何的提示；\n复杂的语句分成多行，格式看起来并不美观，很冗余出现错误；\n终端中查看所有的数据库或者表非常的不直观和不方便；\n等等…\n\n所以在开发中，我们可以借助于一些GUI工具来帮助我们连接上数据库，之后直接在GUI工具中操作就会非常方便。\n常见的MySQL的GUI工具有很多，这里推荐几款：\n\nNavicat：个人最喜欢的一款工作，但是是收费的（有免费的试用时间，或者各显神通）；\nSQLYog：一款免费的SQL工具；\nTablePlus：常用功能都可以使用，但是会多一些限制（比如只能开两个标签页）；\n\n这里我选择使用Navicat。\n连接数据库\n查看所有的数据库、表、表中的数据：\nNavicat界面\n编写SQL语句，并且执行；\nNavicat编写SQL\nSQL语句2.1. 认识SQL语句我们希望操作数据库（特别是在程序中），就需要有和数据库沟通的语言，这个语言就是SQL：\n\nSQL是Structured Query Language，称之为结构化查询语言，简称SQL；\n使用SQL编写出来的语句，就称之为SQL语句；\nSQL语句可以用于对数据库进行操作；\n\n事实上，常见的关系型数据库SQL语句都是比较相似的，所以你学会了MySQL中的SQL语句，之后去操作比如Oracle或者其他关系型数据库，也是非常方便的。\nSQL语句的常用规范：\n\n通常关键字是大写的，比如CREATE、TABLE、SHOW等等；\n一条语句结束后，需要以 ; 结尾；\n如果遇到关键字作为表明或者字段名称，可以使用&#96;&#96;包裹;\n\n常见的SQL语句我们可以分成四类：\n\nDDL（Data Definition Language）：数据定义语言；\n\n\n可以通过DDL语句对数据库或者表进行：创建、删除、修改等操作；\n\n\nDML（Data Manipulation Language）：数据操作语言；\n\n\n可以通过DML语句对表进行：添加、删除、修改等操作；\n\n\nDQL（Data Query Language）：数据查询语言；\n\n\n可以通过DQL从数据库中查询记录；（重点）\n\n\nDCL（Data Control Language）：数据控制语言；\n\n\n对数据库、表格的权限进行相关访问控制操作；\n\n\n\n接下来我们对他们进行一个个的学习和掌握。\n2.2. DDL语句2.2.1. 数据库的操作查看当前的数据库：\n# 查看所有的数据SHOW DATABASES;# 使用某一个数据USE coderhub;# 查看当前正在使用的数据库SELECT DATABASE();\n\n创建新的数据：\n# 创建数据库语句CREATE DATABASE bilibili;CREATE DATABASE IF NOT EXISTS bilibili;CREATE DATABASE IF NOT EXISTS bilibili DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci;\n\n创建数据库时，可以设置字符串和字符排序（我们可以直接使用默认的）：\n\n字符集：utf8mb4在我们需要插入emoji表情时要用到；\n排序规则：ai表示不区分重音；ci表示不区分大小写；\n\nimage-20201108210407214\n删除数据库：\n# 删除数据库DROP DATABASE bilibili;DROP DATABASE IF EXIT bilibili;\n\n修改数据库：\n# 修改数据库的字符集和排序规则ALTER DATABASE bilibili CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_unicode_ci;\n\n2.2.2. 数据表的操作查看数据表\n# 查看所有的数据表SHOW TABLES;# 查看某一个表结构DESC user;\n\n创建数据表\nCREATE TABLE IF NOT EXISTS &#96;users&#96;(\tname VARCHAR(20),\tage INT,\theight DOUBLE);\n\n2.3. 创建表细节2.3.1. SQL数据类型我们知道不同的数据会划分为不同的数据类型，在数据库中也是一样：\n\nMySQL支持的数据类型有：数字类型，日期和时间类型，字符串（字符和字节）类型，空间类型和 JSON数据类型。\n\n数字类型\nMySQL的数字类型有很多：\n\n整数数字类型：INTEGER，INT，SMALLINT，TINYINT，MEDIUMINT，BIGINT；\n\n整数类型\n\n精确数字类型：DECIMAL，NUMERIC（DECIMAL是NUMERIC的实现形式）；\n\nsalary DECIMAL(5,2)\n\n\n浮点数字类型：FLOAT，DOUBLE\n\n\nFLOAT是4个字节，DOUBLE是8个字节；\n\n\n\n日期类型\nMySQL的日期类型也很多：\n\nYEAR以*YYYY*格式显示值\n\n\n范围 1901到2155，和 0000。\n\n\nDATE类型用于具有日期部分但没有时间部分的值：\n\n\nDATE以格式*YYYY-MM-DD*显示值 ；\n\n\n支持的范围是 &#39;1000-01-01&#39; 到 &#39;9999-12-31&#39;；\n\nDATETIME类型用于包含日期和时间部分的值：\n\n\nDATETIME以格式’YYYY-MM-DD hh:mm:ss‘显示值；\n\n\n支持的范围是1000-01-01 00:00:00到9999-12-31 23:59:59;\n\nTIMESTAMP数据类型被用于同时包含日期和时间部分的值：\n\n\nTIMESTAMP以格式’YYYY-MM-DD hh:mm:ss‘显示值；\n\n\n但是它的范围是UTC的时间范围：&#39;1970-01-01 00:00:01&#39;到&#39;2038-01-19 03:14:07&#39;;\n\n另外：DATETIME或TIMESTAMP 值可以包括在高达微秒（6位）精度的后小数秒一部分\n\n\n比如DATETIME表示的范围可以是&#39;1000-01-01 00:00:00.000000&#39;到&#39;9999-12-31 23:59:59.999999&#39;;\n\n\n\n字符串类型\nMySQL的字符串类型表示方式如下：\n\nCHAR类型在创建表时为固定长度，长度可以是0到255之间的任何值；\n\n\n在被查询时，会删除后面的空格；\n\n\nVARCHAR类型的值是可变长度的字符串，长度可以指定为0到65535之间的值；\n\n\n在被查询时，不会删除后面的空格；\n\n\nBINARY和VARBINARY 类型用于存储二进制字符串，存储的是字节字符串；\n\n\nhttps://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html\n\n\nBLOB用于存储大的二进制类型；\n\nTEXT用于存储大的字符串类型；\n\n\n2.3.2. 表的约束主键：PRIMARY KEY\n一张表中，我们为了区分每一条记录的唯一性，必须有一个字段是永远不会重复，并且不会为空的，这个字段我们通常会将它设置为主键：\n\n主键是表中唯一的索引；\n并且必须是NOT NULL的，如果没有设置 NOT NULL，那么MySQL也会隐式的设置为NOT NULL；\n主键也可以是多列索引，PRIMARY KEY(key_part, …)，我们一般称之为联合主键；\n建议：开发中主键字段应该是和业务无关的，尽量不要使用业务字段来作为主键；\n\n唯一：UNIQUE\n某些字段在开发中我们希望是唯一的，不会重复的，比如手机号码、身份证号码等，这个字段我们可以使用UNIQUE来约束：\n\n使用UNIQUE约束的字段在表中必须是不同的；\n对于所有引擎，UNIQUE 索引允许NULL包含的列具有多个值NULL。\n\n不能为空：NOT NULL\n某些字段我们要求用户必须插入值，不可以为空，这个时候我们可以使用 NOT NULL 来约束；\n默认值：DEFAULT\n某些字段我们希望在没有设置值时给予一个默认值，这个时候我们可以使用 DEFAULT来完成；\n自动递增：AUTO_INCREMENT\n某些字段我们希望不设置值时可以进行递增，比如用户的id，这个时候可以使用AUTO_INCREMENT来完成；\n外键约束也是最常用的一种约束手段，我们再讲到多表关系时，再进行讲解；\n# 创建表CREATE TABLE IF NOT EXISTS &#96;users&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\tage INT DEFAULT 0,\ttelPhone VARCHAR(20) DEFAULT &#39;&#39; UNIQUE NOT NULL,\tcreateTime TIMESTAMP DEFAULT CURRENT_TIMESTAMP);\n\n删除数据表\n# 删除表DROP TABLE &#96;moment&#96;;DROP TABLE IF EXISTS &#96;moment&#96;;\n\n修改数据表\n# 1.修改表名ALTER TABLE &#96;moments&#96; RENAME TO &#96;moment&#96;;# 2.添加一个新的列ALTER TABLE &#96;moment&#96; ADD &#96;publishTime&#96; DATETIME;ALTER TABLE &#96;moment&#96; ADD &#96;updateTime&#96; DATETIME;# 3.删除一列数据ALTER TABLE &#96;moment&#96; DROP &#96;updateTime&#96;;# 4.修改列的名称ALTER TABLE &#96;moment&#96; CHANGE &#96;publishTime&#96; &#96;publishDate&#96; DATE;# 5.修改列的数据类型ALTER TABLE &#96;moment&#96; MODIFY &#96;id&#96; INT;\n\n2.3. DML语句新建一张商品表：\nCREATE TABLE IF NOT EXISTS &#96;products&#96;(\t&#96;id&#96; INT PRIMARY KEY AUTO_INCREMENT,\t&#96;title&#96; VARCHAR(20),\t&#96;description&#96; VARCHAR(200),\t&#96;price&#96; DOUBLE,\t&#96;publishTime&#96; DATETIME);\n\n2.3.1. 插入数据INSERT INTO &#96;products&#96; (&#96;title&#96;, &#96;description&#96;, &#96;price&#96;, &#96;publishTime&#96;) \t\t\t\t\t\t\t\tVALUES (&#39;iPhone&#39;, &#39;iPhone12只要998&#39;, 998.88, &#39;2020-10-10&#39;); INSERT INTO &#96;products&#96; (&#96;title&#96;, &#96;description&#96;, &#96;price&#96;, &#96;publishTime&#96;) \t\t\t\t\t\t\t\tVALUES (&#39;huawei&#39;, &#39;iPhoneP40只要888&#39;, 888.88, &#39;2020-11-11&#39;);\n\n2.3.2. 删除数据# 删除数据# 会删除表中所有的数据DELETE FROM &#96;products&#96;;# 会删除符合条件的数据DELETE FROM &#96;products&#96; WHERE &#96;title&#96; &#x3D; &#39;iPhone&#39;;\n\n2.3.3. 修改数据# 修改数据# 会修改表中所有的数据UPDATE &#96;products&#96;  SET &#96;title&#96; &#x3D; &#39;iPhone12&#39;, &#96;price&#96; &#x3D; 1299.88;# 会修改符合条件的数据UPDATE &#96;products&#96;  SET &#96;title&#96; &#x3D; &#39;iPhone12&#39;, &#96;price&#96; &#x3D; 1299.88 WHERE &#96;title&#96; &#x3D; &#39;iPhone&#39;;\n\n如果我们希望修改完数据后，直接可以显示最新的更新时间：\nALTER TABLE &#96;products&#96; ADD &#96;updateTime&#96; TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;\n\n2.4. DQL语句SELECT用于从一个或者多个表中检索选中的行（Record）。\nSELECT select_expr [, select_expr]...\t[FROM table_references]\t[WHERE where_condition]\t[ORDER expr [ASC | DESC]]\t[LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]\t[GROUP BY expr]\t[HAVING where_condition]\n\n我们先准备一张表：\nCREATE TABLE IF NOT EXISTS &#96;products&#96; (\tid INT PRIMARY KEY AUTO_INCREMENT,\tbrand VARCHAR(20),\ttitle VARCHAR(100) NOT NULL,\tprice DOUBLE NOT NULL,\tscore DECIMAL(2,1),\tvoteCnt INT,\turl VARCHAR(100),\tpid INT);\n\n我们在其中插入一些数据：\nconst mysql &#x3D; require(&#39;mysql2&#39;); const connection &#x3D; mysql.createConnection(&#123;  host: &#39;localhost&#39;,  port: 3306,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;,  database: &#39;coderhub&#39;&#125;);const statement &#x3D; &#96;INSERT INTO products SET ?;&#96;const phoneJson &#x3D; require(&#39;.&#x2F;phone.json&#39;);for (let phone of phoneJson) &#123;  connection.query(statement, phone);&#125;\n\nimage-20201111103013994\n2.4.1. 基本查询查询所有的数据并且显示所有的字段：\nSELECT * FROM &#96;products&#96;;\n\n查询title、brand、price：\nSELECT title, brand, price FROM &#96;products&#96;;\n\n我们也可以给字段起别名：\n\n别名一般在多张表或者给客户端返回对应的key时会使用到；\n\nSELECT title as t, brand as b, price as p FROM &#96;products&#96;;\n\n2.4.2. 条件查询在开发中，我们希望根据条件来筛选我们的数据，这个时候我们要使用条件查询：\n\n条件查询会使用 WEHRE查询子句；\n\nWHERE的比较运算符\n# 查询价格小于1000的手机SELECT * FROM &#96;products&#96; WHERE price &lt; 1000;# 查询价格大于等于2000的手机SELECT * FROM &#96;products&#96; WHERE price &gt;&#x3D; 2000;# 价格等于3399的手机SELECT * FROM &#96;products&#96; WHERE price &#x3D; 3399;# 价格不等于3399的手机SELECT * FROM &#96;products&#96; WHERE price &#x3D; 3399;# 查询华为品牌的手机SELECT * FROM &#96;products&#96; WHERE &#96;brand&#96; &#x3D; &#39;华为&#39;;\n\nWHERE的逻辑运算符\n# 查询品牌是华为，并且小于2000元的手机SELECT * FROM &#96;products&#96; WHERE &#96;brand&#96; &#x3D; &#39;华为&#39; and &#96;price&#96; &lt; 2000;SELECT * FROM &#96;products&#96; WHERE &#96;brand&#96; &#x3D; &#39;华为&#39; &amp;&amp; &#96;price&#96; &lt; 2000;# 查询1000到2000的手机（不包含1000和2000）SELECT * FROM &#96;products&#96; WHERE price &gt; 1000 and price &lt; 2000;# OR: 符合一个条件即可# 查询所有的华为手机或者价格小于1000的手机SELECT * FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39; or price &lt; 1000;# 查询1000到2000的手机（包含1000和2000）SELECT * FROM &#96;products&#96; WHERE price BETWEEN 1000 and 2000;# 查看多个结果中的一个SELECT * FROM &#96;products&#96; WHERE brand in (&#39;华为&#39;, &#39;小米&#39;);\n\nWHERE的模糊查询\n模糊查询使用LIKE关键字，结合两个特殊的符号：\n\n%表示匹配任意个的任意字符；\n_表示匹配一个的任意字符；\n\n# 查询所有以v开头的titleSELECT * FROM &#96;products&#96; WHERE title LIKE &#39;v%&#39;;# 查询带M的titleSELECT * FROM &#96;products&#96; WHERE title LIKE &#39;%M%&#39;;# 查询带M的title必须是第三个字符SELECT * FROM &#96;products&#96; WHERE title LIKE &#39;__M%&#39;;\n\n2.4.3. 查询排序当我们查询到结果的时候，我们希望讲结果按照某种方式进行排序，这个时候使用的是ORDER BY；\nORDER BY有两个常用的值：\n\nASC：升序排列；\nDESC：降序排列；\n\nSELECT * FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39; or price &lt; 1000 ORDER BY price ASC;\n\n2.4.4. 分页偏移当数据库中的数据非常多时，一次性查询到所有的结果进行显示是不太现实的：\n\n在真实开发中，我们都会要求用户传入offset、limit或者page等字段；\n它们的目的是让我们可以在数据库中进行分页查询；\n它的用法有[LIMIT[offset,] row_countrow_count OFFSET offset]\n\nSELECT * FROM &#96;products&#96; LIMIT 30 OFFSET 0;SELECT * FROM &#96;products&#96; LIMIT 30 OFFSET 30;SELECT * FROM &#96;products&#96; LIMIT 30 OFFSET 60;# 另外一种写法：offset, row_countSELECT * FROM &#96;products&#96; LIMIT 90, 30;\n\n2.4.5. 聚合函数聚合函数表示对值集合进行操作的组（集合）函数。\n聚合查询\n我们这里学习最常用的一些聚合函数：\n# 华为手机价格的平均值SELECT AVG(price) FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39;;# 计算所有手机的平均分SELECT AVG(score) FROM &#96;products&#96;;# 手机中最低和最高分数SELECT MAX(score) FROM &#96;products&#96;;SELECT MIN(score) FROM &#96;products&#96;;# 计算总投票人数SELECT SUM(voteCnt) FROM &#96;products&#96;;# 计算所有条目的数量SELECT COUNT(*) FROM &#96;products&#96;;# 华为手机的个数SELECT COUNT(*) FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39;;\n\n事实上聚合函数相当于默认将所有的数据分成了一组：\n\n我们前面使用avg还是max等，都是将所有的结果看成一组来计算的；\n那么如果我们希望划分多个组：比如华为、苹果、小米等手机分别的平均价格，应该怎么来做呢？\n这个时候我们可以使用 GROUP BY；\n\nGROUP BY通常和聚合函数一起使用：\n\n表示我们先对数据进行分组，再对每一组数据，进行聚合函数的计算；\n\n我们现在来提一个需求：\n\n根据品牌进行分组；\n计算各个品牌中商品的个数、平均价格、最高价格、最低价格、平均评分；\n\nSELECT brand, \t\t\tCOUNT(*) as count, \t\t\tROUND(AVG(price),2) as avgPrice,\t\t\tMAX(price) as maxPrice,\t\t\tMIN(price) as minPrice,\t\t\tAVG(score) as avgScoreFROM &#96;products&#96; GROUP BY brand;\n\n如果我们还希望筛选出平均价格在4000以下，并且平均分在7以上的品牌：\nSELECT brand, \t\t\tCOUNT(*) as count, \t\t\tROUND(AVG(price),2) as avgPrice,\t\t\tMAX(price) as maxPrice,\t\t\tMIN(price) as minPrice,\t\t\tAVG(score) as avgScoreFROM &#96;products&#96; GROUP BY brand HAVING avgPrice &lt; 4000 and avgScore &gt; 7;\n\n2.5. 外键约束2.5.1. 创建多张表假如我们的上面的商品表中，对应的品牌还需要包含其他的信息：\n\n比如品牌的官网，品牌的世界排名，品牌的市值等等；\n\n如果我们直接在商品中去体现品牌相关的信息，会存在一些问题：\n\n一方面，products表中应该表示的都是商品相关的数据，应该有另外一张表来表示brand的数据；\n另一方面，多个商品使用的品牌是一致时，会存在大量的冗余数据；\n\n所以，我们可以将所有的批评数据，单独放到一张表中，创建一张品牌的表：\nCREATE TABLE IF NOT EXISTS &#96;brand&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\twebsite VARCHAR(100),\tworldRank INT);\n\n插入模拟的数据：\n\n这里我是刻意有一些商品数据的品牌是没有添加的；\n并且也可以添加了一些不存在的手机品牌；\n\nINSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;华为&#39;, &#39;www.huawei.com&#39;, 1);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;小米&#39;, &#39;www.mi.com&#39;, 10);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;苹果&#39;, &#39;www.apple.com&#39;, 5);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;oppo&#39;, &#39;www.oppo.com&#39;, 15);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;京东&#39;, &#39;www.jd.com&#39;, 3);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;Google&#39;, &#39;www.google.com&#39;, 8);\n\n2.5.2. 创建外键我们先给products添加一个brand_id字段：\n将两张表联系起来，我们可以将products中的brand_id关联到brand中的id：\n\n如果是创建表添加外键约束：\nFOREIGN KEY (brand_id) REFERENCES brand(id)\n\n如果是表已经创建好，额外添加外键：\nALTER TABLE &#96;products&#96; ADD FOREIGN KEY (brand_id) REFERENCES brand(id);\n\n现在我们可以将products中的brand_id关联到brand中的id的值：\nUPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 1 WHERE &#96;brand&#96; &#x3D; &#39;华为&#39;;UPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 4 WHERE &#96;brand&#96; &#x3D; &#39;OPPO&#39;;UPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 3 WHERE &#96;brand&#96; &#x3D; &#39;苹果&#39;;UPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 2 WHERE &#96;brand&#96; &#x3D; &#39;小米&#39;;\n\n2.5.3. 删除和更新我们来思考一个问题：\n\n如果products中引用的外键被更新了或者删除了，这个时候会出现什么情况呢？\n\n我们来进行一个更新操作：比如将华为的id更新为100\nUPDATE &#96;brand&#96; SET id &#x3D; 100 WHERE id &#x3D; 1;\n\n这个时候执行代码是报错的：\n不可以更新和删除，因为有一个外键引用\n如果我希望可以更新呢？我们可以给更新时设置几个值：\n\nRESTRICT（默认属性）：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话会报错的，不允许更新或删除；\n\nNO ACTION：和RESTRICT是一致的，是在SQL标准中定义的；\n\nCASCADE：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话：\n\n\n更新：那么会更新对应的记录；\n\n\n删除：那么关联的记录会被一起删除掉；\n\nSET NULL：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话，将对应的值设置为NULL；\n\n\n如果修改外键的更新时的动作呢？\n第一步：查看表结构：\n# 执行命令SHOW CREATE TABLE &#96;products&#96;;# 结果如下：CREATE TABLE &#96;products&#96; (  &#96;id&#96; int NOT NULL AUTO_INCREMENT,  &#96;brand&#96; varchar(20) DEFAULT NULL,  &#96;title&#96; varchar(100) NOT NULL,  &#96;price&#96; double NOT NULL,  &#96;score&#96; decimal(2,1) DEFAULT NULL,  &#96;voteCnt&#96; int DEFAULT NULL,  &#96;url&#96; varchar(100) DEFAULT NULL,  &#96;pid&#96; int DEFAULT NULL,  &#96;brand_id&#96; int DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;),  KEY &#96;brand_id&#96; (&#96;brand_id&#96;),  CONSTRAINT &#96;products_ibfk_1&#96; FOREIGN KEY (&#96;brand_id&#96;) REFERENCES &#96;brand&#96; (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;109 DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci\n\n这个时候，我们可以知道外键的名称是products_ibfk_1。\n第二步：删除之前的外键\nALTER TABLE &#96;products&#96; DROP FOREIGN KEY products_ibfk_1;\n\n第三步：添加新的外键，并且设置新的action\nALTER TABLE &#96;products&#96; ADD FOREIGN KEY (brand_id) REFERENCES brand(id) ON UPDATE CASCADE ON DELETE CASCADE;\n\n2.6. 多表查询2.6.1. 多表查询如果我们希望查询到产品的同时，显示对应的品牌相关的信息，因为数据是存放在两张表中，所以这个时候就需要进行多表查询。\n如果我们直接通过查询语句希望在多张表中查询到数据，这个时候是什么效果呢？\nSELECT * FROM &#96;products&#96;, &#96;brand&#96;;\n\n查询结果\n我们会发现一共有648条数据，这个数据量是如何得到的呢？\n\n第一张表的108条 * 第二张表的6条数据；\n也就是说第一张表中每一个条数据，都会和第二张表中的每一条数据结合一次；\n这个结果我们称之为 笛卡尔乘积，也称之为直积，表示为 X*Y；\n\n但是事实上很多的数据是没有意义的，比如华为和苹果、小米的品牌结合起来的数据就是没有意义的，我们可不可以进行筛选呢？\n\n使用where来进行筛选；\n这个表示查询到笛卡尔乘积后的结果中，符合products.brand_id = brand.id条件的数据过滤出来；\n\nSELECT * FROM &#96;products&#96;, &#96;brand&#96; WHERE &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n事实上我们想要的效果并不是这样的，而且表中的某些特定的数据，这个时候我们可以使用 SQL JOIN 操作：\n\n左连接\n右连接\n内连接\n全连接\n\nSQL JOIN\n2.6.2. 左连接如果我们希望获取到的是左边所有的数据（以左表为主）：\n\n这个时候就表示无论左边的表是否有对应的brand_id的值对应右边表的id，左边的数据都会被查询出来；\n这个也是开发中使用最多的情况，它的完整写法是LEFT [OUTER] JOIN，但是OUTER可以省略的；\n\n\nSELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n如果我们查询的是左连接部分中，和右表无关的数据：\n\n也非常简单，只需要加上一个条件即可：B表中的数据为空\n\n\nSELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE brand.id IS NULL;\n\n2.6.3. 右连接如果我们希望获取到的是右边所有的数据（以由表为主）：\n\n\n这个时候就表示无论左边的表中的brand_id是否有和右边表中的id对应，右边的数据都会被查询出来；\n右连接在开发中没有左连接常用，它的完整写法是RIGHT [OUTER] JOIN，但是OUTER可以省略的；\n\nSELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n如果我们查询的是右连接部分中，和左表无关的数据：\n\n也非常简单，只需要加上一个条件即可：A表中的数据为空；\n\n\nSELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE products.id IS NULL;\n\n2.6.4. 内连接事实上内连接是表示左边的表和右边的表都有对应的数据关联：\nSELECT * FROM &#96;products&#96; INNER JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n我们会发现它和之前的下面写法是一样的效果：\nSELECT * FROM &#96;products&#96;, &#96;brand&#96; WHERE &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n但是他们代表的含义并不相同：\n\nSQL语句一：内连接，代表的是在两张表连接时就会约束数据之间的关系，来决定之后查询的结果；\nSQL语句二：where条件，代表的是先计算出笛卡尔乘积，在笛卡尔乘积的数据基础之上进行where条件的筛选；\n\n内连接在开发中偶尔也会常见使用，看自己的场景。\n内连接有其他的写法：CROSS JOIN或者 JOIN都可以；\n2.6.5. 全连接SQL规范中全连接是使用FULL JOIN，但是MySQL中并没有对它的支持，我们需要使用 UNION 来实现：\n\n(SELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id)UNION(SELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id);\n\n如果我们希望查询的是下面的结果：\n\n(SELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE &#96;brand&#96;.id IS NULL)UNION(SELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE &#96;products&#96;.id IS NULL);\n\n2.7. 多对多关系2.7.1. 准备多张表在开发中我们还会遇到多对多的关系：\n\n比如学生可以选择多门课程，一个课程可以被多个学生选择；\n这种情况我们应该在开发中如何处理呢？\n\n这个时候我们通常是会建三张表来建立它们之间的关系的：\n# 创建学生表CREATE TABLE IF NOT EXISTS &#96;students&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\tage INT);# 创建课程表CREATE TABLE IF NOT EXISTS &#96;courses&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\tprice DOUBLE NOT NULL);\n\n我们在两张表中插入一些数据：\nINSERT INTO &#96;students&#96; (name, age) VALUES(&#39;why&#39;, 18);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;tom&#39;, 22);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;lilei&#39;, 25);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;lucy&#39;, 16);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;lily&#39;, 20);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;英语&#39;, 100);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;语文&#39;, 666);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;数学&#39;, 888);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;历史&#39;, 80);\n\n2.7.2. 创建关系表我们需要一个关系表来记录两张表中的数据关系：\n# 创建关系表CREATE TABLE IF NOT EXISTS &#96;students_select_courses&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tstudent_id INT NOT NULL,\tcourse_id INT NOT NULL,\tFOREIGN KEY (student_id) REFERENCES students(id) ON UPDATE CASCADE,\tFOREIGN KEY (course_id) REFERENCES courses(id) ON UPDATE CASCADE);\n\n我们插入一些数据：\n# why 选修了 英文和数学INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (1, 1);INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (1, 3);# lilei选修了 语文和数学和历史INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (3, 2);INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (3, 3);INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (3, 4);\n\n2.7.3. 多表数据查询查询多条数据：\n# 查询所有的学生选择的所有课程SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id; # 查询所有的选手选课情况SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu LEFT JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id LEFT JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id;\n\n查询单个学生的课程：\n# why同学选择了哪些课程SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id \tWHERE stu.id &#x3D; 1; # lily同学选择了哪些课程SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu LEFT JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id LEFT JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id \tWHERE stu.id &#x3D; 5;\n\n查询哪些学生没有选择和哪些课程没有被选择：\n# 哪些学生是没有选课的SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stuLEFT JOIN &#96;students_select_courses&#96; ssc\tON stu.id &#x3D; ssc.student_idLEFT JOIN &#96;courses&#96; cs\tON ssc.course_id &#x3D; cs.id\tWHERE cs.id IS NULL;# 查询哪些课程没有被学生选择SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stuRIGHT JOIN &#96;students_select_courses&#96; ssc\tON stu.id &#x3D; ssc.student_idRIGHT JOIN &#96;courses&#96; cs\tON ssc.course_id &#x3D; cs.id\tWHERE stu.id IS NULL;\n\nNode操作MySQL3.1.对象和数组3.1.1. 一对多 - 对象前面我们学习的查询语句，查询到的结果通常是一张表，比如查询手机+品牌信息：\nSELECT * FROM products LEFT JOIN brand ON products.brand_id &#x3D; brand.id;\n\n查询结果\n但是在真实开发中，实际上红色圈起来的部分应该放入到一个对象中，那么我们可以使用下面的查询方式：\n\n这个时候我们要用 JSON_OBJECT;\n\nSELECT products.id as id, products.title as title, products.price as price, products.score as score, \t\t\t\tJSON_OBJECT(&#39;id&#39;, brand.id, &#39;name&#39;, brand.name, &#39;rank&#39;, brand.phoneRank, &#39;website&#39;, brand.website) as brandFROM products LEFT JOIN brand ON products.brand_id &#x3D; brand.id;\n\n查询结果\n3.1.2. 多对多 - 数组在多对多关系中，我们希望查询到的是一个数组：\n\n比如一个学生的多门课程信息，应该是放到一个数组中的；\n数组中存放的是课程信息的一个个对象；\n这个时候我们要 JSON_ARRAYAGG和JSON_OBJECT结合来使用；\n\nSELECT stu.id, stu.name, stu.age, \t\t   JSON_ARRAYAGG(JSON_OBJECT(&#39;id&#39;, cs.id, &#39;name&#39;, cs.name)) as courses FROM students stuLEFT JOIN students_select_courses ssc ON stu.id &#x3D; ssc.student_idLEFT JOIN courses cs ON ssc.course_id &#x3D; cs.idGROUP BY stu.id;\n\n查询结果\n3.2. mysql2的使用3.2.1. 认识mysql2前面我们所有的操作都是在GUI工具中，通过执行SQL语句来获取结果的，那真实开发中肯定是通过代码来完成所有的操作的。\n那么如何可以在Node的代码中执行SQL语句来，这里我们可以借助于两个库：\n\nmysql：最早的Node连接MySQL的数据库驱动；\nmysql2：在mysql的基础之上，进行了很多的优化、改进；\n\n目前相对来说，我更偏向于使用mysql2，mysql2兼容mysql的API，并且提供了一些附加功能\n\n更快&#x2F;更好的性能；\n\nPrepared Statement（预编译语句）：\n\n\n提高性能：将创建的语句模块发送给MySQL，然后MySQL编译（解析、优化、转换）语句模块，并且存储它但是不执行，之后我们在真正执行时会给?提供实际的参数才会执行；就算多次执行，也只会编译一次，所以性能是更高的；\n\n\n防止SQL注入：之后传入的值不会像模块引擎那样就编译，那么一些SQL注入的内容不会被执行；or 1 = 1不会被执行；\n\n支持Promise，所以我们可以使用async和await语法\n\n等等….\n\n\n所以后续的学习中我会选择mysql2在node中操作数据。\n安装\nnpm install mysql2\n\n3.2.2. mysql2基本使用mysql2的使用过程如下：\n\n第一步：创建连接（通过createConnection），并且获取连接对象；\n第二步：执行SQL语句即可（通过query）；\n\nconst mysql &#x3D; require(&#39;mysql2&#39;);&#x2F;&#x2F; 创建连接const connection &#x3D; mysql.createConnection(&#123;  host: &#39;localhost&#39;,  database: &#39;coderhub&#39;,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;&#125;);&#x2F;&#x2F; 执行SQL语句connection.query(&#39;SELECT title, price FROM products WHERE price &gt; 9000;&#39;, (err, results, fields) &#x3D;&gt; &#123;  console.log(err);  console.log(&#39;----------&#39;);  console.log(results);  console.log(&#39;----------&#39;);  console.log(fields);&#125;)\n\n通常我们的连接建立之后是不会轻易断开的，因为我们需要这个连接持续帮助我们查询客户端过来的请求。\n但是如果我们确实希望断开连接，可以使用 end 方法：\nconnection.end();\n\n3.2.3. 预编译语句Prepared Statement（预编译语句）：\n\n提高性能：将创建的语句模块发送给MySQL，然后MySQL编译（解析、优化、转换）语句模块，并且存储它但是不执行，之后我们在真正执行时会给?提供实际的参数才会执行；就算多次执行，也只会编译一次，所以性能是更高的；\n防止SQL注入：之后传入的值不会像模块引擎那样就编译，那么一些SQL注入的内容不会被执行；or 1 = 1不会被执行；\n\nconst statement &#x3D; &#39;SELECT * FROM products WHERE price &gt; ? and brand &#x3D; ?;&#39;;connection.execute(statement, [1000, &#39;华为&#39;], (err, results) &#x3D;&gt; &#123;  console.log(results);&#125;);\n\n强调：如果再次执行该语句，它将会从LRU（Least Recently Used） Cache中获取获取，省略了编译statement的时间来提高性能。\n3.2.4. 连接池前面我们是创建了一个连接（connection），但是如果我们有多个请求的话，该连接很有可能正在被占用，那么我们是否需要每次一个请求都去创建一个新的连接呢？\n\n事实上，mysql2给我们提供了连接池（connection pools）；\n连接池可以在需要的时候自动创建连接，并且创建的连接不会被销毁，会放到连接池中，后续可以继续使用；\n我们可以在创建连接池的时候设置LIMIT，也就是最大创建个数；\n\nconst mysql &#x3D; require(&#39;mysql2&#39;);const pool &#x3D; mysql.createPool(&#123;  host: &#39;localhost&#39;,  database: &#39;coderhub&#39;,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;,  connectionLimit: 10&#125;);const statement &#x3D; &#39;SELECT * FROM products WHERE price &gt; ? and brand &#x3D; ?;&#39;;pool.execute(statement, [1000, &#39;华为&#39;], (err, results) &#x3D;&gt; &#123;  console.log(results);&#125;);\n\n为什么Node执行JavaScript时单线程的，还需要连接池呢？\n\n这是因为Node中操作数据库，本质上是通过Libuv进行了的数据库操作；\n而在libuv中是可以有多个线程的，多个线程也是可以同时去建立连接来操作数据库的；\n\n3.2.5. promises目前在JavaScript开发中我们更习惯Promise和await、async的方式，mysql2同样是支持的：\nconst mysql &#x3D; require(&#39;mysql2&#39;);const pool &#x3D; mysql.createPool(&#123;  host: &#39;localhost&#39;,  database: &#39;coderhub&#39;,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;,  connectionLimit: 5&#125;);const statement &#x3D; &#39;SELECT * FROM products WHERE price &gt; ? and brand &#x3D; ?;&#39;;pool.promise().execute(statement, [1000, &#39;华为&#39;]).then(([results]) &#x3D;&gt; &#123;  console.log(results);&#125;);\n\n3.3. ORM的sequelize3.3.1. 认识ORM对象关系映射（英语：Object Relational Mapping，简称ORM，或O&#x2F;RM，或O&#x2F;R mapping），是一种程序设计的方案：\n\n从效果上来讲，它提供了一个可在编程语言中，使用 虚拟对象数据库 的效果；\n比如在Java开发中经常使用的ORM包括：Hibernate、MyBatis；\n\nNode当中的ORM我们通常使用的是 sequelize;\n\nSequelize是用于Postgres，MySQL，MariaDB，SQLite和Microsoft SQL Server的基于Node.js 的 ORM；\n它支持非常多的功能；\n\n如果我们希望将Sequelize和MySQL一起使用，那么我们需要先安装两个东西：\n\nmysql2：sequelize在操作mysql时使用的是mysql2；\nsequelize：使用它来让对象映射到表中；\n\nnpm install sequelize mysql2\n\n3.3.2. Sequelize的使用Sequelize的连接数据库：\n\n第一步：创建一个Sequelize的对象，并且制定数据库、用户名、密码、数据库类型、主机地址等；\n第二步：测试连接是否成功；\n\nconst &#123;Sequelize, DataTypes, Model, Op&#125; &#x3D; require(&#39;sequelize&#39;);const sequelize &#x3D; new Sequelize(&#39;coderhub&#39;, &#39;root&#39;, &#39;Coderwhy888.&#39;, &#123;  host: &#39;localhost&#39;,  dialect: &#39;mysql&#39;&#125;);sequelize.authenticate().then(() &#x3D;&gt; &#123;  console.log(&quot;sequelize连接成功~&quot;);&#125;).catch(err &#x3D;&gt; &#123;  console.log(&quot;sequlize连接失败~&quot;, err);&#125;);\n\nSequelize映射关系表：\nclass Student extends Model &#123;&#125;Student.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  name: &#123;    type: DataTypes.STRING,    allowNull: false  &#125;,  age: DataTypes.INTEGER&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false&#125;)\n\n测试增删改查的操作：\nasync function queryStudent() &#123;  &#x2F;&#x2F; 1.查询所有的学生  const result1 &#x3D; await Student.findAll(&#123;&#125;);  console.log(result1);  &#x2F;&#x2F; 2.查询年龄大于等于20岁的学生  const result2 &#x3D; await Student.findAll(&#123;    where: &#123;      age: &#123;        [Op.gte]: 20      &#125;    &#125;  &#125;);  console.log(result2);  &#x2F;&#x2F; 3.创建用户  const result3 &#x3D; await Student.create(&#123;    name: &#39;hmm&#39;,    age: 22  &#125;);  console.log(result3);  &#x2F;&#x2F; 4.更新用户  const result4 &#x3D; await Student.update(&#123;    age: 25  &#125;, &#123;    where: &#123;      id: 6    &#125;  &#125;);  console.log(result4);&#125;queryStudent();\n\n3.3.3. 多对多关系第一步：连接数据库\nconst &#123; Sequelize, DataTypes, Model, Op &#125; &#x3D; require(&#39;sequelize&#39;);const sequelize &#x3D; new Sequelize(&#39;coderhub&#39;, &#39;root&#39;, &#39;Coderwhy888.&#39;, &#123;  host: &#39;localhost&#39;,  dialect: &#39;mysql&#39;&#125;);\n\n第二步：创建映射关系\nclass Student extends Model &#123;&#125;Student.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  name: &#123;    type: DataTypes.STRING,    allowNull: false  &#125;,  age: DataTypes.INTEGER&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false&#125;)class Course extends Model &#123;&#125;Course.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  name: &#123;    type: DataTypes.STRING(20),    allowNull: false  &#125;,  price: &#123;    type: DataTypes.DOUBLE,    allowNull: false  &#125;&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false&#125;);class StudentCourse extends Model &#123;&#125;;StudentCourse.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  studentId: &#123;    type: DataTypes.INTEGER,    references: &#123;      model: Student,      key: &#39;id&#39;    &#125;,    field: &#39;student_id&#39;,  &#125;,  courseId: &#123;    type: DataTypes.INTEGER,    references: &#123;      model: Course,      key: &#39;id&#39;    &#125;,    field: &#39;course_id&#39;,  &#125;&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false,  tableName: &#39;students_select_courses&#39;&#125;);\n\n第三步：建立多对多的联系\nStudent.belongsToMany(Course, &#123;  through: StudentCourse,   foreignKey: &#39;student_id&#39;,   otherKey: &#39;course_id&#39;,&#125;);Course.belongsToMany(Student, &#123;  through: StudentCourse,   foreignKey: &#39;course_id&#39;,   otherKey: &#39;student_id&#39;&#125;);\n\n第四步：执行多对多查询操作：\nasync function queryStudent() &#123;  &#x2F;&#x2F; 查询结果  const result &#x3D; await Student.findAll(&#123;    include: &#123;      model: Course    &#125;\n\nhttp协议1.超文本传输协议\n规定了如何从网站服务器传输超文本到本地浏览器,基于客户端服务器架构工作,是客户端和服务器端请求和应答标准\n\n2.报文   过程中传递的数据块\n请求报文:1.请求方式 req.method获取请求方式   GET POST\n\t\t2.请求地址 req.url获取请求地址\n\t\t3.请求报文 req.headers[&#39;键名&#39;]获取请求报文\n\t\t\n请求组成:请求行 方式 资源 协议版本\n\t\t请求头 键值对\n\t\t请求体 post有请求参数 get请求参数不在请求体中,在url地址后面\n\t\t\n\n响应报文:1.http状态码   200成功 404没找到 500服务器端错误 400客户端请求语法错\n\t\t2.内容类型 text&#x2F;html text&#x2F;css application&#x2F;javascript image&#x2F;jpeg application&#x2F;json\n\t\t3. 内容长度 内容..\n\t\tres.writeHead(状态码,&#123;&#39;content-type&#39;:&#39;text&#x2F;plain&#39;&#125;) 内容类型默认纯文本\n\t\tres.end(&#39;...&#39;)响应内容\n\t\t\n响应组成:响应行 http协议 状态码 其他状态码(成功2xx 重定向 3xx 客户端4xx 服务器端错误5xx)\n\t\t响应头 键值对\n\t\t响应体 post有请求参数 get请求参数不在请求体中,在url地址后面\n\nhttp请求与响应处理8种请求方式 OPTIONS HEAD  GET POST PUT DELETE TRACE \n\n请求参数GET\n使用url模块,用于处理url地址   \nurl.parse(req.url) 返回一个对象\nurl.parse(req.url,true)把查询参数解析成对象\nurl.parse(req.url,true).query得到这个对象  通过这个对象.键名得到参数值\n\n解构赋值 &#123; query, pathname&#125; &#x3D; url.parse(req.url,true) 得到参数对象和请求地址\n\nwindow释放端口1.cmd\n2.netstat -ano | findstr 9090 查询端口9090使用情况\n3.tasklist | findstr +进程ID  查询端口被进程占用的程序\n4.taskkill &#x2F;f &#x2F;t &#x2F;im  +进程ID或程序  杀死进程\n\nNPMnpm常用命令# 临时\n$ npm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install 插件名\n# 配置\n$ npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org\n\n# 查看 npm 的版本 \n$ npm -v  \n# 查看各个命令的简单用法\n$ npm -l \n# 查看 npm 命令列表\n$ npm help\n# 查看 npm 的配置\n$ npm config list -l\n# 查看插件的版本\nnpm view 插件名 versions\n# 创建模块\nnpm init\n#当前项目安装的所有模块\n$npm list\n#列出全局安装的模块 带上[--depth 0] 不深入到包的支点 更简洁\n$ npm list -g --depth 0\n\n# 读取package.json里面的配置单安装  \n$ npm install \n&#x2F;&#x2F;可简写成 npm i\n\n# 默认安装指定模块的最新(@latest)版本\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt; \n&#x2F;&#x2F;eg:npm install gulp\n\n# 安装指定模块的指定版本\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt;@&lt;version&gt;\n&#x2F;&#x2F;eg: npm install gulp@3.9.1\n\n# 安装指定指定版本范围内的模块\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt;@&lt;version range&gt;\n&#x2F;&#x2F;eg: npm install vue@&quot;&gt;&#x3D;1.0.28 &lt; 2.0.0&quot;\n\n# 安装指定模块的指定标签 默认值为(@latest)\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt;@&lt;tag&gt;\n&#x2F;&#x2F;eg:npm install sax@0.1.1\n\n# 通过Github代码库地址安装\n$ npm install &lt;tarball url&gt;\n&#x2F;&#x2F;eg:npm install git:&#x2F;&#x2F;github.com&#x2F;package&#x2F;path.git\n\n#卸载当前项目或全局模块 \n$ npm uninstall &lt;name&gt; [-g] \n\n#升级当前项目或全局的指定模块\n$ npm update &lt;name&gt; [-g]\n\n# 引用依赖 有些包是全局安装了，在项目里面只需要引用即可。\n$ npm link [&lt;@scope&gt;&#x2F;]&lt;pkg&gt;[@&lt;version&gt;]\n&#x2F;&#x2F;eg: 引用   npm link gulp gulp-ssh gulp-ftp\n&#x2F;&#x2F;eg: 解除引用 npm unlink gulp\n\n# 未注册 申请注册一个用户 直接在https:&#x2F;&#x2F;www.npmjs.com&#x2F;注册一样\n$ npm adduser\n&#x2F;&#x2F;执行后 填写几个问题 Username、Password、Email\n\n#已注册\n$ npm login \n\n#发布\n$ npm publish\n\nNPM私库搭建npm+git1.新建私有git仓库\n2.clone仓库\n3.npm init\n4.按npm规范开发完。push到仓库即可\n\nverdaccio(https://www.jianshu.com/p/0c905e4a8b70)\n云服务器安装node环境,nginx\n\n\n\n\n\n\n\n\n1 云服务器安装verdaccio(轻量级开源私有npm代理注册表)npm i verdaccio -g\n\n\n\n\n\n\n\n\n\n2 启动服务：verdaccio\n\n\n\n\n\n\n\n\n\n3 配置config.yaml\n1、vim &#x2F;home&#x2F;yg&#x2F;.config&#x2F;verdaccio&#x2F;config.yaml 进入编辑配置文件\n\n# This is the default config file. It allows all users to do anything,\n# so don&#39;t use it on production systems.\n#\n# Look here for more config file examples:\n# https:&#x2F;&#x2F;github.com&#x2F;verdaccio&#x2F;verdaccio&#x2F;tree&#x2F;master&#x2F;conf\n#\n\n# path to a directory with all packages\n# 所有包缓存的目录\nstorage: .&#x2F;storage\n# path to a directory with plugins to include\n# 插件目录\nplugins: .&#x2F;plugins\n\n# 开启web服务，能够通过web访问\nweb:\n  # WebUI is enabled as default, if you want disable it, just uncomment this line\n  #enable: false\n  title: Verdaccio\n\n# 验证信息\nauth:\n  htpasswd:\n    # 用户信息存储目录\n    file: .&#x2F;htpasswd\n    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.\n    # You can set this to -1 to disable registration.\n    #max_users: 1000\n\n# a list of other known repositories we can talk to\n# 公有仓库配置\nuplinks:\n  npmjs:\n    url: https:&#x2F;&#x2F;registry.npmjs.org&#x2F;\n\npackages:\n  &#39;@*&#x2F;*&#39;:\n    # scoped packages\n    access: $all\n    publish: $authenticated\n    # 代理，表示没有的仓库去这个npmjs里边去找\n    # npmjs 又指向 https:&#x2F;&#x2F;registry.npmjs.org&#x2F; ,就是上面的 uplinks 配置\n    proxy: npmjs\n\n  &#39;**&#39;:\n    # allow all users (including non-authenticated users) to read and\n    # publish all packages\n    #\n    # you can specify usernames&#x2F;groupnames (depending on your auth plugin)\n    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;\n    # 三种身份所有人，匿名用户，认证（登录用户）\n    # 是否可访问所需的权限\n    access: $all\n\n    # allow all known users to publish packages\n    # (anyone can register by default, remember?)\n    # 发布package的权限\n    publish: $authenticated\n\n    # if package is not available locally, proxy requests to &#39;npmjs&#39; registry\n    # 如果package不存在，就向代理的上游服务器发起请求\n    proxy: npmjs\n\n# To use &#96;npm audit&#96; uncomment the following section\nmiddlewares:\n  audit:\n    enabled: true\n\n# 监听端口，重点，不配置这个只能本机可以访问\nlisten: 0.0.0.0:4873\n\n# log settings\nlogs:\n  - &#123;type: stdout, format: pretty, level: http&#125;\n  #- &#123;type: file, path: verdaccio.log, level: info&#125;\n\n\n\n\n\n\n\n\n\n\n4.启动  pm2 start verdaccio   这是后就可以通过http://xxx（ip地址）去访问了\n\n\n\n\n\n\n\n\n\n5.如何使用\n#当前npm 服务指向本地 \nnpm set registry http:&#x2F;&#x2F;localhost:4873\n# 注册用户 在本地注册一个用户然后指向我们的地址然后我们就可以发布包了\nnpm adduser --registry http:&#x2F;&#x2F;xxx:4873\nUsername: xxx\nPassword: xxx\nPassword:  xxx\nEmail: (this IS public) xxx\nLogged in as yg-ui on http:&#x2F;&#x2F;xxx&#x2F; （你的ip地址）这时候我们就注册一个用户，我们可以用这个用户名和密码去登录去上图窗口去登录\n\n\n与私服连接\n\nnpm set registry http:&#x2F;&#x2F;xxx：4873 (失败试试：npm config set registry http:&#x2F;&#x2F;xxx:4873 ，然后查看是否配置成功npm config edit）\n把下载镜像源的地址切换到从我们的服务器上下载。这里的npmrc文件里面内地址也就会易主\n\n\n安装nrm\n\nnrm是 npm registry 管理工具, 能够查看和切换当前使用的registry。不安装也可以，安装会更高效。\n1、安装 npm install -g nrm\n2、添加私服地址到nrm管理工具\n\n3、这里的 yg-ui是我们给自己的私服地址起的别名，为了切换和使用方便。\n   nrm add yg-ui http:&#x2F;&#x2F;xxx:4873 成功后如下\n     add registry my50 success\n4、将npm包的下载地址改到my50的私服。\n   nrm use yg-ui 成功后如下\n     verb config Skipping project config: &#x2F;home&#x2F;yg&#x2F;.npmrc.\n     Registry has been set to: http:&#x2F;&#x2F;xxx:4873&#x2F;\n5、使用nrm ls可查到我们可以使用的所有镜像源地址，* 后面是当前使用的，如果我们不想从私服上下载包，就可以用上一步骤的nrm use命令，use其它的地址，将下载地址改到别的服务器。\n   \n   输入 nrm ls 成功后如下\n   npm ---- https:&#x2F;&#x2F;registry.npmjs.org&#x2F;\n   cnpm --- http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;\n   taobao - https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;\n   nj ----- https:&#x2F;&#x2F;registry.nodejitsu.com&#x2F;\n   rednpm - http:&#x2F;&#x2F;registry.mirror.cqupt.edu.cn&#x2F;\n   npmMirror  https:&#x2F;&#x2F;skimdb.npmjs.com&#x2F;registry&#x2F;\n   edunpm - http:&#x2F;&#x2F;registry.enpmjs.org&#x2F; \n   * yg-ui --- http:&#x2F;&#x2F;xxx:4873&#x2F;\n\n   其实nrm只是个npm registry 管理工具，有了它可以让我们切换和查看registry 地址更方便快捷，即便没有它，我们直接用npm的set命令也可以切换地址，用type命令也可以查看地址，只不过用nrm更便捷，用不用随你了，觉得方便就用。\n\n\n发布包\n\n1、新建一个npmtest 目录，里边放一个文件\n2、进入目录 npm init 生成package.json\n3、npm publish           # 第二次发包已经切换到我们私服地址的情况下\n   npm publish --registry http:&#x2F;&#x2F;xxx:4873   #未切换到我们的私服时，直接加后缀可以发布到私服上。\n  第二次发包我们需要npm login 输入用户密码以及邮箱即可（这里需要注意的是\n\n\n下载包\n\n1、新建.npmrc文件\n   registry&#x3D;http:&#x2F;&#x2F;xxx:4873&#x2F;#&#x2F;detail&#x2F;ui-test\n   &#x2F;&#x2F;xxx&#x2F;:_authToken&#x3D;&quot;EF+Q227aTInBu2cvmkDyiozkm&#x2F;Z&#x2F;nOz9m1mWK&#x2F;PlgoA&#x3D;&quot;\n   &#x2F;&#x2F;localhost:4873&#x2F;:_authToken&#x3D;&quot;OTmT9IjKXStdvRwV8RRf6g&#x3D;&#x3D;&quot;\n   package-lock&#x3D;false\n   npm config edit  可以查看到_authToken\n2、npm install npmtest --save\n\n   这个命令是默认下载当前定位文件夹下package.json文件中需要的所有包，包括其间接依赖的包。第一次下载\n\n   之后的包都会缓存在我们的私服上，然后后期下载的时候从私服下载，就不会再从npmjs上下载包，但是它下\n\n   载每个包的时候都会再走一遍npmjs去检查包的版本，即便不下载资源，但这无疑也浪费了时间。经验证发\n\n   现，我们的package-lock.json文件在此刻起了大作用，因为package-lock.json文件本来就是更新node库后自\n\n   动生成的文件，里面包含了node库中所有包的下载地址当前版本以及包之间的依赖关系，既然package-\n\n   lock.json稳定了版本，所以当我们项目中包含了这个文件时，我们下包时就会根据package-lock.json的稳定版\n\n   本来，就不会再去npmjs上去检查了，这样会极大的提升下载包的速度。所以项目中一定要有稳定的\n\n   package.json和package-lock.json文件，并及时更新这两个文件。\n   package.json里边配置\n   &quot;publishConfig&quot;: &#123;\n     &quot;registry&quot;: &quot;http:&#x2F;&#x2F;xxx&#x2F;repository&#x2F;npmself&#x2F;&quot;\n   &#125;,\n\n\n删除包\n\n$ cd &#x2F;home&#x2F;yg&#x2F;.config&#x2F;verdaccio\n$ ls \nconfig.yaml  htpasswd  storage\n$ cd storage\n$ ls\n$ rm -rf  ui-test\n\n","slug":"node/base/Node基础十二","date":"2022-10-01T04:32:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"52153482f8bb5490978c774dade2918c","title":"Node基础十一","content":"十一.koa开发web服务器Koa初体验1.1. 认识Koa前面我们已经学习了express，另外一个非常流行的Node Web服务器框架就是Koa。\nKoa官方的介绍：\n\nkoa：next generation web framework for node.js；\nkoa：node.js的下一代web框架；\n\n事实上，koa是express同一个团队开发的一个新的Web框架：\n\n目前团队的核心开发者TJ的主要精力也在维护Koa，express已经交给团队维护了；\nKoa旨在为Web应用程序和API提供更小、更丰富和更强大的能力；\n相对于express具有更强的异步处理能力（后续我们再对比）；\nKoa的核心代码只有1600+行，是一个更加轻量级的框架，我们可以根据需要安装和使用中间件；\n\n1.2. koa初体验因为学习过了express，它们的基本开发模式是比较相似的。\n我们来体验一下koa的Web服务器：\nconst Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(&quot;middleware 01&quot;);\n  next();\n&#125;)\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(&quot;middleware 02&quot;);\n  ctx.response.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动成功~&quot;);\n&#125;);\n\nkoa注册的中间件提供了两个参数：\n\nctx：上下文（Context）对象；\n\n\nkoa并没有像express一样，将req和res分开，而是将它们作为ctx的属性；\n\n\nctx代表依次请求的上下文对象；\n\nctx.request：获取请求对象；\n\nctx.response：获取响应对象；\n\nnext：本质上是一个dispatch，类似于之前的next；\n\n\n后续我们学习Koa的源码，来看一下它是一个怎么样的函数；\n\n\n\nkoa通过创建的app对象，注册中间件只能通过use方法：\n\nKoa并没有提供methods的方式来注册中间件；\n也没有提供path中间件来匹配路径；\n\n但是真实开发中我们如何将路径和method分离呢？\n\n方式一：根据request自己来判断；\n方式二：使用第三方路由中间件；\n\n方式一：根据request自己判断\napp.use((ctx, next) &#x3D;&gt; &#123;\n  if (ctx.request.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;users&#39;) &#123;\n    if (ctx.request.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      ctx.response.body &#x3D; &quot;Create User Success~&quot;;\n    &#125; else &#123;\n      ctx.response.body &#x3D; &quot;Users List~&quot;;\n    &#125;\n  &#125; else &#123;\n    ctx.response.body &#x3D; &quot;Other Request Response&quot;;\n  &#125;\n&#125;)\n\n整个代码的逻辑是非常复杂和混乱的，真实开发中我们会使用路由。\n1.3. 路由的使用koa官方并没有给我们提供路由的库，我们可以选择第三方库：koa-router\n1.3.1. 安装koa-router因为是第三方的库，所以我们需要单独下项目中安装：\nnpm install koa-router\n\n1.3.2. koa-router基本使用我们可以先封装一个 user.router.js 的文件：\nconst Router &#x3D; require(&#39;koa-router&#39;);\n\nconst userRouter &#x3D; new Router();\n\nuserRouter.get(&#39;&#x2F;users&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;user list~&quot;;\n&#125;);\n\nuserRouter.post(&#39;&#x2F;users&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;create user info~&quot;;\n&#125;);\n\nmodule.exports &#x3D; userRouter;\n\n在app中将router.routes()注册为中间件：\napp.use(userRouter.routes());\napp.use(userRouter.allowedMethods());\n\n注意：allowedMethods用于判断某一个method是否支持：\n\n如果我们请求 get，那么是正常的请求，因为我们有实现get；\n如果我们请求 put、delete、patch，那么就自动报错：Method Not Allowed，状态码：405；\n如果我们请求 link、copy、lock，那么就自动报错：Not Implemented，状态码：501；\n\n1.3.3. router的前缀通常一个路由对象是对一组相似路径的封装，那么路径的前缀都是一直的，所以我们可以直接在创建Router时，添加前缀：\nconst userRouter &#x3D; new Router(&#123;prefix: &#39;&#x2F;users&#39;&#125;);\n\nuserRouter.get(&#39;&#x2F;&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;user list~&quot;;\n&#125;);\n\nuserRouter.post(&#39;&#x2F;&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;create user info~&quot;;\n&#125;);\n\nmodule.exports &#x3D; userRouter;\n\n1.4. 请求解析客户端传递到服务器参数的方法常见的是5种：\n\n方式一：通过get请求中的URL的params；\n方式二：通过get请求中的URL的query；\n方式三：通过post请求中的body的json格式；\n方式四：通过post请求中的body的x-www-form-urlencoded格式；\n方式五：通过post请求中的form-data格式；\n\n1.4.1. 方式一：params请求地址：http://localhost:8000/users/123\n获取params：\nconst userRouter &#x3D; new Router(&#123;prefix: &quot;&#x2F;users&quot;&#125;)\n\nuserRouter.get(&quot;&#x2F;:id&quot;, (ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.params.id);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.2. 方式二：query请求地址：http://localhost:8000/login?username=why&amp;password=123\n获取query：\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.query);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.3. 方式三：json请求地址：http://localhost:8000/login\nbody是json格式：\n&#123;\n    &quot;username&quot;: &quot;coderwhy&quot;,\n    &quot;password&quot;: &quot;123&quot;\n&#125;\n\n获取json数据：\n\n安装依赖：npm install koa-bodyparser;\n使用 koa-bodyparser的中间件；\n\napp.use(bodyParser());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.4. 方式四：x-www-form-urlencoded请求地址：http://localhost:8000/login\nbody是x-www-form-urlencoded格式：\nx-www-form-urlencoded\n获取json数据：(和json是一致的)\n\n安装依赖：npm install koa-bodyparser;\n使用 koa-bodyparser的中间件；\n\napp.use(bodyParser());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.5. 方式五：form-data请求地址：http://localhost:8000/login\nbody是form-data格式：\nform-data\n解析body中的数据，我们需要使用multer\n\n安装依赖：npm install koa-multer;\n使用 multer中间件；\n\nconst upload &#x3D; multer(&#123;\n&#125;);\n\napp.use(upload.any());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.req.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;);\n\n我们知道multer还可以实现文件的上传：\nconst storage &#x3D; multer.diskStorage(&#123;\n  destination: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, &quot;.&#x2F;uploads&#x2F;&quot;)\n  &#125;,\n  filename: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, Date.now() + path.extname(file.originalname))\n  &#125;\n&#125;)\n\nconst upload &#x3D; multer(&#123;\n  storage\n&#125;);\n\nconst fileRouter &#x3D; new Router();\n\nfileRouter.post(&quot;&#x2F;upload&quot;, upload.single(&#39;avatar&#39;), (ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.req.file);\n&#125;)\n\napp.use(fileRouter.routes());\n\n1.5. 响应方式输出结果：body\n将响应主体设置为以下之一：\n\nstring ：字符串数据\nBuffer ：Buffer数据\nStream ：流数据\nObject|| Array：对象或者数组\nnull ：不输出任何内容\n\n如果response.status尚未设置，Koa会自动将状态设置为200或204。\n比较常见的输出方式：\nctx.response.body &#x3D; &quot;Hello World&quot;;\nctx.body &#x3D; &#123;\n  name: &quot;why&quot;,\n  age: 18,\n  height: 1.88\n&#125;;\nctx.body &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];\n\n疑惑：ctx.response.body和ctx.body之间的区别：\n\n事实上，我们访问ctx.body时，本质上是访问ctx.response.body；\n我们可以看到源码中，我们访问 proto（这里就是ctx），其实是访问proto中的response的属性；\n\nimage-20201104155927483\n请求状态：status\n请求状态我们可以直接给ctx设置，或者给ctx.response设置也是一样的效果：\nctx.status &#x3D; 201;\nctx.response.status &#x3D; 204;\n\n1.6. 错误处理const Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  ctx.app.emit(&#39;error&#39;, new Error(&quot;哈哈哈&quot;), ctx);\n&#125;)\n\napp.on(&#39;error&#39;, (err, ctx) &#x3D;&gt; &#123;\n  console.log(err.message);\n  ctx.response.body &#x3D; &quot;哈哈哈&quot;;\n&#125;)\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;错误处理服务启动成功~&quot;);\n&#125;)\n\n1.7. 静态服务器koa并没有内置部署相关的功能，所以我们需要使用第三方库：\nnpm install koa-static\n\n部署的过程类似于express：\nconst Koa &#x3D; require(&#39;koa&#39;);\nconst static &#x3D; require(&#39;koa-static&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use(static(&#39;.&#x2F;build&#39;));\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;静态服务器启动成功~&quot;);\n&#125;);\n\n1.8. 源码解析视频里面有讲解，这里不再截图\n二. 和express对比在学习了两个框架之后，我们应该已经可以发现koa和express的区别：\n从架构设计上来说：\n\nexpress是完整和强大的，其中帮助我们内置了非常多好用的功能；\n\nkoa是简洁和自由的，它只包含最新的功能，并不会对我们使用其他中间件进行任何的限制。\n\n\n甚至是在app中连最基本的get、post都没有给我们提供；\n\n\n我们需要通过自己或者路由来判断请求方式或者其他功能；\n\n\n因为express和koa框架他们的核心其实都是中间件：\n\n但是他们的中间件事实上，它们的中间件的执行机制是不同的，特别是针对某个中间件中包含异步操作时；\n所以，接下来，我们再来研究一下express和koa中间件的执行顺序问题；\n\n我通过一个需求来演示所有的过程：\n\n假如有三个中间件会在一次请求中匹配到，并且按照顺序执行；\n\n我希望最终实现的方案是：\n\n\n注意：是middleware1中；\n\n\n在middleware1中，在req.message中添加一个字符串 aaa；\n\n在middleware2中，在req.message中添加一个 字符串bbb；\n\n在middleware3中，在req.message中添加一个 字符串ccc；\n\n当所有内容添加结束后，在middleware1中，通过res返回最终的结果；\n\n\n2.1. 同步执行顺序假如我们获取的所有数据，是可以同步获取的；\n我们先通过express实现这个过程：\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\n\nconst middleware1 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;ccc&#39;;\n&#125;\n\napp.use(middleware1, middleware2, middleware3);\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;启动成功~&quot;);\n&#125;)\n\n最终的结果是：aaabbbccc，没问题；\n我们再通过koa实现这个过程：\nconst Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\nconst middleware1 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  next();\n  console.log(&quot;aaaa&quot;);\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  console.log(&quot;bbbb&quot;);\n  next();\n&#125;\n\nconst middleware3 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;ccc&#39;;\n&#125;\n\napp.use(middleware1);\napp.use(middleware2);\napp.use(middleware3);\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;启动成功~&quot;);\n&#125;)\n\n最终的结果也是：aaabbbccc，也没问题；\n2.2. 异步执行顺序但是，如果我们最后的ccc中的结果，是需要异步操作才能获取到的，是否会产生问题呢？\n2.2.1. express中遇到异步操作express有异步操作（没有在next前，加async、await）：\nconst middleware1 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  req.message &#x3D; req.message + result.data.lrc.lyric;\n  console.log(req.message);\n&#125;\n\n最终的结果aaabbb，是不正确。\nexpress有异步操作（有在next前，加async、await）：\nconst middleware1 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  await next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  await next();\n&#125;\n\nconst middleware3 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  req.message &#x3D; req.message + result.data.lrc.lyric;\n  console.log(req.message);\n&#125;\n\n最终的结果也是aaabbb，也是不正确。\n为什么呢？\n\n原因是本质上的next()和异步没有任何关系；\n它本身就是一个同步函数的调用，所以它不会等到你异步有结果之后，再继续执行后续的操作；\n\nimage-20201106175205300\n2.2.2. koa中遇到异步操作koa有异步操作（没有在next前，加async、await）：\nconst middleware1 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  next();\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  ctx.message &#x3D; ctx.message + result.data.lrc.lyric;\n&#125;\n\n最终的结果也是aaabbb，也是不正确。\n\n这是因为虽然next函数是一个返回promise的异步操作，但是在前面不加await的情况，是不同等待结果的返回，就会继续向后执行了；\n\nkoa有异步操作（有在next前，加async、await）：\nconst middleware1 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  await next();\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  await next();\n&#125;\n\nconst middleware3 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  ctx.message &#x3D; ctx.message + result.data.lrc.lyric;\n&#125;\n\n最终的结果是aaabbb+歌词信息，是正确。\n\n这是因为，当我们在koa中的next前面加await时，它会等到后续有一个确定结果时，在执行后续的代码；\n\n","slug":"node/base/Node基础十一","date":"2022-10-01T04:31:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"c2943d2fce9c96d8a973d43b491afc6a","title":"Node基础十","content":"十.express开发web服务器Express初体验1.1. 认识Web框架前面我们已经学习了使用http内置模块来搭建Web服务器，为什么还要使用框架？\n\n原生http在进行很多处理时，会较为复杂；\n有URL判断、Method判断、参数处理、逻辑代码处理等，都需要我们自己来处理和封装；\n并且所有的内容都放在一起，会非常的混乱；\n\n目前在Node中比较流行的Web服务器框架是express、koa；\n\n我们先来学习express，后面再学习koa，并且对他们进行对比；\n\nexpress早于koa出现，并且在Node社区中迅速流行起来：\n\n我们可以基于express快速、方便的开发自己的Web服务器；\n并且可以通过一些实用工具和中间件来扩展自己功能；\n\nexpress中文网连接: https://www.expressjs.com.cn/\n1.2. express的安装express的使用过程有两种方式：\n\n方式一：通过express提供的脚手架，直接创建一个应用的骨架；\n方式二：从零搭建自己的express应用结构；\n\n方式一：安装express-generator\nnpm install -g express-generator\n\n创建项目：\nexpress express-demo\n\n项目目录如下：\n├── app.js\n├── bin\n│   └── www\n├── package-lock.json\n├── package.json\n├── public\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes\n│   ├── index.js\n│   └── users.js\n└── views\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n\n我们可以安装依赖，将程序跑起来：\nnpm install\nnode bin&#x2F;www\n\n方式二：从零学习搭建\n刚才创建的项目express项目，很多内容可能我们并不认识，所以刚开始我们最好从零来学习。\n初始化一个新的项目\nnpm init -y\n\nexpress的安装：\n\n目前最新的 release 版本是4.17.1，我们使用该版本；\n\nnpm install express\n\n1.3. express初体验我们来创建自己的第一个express程序：\nconst express &#x3D; require(&#39;express&#39;);\n\n&#x2F;&#x2F; 创建服务器\nconst app &#x3D; express();\n\n&#x2F;&#x2F; &#x2F;home的get请求处理\napp.get(&quot;&#x2F;home&quot;, (req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Home&quot;);\n&#125;);\n\n&#x2F;&#x2F; &#x2F;login的post请求处理\napp.post(&quot;&#x2F;login&quot;, (req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Login&quot;);\n&#125;);\n\n&#x2F;&#x2F; 开启监听\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动成功~&quot;);\n&#125;)\n\n我们会发现，之后的开发过程中，可以方便的将请求进行分离：\n\n无论是不同的URL，还是get、post等请求方式；\n这样的方式非常方便我们已经进行维护、扩展；\n\n当然，这只是初体验，接下来我们来探索更多的用法；\n1.4. 请求和响应请求的路径中如果有一些参数，可以这样表达：\n\n/users/:userId；\n在request对象中要获取可以通过 req.params.userId;\n\n返回数据，我们可以方便的使用json：\n\nres.json(数据)方式；\n可以支持其他的方式，可以自行查看文档；\nhttps://www.expressjs.com.cn/guide/routing.html\n\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\napp.get(&#39;&#x2F;users&#x2F;:userId&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.params.userId);\n  res.json(&#123;username: &quot;coderwhy&quot;, level: 99&#125;);\n&#125;);\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;静态服务器启动成功~&quot;);\n&#125;)\n\n二. Express中间件2.1. 认识中间件Express是一个路由和中间件的Web框架，它本身的功能非常少：\n\nExpress应用程序本质上是一系列中间件函数的调用；\n\n中间件是什么呢？\n\n中间件的本质就是一个回调函数；\n\n这个回调函数接受三个参数：\n\n\n请求对象（request对象）；\n\n\n响应对象（response对象）；\n\nnext函数（在express中定义的用于执行下一个中间件的函数）；\n\n\n中间件中可以执行哪些任务呢？\n\n执行任何代码；\n更改请求（request）和响应（response）对象；\n结束请求-响应周期（返回数据）；\n调用栈中的下一个中间件；\n\n如果当前中间件功能没有结束请求-响应周期，则必须调用next()将控制权传递给下一个中间件功能，否则，请求将被挂起。\n中间件函数调用的元素：\nimage-20201101205333843\n2.2. 应用中间件那么，如何将一个中间件应用到我们的应用程序中呢？\n\nexpress主要提供了两种方式：app/router.use和app/router.methods；\n可以是 app，也可以是router，router我们后续再学习:\nmethods指的是常用的请求方式，比如：app.get或app.post等；\n\n我们先来学习use的用法，因为methods的方式本质是use的特殊情况；\n案例一：最普通的中间件\n之所以称之为最普通的中间件，是因为无论是什么path、methods都会应用该中间件；\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware 01&quot;);\n  next();\n&#125;)\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware 02&quot;);\n  res.end(&quot;Hello Common Middleware~&quot;);\n&#125;)\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;中间件服务器启动成功~&quot;);\n&#125;)\n\n中间件的执行顺序：\n\n在匹配上的情况下，中间件按照注册的顺序执行；\n\n案例二：path匹配中间件\n如果我们希望匹配一个明确的路径，也可以使用use方法：\n&#x2F;&#x2F; 案例二: 路径匹配中间件\napp.use(&#39;&#x2F;home&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;home middleware 01&quot;);\n  next();\n&#125;);\n\napp.use(&#39;&#x2F;home&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;home middleware 02&quot;);\n  next();\n  res.end(&quot;Hello Home middleware&quot;);\n&#125;);\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware&quot;);\n&#125;);\n\n案例三：path和method匹配中间件\n&#x2F;&#x2F; 案例三: method匹配中间件\napp.get(&#39;&#x2F;home&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;home get middleware&quot;);\n  next();\n&#125;)\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;login post middleware&quot;);\n  next();\n&#125;);\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware&quot;);\n&#125;);\n\n案例四：注册多个中间件\n&#x2F;&#x2F; 案例四: 注册多个中间件\nconst homeMiddleware1 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  console.log(&#39;home middleware 01&#39;);\n  next();\n&#125;\n\nconst homeMiddleware2 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  console.log(&#39;home middleware 02&#39;);\n  next();\n&#125;\n\nconst homeHandle &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Home~&quot;);\n&#125;\n\napp.get(&#39;&#x2F;home&#39;, homeMiddleware1, homeMiddleware2, homeHandle);\n\n2.3. 应用其他中间件并非所有的中间件都需要我们从零去编写：\n\nexpress有内置一些帮助我们完成对request解析的中间件；\nregistry仓库中也有很多可以辅助我们开发的中间件；\n\n2.3.1. request解析中间件在客户端发送post请求时，会将数据放到body中：\n\n客户端可以通过json的方式传递；\n也可以通过form表单的方式传递；\n\n我们这里先使用json传递给服务器body：\njson传递body\n不进行解析时的操作：\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  req.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n    console.log(data.toString());\n  &#125;)\n  req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n    res.end(&quot;登录成功~&quot;);\n  &#125;);\n&#125;);\n\n我们也可以自己编写中间件来解析JSON：\napp.use((req, res, next) &#x3D;&gt; &#123;\n  if (req.headers[&#39;content-type&#39;] &#x3D;&#x3D;&#x3D; &#39;application&#x2F;json&#39;) &#123;\n    req.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n      const userInfo &#x3D; JSON.parse(data.toString());\n      req.body &#x3D; userInfo;\n    &#125;)\n    req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n      next();\n    &#125;)\n  &#125; else &#123;\n    next();\n  &#125;\n&#125;)\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n  res.end(&quot;登录成功~&quot;);\n&#125;);\n\n但是，事实上我们可以使用express内置的中间件或者使用body-parser来完成：\napp.use(express.json());\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n  res.end(&quot;登录成功~&quot;);\n&#125;);\n\n如果我们解析的是 application/x-www-form-urlencoded：\nform传递body\n我们可以使用express自带的 urlencoded函数来作为中间件：\n\n传入的extended用于表示使用哪一种解析方式：\n\n\ntrue：使用qs第三方模块；\n\n\nfalse：使用querystring内置模块；\n\n备注：它们之间的区别这里不展开讲解；\n\n\napp.use(express.json());\napp.use(express.urlencoded(&#123;extended: true&#125;));\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n  res.end(&quot;登录成功~&quot;);\n&#125;);\n\n2.3.2. 日志记录中间件如果我们希望将请求日志记录下来，那么可以使用express官网开发的第三方库：morgan\n安装morgan：\nnpm install morgan\n\n直接作为中间件使用即可：\nconst loggerWriter &#x3D; fs.createWriteStream(&#39;.&#x2F;log&#x2F;access.log&#39;, &#123;\n  flags: &#39;a+&#39;\n&#125;)\napp.use(morgan(&#39;combined&#39;, &#123;stream: loggerWriter&#125;));\n\n2.3.3. 上传文件中间件图片上传我们可以使用express官方开发的第三方库：multer\nnpm install multer\n\n上传文件，并且默认文件名：\nconst upload &#x3D; multer(&#123;\n  dest: &quot;uploads&#x2F;&quot;\n&#125;)\n\napp.post(&#39;&#x2F;upload&#39;, upload.single(&#39;file&#39;), (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.file.buffer);\n  res.end(&quot;文件上传成功~&quot;);\n&#125;)\n\n添加文件名后缀：\nconst storage &#x3D; multer.diskStorage(&#123;\n  destination: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, &quot;uploads&#x2F;&quot;)\n  &#125;,\n  filename: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, Date.now() + path.extname(file.originalname));\n  &#125;\n&#125;)\n\nconst upload &#x3D; multer(&#123;\n  storage\n&#125;)\n\napp.post(&#39;&#x2F;upload&#39;, upload.single(&#39;file&#39;), (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.file.buffer);\n  res.end(&quot;文件上传成功~&quot;);\n&#125;)\n\n我们也可以上传多张图片：\napp.use(&#39;&#x2F;upload&#39;, upload.array(&#39;files&#39;), (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.files);\n&#125;);\n\n如果我们希望借助于multer帮助我们解析一些form-data中的普通数据，那么我们可以使用any：\n\n请求如下：\n\nimage-20201104165039444\napp.use(upload.any());\n\napp.use(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n&#125;);\n\n2.4. 请求和响应客户端传递到服务器参数的方法常见的是5种：\n\n方式一：通过get请求中的URL的params；\n方式二：通过get请求中的URL的query；\n方式三：通过post请求中的body的json格式（中间件中已经使用过）；\n方式四：通过post请求中的body的x-www-form-urlencoded格式（中间件使用过）；\n方式五：通过post请求中的form-data格式（中间件中使用过）；\n\n2.4.1. 请求解析方式一：params\n请求地址：http://localhost:8000/login/abc/why\n获取参数：\napp.use(&#39;&#x2F;login&#x2F;:id&#x2F;:name&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.params);\n  res.json(&quot;请求成功~&quot;);\n&#125;)\n\n方式二：query\n请求地址：http://localhost:8000/login?username=why&amp;password=123\n获取参数：\napp.use(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.query);\n\n  res.json(&quot;请求成功~&quot;);\n&#125;)\n\n2.4.2. 响应方式end方法\n类似于http中的response.end方法，用法是一致的\nres.end(&quot;Hello World&quot;);\n\njson方法\njson方法中可以传入很多的类型：object、array、string、boolean、number、null等，它们会被转换成json格式返回；\nres.json(&#123;name: &quot;why&quot;, age: 18&#125;);\n\nstatus方法\n用于设置状态码：\nres.status(204);\n\n三. 其他支持补充3.1. 路由的使用如果我们将所有的代码逻辑都写在app中，那么app会变得越来越复杂：\n\n一方面完整的Web服务器包含非常多的处理逻辑；\n\n另一方面有些处理逻辑其实是一个整体，我们应该将它们放在一起：比如对users相关的处理\n\n\n获取用户列表；\n\n\n获取某一个用户信息；\n\n创建一个新的用户；\n\n删除一个用户；\n\n更新一个用户；\n\n\n我们可以使用 express.Router来创建一个路由处理程序：\n\n一个Router实例拥有完整的中间件和路由系统；\n因此，它也被称为 迷你应用程序（mini-app）；\n\n&#x2F;&#x2F; 用户相关的处理\nconst userRouter &#x3D; express.Router();\n\nuserRouter.get(&#39;&#x2F;&#39;, (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;用户列表&quot;);\n&#125;);\n\nuserRouter.post(&#39;&#x2F;&#39;, (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;创建用户&quot;);\n&#125;);\n\nuserRouter.delete(&#39;&#x2F;&#39;, (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;删除用户&quot;);\n&#125;);\n\napp.use(&#39;&#x2F;users&#39;, userRouter);\n\n当然，我们可以配置更多的路由，并且将所有的逻辑放到一个单独的文件中。\n3.2. 静态资源服务器部署静态资源我们可以选择很多方式：\n\nNode也可以作为静态资源服务器，并且express给我们提供了方便部署静态资源的方法；\n\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\napp.use(express.static(&#39;.&#x2F;build&#39;));\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;静态服务器启动成功~&quot;);\n&#125;)\n\n3.3. 错误处理方式app.use((req, res, next) &#x3D;&gt; &#123;\n  next(new Error(&quot;USER DOES NOT EXISTS&quot;));\n&#125;);\n\napp.use((err, req, res, next) &#x3D;&gt; &#123;\n  const message &#x3D; err.message;\n\n  switch (message) &#123;\n    case &quot;USER DOES NOT EXISTS&quot;:\n      res.status(400).json(&#123;message&#125;)\n  &#125;\n\n  res.status(500)\n&#125;)\n\n3.4. 源码分析3.4.1. 创建app的过程express函数的本质其实是createApplication：\nimage-20201102161803339\n当我们调用app.listen的时候，本质上是调用proto中的listen\n\n因为上面有进行 mixin 的操作；\n\nimage-20201102161939032\n3.4.2. 注册中间件比如我们通过use来注册一个中间件，源码中发生了什么？\n\n我们会发现无论是app.use还是app.methods都会注册一个主路由；\n我们会发现app本质上会将所有的函数，交给这个主路由去处理的；\n\nimage-20201102162627758\n我们来看一下router.use中又做了什么事情？\n\n本质上一个函数会创建一个layer，并且会被放入到stack中；\n\nimage-20201102162749391\n3.4.3. 请求的处理过程如果有一个请求过来，那么从哪里开始呢？\n\napp函数被调用开始的；\n\nimage-20201102162943190\napp.handle本质上会去调用router.handle：\nimage-20201102163035566\nrouter.handle中做的什么事情呢？\nimage-20201102163153121\nimage-20201102163314862\n","slug":"node/base/Node基础十","date":"2022-10-01T04:30:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"b171402bc406b8e8ddf1dcd5f712137e","title":"Node基础九","content":"九.http开发web服务器\n\n\n\n\n\n\n\n\n什么是Web服务器？\n当应用程序（客户端）需要某一个资源时，可以向一个台服务器，通过Http请求获取到这个资源；提供服务器的这个服务器，就是一个Web服务器；\nWeb服务器\n目前有很多开源的Web服务器：Nginx、Apache（静态）、Apache Tomcat（静态、动态）、Node.js\n一. Http模板基本使用1.1. 如何创建服务1.1.1. Web服务器初体验创建一个Web服务器的初体验：\nconst http &#x3D; require(&#39;http&#39;);\n\nconst HTTP_PORT &#x3D; 8000;\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello World&quot;);\n&#125;);\n\nserver.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&#96;🚀服务器在$&#123;HTTP_PORT&#125;启动~&#96;)\n&#125;)\n\n1.1.2. 创建服务器创建服务器对象，我们是通过 createServer 来完成的\n\nhttp.createServer会返回服务器的对象；\n底层其实使用直接 new Server 对象。\n\nfunction createServer(opts, requestListener) &#123;\n  return new Server(opts, requestListener);\n&#125;\n\n那么，当然，我们也可以自己来创建这个对象：\nconst server2 &#x3D; new http.Server((req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Server2&quot;);\n&#125;);\n\nserver2.listen(9000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动成功~&quot;);\n&#125;)\n\n上面我们已经看到，创建Server时会传入一个回调函数，这个回调函数在被调用时会传入两个参数：\n\nreq：request请求对象，包含请求相关的信息；\nres：response响应对象，包含我们要发送给客户端的信息；\n\n1.1.3. 监听端口和主机Server通过listen方法来开启服务器，并且在某一个主机和端口上监听网络请求：\n\n也就是当我们通过 ip:port的方式发送到我们监听的Web服务器上时；\n我们就可以对其进行相关的处理；\n\nlisten函数有三个参数：\n\n端口port: 可以不传, 系统会默认分配端, 后续项目中我们会写入到环境变量中；\n\n主机host: 通常可以传入localhost、ip地址127.0.0.1、或者ip地址0.0.0.0，默认是0.0.0.0；\n\n\n监听IPV4上所有的地址，再根据端口找到不同的应用程序；\n\n\n比如我们监听 0.0.0.0时，在同一个网段下的主机中，通过ip地址是可以访问的；\n\n正常的数据库包经常 应用层 - 传输层 - 网络层 - 数据链路层 - 物理层 ；\n\n而回环地址，是在网络层直接就被获取到了，是不会经常数据链路层和物理层的；\n\n比如我们监听 127.0.0.1时，在同一个网段下的主机中，通过ip地址是不能访问的；\n\nlocalhost：本质上是一个域名，通常情况下会被解析成127.0.0.1；\n\n127.0.0.1：回环地址（Loop Back Address），表达的意思其实是我们主机自己发出去的包，直接被自己接收；\n\n0.0.0.0：\n\n回调函数：服务器启动成功时的回调函数；\n\n\nserver.listen(() &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动~🚀&quot;);\n&#125;)\n\n1.2. request请求对象在向服务器发送请求时，我们会携带很多信息，比如：\n\n本次请求的URL，服务器需要根据不同的URL进行不同的处理；\n本次请求的请求方式，比如GET、POST请求传入的参数和处理的方式是不同的；\n本次请求的headers中也会携带一些信息，比如客户端信息、接受数据的格式、支持的编码格式等；\n等等…\n\n这些信息，Node会帮助我们封装到一个request的对象中，我们可以直接来处理这个request对象：\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; request对象\n  console.log(req.url);\n  console.log(req.method);\n  console.log(req.headers);\n\n  res.end(&quot;Hello World&quot;);\n&#125;);\n\n1.2.1. URL的处理客户端在发送请求时，会请求不同的数据，那么会传入不同的请求地址：\n\n比如 http://localhost:8000/login；\n比如 http://localhost:8000/products;\n\n服务器端需要根据不同的请求地址，作出不同的响应：\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  const url &#x3D; req.url;\n  console.log(url);\n\n  if (url &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n    res.end(&quot;welcome Back~&quot;);\n  &#125; else if (url &#x3D;&#x3D;&#x3D; &#39;&#x2F;products&#39;) &#123;\n    res.end(&quot;products&quot;);\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);\n\n那么如果用户发送的地址中还携带一些额外的参数呢？\n\nhttp://localhost:8000/login?name=why&amp;password=123;\n这个时候，url的值是 /login?name=why&amp;password=123；\n\n我们如何对它进行解析呢？\n\n使用内置模块url；\n\nconst url &#x3D; require(&#39;url&#39;);\n\n&#x2F;&#x2F; 解析请求\nconst parseInfo &#x3D; url.parse(req.url);\nconsole.log(parseInfo);\n\n解析结果：\nUrl &#123;\n  protocol: null,\n  slashes: null,\n  auth: null,\n  host: null,\n  port: null,\n  hostname: null,\n  hash: null,\n  search: &#39;?name&#x3D;why&amp;password&#x3D;123&#39;,\n  query: &#39;name&#x3D;why&amp;password&#x3D;123&#39;,\n  pathname: &#39;&#x2F;login&#39;,\n  path: &#39;&#x2F;login?name&#x3D;why&amp;password&#x3D;123&#39;,\n  href: &#39;&#x2F;login?name&#x3D;why&amp;password&#x3D;123&#39;\n&#125;\n\n我们会发现 pathname就是我们想要的结果。\n但是 query 信息如何可以获取呢？\n\n方式一：截取字符串；\n方式二：使用querystring内置模块；\n\nconst &#123; pathname, query &#125; &#x3D; url.parse(req.url);\nconst queryObj &#x3D; qs.parse(query);\nconsole.log(queryObj.name);\nconsole.log(queryObj.password);\n\n1.2.2. Method的处理在Restful规范（设计风格）中，我们对于数据的增删改查应该通过不同的请求方式：\n\nGET：查询数据；\nPOST：新建数据；\nPATCH：更新数据；\nDELETE：删除数据；\n\n所以，我们可以通过判断不同的请求方式进行不同的处理。\n比如创建一个用户：\n\n请求接口为 /users；\n请求方式为 POST请求；\n携带数据 username和password；\n\n创建用户请求\n在我们程序中如何进行判断以及获取对应的数据呢？\n\n这里我们需要判断接口是 /users，并且请求方式是POST方法去获取传入的数据；\n获取这种body携带的数据，我们需要通过监听req的 data事件来获取；\n\nif (req.url.indexOf(&#39;&#x2F;users&#39;) !&#x3D;&#x3D; -1) &#123;\n  if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n  \n    &#x2F;&#x2F; 可以设置编码，也可以在下方通过 data.toString() 获取字符串格式\n    req.setEncoding(&#39;utf-8&#39;);\n\n    req.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n      const &#123;username, password&#125; &#x3D; JSON.parse(data);\n      console.log(username, password);\n    &#125;);\n\n    res.end(&quot;create user success&quot;);\n  &#125; else &#123;\n    res.end(&quot;users list&quot;);\n  &#125;\n&#125; else &#123;\n  res.end(&quot;error message&quot;);\n&#125;\n\n将JSON字符串格式转成对象类型，通过JSON.parse方法即可。\n1.2.3. header属性在request对象的header中也包含很多有用的信息：\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  console.log(req.headers);\n\n  res.end(&quot;Hello Header&quot;);\n&#125;);\n\n浏览器会默认传递过来一些信息：\n&#123;\n  &#39;content-type&#39;: &#39;application&#x2F;json&#39;,\n  &#39;user-agent&#39;: &#39;PostmanRuntime&#x2F;7.26.5&#39;,\n  accept: &#39;*&#x2F;*&#39;,\n  &#39;postman-token&#39;: &#39;afe4b8fe-67e3-49cc-bd6f-f61c95c4367b&#39;,\n  host: &#39;localhost:8000&#39;,\n  &#39;accept-encoding&#39;: &#39;gzip, deflate, br&#39;,\n  connection: &#39;keep-alive&#39;,\n  &#39;content-length&#39;: &#39;48&#39;\n&#125;\n\ncontent-type是这次请求携带的数据的类型：\n\napplication/json表示是一个json类型；\ntext/plain表示是文本类型；\napplication/xml表示是xml类型；\nmultipart/form-data表示是上传文件；\n\ncontent-length：\n\n文件的大小和长度\n\nkeep-alive：\n\nhttp是基于TCP协议的，但是通常在进行一次请求和响应结束后会立刻中断；\n\n在http1.0中，如果想要继续保持连接：\n\n\n浏览器需要在请求头中添加 connection: keep-alive；\n\n\n服务器需要在响应头中添加 connection:keey-alive；\n\n当客户端再次放请求时，就会使用同一个连接，直接一方中断连接；\n\n在http1.1中，所有连接默认是 connection: keep-alive的；\n\n\n不同的Web服务器会有不同的保持 keep-alive的时间；\n\n\nNode中默认是5s中；\n\n\naccept-encoding：\n\n告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip编码，对应 .gz文件；\n\naccept：\n\n告知服务器，客户端可接受文件的格式类型；\n\nuser-agent：\n\n客户端相关的信息；\n\n1.3. 响应对象response1.3.1. 返回响应结果如果我们希望给客户端响应的结果数据，可以通过两种方式：\n\nWrite方法：这种方式是直接写出数据，但是并没有关闭流；\nend方法：这种方式是写出最后的数据，并且写出后会关闭流；\n\nconst http &#x3D; require(&#39;http&#39;);\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n\n  &#x2F;&#x2F; 响应数据的方式有两个:\n  res.write(&quot;Hello World&quot;);\n  res.write(&quot;Hello Response&quot;);\n  res.end(&quot;message end&quot;);\n&#125;);\n\nserver.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动🚀~&quot;)\n&#125;);\n\n如果我们没有调用 end和close，客户端将会一直等待结果，所以客户端在发送网络请求时，都会设置超时时间。\n1.3.2. 返回状态码Http状态码（Http Status Code）是用来表示Http响应状态的数字代码：\n\nHttp状态码非常多，可以根据不同的情况，给客户端返回不同的状态码；\n常见的状态码是下面这些（后续项目中，也会用到其中的状态码）；\n\n状态码\n设置状态码常见的有两种方式：\nres.statusCode &#x3D; 400;\nres.writeHead(200);\n\n1.3.3. 响应头文件返回头部信息，主要有两种方式：\n\nres.setHeader：一次写入一个头部信息；\nres.writeHead：同时写入header和status；\n\nres.setHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;utf8&quot;);\n\nres.writeHead(200, &#123;\n  &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;utf8&quot;\n&#125;)\n\nHeader设置 Content-Type有什么作用呢？\n\n默认客户端接收到的是字符串，客户端会按照自己默认的方式进行处理；\n\n比如，我们返回的是一段HTML，但是没有指定格式：\nres.end(&#39;&lt;h2&gt;Hello World&lt;&#x2F;h2&gt;&#39;)\n\nimage-20201030154312050\n但是，如果我们指定了格式：\nres.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html;charset&#x3D;utf8&quot;);\nres.end(&#39;&lt;h2&gt;Hello World&lt;&#x2F;h2&gt;&#39;)\n\nimage-20201030154404172\n如果我们希望返回一段JSON数据，应该怎么做呢？\nres.writeHead(200, &#123;\n  &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;utf8&quot;\n&#125;)\n\nconst data &#x3D; &#123;\n  name: &quot;王红元&quot;,\n  age: 18,\n  height: 1.88\n&#125;;\n\nres.end(JSON.stringify(data));\n\n二. Web其他补充2.1. 文件上传的使用如果是一个很大的文件需要上传到服务器端，服务器端进行保存应该如何操作呢？\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;upload&#39;) &#123;\n    if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      const fileWriter &#x3D; fs.createWriteStream(&#39;.&#x2F;foo.png&#39;);\n      req.pipe(fileWriter);\n\n      const fileSize &#x3D; req.headers[&#39;content-length&#39;];\n      let curSize &#x3D; 0;\n      console.log(fileSize);\n\n      req.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n        curSize +&#x3D; data.length;\n        console.log(curSize);\n        res.write(&#96;文件上传进度: $&#123;curSize&#x2F;fileSize * 100&#125;%\\n&#96;);\n      &#125;);\n\n      req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n        res.end(&quot;文件上传完成~&quot;);\n      &#125;)\n    &#125;\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);\n\n这个时候我们发现文件上传成功了，但是文件却打不开：\n\n这是因为我们写入的数据，里面包含一些特殊的信息；\n这些信息打开的软件并不能很好的解析；\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;upload&#39;) &#123;\n    if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      &#x2F;&#x2F; 图片文件必须设置为二进制的\n      req.setEncoding(&#39;binary&#39;);\n\n      &#x2F;&#x2F; 获取content-type中的boundary的值\n      var boundary &#x3D; req.headers[&#39;content-type&#39;].split(&#39;; &#39;)[1].replace(&#39;boundary&#x3D;&#39;,&#39;&#39;);\n      \n      &#x2F;&#x2F; 记录当前数据的信息\n      const fileSize &#x3D; req.headers[&#39;content-length&#39;];\n      let curSize &#x3D; 0;\n      let body &#x3D; &#39;&#39;;\n\n      &#x2F;&#x2F; 监听当前的数据\n      req.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n        curSize +&#x3D; data.length;\n        res.write(&#96;文件上传进度: $&#123;curSize&#x2F;fileSize * 100&#125;%\\n&#96;);\n        body +&#x3D; data;\n      &#125;);\n\n      &#x2F;&#x2F; 数据结构\n      req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 切割数据\n        const payload &#x3D; qs.parse(body, &quot;\\r\\n&quot;, &quot;:&quot;);\n        &#x2F;&#x2F; 获取最后的类型(image&#x2F;png)\n        const fileType &#x3D; payload[&quot;Content-Type&quot;].substring(1);\n        &#x2F;&#x2F; 获取要截取的长度\n        const fileTypePosition &#x3D; body.indexOf(fileType) + fileType.length;\n        let binaryData &#x3D; body.substring(fileTypePosition);\n        binaryData &#x3D; binaryData.replace(&#x2F;^\\s\\s*&#x2F;, &#39;&#39;);\n\n        &#x2F;&#x2F; binaryData &#x3D; binaryData.replaceAll(&#39;\\r\\n&#39;, &#39;&#39;);\n        const finalData &#x3D; binaryData.substring(0, binaryData.indexOf(&#39;--&#39;+boundary+&#39;--&#39;));\n\n        fs.writeFile(&#39;.&#x2F;boo.png&#39;, finalData, &#39;binary&#39;, (err) &#x3D;&gt; &#123;\n          console.log(err);\n          res.end(&quot;文件上传完成~&quot;);\n        &#125;)\n      &#125;)\n    &#125;\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);\n\n2.2. http发送网络请求axios库可以在浏览器中使用，也可以在Node中使用：\n\n在浏览器中，axios使用的是封装xhr；\n在Node中，使用的是http内置模块；\n\n所以http模块是可以在Node中直接发送网络请求的。\n发送get请求：\nhttp.get(&quot;http:&#x2F;&#x2F;localhost:8000&quot;, (res) &#x3D;&gt; &#123;\n  res.on(&#39;data&#39;, data &#x3D;&gt; &#123;\n    console.log(data.toString());\n    console.log(JSON.parse(data.toString()));\n  &#125;)\n&#125;);\n\n发送post请求：\nconst req &#x3D; http.request(&#123;\n  method: &#39;POST&#39;,\n  hostname: &quot;localhost&quot;,\n  port: 8000\n&#125;, (res) &#x3D;&gt; &#123;\n  res.on(&#39;data&#39;, data &#x3D;&gt; &#123;\n    console.log(data.toString());\n    console.log(JSON.parse(data.toString()));\n  &#125;)\n&#125;)\n\nreq.on(&#39;error&#39;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\n\nreq.end();\n","slug":"node/base/Node基础九","date":"2022-10-01T04:29:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"adefcce4d4f2d80811a82b2ac8c91417","title":"Node基础八","content":"八. 深入事件循环事件循环是什么？事实上我把事件循环理解成我们编写的JavaScript和浏览器或者Node之间的一个桥梁。\n浏览器的事件循环是一个我们编写的JavaScript代码和浏览器API调用(setTimeout&#x2F;AJAX&#x2F;监听事件等)的一个桥梁, 桥梁之间他们通过回调函数进行沟通。\nNode的事件循环是一个我们编写的JavaScript代码和系统调用（file system、network等）之间的一个桥梁, 桥梁之间他们通过回调函数进行沟通的.\n浏览器的事件循环1.1. 进程和线程线程和进程是操作系统中的两个概念：\n\n进程（process）：计算机已经运行的程序；\n线程（thread）：操作系统能够运行运算调度的最小单位；\n\n听起来很抽象，我们直观一点解释：\n\n进程：我们可以认为，启动一个应用程序，就会默认启动一个进程（也可能是多个进程）；\n线程：每一个进程中，都会启动一个线程用来执行程序中的代码，这个线程被称之为主线程；\n所以我们也可以说进程是线程的容器；\n\n再用一个形象的例子解释：\n\n操作系统类似于一个工厂；\n工厂中里有很多车间，这个车间就是进程；\n每个车间可能有一个以上的工人在工厂，这个工人就是线程；\n\n操作系统、线程、进程\n操作系统是如何做到同时让多个进程（边听歌、边写代码、边查阅资料）同时工作呢？\n\n这是因为CPU的运算速度非常快，它可以快速的在多个进程之间迅速的切换；\n当我们的进程中的线程获取获取到时间片时，就可以快速执行我们编写的代码；\n对于用于来说是感受不到这种快速的切换的；\n\n你可以在Mac的活动监视器或者Windows的资源管理器中查看到很多进程：\n活动监视器\n1.2. 浏览器和JavaScript我们经常会说JavaScript是单线程的，但是JavaScript的线程应该有自己的容器进程：浏览器或者Node。\n浏览器是一个进程吗，它里面只有一个线程吗？\n\n目前多数的浏览器其实都是多进程的，当我们打开一个tab页面时就会开启一个新的进程，这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出；\n每个进程中又有很多的线程，其中包括执行JavaScript代码的线程；\n\n但是JavaScript的代码执行是在一个单独的线程中执行的：\n\n这就意味着JavaScript的代码，在同一个时刻只能做一件事；\n如果这件事是非常耗时的，就意味着当前的线程就会被阻塞；\n\n分析下面代码的执行过程：\n\n定义变量name；\n执行log函数，函数会被放入到调用栈中执行；\n调用bar()函数，被压入到调用栈中，但是执行未结束；\nbar因为调用了sum，sum函数被压入到调用栈中，获取到结果后出栈；\nbar获取到结果后出栈，获取到结果result；\n将log函数压入到调用栈，log被执行，并且出栈；\n\nconst name &#x3D; &quot;coderwhy&quot;;\n\n&#x2F;&#x2F; 1.将该函数放入到调用栈中被执行\nconsole.log(name);\n\n&#x2F;&#x2F; 2. 调用栈\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nfunction bar() &#123;\n  return sum(20, 30);\n&#125;\n\nconsole.log(bar());\n\n1.3. 浏览器的事件循环如果在执行JavaScript代码的过程中，有异步操作呢？\n\n中间我们插入了一个setTimeout的函数调用；\n这个函数被放到入调用栈中，执行会立即结束，并不会阻塞后续代码的执行；\n\nconst name &#x3D; &quot;coderwhy&quot;;\n\n&#x2F;&#x2F; 1.将该函数放入到调用栈中被执行\nconsole.log(name);\n\n&#x2F;&#x2F; 2.调用栈\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nfunction bar() &#123;\n  return sum(20, 30);\n&#125;\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;settimeout&quot;);\n&#125;, 1000);\n\nconst result &#x3D; bar();\n\nconsole.log(result);\n\n那么，传入的一个函数（比如我们称之为timer函数），会在什么时候被执行呢？\n\n事实上，setTimeout是调用了web api，在合适的时机，会将timer函数加入到一个事件队列中；\n事件队列中的函数，会被放入到调用栈中，在调用栈中被执行；\n\n浏览器的事件循环\n1.4. 宏任务和微任务但是事件循环中并非只维护着一个队列，事实上是有两个队列：\n\n宏任务队列（macrotask queue）：ajax、setTimeout、setInterval、DOM监听、UI Rendering等\n微任务队列（microtask queue）：Promise的then回调、 Mutation Observer API、queueMicrotask()等\n\n那么事件循环对于两个队列的优先级是怎么样的呢？\n\n1.main script中的代码优先执行（编写的顶层script代码）；\n\n2.在执行任何一个宏任务之前（不是队列，是一个宏任务），都会先查看微任务队列中是否有任务需要执行\n\n\n也就是宏任务执行之前，必须保证微任务队列是空的；\n\n\n如果不为空，那么就优先执行微任务队列中的任务（回调）；\n\n\n我们来看一个面试题：执行结果如何？\nsetTimeout(function () &#123;\n  console.log(&quot;set1&quot;);\n\n  new Promise(function (resolve) &#123;\n    resolve();\n  &#125;).then(function () &#123;\n    new Promise(function (resolve) &#123;\n      resolve();\n    &#125;).then(function () &#123;\n      console.log(&quot;then4&quot;);\n    &#125;);\n    console.log(&quot;then2&quot;);\n  &#125;);\n&#125;);\n\nnew Promise(function (resolve) &#123;\n  console.log(&quot;pr1&quot;);\n  resolve();\n&#125;).then(function () &#123;\n  console.log(&quot;then1&quot;);\n&#125;);\n\nsetTimeout(function () &#123;\n  console.log(&quot;set2&quot;);\n&#125;);\n\nconsole.log(2);\n\nqueueMicrotask(() &#x3D;&gt; &#123;\n  console.log(&quot;queueMicrotask1&quot;)\n&#125;);\n\nnew Promise(function (resolve) &#123;\n  resolve();\n&#125;).then(function () &#123;\n  console.log(&quot;then3&quot;);\n&#125;);\n\n执行结果：\npr1\n2\nthen1\nqueueMicrotask1\nthen3\nset1\nthen2\nthen4\nset2\n\nasync、await是Promise的一个语法糖：\n\n我们可以将await关键字后面执行的代码，看做是包裹在(resolve, reject) =&gt; &#123;函数执行&#125;中的代码；\nawait的下一条语句，可以看做是then(res =&gt; &#123;函数执行&#125;)中的代码；\n\n今日头条的面试题：\nasync function async1 () &#123;\n  console.log(&#39;async1 start&#39;)\n  await async2();\n  console.log(&#39;async1 end&#39;)\n&#125;\n \nasync function async2 () &#123;\n  console.log(&#39;async2&#39;)\n&#125;\n\nconsole.log(&#39;script start&#39;)\n \nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout&#39;)\n&#125;, 0)\n \nasync1();\n \nnew Promise (function (resolve) &#123;\n  console.log(&#39;promise1&#39;)\n  resolve();\n&#125;).then (function () &#123;\n  console.log(&#39;promise2&#39;)\n&#125;)\n\nconsole.log(&#39;script end&#39;)\n\n执行结果如下：\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n\nNode的事件循环2.1. Node的事件循环浏览器中的EventLoop是根据HTML5定义的规范来实现的，不同的浏览器可能会有不同的实现，而Node中是由libuv实现的。\n我们来看在很早就给大家展示的Node架构图：\n\n我们会发现libuv中主要维护了一个EventLoop和worker threads（线程池）；\nEventLoop负责调用系统的一些其他操作：文件的IO、Network、child-processes等\n\nNode的架构图\nlibuv到底是什么呢？\n\nlibuv is a multi-platform support library with a focus on asynchronous I&#x2F;O. It was primarily developed for use by Node.js, but it’s also used by Luvit, Julia, pyuv, and others.\nlibuv是一个多平台的专注于异步IO的库，它最初是为Node开发的，但是现在也被使用到Luvit、Julia、pyuv等其他地方；\n\nlibuv到底帮助我们做了什么事情呢？\n\n我们以文件操作为例，来讲解一下它内部的结构；\n\n2.2. 阻塞IO和非阻塞IO如果我们希望在程序中对一个文件进行操作，那么我们就需要打开这个文件：通过文件描述符。\n\n我们思考：JavaScript可以直接对一个文件进行操作吗？\n看起来是可以的，但是事实上我们任何程序中的文件操作都是需要进行系统调用（操作系统封装了文件系统）；\n事实上对文件的操作，是一个操作系统的IO操作（输入、输出）；\n\n操作系统为我们提供了阻塞式调用和非阻塞式调用：\n\n阻塞式调用： 调用结果返回之前，当前线程处于阻塞态（阻塞态CPU是不会分配时间片的），调用线程只有在得到调用结果之后才会继续执行。\n非阻塞式调用： 调用执行之后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。\n\n所以我们开发中的很多耗时操作，都可以基于这样的 非阻塞式调用：\n\n比如网络请求本身使用了Socket通信，而Socket本身提供了select模型，可以进行非阻塞方式的工作；\n比如文件读写的IO操作，我们可以使用操作系统提供的基于事件的回调机制；\n\n但是非阻塞IO也会存在一定的问题：我们并没有获取到需要读取（我们以读取为例）的结果\n\n那么就意味着为了可以知道是否读取到了完整的数据，我们需要频繁的去确定读取到的数据是否是完整的；\n这个过程我们称之为轮训操作；\n\n那么这个轮训的工作由谁来完成呢？\n\n如果我们的主线程频繁的去进行轮训的工作，那么必然会大大降低性能；\n并且开发中我们可能不只是一个文件的读写，可能是多个文件；\n而且可能是多个功能：网络的IO、数据库的IO、子进程调用；\n\nlibuv提供了一个线程池（Thread Pool）：\n\n线程池会负责所有相关的操作，并且会通过轮训等方式等待结果；\n当获取到结果时，就可以将对应的回调放到事件循环（某一个事件队列）中；\n事件循环就可以负责接管后续的回调工作，告知JavaScript应用程序执行对应的回调函数；\n\nEvent loop in node.js\n阻塞和非阻塞，同步和异步有什么区别？\n\n阻塞和非阻塞是对于被调用者来说的；\n\n\n在我们这里就是系统调用，操作系统为我们提供了阻塞调用和非阻塞调用；\n\n\n同步和异步是对于调用者来说的；\n\n\n在我们这里就是自己的程序；\n\n\n如果我们在发起调用之后，不会进行其他任何的操作，只是等待结果，这个过程就称之为同步调用；\n\n如果我们再发起调用之后，并不会等待结果，继续完成其他的工作，等到有回调时再去执行，这个过程就是异步调用；\n\n\n2.3. Node事件循环的阶段我们最前面就强调过，事件循环像是一个桥梁，是连接着应用程序的JavaScript和系统调用之间的通道：\n\n无论是我们的文件IO、数据库、网络IO、定时器、子进程，在完成对应的操作后，都会将对应的结果和回调函数放到事件循环（任务队列）中；\n事件循环会不断的从任务队列中取出对应的事件（回调函数）来执行；\n\n但是一次完整的事件循环Tick分成很多个阶段：\n\n定时器（Timers）：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。\n待定回调（Pending Callback）：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到ECONNREFUSED。\nidle, prepare：仅系统内部使用。\n轮询（Poll）：检索新的 I&#x2F;O 事件；执行与 I&#x2F;O 相关的回调；\n检测：setImmediate() 回调函数在这里执行。\n关闭的回调函数：一些关闭的回调函数，如：socket.on(&#39;close&#39;, ...)。\n\n一次tick的事件循环阶段\n我们会发现从一次事件循环的Tick来说，Node的事件循环更复杂，它也分为微任务和宏任务：\n\n宏任务（macrotask）：setTimeout、setInterval、IO事件、setImmediate、close事件；\n微任务（microtask）：Promise的then回调、process.nextTick、queueMicrotask；\n\n但是，Node中的事件循环不只是 微任务队列和 宏任务队列：\n\n微任务队列：\n\n\nnext tick queue：process.nextTick；\n\n\nother queue：Promise的then回调、queueMicrotask；\n\n宏任务队列：\n\n\ntimer queue：setTimeout、setInterval；\n\n\npoll queue：IO事件；\n\ncheck queue：setImmediate；\n\nclose queue：close事件；\n\n\n所以，在每一次事件循环的tick中，会按照如下顺序来执行代码：\n\nnext tick microtask queue；\nother microtask queue；\ntimer queue；\npoll queue；\ncheck queue；\nclose queue；\n\n2.4. Node代码执行面试面试题一：\nasync function async1() &#123;\n  console.log(&#39;async1 start&#39;)\n  await async2()\n  console.log(&#39;async1 end&#39;)\n&#125;\n\nasync function async2() &#123;\n  console.log(&#39;async2&#39;)\n&#125;\n\nconsole.log(&#39;script start&#39;)\n\nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout0&#39;)\n&#125;, 0)\n\nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout2&#39;)\n&#125;, 300)\n\nsetImmediate(() &#x3D;&gt; console.log(&#39;setImmediate&#39;));\n\nprocess.nextTick(() &#x3D;&gt; console.log(&#39;nextTick1&#39;));\n\nasync1();\n\nprocess.nextTick(() &#x3D;&gt; console.log(&#39;nextTick2&#39;));\n\nnew Promise(function (resolve) &#123;\n  console.log(&#39;promise1&#39;)\n  resolve();\n  console.log(&#39;promise2&#39;)\n&#125;).then(function () &#123;\n  console.log(&#39;promise3&#39;)\n&#125;)\n\nconsole.log(&#39;script end&#39;)\n\n执行结果如下：\nscript start\nasync1 start\nasync2\npromise1\npromise2\nscript end\nnextTick\nasync1 end\npromise3\n\nsetTimeout0\nsetImmediate\nsetTimeout2\n\n面试题二：\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimeout&quot;);\n&#125;, 0);\n\nsetImmediate(() &#x3D;&gt; &#123;\n  console.log(&quot;setImmediate&quot;);\n&#125;);\n\n执行结果：\n情况一：\nsetTimeout\nsetImmediate\n\n情况二：\nsetImmediate\nsetTimeout\n\n为什么会出现不同的情况呢？\n\n在Node源码的deps&#x2F;uv&#x2F;src&#x2F;timer.c中141行，有一个 uv__next_timeout的函数；\n这个函数决定了，poll阶段要不要阻塞在这里；\n阻塞在这里的目的是当有异步IO被处理时，尽可能快的让代码被执行；\n\nint uv__next_timeout(const uv_loop_t* loop) &#123;\n  const struct heap_node* heap_node;\n  const uv_timer_t* handle;\n  uint64_t diff;\n\n  &#x2F;&#x2F; 计算距离当前时间节点最小的计时器\n  heap_node &#x3D; heap_min(timer_heap(loop));\n  &#x2F;&#x2F; 如果为空, 那么返回-1,表示为阻塞状态\n  if (heap_node &#x3D;&#x3D; NULL)\n    return -1; &#x2F;* block indefinitely *&#x2F;\n\n  &#x2F;&#x2F; 如果计时器的时间小于当前loop的开始时间, 那么返回0\n  &#x2F;&#x2F; 继续执行后续阶段, 并且开启下一次tick\n  handle &#x3D; container_of(heap_node, uv_timer_t, heap_node);\n  if (handle-&gt;timeout &lt;&#x3D; loop-&gt;time)\n    return 0;\n\n  &#x2F;&#x2F; 如果不大于loop的开始时间, 那么会返回时间差\n  diff &#x3D; handle-&gt;timeout - loop-&gt;time;\n  if (diff &gt; INT_MAX)\n    diff &#x3D; INT_MAX;\n\n  return (int) diff;\n&#125;\n\n和上面有什么关系呢？\n\n情况一：如果事件循环开启的时间(ms)是小于 setTimeout函数的执行时间的；\n\n\n也就意味着先开启了event-loop，但是这个时候执行到timer阶段，并没有定时器的回调被放到入 timer queue中；\n\n\n所以没有被执行，后续开启定时器和检测到有setImmediate时，就会跳过poll阶段，向后继续执行；\n\n这个时候是先检测 setImmediate，第二次的tick中执行了timer中的 setTimeout；\n\n情况二：如果事件循环开启的时间(ms)是大于 setTimeout函数的执行时间的；\n\n\n这就意味着在第一次 tick中，已经准备好了timer queue；\n\n\n所以会直接按照顺序执行即可；\n\n\n","slug":"node/base/Node基础八","date":"2022-10-01T04:28:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"9cc987ed6425e4445f09c1cfe9b13abf","title":"Node基础七","content":"七.脚手架开发目前前端工程化开发过程中，我们会使用各种各样的脚手架，vue-cli、create-react-app，当然也包括webpack、gulp、rollup、vite等工具。\n这些工具是怎么开发出来的呢？当我们执行一个命令时，它们做了什么事情？是怎么样完成的一系列操作？\n这里我开发了一个coderwhy的脚手架：一个帮助你快速搭建和开发前端项目的CLI。\n文档内容分成两部分：\n第一部分：coderwhy使用说明；\n第二部分：coderwhy脚手架开发过程；\n如何安装？\nnpm install coderwhy -g\n\n使用说明一. 创建项目目前支持Vue，后期会支持React，Angular考虑中~\nvue项目模块已经帮你配置：\n\n常用的目录结构（你可以在此基础上修改）\nvue.config.js（其中配置了别名，你可以自行修改和配置更多）\naxios（网络请求axios的安装以及二次封装）\nvue-router（router的安装和配置，另外有路由的动态加载，后面详细说明）\nvuex（vuex的安装和配置，另外有动态加载子模块，后面详细说明）\n\n创建项目\ncoderwhy create your_project_name\n\n自动拉取项目模板、安装项目依赖、打开浏览器 http://localhost:8080/、自动启动项目\n二. 项目开发项目开发目前提供三个功能：\n\n创建Vue组件\n创建Vue页面，并配置路由\n创建Vuex子模块\n\n2.1. 创建Vue组件：coderwhy addcpn YourComponentName # 例如coderwhy add NavBar，默认会存放到src&#x2F;components文件夹中\ncoderwhy addcpn YourComponentName -d src&#x2F;pages&#x2F;home # 也可以指定存放的具体文件夹\n\n2.2. 创建Vue页面，并配置路由coderwhy addpage YourPageName # 例如coderwhy addpage Home，默认会放到src&#x2F;pages&#x2F;home&#x2F;Home.vue中，并且会创建src&#x2F;page&#x2F;home&#x2F;router.js\ncoderwhy addpage YourPageName -d src&#x2F;views # 也可以指定文件夹，但需要手动集成路由\n\n为什么会创建router.js文件：\n\nrouter.js文件是路由的其中一个配置；\n创建该文件中 src/router/index.js中会自动加载到路由的 routes配置中，不需要手动配置了（如果是自己配置的文件夹需要手动配置）\n\nsrc/router/index.js中已经完成如下操作：\n&#x2F;&#x2F; 动态加载pages中所有的路由文件\nconst files &#x3D; require.context(&#39;@&#x2F;pages&#39;, true, &#x2F;router\\.js$&#x2F;);\nconst routes &#x3D; files.keys().map(key &#x3D;&gt; &#123;\n  const page &#x3D; require(&#39;@&#x2F;pages&#39; + key.replace(&#39;.&#39;, &#39;&#39;));\n  return page.default;\n&#125;)\n\n2.3. 创建Vuex子模块coderwhy addstore YourVuexChildModuleName # 例如coderwhy addstore home，默认会放到src&#x2F;store&#x2F;modules&#x2F;home&#x2F;index.js和types.js\ncoderwhy addstore YourVuexChildModuleName -d src&#x2F;vuex&#x2F;modules # 也可以指定文件夹\n\n创建完成后，不需要手动配置，已经动态将所有子模块集成进去：\n&#x2F;&#x2F; 动态加载modules\nconst modules &#x3D; &#123;&#125;\nconst files &#x3D; require.context(&#39;.&#x2F;&#39;, true, &#x2F;index\\.js$&#x2F;);\nfiles.keys().filter(key &#x3D;&gt; &#123;\n  if (key &#x3D;&#x3D;&#x3D; &#39;.&#x2F;index.js&#39;) return false;\n  return true\n&#125;).map(key &#x3D;&gt; &#123;  \n  &#x2F;&#x2F; 获取名字\n  const modulePath &#x3D; key.replace(&#39;.&#x2F;modules&#x2F;&#39;, &#39;&#39;);\n  const moduleName &#x3D; modulePath.replace(&#39;&#x2F;index.js&#39;, &#39;&#39;);\n  const module &#x3D; require(&#96;$&#123;key&#125;&#96;);\n\n  modules[&#96;$&#123;moduleName&#125;&#96;] &#x3D; module.default;\n&#125;)\n\n脚手架开发过程一. 创建文件创建index.js\nconsole.log(&quot;Hello Coderwhy&quot;)\n\n创建package.json\n&#123;\n  &quot;name&quot;: &quot;coderwhy&quot;,\n  &quot;version&quot;: &quot;1.1.0&quot;,\n  &quot;description&quot;: &quot;CLI front-end development tools&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;bin&quot;: &#123;\n    &quot;coderwhy&quot;: &quot;index.js&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [\n    &quot;vue&quot;,\n    &quot;react&quot;,\n    &quot;CLI&quot;,\n    &quot;component&quot;\n  ],\n  &quot;author&quot;: &quot;coderwhy&quot;,\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;,\n  &quot;repository&quot;: &#123;\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;chalk&quot;: &quot;^4.1.0&quot;,\n    &quot;commander&quot;: &quot;^6.1.0&quot;,\n    &quot;download-git-repo&quot;: &quot;^3.0.2&quot;,\n    &quot;ejs&quot;: &quot;^3.1.5&quot;,\n    &quot;open&quot;: &quot;^7.3.0&quot;\n  &#125;\n&#125;\n\n最终的目录结构：\n├── LICENSE\n├── index.js\n├── lib\n│   ├── config\n│   │   └── repo_config.js\n│   ├── core\n│   │   ├── actions.js\n│   │   ├── create.js\n│   │   └── help.js\n│   ├── template\n│   │   ├── component.vue.ejs\n│   │   ├── vue-router.js.ejs\n│   │   ├── vue-store.js.ejs\n│   │   └── vue-types.js.ejs\n│   └── utils\n│       ├── file.js\n│       ├── log.js\n│       └── terminal.js\n├── package-lock.json\n├── package.json\n└── readme.md\n\n二. 创建coderwhy的命令自动在你的环境变量中查找node\n注意：必须放在第一行\n#!&#x2F;usr&#x2F;bin&#x2F;env node\n\n修改package.json\n&quot;bin&quot;: &#123;\n  &quot;coderwhy&quot;: &quot;index.js&quot;\n&#125;\n\n执行npm link\n三. commander用法3.1. 定义版本号#!&#x2F;usr&#x2F;bin&#x2F;env node\nconst cmd &#x3D; require(&#39;commander&#39;);\n&#x2F;&#x2F; 定义显示模块的版本号\ncmd.version(require(&#39;.&#x2F;package.json&#39;).version);\n&#x2F;&#x2F; 解析终端指令\ncmd.parse(process.argv);\n\n3.2. 给help增加其他选项添加单个选项\nprogram.option(&#39;-s --src &lt;src&gt;&#39;, &#39;a source folder&#39;);\nprogram.option(&#39;-d --dest &lt;dest&gt;&#39;, &#39;a destination folder&#39;);\nprogram.option(&#39;-f --framework &lt;framework&gt;&#39;, &#39;your framework name&#39;);\n\n监听help指令\nprogram.on(&#39;--help&#39;, function() &#123;\n  console.log(&quot;&quot;);\n  console.log(&quot;usage&quot;);\n  console.log(&quot;   coderwhy -v&quot;);\n  console.log(&quot;   coderwhy -version&quot;);\n&#125;)\n\n四. 创建项目指令&#x2F;&#x2F; 创建命令\nprogram\n  .command(&#39;create &lt;project&gt; [otherArgs...]&#39;)\n  .description(&#39;clone a repository into a newly created directory&#39;)\n  .action((project, otherArgs) &#x3D;&gt; &#123;\n    console.log(project);\n    console.log(otherArgs);\n   &#x2F;&#x2F; 调用封装的函数\n   createProject(project, otherArgs)\n  &#125;)\n\n在actions中封装创建过程：\nconst downloadRepo &#x3D; promisify(require(&#39;download-git-repo&#39;));\n\nconst createProject &#x3D; async (project, otherArg) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 1.提示信息\n  console.log(&#39;coderwhy helps you create your project, please wait a moment~&#39;);\n\n  &#x2F;&#x2F; 2.clone项目从仓库\n  await downloadRepo(repoConfig.vueGitRepo, project, &#123; clone: true &#125;);\n\n  &#x2F;&#x2F; 3.执行终端命令npm install\n  &#x2F;&#x2F; terminal.exec(&#39;npm install&#39;, &#123;cwd: &#96;.&#x2F;$&#123;project&#125;&#96;&#125;);\n  const npm &#x3D; process.platform &#x3D;&#x3D;&#x3D; &#39;win32&#39; ? &#39;npm.cmd&#39; : &#39;npm&#39;;\n  await terminal.spawn(npm, [&#39;install&#39;], &#123; cwd: &#96;.&#x2F;$&#123;project&#125;&#96; &#125;);\n\n  &#x2F;&#x2F; 4.打开浏览器\n  open(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;&#39;);\n\n  &#x2F;&#x2F; 5.运行项目\n  await terminal.spawn(npm, [&#39;run&#39;, &#39;serve&#39;], &#123; cwd: &#96;.&#x2F;$&#123;project&#125;&#96; &#125;);\n&#125;\n\n配置的Git地址如下：\n\n后续会开发一个设置自己地址的指令\n\nconst vueGitRepo &#x3D; &quot;direct:https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;hy-vue-temp.git&quot;;\n\nmodule.exports &#x3D; &#123;\n  vueGitRepo\n&#125;\n\n封装执行终端命令的过程：\nconst &#123; spawn, exec &#125; &#x3D; require(&#39;child_process&#39;);\n\nconst spawnCommand &#x3D; (...args) &#x3D;&gt; &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    const childProcess &#x3D; spawn(...args);\n    childProcess.stdout.pipe(process.stdout);\n    childProcess.stderr.pipe(process.stderr);\n    childProcess.on(&#39;close&#39;, () &#x3D;&gt; &#123;\n      resolve();\n    &#125;);\n  &#125;)\n&#125;\n\nprocess和child_process使用process在Node.js中每个应用程序都是一个进程类的实例对象。使用process对象代表应用程序,这是一个全局对象，可以通过它来获取Node.jsy应用程序以及运行该程序的用户、环境等各种信息的属性、方法和事件\n进程中几个重要的属性\nstdin 标准输入可读流\nstdout 标准输入可写流\nstderr 标准错误输出流\nargv 终端输入参数数组\nenv 操作系统环境信息\npid 应用程序进程id\n\n进程方法\nprocess.memoryUsage() 查看内存使用信息\nprocess.nextTick() 当前eventloop执行完毕执行回调函数\nprocess.chdir() chdir方法用于修改Node.js应用程序中使用的当前工作目录\nprocess.cwd() 进程当前工作目录\nprocess.kill() 杀死进程\nprocess.uncaughtException() 当应用程序抛出一个未被捕获的异常时触发进程对象的uncaughtException事件\n\nchild_process在Node.js中，提供了一个child_process模块,通过它可以开启多个子进程，在多个子进程之间可以共享内存空间，可以通过子进程的互相通信来实现信息的交换,child_process模块给予node任意创建子进程的能力，node官方文档对于child_proces模块给出了四种方法，映射到操作系统其实都是创建子进程。但对于开发者而已，这几种方法的api有点不同\nchild_process.exec(command[, options][, callback]) 启动子进程来执行shell命令,可以通过回调参数来获取脚本shell执行结果\nchild_process.execfile(file[, args][, options][, callback]) 与exec类型不同的是，它执行的不是shell命令而是一个可执行文件\nchild_process.spawn(command[, args][, options])仅仅执行一个shell命令，不需要获取执行结果\\\nchild_process.fork(modulePath[, args][, options]) 可以用node执行的.js文件，也不需要获取执行结果。fork出来的子进程一定是node进程\n\n&#x2F;&#x2F;exec用法:\n&#x2F;&#x2F;执行shell脚本, 使用管道符也是可以的\n&#x2F;&#x2F;exec也是可以执行文件的，只不过不能传参数\n&#x2F;&#x2F;适合开销比较小的任务\nconst cp &#x3D; require(&#39;child_process&#39;)\ncp.exec(&#39;ls -al|grep node_modules&#39;, &#123; \n  timeout: 0, &#x2F;&#x2F; 超时时间\n  cwd: process.cwd(), &#x2F;&#x2F; 可以改变当前的执行路径\n  &#125;, function (err, stdout, stderr) &#123;\n  &#x2F;&#x2F; 执行结果\n&#125;)\n\n&#x2F;&#x2F;execFile用法:\n&#x2F;&#x2F;可以执行文件，也可以执行语句，可传参\n&#x2F;&#x2F;适合开销比较小的任务\n&#x2F;&#x2F; 执行文件,参数\ncp.execFile(&#39;ls&#39;, [&#39;-al&#39;], function (err, stdout, std,err) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 执行结果\n&#125;)\n&#x2F;&#x2F; 让execFile执行ls -al|grep node_modules这种语句\n&#x2F;&#x2F;test.shell:\n  ls -al|grep node_modules\n  echo $1 &#x2F;&#x2F; 打印参数\n  echo $2\n&#x2F;&#x2F;index.js:\ncp.execFile(path.resolve(__dirname, &#39;test.shell&#39;), [&#39;-al&#39;, &#39;bl&#39;], \nfunction(err,   stdout, stderr) &#123;\n&#125;)\n\n&#x2F;&#x2F;fork用法\n&#x2F;&#x2F;用node执行, 耗时操作且用node实现，如下载文件\n\n&#x2F;&#x2F; cp.fork(模块路径)\n&#x2F;&#x2F; 和require一样把文件执行起来\nconst child &#x3D; cp.fork(path.resolve(__dirname, &#39;child_process_demo&#39;))\nconsole.log(process.pid)\n&#x2F;&#x2F; 主进程向子进程通信\nchild.send(&#39;hello child_process&#39;, () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; child.disconnent() &#x2F;&#x2F; 如果不断开，两边会出现等待的情况\n&#125;)\n&#x2F;&#x2F; 子进程向主进程通信\nchild.on(&#39;message&#39;, msg &#x3D;&gt; &#123;\n  \n&#125;)\n\n&#x2F;&#x2F; child_process_demo.js:\nconsole.log(&#39;aaa&#39;, process.pid)\nprocess.on(&#39;message&#39;, msg &#x3D;&gt; &#123;\n  console.log(msg)\n  &#x2F;&#x2F; 很容易出现死循环\n&#125;)\nprocess.send(&#39;send msg to parent&#39;)\n&#x2F;&#x2F; 进程不一样,完全独立，本质也是调用spawn\n\n\n&#x2F;&#x2F;spawn 用法\n&#x2F;&#x2F;spawn: 流式的，没有回调，适合耗时任务(比如：npm install), 需要不断打印日志(不断给用户输出日志\ncp.spawn(file, args, options) &#x2F;&#x2F; 不支持回调, exec,execFile底层都是spwan\nconst childProcess &#x3D; cp.spawn(path.resolve(__dirname, &#39;test.shell&#39;), [&#39;-al&#39;, &#39;-bl&#39;], &#123;\n  cwd: path.resolve(&#39;..&#39;),\n&#125;) &#x2F;&#x2F; 返回的是子进程\nconsole.log(childProcess.pid, childProcess.pid)\n&#x2F;&#x2F; 监听成功\nchildProcess.stdout.on(&#39;data&#39;, function(chunk) &#123;\n  console.log(chunk.toString())\n&#125;)\n&#x2F;&#x2F; 监听失败\nchildProcess.stderr.on(&#39;data&#39;, function(chunk) &#123;\n  console.log(chunk.toString())\n&#125;)\n\nconst code &#x3D; &#96;require(&#39;$&#123;rootFile&#125;&#39;).call(null, $&#123;JSON.stringify(args)&#125;)&#96;\n &#x2F;&#x2F; cp.spawn(&#39;cmd&#39;, [&#39;&#x2F;c&#39;, &#39;node&#39;, &#39;-e&#39;, code]) &#x2F;&#x2F; win下是这种结构\n const childProcess &#x3D; spawn(&#39;node&#39;, [&#39;-e&#39;, code], &#123;\n   cwd: process.cwd(), &#x2F;&#x2F; 当前执行未知的cwd\n   stdio: &#39;inherit&#39;, &#x2F;&#x2F; 默认是pipe,pipe必须通过on来接收信息，inherit不需要，实时反馈\n &#125;)\n childProcess.on(&#39;error&#39;, e &#x3D;&gt; &#123;\n   log.error(e.message)\n   process.exit(1)\n &#125;)\nchildProcess.on(&#39;exit&#39;, e &#x3D;&gt; &#123;\n  log.verbose(&#39;命令执行成功&#39;, e)\n  process.exit(e)\n&#125;)\n\n\n\n五. 添加组件指令5.1. 封装ejs模板组件模块如下：\n&lt;%_ if(data) &#123; _%&gt;\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&lt;%&#x3D; data.lowerName %&gt;&quot;&gt;\n    &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n  export default &#123;\n    name: &quot;&lt;%&#x3D; data.name %&gt;&quot;,\n    components: &#123;\n\n    &#125;,\n    mixins: [],\n    props: &#123;\n\n    &#125;,\n    data: function() &#123;\n      return &#123;\n        message: &quot;Hello &lt;%&#x3D; data.name %&gt;&quot;\n      &#125;\n    &#125;,\n    created: function() &#123;\n\n    &#125;,\n    mounted: function() &#123;\n\n    &#125;,\n    computed: &#123;\n\n    &#125;,\n    methods: &#123;\n\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n  .&lt;%&#x3D; data.lowerName %&gt; &#123;\n    \n  &#125;\n&lt;&#x2F;style&gt;\n\n&lt;%_ &#125; _%&gt;\n\n路由模板：\n\n组件模板，直接使用上面的即可\nrouter.js模板\n\n&lt;%_ if (data) &#123; _%&gt;\n&#x2F;&#x2F; 普通加载路由\n&#x2F;&#x2F; import &lt;%&#x3D; data.name %&gt; from &#39;.&#x2F;&lt;%&#x3D; data.name %&gt;.vue&#39;\n&#x2F;&#x2F; 懒加载路由\nconst &lt;%&#x3D; data.name %&gt; &#x3D; () &#x3D;&gt; import(&#39;.&#x2F;&lt;%&#x3D; data.name %&gt;.vue&#39;)\nexport default &#123;\n  path: &#39;&#x2F;&lt;%&#x3D; data.lowerName %&gt;&#39;,\n  name: &#39;&lt;%&#x3D; data.name %&gt;&#39;,\n  component: &lt;%&#x3D; data.name %&gt;,\n  children: [\n  ]\n&#125;\n&lt;%_ &#125; _%&gt;\n\nvuex模块的模板\n\nindex.js模板\ntypes.js模板\n\nindex.js模块\nimport * as types from &#39;.&#x2F;types.js&#39;\nexport default &#123;\n  namespaced: true,\n  state: &#123;\n  &#125;,\n  mutations: &#123;\n  &#125;,\n  actions: &#123;\n  &#125;,\n  getters: &#123;\n  &#125;\n&#125;\n\ntypes.js模块\nexport &#123;\n  \n&#125;\n\n5.2. 封装ejs解析封装ejs的编译过程：\nconst ejsCompile &#x3D; (templatePath, data&#x3D;&#123;&#125;, options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    ejs.renderFile(templatePath, &#123;data&#125;, options, (err, str) &#x3D;&gt; &#123;\n      if (err) &#123;\n        reject(err);\n        return;\n      &#125;\n      resolve(str);\n    &#125;)\n  &#125;)\n&#125;\n\n封装创建文件夹的过程：\nconst mkdirSync &#x3D; (dirname) &#x3D;&gt; &#123;\n  if (fs.existsSync(dirname)) &#123;\n    return true\n  &#125; else &#123;\n    &#x2F;&#x2F; 不存在,判断父亲文件夹是否存在？\n    if (mkdirSync(path.dirname(dirname))) &#123;\n      &#x2F;&#x2F; 存在父亲文件，就直接新建该文件\n      fs.mkdirSync(dirname)\n      return true\n    &#125;\n  &#125;\n&#125;\n\n封装写入文件的过程：\nconst writeFile &#x3D; (path, content) &#x3D;&gt; &#123;\n  if (fs.existsSync(path)) &#123;\n    log.error(&quot;the file already exists~&quot;)\n    return;\n  &#125;\n  return fs.promises.writeFile(path, content);\n&#125;\n\n封装ejs到文件的转化过程：\nconst handleEjsToFile &#x3D; async (name, dest, template, filename) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 1.获取模块引擎的路径\n  const templatePath &#x3D; path.resolve(__dirname, template);\n  const result &#x3D; await ejsCompile(templatePath, &#123;name, lowerName: name.toLowerCase()&#125;);\n\n  &#x2F;&#x2F; 2.写入文件中\n  &#x2F;&#x2F; 判断文件不存在,那么就创建文件\n  mkdirSync(dest);\n  const targetPath &#x3D; path.resolve(dest, filename);\n  writeFile(targetPath, result);\n&#125;\n\n5.3. 创建添加指令添加指令\nprogram\n  .command(&#39;addcpn &lt;name&gt;&#39;)\n  .description(&#39;add vue component, 例如: coderwhy addcpn NavBar [-d src&#x2F;components]&#39;)\n  .action(name &#x3D;&gt; addComponent(name, program.dest || &#39;src&#x2F;components&#39;))\n\nprogram\n  .command(&#39;addpage &lt;name&gt;&#39;)\n  .description(&#39;add vue page, 例如: coderwhy addpage Home [-d dest]&#39;)\n  .action(name &#x3D;&gt; &#123;\n  addPage(name, program.dest || &#96;src&#x2F;pages&#x2F;$&#123;name.toLowerCase()&#125;&#96;)\n&#125;)\n\nprogram\n  .command(&#39;addstore &lt;name&gt;&#39;)\n  .description(&#39;add vue store, 例如: coderwhy addstore favor [-d dest]&#39;)\n  .action(name &#x3D;&gt; &#123;\n  addStore(name, program.dest || &#96;src&#x2F;store&#x2F;modules&#x2F;$&#123;name.toLowerCase()&#125;&#96;)\n&#125;)\n\n封装对应的action\nconst addComponent &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;component.vue.ejs&#39;, &#96;$&#123;name&#125;.vue&#96;);\n&#125;\n\nconst addPage &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  addComponent(name, dest);\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-router.js.ejs&#39;, &#39;router.js&#39;)\n&#125;\n\nconst addStore &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-store.js.ejs&#39;, &#39;index.js&#39;)\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-types.js.ejs&#39;, &#39;types.js&#39;)\n&#125;\n\n六. 发布工具注册npm账号：\n\nhttps://www.npmjs.com/\n选择sign up\n\nsign up注册\n在命令行登录：\nnpm login\n# 输入账号、密码、邮箱\n\n修改好package.json文件：\n&quot;keywords&quot;: [\n  &quot;vue&quot;,\n  &quot;react&quot;,\n  &quot;CLI&quot;,\n  &quot;component&quot;\n],\n&quot;author&quot;: &quot;coderwhy&quot;,\n&quot;license&quot;: &quot;MIT&quot;,\n&quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;,\n&quot;repository&quot;: &#123;\n  &quot;type&quot;: &quot;git&quot;,\n  &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;\n&#125;,\n\n发布到npm registry中\nnpm publish\n\n更新registry\n# 1.修改版本号(最好符合semver规范)\n# 2.重新发布\n\n删除发布的包：\nnpm unpublish\n\n过期发布的包：\nnpm deprecate\n","slug":"node/base/Node基础七","date":"2022-10-01T04:27:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"2625758c12baaaa025e1a25440bca02f","title":"Node基础六","content":"六.Buffer的使用1.1. 数据的二进制计算机中所有的内容：文字、数字、图片、音频、视频最终都会使用二进制来表示。\nJavaScript可以直接去处理非常直观的数据：比如字符串，我们通常展示给用户的也是这些内容。\n不对啊，JavaScript不是也可以处理图片吗？\n\n事实上在网页端，图片我们一直是交给浏览器来处理的；\nJavaScript或者HTML，只是负责告诉浏览器一个图片的地址；\n浏览器负责获取这个图片，并且最终将这个图片渲染出来；\n\n但是对于服务器来说是不一样的：\n\n服务器要处理的本地文件类型相对较多;\n比如某一个保存文本的文件并不是使用 utf-8进行编码的，而是用 GBK，那么我们必须读取到他们的二进制数据，再通过GKB转换成对应的文字；\n比如我们需要读取的是一张图片数据（二进制），再通过某些手段对图片数据进行二次的处理（裁剪、格式转换、旋转、添加滤镜），Node中有一个Sharp的库，就是读取图片或者传入图片的Buffer对其再进行处理；\n比如在Node中通过TCP建立长连接，TCP传输的是字节流，我们需要将数据转成字节再进行传入，并且需要知道传输字节的大小（客服端需要根据大小来判断读取多少内容）；\n\n我们会发现，对于前端开发来说，通常很少会和二进制打交道，但是对于服务器端为了做很多的功能，我们必须直接去操作其二进制的数据；\n所以Node为了可以方便开发者完成更多功能，提供给了我们一个类Buffer，并且它是全局的。\n1.2. Buffer和二进制我们前面说过，Buffer中存储的是二进制数据，那么到底是如何存储呢？\n\n我们可以将Buffer看成是一个存储二进制的数组；\n这个数组中的每一项，可以保存8位二进制：00000000\n\n为什么是8位呢？\n\n在计算机中，很少的情况我们会直接操作一位二进制，因为一位二进制存储的数据是非常有限的；\n所以通常会将8位合在一起作为一个单元，这个单元称之为一个字节（byte）；\n也就是说 1byte = 8bit，1kb=1024byte，1M=1024kb;\n比如很多编程语言中的int类型是4个字节，long类型是8个字节；\n比如TCP传输的是字节流，在写入和读取时都需要说明字节的个数；\n比如RGB的值分别都是255，所以本质上在计算机中都是用一个字节存储的；\n\n也就是说，Buffer相当于是一个字节的数组，数组中的每一项对于一个字节的大小：\n如果我们希望将一个字符串放入到Buffer中，是怎么样的过程呢？\nconst buffer01 &#x3D; new Buffer(&quot;why&quot;);\n\nconsole.log(buffer01);\n\n字符串存储buffer的过程\n当然目前已经不希望我们这样来做了：\nVSCode的警告\n那么我们可以通过另外一个创建方法：\nconst buffer2 &#x3D; Buffer.from(&quot;why&quot;);\nconsole.log(buffer2);\n\n如果是中文呢？\nconst buffer3 &#x3D; Buffer.from(&quot;王红元&quot;);\nconsole.log(buffer3);\n&#x2F;&#x2F; &lt;Buffer e7 8e 8b e7 ba a2 e5 85 83&gt;\nconst str &#x3D; buffer3.toString();\nconsole.log(str);\n&#x2F;&#x2F; 王红元\n\n如果编码和解码不同：\nconst buffer3 &#x3D; Buffer.from(&quot;王红元&quot;, &#39;utf16le&#39;);\nconsole.log(buffer3);\n\nconst str &#x3D; buffer3.toString(&#39;utf8&#39;);\nconsole.log(str); &#x2F;&#x2F; �s�~CQ\n\nBuffer其他用法2.1. Buffer的其他创建Buffer的创建方式有很多：\nbuffer的创建\n来看一下Buffer.alloc:\n\n我们会发现创建了一个8位长度的Buffer，里面所有的数据默认为00；\n\nconst buffer01 &#x3D; Buffer.alloc(8);\n\nconsole.log(buffer01); &#x2F;&#x2F; &lt;Buffer 00 00 00 00 00 00 00 00&gt;\n\n我们也可以对其进行操作：\nbuffer01[0] &#x3D; &#39;w&#39;.charCodeAt();\nbuffer01[1] &#x3D; 100;\nbuffer01[2] &#x3D; 0x66;\nconsole.log(buffer01);\n\n也可以使用相同的方式来获取：\nconsole.log(buffer01[0]);\nconsole.log(buffer01[0].toString(16));\n\n2.2. Buffer和文件读取文本文件的读取：\nconst fs &#x3D; require(&#39;fs&#39;);\n\nfs.readFile(&#39;.&#x2F;test.txt&#39;, (err, data) &#x3D;&gt; &#123;\n  console.log(data); &#x2F;&#x2F; &lt;Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64&gt;\n  console.log(data.toString()); &#x2F;&#x2F; Hello World\n&#125;)\n\n图片文件的读取：\nfs.readFile(&#39;.&#x2F;zznh.jpg&#39;, (err, data) &#x3D;&gt; &#123;\n  console.log(data); &#x2F;&#x2F; &lt;Buffer ff d8 ff e0 ... 40418 more bytes&gt;\n&#125;);\n\n图片文件的读取和转换：\n\n将读取的某一张图片，转换成一张200x200的图片；\n这里我们可以借助于 sharp 库来完成；\n\nconst sharp &#x3D; require(&#39;sharp&#39;);\nconst fs &#x3D; require(&#39;fs&#39;);\n\nsharp(&#39;.&#x2F;test.png&#39;)\n  .resize(1000, 1000)\n  .toBuffer()\n  .then(data &#x3D;&gt; &#123;\n    fs.writeFileSync(&#39;.&#x2F;test_copy.png&#39;, data);\n  &#125;)\n\n2.3. buffer使用&#x2F;&#x2F;buffer与字符串转换\nBuffer.from(string[, encoding])\nbuf.toString([encoding[, start[, end]]])\n\n&#x2F;&#x2F;复制buffer\nBuffer.from(buf)\n\n&#x2F;&#x2F;ArrayBuffer转换到buffer arrayBuffer类型为TypedArray.buffer属性\nBuffer.from(arrayBuffer[, byteOffset[, length]])\n\n&#x2F;&#x2F;buffer 转 Uint8Array\nvar array &#x3D; new Uint8Array(buffer);\n&#x2F;&#x2F;Uint8Array 转 ArrayBuffer\nvar arraybuffer &#x3D; array.buffer;\n&#x2F;&#x2F;ArrayBuffer 转 Buffer\nvar bufferCopy &#x3D; Buffer.from(arraybuffer);\n&#x2F;&#x2F;ArrayBuffer 转 DataView \nvar view &#x3D; new DataView(arraybuffer)\n&#x2F;&#x2F;DataView 转 ArrrayBuffer\nvar arraybuffer2 &#x3D; view.buffer;\n\n2.4. Buffer 和 TypeArray，ArrayBuffer, Unit8ArrayTypedArray\n概念: TypedArray ES6中新出的一个接口, 不能直接被实例化, Uint8Array 就是实现 TypedArray 接口的一个子类\n子类有:\nInt8Array: 每个元素是8个二进制位(1个字节)的有符号整数\nUint8Array： 每个元素是8个二进制位(1个字节)的无符号整数\nInt16Array： 每个元素是16个二进制位(2个字节)的有符号整数\nUint16Array：每个元素是16个二进制位(2个字节)的无符号整数\nInt32Array： 每个元素是32个二进制位(4个字节)的有符号整数\nUint32Array： 每个元素是32个二进制位(4个字节)的无符号整数\n\n\nArrayBuffer\n概念: TypedArray 的作用是操作二进制数据, 其内部还有一个buffer属性, 这个buffer就是 ArrayBuffer 实例. ArrayBuffer 就存储了要操作的二进制数据,TypedArray 是一个操作二进制数据的接口, 内部的 ArrayBuffer 存储了要操作的二进制数据.\n\nUint8Array\n概念: 数组中的每一个元素都是 8个二进制位(1个字节)的无符号整数.无符号的含义是, 该二进制的首位不表示符号位. 而对于有符号的二进制位, \n\nBuffer\n概念: Node中才有, 继承自 Unit8array, 拥有更多强大的二进制数据操作.\n\nBuffer的内存分配事实上我们创建Buffer时，并不会频繁的向操作系统申请内存，它会默认先申请一个8 * 1024个字节大小的内存，也就是8kb\n\nnode&#x2F;lib&#x2F;buffer.js：135行\n\nBuffer.poolSize &#x3D; 8 * 1024;\nlet poolSize, poolOffset, allocPool;\n\nconst encodingsMap &#x3D; ObjectCreate(null);\nfor (let i &#x3D; 0; i &lt; encodings.length; ++i)\n  encodingsMap[encodings[i]] &#x3D; i;\n\nfunction createPool() &#123;\n  poolSize &#x3D; Buffer.poolSize;\n  allocPool &#x3D; createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset &#x3D; 0;\n&#125;\ncreatePool();\n\n假如我们调用Buffer.from申请Buffer：\n\n这里我们以从字符串创建为例\nnode&#x2F;lib&#x2F;buffer.js：290行\n\nBuffer.from &#x3D; function from(value, encodingOrOffset, length) &#123;\n  if (typeof value &#x3D;&#x3D;&#x3D; &#39;string&#39;)\n    return fromString(value, encodingOrOffset);\n \n &#x2F;&#x2F; 如果是对象，另外一种处理情况\n  &#x2F;&#x2F; ...\n&#125;;\n\n我们查看fromString的调用：\n\nnode&#x2F;lib&#x2F;buffer.js：428行\n\nfunction fromString(string, encoding) &#123;\n  let ops;\n  if (typeof encoding !&#x3D;&#x3D; &#39;string&#39; || encoding.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    if (string.length &#x3D;&#x3D;&#x3D; 0)\n      return new FastBuffer();\n    ops &#x3D; encodingOps.utf8;\n    encoding &#x3D; undefined;\n  &#125; else &#123;\n    ops &#x3D; getEncodingOps(encoding);\n    if (ops &#x3D;&#x3D;&#x3D; undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length &#x3D;&#x3D;&#x3D; 0)\n      return new FastBuffer();\n  &#125;\n  return fromStringFast(string, ops);\n&#125;\n\n接着我们查看fromStringFast：\n\n这里做的事情是判断剩余的长度是否还足够填充这个字符串；\n如果不足够，那么就要通过 createPool 创建新的空间；\n如果够就直接使用，但是之后要进行 poolOffset的偏移变化；\nnode&#x2F;lib&#x2F;buffer.js：428行\n\nfunction fromStringFast(string, ops) &#123;\n  const length &#x3D; ops.byteLength(string);\n\n  if (length &gt;&#x3D; (Buffer.poolSize &gt;&gt;&gt; 1))\n    return createFromString(string, ops.encodingVal);\n\n  if (length &gt; (poolSize - poolOffset))\n    createPool();\n  let b &#x3D; new FastBuffer(allocPool, poolOffset, length);\n  const actual &#x3D; ops.write(b, string, 0, length);\n  if (actual !&#x3D;&#x3D; length) &#123;\n    &#x2F;&#x2F; byteLength() may overestimate. That&#39;s a rare case, though.\n    b &#x3D; new FastBuffer(allocPool, poolOffset, actual);\n  &#125;\n  poolOffset +&#x3D; actual;\n  alignPool();\n  return b;\n&#125;\n\nStream4.1. 认识Stream什么是流呢？\n\n我们的第一反应应该是流水，源源不断的流动；\n程序中的流也是类似的含义，我们可以想象当我们从一个文件中读取数据时，文件的二进制（字节）数据会源源不断的被读取到我们程序中；\n而这个一连串的字节，就是我们程序中的流；\n\n所以，我们可以这样理解流：\n\n是连续字节的一种表现形式和抽象概念；\n流应该是可读的，也是可写的；\n\n在之前学习文件的读写时，我们可以直接通过 readFile或者 writeFile方式读写文件，为什么还需要流呢？\n\n直接读写文件的方式，虽然简单，但是无法控制一些细节的操作；\n比如从什么位置开始读、读到什么位置、一次性读取多少个字节；\n读到某个位置后，暂停读取，某个时刻恢复读取等等；\n或者这个文件非常大，比如一个视频文件，一次性全部读取并不合适；\n\n事实上Node中很多对象是基于流实现的：\n\nhttp模块的Request和Response对象；\nprocess.stdout对象；\n\n官方：另外所有的流都是EventEmitter的实例：\n我们可以看一下Node源码中有这样的操作：\n\nStream和EventEmitter关系\n流（Stream）的分类：\n\nWritable：可以向其写入数据的流（例如 fs.createWriteStream()）。\nReadable：可以从中读取数据的流（例如 fs.createReadStream()）。\nDuplex：同时为Readable和的流Writable（例如 net.Socket）。\nTransform：Duplex可以在写入和读取数据时修改或转换数据的流（例如zlib.createDeflate()）。\n\n这里我们通过fs的操作，讲解一下Writable、Readable，另外两个大家可以自行学习一下。\n4.2. Readable之前我们读取一个文件的信息：\nfs.readFile(&#39;.&#x2F;foo.txt&#39;, (err, data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)\n\n这种方式是一次性将一个文件中所有的内容都读取到程序（内存）中，但是这种读取方式就会出现我们之前提到的很多问题：\n\n文件过大、读取的位置、结束的位置、一次读取的大小；\n\n这个时候，我们可以使用 createReadStream，我们来看几个参数，更多参数可以参考官网：\n\nstart：文件读取开始的位置；\nend：文件读取结束的位置；\nhighWaterMark：一次性读取字节的长度，默认是64kb；\n\nconst read &#x3D; fs.createReadStream(&quot;.&#x2F;foo.txt&quot;, &#123;\n  start: 3,\n  end: 8,\n  highWaterMark: 4\n&#125;);\n\n我们如何获取到数据呢？\n\n可以通过监听data事件，获取读取到的数据；\n\nread.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;);\n\n我们也可以监听其他的事件：\nread.on(&#39;open&#39;, (fd) &#x3D;&gt; &#123;\n  console.log(&quot;文件被打开&quot;);\n&#125;)\n\nread.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件读取结束&quot;);\n&#125;)\n\nread.on(&#39;close&#39;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件被关闭&quot;);\n&#125;)\n\n甚至我们可以在某一个时刻暂停和恢复读取：\nread.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n  console.log(data);\n\n  read.pause();\n\n  setTimeout(() &#x3D;&gt; &#123;\n    read.resume();\n  &#125;, 2000);\n&#125;);\n\n4.3. Writable之前我们写入一个文件的方式是这样的：\nfs.writeFile(&#39;.&#x2F;foo.txt&#39;, &quot;内容&quot;, (err) &#x3D;&gt; &#123;\n  \n&#125;);\n\n这种方式相当于一次性将所有的内容写入到文件中，但是这种方式也有很多问题：\n\n比如我们希望一点点写入内容，精确每次写入的位置等；\n\n这个时候，我们可以使用 createWriteStream，我们来看几个参数，更多参数可以参考官网：\n\nflags：默认是w，如果我们希望是追加写入，可以使用 a或者 a+；\nstart：写入的位置；\n\n我们进行一次简单的写入\nconst writer &#x3D; fs.createWriteStream(&quot;.&#x2F;foo.txt&quot;, &#123;\n  flags: &quot;a+&quot;,\n  start: 8\n&#125;);\n\nwriter.write(&quot;你好啊&quot;, err &#x3D;&gt; &#123;\n  console.log(&quot;写入成功&quot;);\n&#125;);\n\n如果我们希望监听一些事件：\nwriter.on(&quot;open&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件打开&quot;);\n&#125;)\n\nwriter.on(&quot;finish&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件写入结束&quot;);\n&#125;)\n\nwriter.on(&quot;close&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件关闭&quot;);\n&#125;)\n\n我们会发现，我们并不能监听到 close 事件：\n\n这是因为写入流在打开后是不会自动关闭的；\n我们必须手动关闭，来告诉Node已经写入结束了；\n并且会发出一个 finish 事件的；\n\nwriter.close();\n\nwriter.on(&quot;finish&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件写入结束&quot;);\n&#125;)\n\nwriter.on(&quot;close&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件关闭&quot;);\n&#125;)\n\n另外一个非常常用的方法是 end：\n\nend方法相当于做了两步操作：write传入的数据和调用close方法；\n\nwriter.end(&quot;Hello World&quot;);\n\n4.4. pipe方法正常情况下，我们可以将读取到的 输入流，手动的放到 输出流中进行写入：\nconst fs &#x3D; require(&#39;fs&#39;);\nconst &#123; read &#125; &#x3D; require(&#39;fs&#x2F;promises&#39;);\n\nconst reader &#x3D; fs.createReadStream(&#39;.&#x2F;foo.txt&#39;);\nconst writer &#x3D; fs.createWriteStream(&#39;.&#x2F;bar.txt&#39;);\n\nreader.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n  console.log(data);\n  writer.write(data, (err) &#x3D;&gt; &#123;\n    console.log(err);\n  &#125;);\n&#125;);\n\n我们也可以通过pipe来完成这样的操作：\nreader.pipe(writer);\n\nwriter.on(&#39;close&#39;, () &#x3D;&gt; &#123;\n  console.log(&quot;输出流关闭&quot;);\n&#125;)\n","slug":"node/base/Node基础六","date":"2022-10-01T04:26:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"f31c41ff35acbf9aa56d10f7617b9f93","title":"Node基础五","content":"五.npm你不知道的细节1.1. 认识npm我们已经学习了在JavaScript中可以通过模块化的方式将代码划分成一个个小的结构：\n\n在以后的开发中我们就可以通过模块化的方式来封装自己的代码，并且封装成一个工具；\n这个工具我们可以让同事通过导入的方式来使用，甚至你可以分享给世界各地的程序员来使用；\n\n如果我们分享给世界上所有的程序员使用，有哪些方式呢？\n方式一：上传到GitHub上、其他程序员通过GitHub下载我们的代码手动的引用；\n\n缺点是大家必须知道你的代码GitHub的地址，并且从GitHub上手动下载；\n需要在自己的项目中手动的引用，并且管理相关的依赖；\n不需要使用的时候，需要手动来删除相关的依赖；\n当遇到版本升级或者切换时，需要重复上面的操作；\n\n显然，上面的方式是有效的，但是这种传统的方式非常麻烦，并且容易出错；\n方式二：使用一个专业的工具来管理我们的代码\n\n我们通过工具将代码发布到特定的位置；\n其他程序员直接通过工具来安装、升级、删除我们的工具代码；\n\n显然，通过第二种方式我们可以更好的管理自己的工具包，其他人也可以更好的使用我们的工具包。\n包管理工具npm：\n\nNode Package Manager，也就是Node包管理器；\n但是目前已经不仅仅是Node包管理器了，在前端项目中我们也在使用它来管理依赖的包；\n比如express、koa、react、react-dom、axios、babel、webpack等等；\n\nnpm管理的包可以在哪里查看、搜索呢？\n\nhttps://www.npmjs.com/\n这是我们安装相关的npm包的官网；\n\nnpm管理的包存放在哪里呢？\n\n我们发布自己的包其实是发布到registry上面的；\n当我们安装一个包时其实是从registry上面下载的包；\n\n1.2. 项目配置文件事实上，我们每一个项目都会有一个对应的配置文件，无论是前端项目还是后端项目：\n\n这个配置文件会记录着你项目的名称、版本号、项目描述等；\n也会记录着你项目所依赖的其他库的信息和依赖库的版本号；\n\n这个配置文件在Node环境下面（无论是前端还是后端）就是package.json。\n我们以vue cli4脚手架创建的项目为例：\n&#123;\n  &quot;name&quot;: &quot;my-vue&quot;,\n  &quot;version&quot;: &quot;0.1.0&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,\n    &quot;build&quot;: &quot;vue-cli-service build&quot;,\n    &quot;lint&quot;: &quot;vue-cli-service lint&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;core-js&quot;: &quot;^3.6.5&quot;,\n    &quot;vue&quot;: &quot;^2.6.11&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@vue&#x2F;cli-plugin-babel&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue&#x2F;cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue&#x2F;cli-service&quot;: &quot;~4.5.0&quot;,\n    &quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n    &quot;eslint&quot;: &quot;^6.7.2&quot;,\n    &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n    &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot;\n  &#125;,\n  &quot;browserslist&quot;: [\n    &quot;&gt; 1%&quot;,\n    &quot;last 2 versions&quot;,\n    &quot;not dead&quot;\n  ]\n&#125;\n\n事实上Vue ClI4脚手架创建的项目相对进行了简化，我们来看一下CLI2创建的项目：\n&#123;\n  &quot;name&quot;: &quot;vuerouterbasic&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;A Vue.js project&quot;,\n  &quot;author&quot;: &quot;&#39;coderwhy&#39; &lt;&#39;coderwhy@gmail.com&#39;&gt;&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build&#x2F;webpack.dev.conf.js&quot;,\n    &quot;start&quot;: &quot;npm run dev&quot;,\n    &quot;build&quot;: &quot;node build&#x2F;build.js&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;vue&quot;: &quot;^2.5.2&quot;,\n    &quot;vue-router&quot;: &quot;^3.0.1&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,\n    &quot;babel-core&quot;: &quot;^6.22.1&quot;,\n    &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;,\n    &quot;babel-loader&quot;: &quot;^7.1.1&quot;,\n    &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;,\n    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,\n    &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;,\n    &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;,\n    &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;,\n    &quot;chalk&quot;: &quot;^2.0.1&quot;,\n    &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;,\n    &quot;css-loader&quot;: &quot;^0.28.0&quot;,\n    &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;,\n    &quot;file-loader&quot;: &quot;^1.1.4&quot;,\n    &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;,\n    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,\n    &quot;node-notifier&quot;: &quot;^5.1.2&quot;,\n    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;,\n    &quot;ora&quot;: &quot;^1.2.0&quot;,\n    &quot;portfinder&quot;: &quot;^1.0.13&quot;,\n    &quot;postcss-import&quot;: &quot;^11.0.0&quot;,\n    &quot;postcss-loader&quot;: &quot;^2.0.8&quot;,\n    &quot;postcss-url&quot;: &quot;^7.2.1&quot;,\n    &quot;rimraf&quot;: &quot;^2.6.0&quot;,\n    &quot;semver&quot;: &quot;^5.3.0&quot;,\n    &quot;shelljs&quot;: &quot;^0.7.6&quot;,\n    &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;,\n    &quot;url-loader&quot;: &quot;^0.5.8&quot;,\n    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,\n    &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;,\n    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,\n    &quot;webpack&quot;: &quot;^3.6.0&quot;,\n    &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;,\n    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;,\n    &quot;webpack-merge&quot;: &quot;^4.1.0&quot;\n  &#125;,\n  &quot;engines&quot;: &#123;\n    &quot;node&quot;: &quot;&gt;&#x3D; 6.0.0&quot;,\n    &quot;npm&quot;: &quot;&gt;&#x3D; 3.0.0&quot;\n  &#125;,\n  &quot;browserslist&quot;: [\n    &quot;&gt; 1%&quot;,\n    &quot;last 2 versions&quot;,\n    &quot;not ie &lt;&#x3D; 8&quot;\n  ]\n&#125;\n\n我们也可以手动创建一个package.json文件：\nnpm init #创建时填写信息\nnpm init -y # 所有信息使用默认的\n\nnpm init -y生成文件的效果：\n&#123;\n  &quot;name&quot;: &quot;learn-npm&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;main.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n我们会发现属性非常的多，我们这里对一些常见属性进行一些解析。\n必须填写的属性：name、version\n\nname是项目的名称；\nversion是当前项目的版本号；\ndescription是描述信息，很多时候是作为项目的基本描述；\nauthor是作者相关信息（发布时用到）；\nlicense是开源协议（发布时用到）；\n\nprivate属性：\n\nprivate属性记录当前的项目是否是私有的；\n当值为true时，npm是不能发布它的，这是防止私有项目或模块发布出去的方式；\n\nmain属性：\n\n设置程序的入口。\n\n很多人会有疑惑，webpack不是会自动找到程序的入口吗？\n\n\n这个入口和webpack打包的入口并不冲突；\n\n\n它是在你发布一个模块的时候会用到的；\n\n比如我们使用axios模块 const axios = require(&#39;axios&#39;);\n\n实际上是找到对应的main属性查找文件的；\n\n\naxios的入口\nscripts属性\n\nscripts属性用于配置一些脚本命令，以键值对的形式存在；\n\n配置后我们可以通过 npm run 命令的key来执行这个命令；\n\nnpm start和npm run start的区别是什么？\n\n\n它们是等价的；\n\n\n对于常用的 start、 test、stop、restart可以省略掉run直接通过 npm start等方式运行；\n\n\ndependencies属性\n\ndependencies属性是指定无论开发环境还是生成环境都需要依赖的包；\n通常是我们项目实际开发用到的一些库模块；\n与之对应的是devDependencies；\n\ndevDependencies属性\n\n一些包在生成环境是不需要的，比如webpack、babel等；\n这个时候我们会通过 npm install webpack --save-dev，将它安装到devDependencies属性中；\n\n疑问：那么在生成环境如何保证不安装这些包呢？\n\n生成环境不需要安装时，我们需要通过 npm install --production 来安装文件的依赖；\n\n版本管理的问题\n我们会发现安装的依赖版本出现：^2.0.3或~2.0.3，这是什么意思呢？\nnpm的包通常需要遵从semver版本规范：\n\nsemver：https://semver.org/lang/zh-CN/\nnpm semver：https://docs.npmjs.com/misc/semver\n\nsemver版本规范是X.Y.Z：\n\nX主版本号（major）：当你做了不兼容的 API 修改（可能不兼容之前的版本）；\nY次版本号（minor）：当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）；\nZ修订号（patch）：当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug）；\n\n我们这里解释一下 ^和~的区别：\n\n^x.y.z：表示x是保持不变的，y和z永远安装最新的版本；\n~x.y.z：表示x和y保持不变的，z永远安装最新的版本；\n\nengines属性\n\nengines属性用于指定Node和NPM的版本号；\n在安装的过程中，会先检查对应的引擎版本，如果不符合就会报错；\n事实上也可以指定所在的操作系统 &quot;os&quot; : [ &quot;darwin&quot;, &quot;linux&quot; ]，只是很少用到；\n\nbrowserslist属性\n\n用于配置打包后的JavaScript浏览器的兼容情况，参考；\n否则我们需要手动的添加polyfills来让支持某些语法；\n也就是说它是为webpack等打包工具服务的一个属性（这里不是详细讲解webpack等工具的工作原理，所以不再给出详情）；\n\nnpm工具解析2.1. npm install命令安装npm包分两种情况：\n\n全局安装（global install）：npm install yarn -g;\n项目（局部）安装（local install）：npm install\n\n全局安装\n全局安装是直接将某个包安装到全局：\n比如yarn的全局安装：\nnpm install yarn -g\n\n但是很多人对全局安装有一些误会：\n\n通常使用npm全局安装的包都是一些工具包：yarn、webpack等；\n并不是类似于 axios、express、koa等库文件；\n所以全局安装了之后并不能让我们在所有的项目中使用 axios等库；\n\n项目安装\n项目安装会在当前目录下生产一个 node_modules 文件夹，我们之前讲解require查找顺序时有讲解过这个包在什么情况下被查找；\n局部安装分为开发时依赖和生产时依赖：\n# 安装开发和生产依赖\nnpm install axios --save\nnpm install axios -S\nnpm install axios\nnpm i axios\n\n# 开发者\nnpm install axios --save-dev\nnpm install axios -D\nnpm i axios -D\n\n2.2. npm install原理很多同学之情应该已经会了 npm install &lt;package&gt;，但是你是否思考过它的内部原理呢？\n\n执行 npm install它背后帮助我们完成了什么操作？\n我们会发现还有一个成为package-lock.json的文件，它的作用是什么？\n从npm5开始，npm支持缓存策略（来自yarn的压力），缓存有什么作用呢？\n\n这是一幅我画出的根据 npm install 的原理图：\n\nnpm install会检测是有package-lock.json文件：\n\n\n检测lock中包的版本是否和package.json中一致（会按照semver版本规范检测）；\n\n\n一致的情况下，会去优先查找缓存\n\n查找到，会获取缓存中的压缩文件，并且将压缩文件解压到node_modules文件夹中；\n\n不一致，那么会重新构建依赖关系，直接会走顶层的流程；\n\n没有找到，会从registry仓库下载，直接走顶层流程；\n\n分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产生相同依赖的情况；\n\n从registry仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）；\n\n获取到压缩包后会对压缩包进行缓存（从npm5开始有的）；\n\n将压缩包解压到项目的node_modules文件夹中（前面我们讲过，require的查找顺序会在该包下面查找）\n\n没有lock文件\n\n有lock文件\n\n\nnpm install原理图\npackage-lock.json文件：\n&#123;\n  &quot;name&quot;: &quot;learn-npm&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;lockfileVersion&quot;: 1,\n  &quot;requires&quot;: true,\n  &quot;dependencies&quot;: &#123;\n    &quot;axios&quot;: &#123;\n      &quot;version&quot;: &quot;0.20.0&quot;,\n      &quot;resolved&quot;: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;axios&#x2F;-&#x2F;axios-0.20.0.tgz&quot;,\n      &quot;integrity&quot;: &quot;sha512-ANA4rr2BDcmmAQLOKft2fufrtuvlqR+cXNNinUmvfeSNCOF98PZL+7M&#x2F;v1zIdGo7OLjEA9J2gXJL+j4zGsl0bA&#x3D;&#x3D;&quot;,\n      &quot;requires&quot;: &#123;\n        &quot;follow-redirects&quot;: &quot;^1.10.0&quot;\n      &#125;\n    &#125;,\n    &quot;follow-redirects&quot;: &#123;\n      &quot;version&quot;: &quot;1.13.0&quot;,\n      &quot;resolved&quot;: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;follow-redirects&#x2F;-&#x2F;follow-redirects-1.13.0.tgz&quot;,\n      &quot;integrity&quot;: &quot;sha512-aq6gF1BEKje4a9i9+5jimNFIpq4Q1WiwBToeRK5NvZBd&#x2F;TRsmW8BsJfOEGkr76TbOyPVD3OVDN910EcUNtRYEA&#x3D;&#x3D;&quot;\n    &#125;\n  &#125;\n&#125;\n\npackage-lock.json文件解析：\n\nname：项目的名称；\n\nversion：项目的版本；\n\nlockfileVersion：lock文件的版本；\n\nrequires：使用requires来跟着模块的依赖关系；\n\ndependencies：项目的依赖\n\n\nversion表示实际安装的axios的版本；\n\n\nresolved用来记录下载的地址，registry仓库中的位置；\n\nrequires记录当前模块的依赖；\n\nintegrity用来从缓存中获取索引，再通过索引去获取压缩包文件；\n\n当前项目依赖axios，但是axios依赖follow-redireacts；\n\naxios中的属性如下：\n\n\n2.3. 其他npm命令我们这里再介绍几个比较常用的：\n卸载某个依赖包：\nnpm uninstall package\nnpm uninstall package --save-dev\nnpm uninstall package -D\n\n强制重新build\nnpm rebuild\n\n清除缓存\nnpm cache clean\n\nnpm的命令其实是非常多的：\n\nhttps://docs.npmjs.com/cli-documentation/cli\n更多的命令，可以根据需要查阅官方文档\n\n2.4. yarn和cnpm另一个node包管理工具yarn：\n\nyarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具；\nyarn 是为了弥补 npm 的一些缺陷而出现的；\n早期的npm存在很多的缺陷，比如安装依赖速度很慢、版本依赖混乱等等一系列的问题；\n虽然从npm5版本开始，进行了很多的升级和改进，但是依然很多人喜欢使用yarn；\n\n这里给出一张常用命令的对比\nnpm和yarn常用命令对比\n补充：cnpm\n由于一些特殊的原因，某些情况下我们没办法很好的从 https://registry.npmjs.org下载下来一些需要的包。\n查看npm镜像：\nnpm config get registry # npm config get registry\n\n我们可以直接设置npm的镜像：\nnpm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org\n\n但是对于大多数人来说（比如我），并不希望将npm镜像修改了：\n\n第一，不太希望随意修改npm原本从官方下来包的渠道；\n第二，担心某天淘宝的镜像挂了或者不维护了，又要改来改去；\n\n这个时候，我们可以使用cnpm，并且将cnpm设置为淘宝的镜像：\nnpm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org\ncnpm config get registry # https:&#x2F;&#x2F;r.npm.taobao.org&#x2F;\n\n补充：npx\nnpx是npm5.2之后自带的一个命令。\nnpx的作用非常多，但是比较常见的是使用它来调用项目中的某个模块的指令。\n我们以webpack为例：\n\n全局安装的是webpack5.1.3\n项目安装的是webpack3.6.0\n\n如果我在终端执行 webpack --version使用的是哪一个命令呢？\n\n显示结果会是 webpack 5.1.3，事实上使用的是全局的，为什么呢？\n原因非常简单，在当前目录下找不到webpack时，就会去全局找，并且执行命令；\n\n那么如何使用项目（局部）的webpack，常见的是两种方式：\n\n方式一：明确查找到node_module下面的webpack\n方式二：在 scripts定义脚本，来执行webpack；\n\n方式一：在终端中使用如下命令（在项目根目录下）\n.&#x2F;node_modules&#x2F;.bin&#x2F;webpack --version\n\n方式二：修改package.json中的scripts\n&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n  &quot;webpack&quot;: &quot;webpack --version&quot;\n&#125;,\n\n终端中执行：\nnpm run webpack\n\n但是这两种方式都有一点点麻烦，更好的办法是直接使用npx：\nnpx webpack --version\n\nnpx的原理非常简单，它会到当前目录的node_modules&#x2F;.bin目录下查找对应的命令；\n","slug":"node/base/Node基础五","date":"2022-10-01T04:25:11.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"e9d3cfba4c19a66c9a7d2ec6535dbb77","title":"Node基础四","content":"四.常用内置模块1.1. 认识path模块path模块用于对路径和文件进行处理，提供了很多好用的方法。\n并且我们知道在Mac OS、Linux和window上的路径是不一样的\n\nwindow上会使用 \\或者 \\\\ 来作为文件路径的分隔符，当然目前也支持 /；\n在Mac OS、Linux的Unix操作系统上使用 / 来作为文件路径的分隔符；\n\n那么如果我们在window上使用 \\ 来作为分隔符开发了一个应用程序，要部署到Linux上面应该怎么办呢？\n\n显示路径会出现一些问题；\n所以为了屏蔽他们之间的差异，在开发中对于路径的操作我们可以使用 path 模块；\n\n1.2. path常见的API从路径中获取信息\n\ndirname：获取文件的父文件夹；\nbasename：获取文件名；\nextname：获取文件扩展名；\n\nconst path &#x3D; require(&quot;path&quot;);\n\nconst myPath &#x3D; &#39;&#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;课堂&#x2F;PPT&#x2F;01_邂逅Node.pdf&#39;;\n\nconst dirname &#x3D; path.dirname(myPath);\nconst basename &#x3D; path.basename(myPath);\nconst extname &#x3D; path.extname(myPath);\n\nconsole.log(dirname); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;课堂&#x2F;PPT\nconsole.log(basename); &#x2F;&#x2F; 01_邂逅Node.pdf\nconsole.log(extname); &#x2F;&#x2F; .pdf\n\n路径的拼接\n\n如果我们希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符；\n这个时候我们可以使用path.join函数；\n\nconsole.log(path.join(&#39;&#x2F;user&#39;, &#39;why&#39;, &#39;abc.txt&#39;));\n\n将文件和某个文件夹拼接\n\n如果我们希望将某个文件和文件夹拼接，可以使用 path.resolve;\n\n\nresolve函数会判断我们拼接的路径前面是否有 /或../或./；\n\n\n如果有表示是一个绝对路径，会返回对应的拼接路径；\n\n如果没有，那么会和当前执行文件所在的文件夹进行路径的拼接\n\n\npath.resolve(&#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;06_常见的内置模块&#x2F;02_文件路径&#x2F;abc.txt\npath.resolve(&#39;&#x2F;abc.txt&#39;); &#x2F;&#x2F; &#x2F;abc.txt\npath.resolve(&#39;&#x2F;User&#x2F;why&#39;, &#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;User&#x2F;why&#x2F;abc.txt\npath.resolve(&#39;User&#x2F;why&#39;, &#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;06_常见的内置模块&#x2F;02_文件路径&#x2F;User&#x2F;why&#x2F;abc.txt\n\nresolve其实我们在webpack中也会使用：\nconst CracoLessPlugin &#x3D; require(&#39;craco-less&#39;);\nconst path &#x3D; require(&quot;path&quot;);\n\nconst resolve &#x3D; dir &#x3D;&gt; path.resolve(__dirname, dir);\n\nmodule.exports &#x3D; &#123;\n  plugins: [\n    &#123;\n      plugin: CracoLessPlugin,\n      options: &#123;\n        lessLoaderOptions: &#123;\n          lessOptions: &#123;\n            modifyVars: &#123; &#39;@primary-color&#39;: &#39;#1DA57A&#39; &#125;,\n            javascriptEnabled: true,\n          &#125;,\n        &#125;,\n      &#125;,\n    &#125;\n  ],\n  webpack: &#123;\n    alias: &#123;\n      &quot;@&quot;: resolve(&quot;src&quot;),\n      &quot;components&quot;: resolve(&quot;src&#x2F;components&quot;)\n    &#125;\n  &#125;\n&#125;\n\n内置模块fs1.1. 认识fs模块fs是File System的缩写，表示文件系统。\n对于任何一个为服务器端服务的语言或者框架通常都会有自己的文件系统：\n\n因为服务器需要将各种数据、文件等放置到不同的地方；\n比如用户数据可能大多数是放到数据库中的（后面我们也会学习）；\n比如某些配置文件或者用户资源（图片、音视频）都是以文件的形式存在于操作系统上的；\n\nNode也有自己的文件系统操作模块，就是fs：\n\n借助于Node帮我们封装的文件系统，我们可以在任何的操作系统（window、Mac OS、Linux）上面直接去操作文件；\n这也是Node可以开发服务器的一大原因，也是它可以成为前端自动化脚本等热门工具的原因；\n\nNode文件系统的API非常的多：https://nodejs.org/dist/latest-v14.x/docs/api/fs.html\n\n我们不可能，也没必要一个个去学习；\n这个更多的应该是作为一个API查询的手册，等用到的时候查询即可；\n学习阶段我们只需要学习最常用的即可；\n\n但是这些API大多数都提供三种操作方式：\n\n方式一：同步操作文件：代码会被阻塞，不会继续执行；\n方式二：异步回调函数操作文件：代码不会被阻塞，需要传入回调函数，当获取到结果时，回调函数被执行；\n方式三：异步Promise操作文件：代码不会被阻塞，通过 fs.promises 调用方法操作，会返回一个Promise，可以通过then、catch进行处理；\n\n我们这里以获取一个文件的状态为例：\n\n注意：都需要引入 fs 模块；\n\n方式一：同步操作文件\n&#x2F;&#x2F; 1.方式一: 同步读取文件\nconst state &#x3D; fs.statSync(&#39;..&#x2F;foo.txt&#39;);\nconsole.log(state);\n\nconsole.log(&#39;后续代码执行&#39;);\n\n方式二：异步回调函数操作文件\n&#x2F;&#x2F; 2.方式二: 异步读取\nfs.stat(&quot;..&#x2F;foo.txt&quot;, (err, state) &#x3D;&gt; &#123;\n  if (err) &#123;\n    console.log(err);\n    return;\n  &#125;\n  console.log(state);\n&#125;)\nconsole.log(&quot;后续代码执行&quot;);\n\n方式三：异步Promise操作文件\n&#x2F;&#x2F; 3.方式三: Promise方式\nfs.promises.stat(&quot;..&#x2F;foo.txt&quot;).then(state &#x3D;&gt; &#123;\n  console.log(state);\n&#125;).catch(err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\nconsole.log(&quot;后续代码执行&quot;);\n\n后续代码演练中，我将以异步回调的方式演练：相对更通用一些；\n1.2. 文件描述符文件描述符（File descriptors）是什么呢？\n在 POSIX 系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。\n\n每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。\n在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件。\nWindows 系统使用了一个虽然不同但概念上类似的机制来跟踪资源。\n为了简化用户的工作，Node.js 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符。\n\nfs.open() 方法用于分配新的文件描述符。一旦被分配，则文件描述符可用于从文件读取数据、向文件写入数据、或请求关于文件的信息。\n&#x2F;&#x2F; 获取文件描述符\nfs.open(&quot;..&#x2F;foo.txt&quot;, &#39;r&#39;, (err, fd) &#x3D;&gt; &#123;\n  console.log(fd);\n\n  fs.fstat(fd, (err, state) &#x3D;&gt; &#123;\n    console.log(state);\n  &#125;)\n&#125;)\n\n1.3. 文件的读写如果我们希望对文件的内容进行操作，这个时候可以使用文件的读写：\n\nfs.readFile(path[, options], callback)：读取文件的内容；\nfs.writeFile(file, data[, options], callback)：在文件中写入内容；\n\n文件写入：\nfs.writeFile(&#39;..&#x2F;foo.txt&#39;, content, &#123;&#125;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\n\n在上面的代码中，你会发现有一个大括号没有填写任何的内容，这个是写入时填写的option参数：\n\nflag：写入的方式。\nencoding：字符的编码；\n\n我们先来看flag：\n\nflag的值有很多：https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system_flags\n\n\nw 打开文件写入，默认值；\n\n\nw+打开文件进行读写，如果不存在则创建文件；\n\nr+ 打开文件进行读写，如果不存在那么抛出异常；\n\nr打开文件读取，读取时的默认值；\n\na打开要写入的文件，将流放在文件末尾。如果不存在则创建文件；\n\na+打开文件以进行读写，将流放在文件末尾。如果不存在则创建文件\n\n\n我们再来看看编码：\n\n我之前在简书上写过一篇关于字符编码的文章：https://www.jianshu.com/p/899e749be47c\n目前基本用的都是UTF-8编码；\n\n文件读取：\n\n如果不填写encoding，返回的结果是Buffer；\n\nfs.readFile(&#39;..&#x2F;foo.txt&#39;, &#123;encoding: &#39;utf-8&#39;&#125;, (err, data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)\n\n文件读取：\nconst fs &#x3D; require(&#39;fs&#39;);\n\nfs.readFile(&#39;..&#x2F;foo.txt&#39;, &#123;encoding: &#39;utf-8&#39;&#125;, (err, data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)\n\n1.4. 文件夹操作新建一个文件夹\n使用fs.mkdir()或fs.mkdirSync()创建一个新文件夹：\nconst fs &#x3D; require(&#39;fs&#39;);\n\nconst dirname &#x3D; &#39;..&#x2F;why&#39;;\n\nif (!fs.existsSync(dirname)) &#123;\n  fs.mkdir(dirname, (err) &#x3D;&gt; &#123;\n    console.log(err);\n  &#125;)\n&#125;\n\n获取文件夹的内容\n&#x2F;&#x2F; 读取文件夹\nfunction readFolders(folder) &#123;\n  fs.readdir(folder, &#123;withFileTypes: true&#125; ,(err, files) &#x3D;&gt; &#123;\n    files.forEach(file &#x3D;&gt; &#123;\n      if (file.isDirectory()) &#123;\n        const newFolder &#x3D; path.resolve(dirname, file.name);\n        readFolders(newFolder);\n      &#125; else &#123;\n        console.log(file.name);\n      &#125;\n    &#125;)\n  &#125;)\n&#125;\n\nreadFolders(dirname);\n\n文件重命名\nfs.rename(&#39;..&#x2F;why&#39;, &#39;..&#x2F;coder&#39;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\n\n内置模块events3.1. 基本使用Node中的核心API都是基于异步事件驱动的：\n\n在这个体系中，某些对象（发射器（Emitters））发出某一个事件；\n我们可以监听这个事件（监听器 Listeners），并且传入的回调函数，这个回调函数会在监听到事件时调用；\n\n发出事件和监听事件都是通过EventEmitter类来完成的，它们都属于events对象。\n\nemitter.on(eventName, listener)：监听事件，也可以使用addListener；\nemitter.off(eventName, listener)：移除事件监听，也可以使用removeListener；\nemitter.emit(eventName[, ...args])：发出事件，可以携带一些参数；\n\nconst EventEmmiter &#x3D; require(&#39;events&#39;);\n\n&#x2F;&#x2F; 监听事件\nconst bus &#x3D; new EventEmmiter();\n\nfunction clickHanlde(args) &#123;\n  console.log(&quot;监听到click事件&quot;, args);\n&#125;\n\nbus.on(&quot;click&quot;, clickHanlde);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  bus.emit(&quot;click&quot;, &quot;coderwhy&quot;);\n  bus.off(&quot;click&quot;, clickHanlde);\n  bus.emit(&quot;click&quot;, &quot;kobe&quot;);\n&#125;, 2000);\n\n3.2. 常见的属性EventEmitter的实例有一些属性，可以记录一些信息：\n\nemitter.eventNames()：返回当前 EventEmitter对象注册的事件字符串数组；\nemitter.getMaxListeners()：返回当前 EventEmitter对象的最大监听器数量，可以通过setMaxListeners()来修改，默认是10；\nemitter.listenerCount(事件名称)：返回当前 EventEmitter对象某一个事件名称，监听器的个数；\nemitter.listeners(事件名称)：返回当前 EventEmitter对象某个事件监听器上所有的监听器数组；\n\nconsole.log(bus.eventNames());\nconsole.log(bus.getMaxListeners());\nconsole.log(bus.listenerCount(&quot;click&quot;));\nconsole.log(bus.listeners(&quot;click&quot;));\n\n3.3. 方法的补充emitter.once(eventName, listener)：事件监听一次\nconst EventEmitter &#x3D; require(&#39;events&#39;);\n\nconst emitter &#x3D; new EventEmitter();\n\nemitter.once(&#39;click&#39;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;监听到事件&quot;, args);\n&#125;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  emitter.emit(&#39;click&#39;, &#39;coderwhy&#39;);\n  emitter.emit(&#39;click&#39;, &#39;coderwhy&#39;);\n&#125;, 2000);\n\nemitter.prependListener()：将监听事件添加到最前面\nemitter.on(&#39;click&#39;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;a监听到事件&quot;, args);\n&#125;)\n\n&#x2F;&#x2F; b监听事件会被放到前面\nemitter.prependListener(&quot;click&quot;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;b监听到事件&quot;, args);\n&#125;)\n\nemitter.prependOnceListener()：将监听事件添加到最前面，但是只监听一次\nemitter.prependOnceListener(&quot;click&quot;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;c监听到事件&quot;, args);\n&#125;)\n\nemitter.removeAllListeners([eventName])：移除所有的监听器\n&#x2F;&#x2F; 移除emitter上的所有事件监听\nemitter.removeAllListeners();\n&#x2F;&#x2F; 移除emitter上的click事件监听\nemitter.removeAllListeners(&quot;click&quot;);\n","slug":"node/base/Node基础四","date":"2022-10-01T04:24:10.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"4d3281e0b26c044e36154a269947cf99","title":"Node基础三","content":"三 . 掌握前端模块化1.1. JavaScript设计缺陷那么，到底什么是模块化开发呢？\n\n事实上模块化开发最终的目的是将程序划分成一个个小的结构；\n这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；\n这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用；\n也可以通过某种方式，导入另外结构中的变量、函数、对象等；\n\n上面说提到的结构，就是模块；\n按照这种结构划分开发程序的过程，就是模块化开发的过程；\n无论你多么喜欢JavaScript，以及它现在发展的有多好，我们都需要承认在Brendan Eich用了10天写出JavaScript的时候，它都有很多的缺陷：\n\n比如var定义的变量作用域问题；\n比如JavaScript的面向对象并不能像常规面向对象语言一样使用class；\n比如JavaScript没有模块化的问题；\n\nBrendan Eich本人也多次承认过JavaScript设计之初的缺陷，但是随着JavaScript的发展以及标准化，存在的缺陷问题基本都得到了完善。\n\nJavaScript目前已经得到了快速的发展，无论是web、移动端、小程序端、服务器端、桌面应用都被广泛的使用；\n\n在网页开发的早期，Brendan Eich开发JavaScript仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的：\n\n这个时候我们只需要讲JavaScript代码写到标签中即可；\n并没有必要放到多个文件中来编写；\n\n&lt;button id&#x3D;&quot;btn&quot;&gt;按钮&lt;&#x2F;button&gt;\n\n&lt;script&gt;\n  document.getElementById(&quot;btn&quot;).onclick &#x3D; function() &#123;\n    console.log(&quot;按钮被点击了&quot;);\n  &#125;\n&lt;&#x2F;script&gt;\n\n但是随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂了：\n\najax的出现，前后端开发分离，意味着后端返回数据后，我们需要通过JavaScript进行前端页面的渲染；\nSPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现；\n包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤；\n\n所以，模块化已经是JavaScript一个非常迫切的需求：\n\n但是JavaScript本身，直到ES6（2015）才推出了自己的模块化方案；\n在此之前，为了让JavaScript支持模块化，涌现出了很多不同的模块化规范：AMD、CMD、CommonJS等；\n\n在这个章节，我们将详细学习JavaScript的模块化，尤其是CommonJS和ES6的模块化。\n1.2. 没有模块化的问题我们先来简单体会一下没有模块化代码的问题。\n我们知道，对于一个大型的前端项目，通常是多人开发的（即使一个人开发，也会将代码划分到多个文件夹中）：\n\n我们假设有两个人：小明和小丽同时在开发一个项目，并且会将自己的JavaScript代码放在一个单独的js文件中。\n\n小明开发了aaa.js文件，代码如下（当然真实代码会复杂的多）：\nvar flag &#x3D; true;\n\nif (flag) &#123;\n  console.log(&quot;aaa的flag为true&quot;)\n&#125;\n\n小丽开发了bbb.js文件，代码如下：\nvar flag &#x3D; false;\n\nif (!flag) &#123;\n  console.log(&quot;bbb使用了flag为false&quot;);\n&#125;\n\n很明显出现了一个问题：\n\n大家都喜欢使用flag来存储一个boolean类型的值；\n但是一个人赋值了true，一个人赋值了false；\n如果之后都不再使用，那么也没有关系；\n\n但是，小明又开发了ccc.js文件：\nif (flag) &#123;\n  console.log(&quot;使用了aaa的flag&quot;);\n&#125;\n\n问题来了：小明发现ccc中的flag值不对\n\n对于聪明的你，当然一眼就看出来，是小丽将flag赋值为了false；\n但是如果每个文件都有上千甚至更多的代码，而且有上百个文件，你可以一眼看出来flag在哪个地方被修改了吗？\n\n备注：引用路径如下：\n&lt;script src&#x3D;&quot;.&#x2F;aaa.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;.&#x2F;bbb.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;.&#x2F;ccc.js&quot;&gt;&lt;&#x2F;script&gt;\n\n所以，没有模块化对于一个大型项目来说是灾难性的。\n当然，我们有办法可以解决上面的问题：立即函数调用表达式（IIFE）\n\nIIFE (Immediately Invoked Function Expression)\n\naaa.js\nconst moduleA &#x3D; (function () &#123;\n  var flag &#x3D; true;\n\n  if (flag) &#123;\n    console.log(&quot;aaa的flag为true&quot;)\n  &#125;\n\n  return &#123;\n    flag: flag\n  &#125;\n&#125;)();\n\nbbb.js\nconst moduleB &#x3D; (function () &#123;\n  var flag &#x3D; false;\n\n  if (!flag) &#123;\n    console.log(&quot;bbb使用了flag为false&quot;);\n  &#125;\n&#125;)();\n\nccc.js\nconst moduleC &#x3D; (function() &#123;\n  const flag &#x3D; moduleA.flag;\n  if (flag) &#123;\n    console.log(&quot;使用了aaa的flag&quot;);\n  &#125;\n&#125;)();\n\n命名冲突的问题，有没有解决呢？解决了。\n但是，我们其实带来了新的问题：\n\n第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用；\n第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；\n第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况；\n\n所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。\n\n我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码；\n这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性；\n\nJavaScript社区为了解决上面的问题，涌现出一系列好用的规范，接下来我们就学习具有代表性的一些规范。\nCommonJS规范2.1. CommonJS和Node我们需要知道CommonJS是一个规范，最初提出来是在浏览器意外的地方使用，并且当时被命名为ServerJS，后来为了体现它的广泛性，修改为CommonJS，平时我们也会简称为CJS。\n\nNode是CommonJS在服务器端一个具有代表性的实现；\nBrowserify是CommonJS在浏览器中的一种实现；\nwebpack打包工具具备对CommonJS的支持和转换（后面我会讲到）；\n\n所以，Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：\n\n在Node中每一个js文件都是一个单独的模块；\n这个模块中包括CommonJS规范的核心变量：exports、module.exports、require；\n我们可以使用这些变量来方便的进行模块化开发；\n\n前面我们提到过模块化的核心是导出和导入，Node中对其进行了实现：\n\nexports和module.exports可以负责对模块中的内容进行导出；\nrequire函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；\n\n2.2. Node模块化开发我们来看一下两个文件：\nbar.js\nconst name &#x3D; &#39;coderwhy&#39;;\nconst age &#x3D; 18;\n\nfunction sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\nmain.js\nconsole.log(name);\nconsole.log(age);\n\nsayHello(&#39;kobe&#39;);\n\n上面的代码会报错：\n\n在node中每一个文件都是一个独立的模块，有自己的作用域；\n那么，就意味着别的模块main中不能随便访问另外一个模块bar中的内容；\nbar需要导出自己想要暴露的变量、函数、对象等等；\nmain从bar中导入自己想要使用的变量、函数、对象等等；\n\n导出和导入\n2.2.1. exports导出强调：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出\nbar.js中导出内容：\nexports.name &#x3D; name;\nexports.age &#x3D; age;\nexports.sayHello &#x3D; sayHello;\n\nmain.js中导入内容：\nconst bar &#x3D; require(&#39;.&#x2F;bar&#39;);\n\n上面这行代码意味着什么呢？\n\n意味着main中的bar变量等于exports对象；\n\nmain中的bar &#x3D; bar中的exports\n\n所以，我可以编写下面的代码：\nconst bar &#x3D; require(&#39;.&#x2F;bar&#39;);\n\nconst name &#x3D; bar.name;\nconst age &#x3D; bar.age;\nconst sayHello &#x3D; bar.sayHello;\n\nconsole.log(name);\nconsole.log(age);\n\nsayHello(&#39;kobe&#39;);\n\n\n模块之间的引用关系\n为了进一步论证，bar和exports是同一个对象：\n\n所以，bar对象是exports对象的浅拷贝；\n浅拷贝的本质就是一种引用的赋值而已；\n\n定时器修改对象\n2.2.2. module.exports但是Node中我们经常导出东西的时候，又是通过module.exports导出的：\n\nmodule.exports和exports有什么关系或者区别呢？\n\n我们追根溯源，通过维基百科中对CommonJS规范的解析：\n\nCommonJS中是没有module.exports的概念的；\n但是为了实现模块的导出，Node中使用的是Module的类，每一个模块都是Module的一个实例，也就是module；\n所以在Node中真正用于导出的其实根本不是exports，而是module.exports；\n因为module才是导出的真正实现者；\n\n但是，为什么exports也可以导出呢？\n\n这是因为module对象的exports属性是exports对象的一个引用；\n也就是说 module.exports = exports = main中的bar；\n\nimage-20201011163653515\n注意：真正导出的模块内容的核心其实是module.exports，只是为了实现CommonJS的规范，刚好module.exports对exports对象有一个引用而已；\n那么，如果我的代码这样修改了：\nimage-20201011164006266\n你能猜到内存中会有怎么样的表现吗？\n\n结论：和exports对象没有任何关系了，exports你随便玩自己的吧；\nmodule.exports我现在导出一个自己的对象，不带着你玩了；\n新的对象取代了exports对象的导出，那么就意味着require导入的对象是新的对象；\n\nimage-20201011164223607\n2.2.3. require细节我们现在已经知道，require是一个函数，可以帮助我们引入一个文件（模块）中导入的对象。\n那么，require的查找规则是怎么样的呢？\n\nhttps://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together\n\n这里我总结比较常见的查找规则：\n导入格式如下：require(X)\n\n情况一：X是一个核心模块，比如path、http\n\n\n直接返回核心模块，并且停止查找\n\n\n情况二：X是以 ./ 或 ../ 或 /（根目录）开头的\n\n\n查找目录下面的index文件\n\n\n1> 查找X/index.js文件\n\n2> 查找X/index.json文件\n\n3> 查找X/index.node文件\n\n1.如果有后缀名，按照后缀名的格式查找对应的文件\n\n2.如果没有后缀名，会按照如下顺序：\n\n1> 直接查找文件X\n\n2> 查找X.js文件\n\n3> 查找X.json文件\n\n4> 查找X.node文件\n\n第一步：将X当做一个文件在对应的目录下查找；\n\n第二步：没有找到对应的文件，将X作为一个目录\n\n如果没有找到，那么报错：not found\n\n情况三：直接是一个X（没有路径），并且X不是一个核心模块\n\n\n比如 /Users/coderwhy/Desktop/Node/TestCode/04_learn_node/05_javascript-module/02_commonjs/main.js中编写 require(&#39;why&#39;)\n\n\n查找顺序\n\n如果上面的路径中都没有找到，那么报错：not found\n\n\n2.2.4. 模块加载顺序这里我们研究一下模块的加载顺序问题。\n结论一：模块在被第一次引入时，模块中的js代码会被运行一次\naaa.js\nconst name &#x3D; &#39;coderwhy&#39;;\n\nconsole.log(&quot;Hello aaa&quot;);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimeout&quot;);\n&#125;, 1000);\n\nmain.js\nconst aaa &#x3D; require(&#39;.&#x2F;aaa&#39;);\n\naaa.js中的代码在引入时会被运行一次\n结论二：模块被多次引入时，会缓存，最终只加载（运行）一次\nmain.js\nconst aaa &#x3D; require(&#39;.&#x2F;aaa&#39;);\nconst bbb &#x3D; require(&#39;.&#x2F;bbb&#39;);\n\naaa.js\nconst ccc &#x3D; require(&quot;.&#x2F;ccc&quot;);\n\nbbb.js\nconst ccc &#x3D; require(&quot;.&#x2F;ccc&quot;);\n\nccc.js\nconsole.log(&#39;ccc被加载&#39;);\n\nccc中的代码只会运行一次。\n为什么只会加载运行一次呢？\n\n这是因为每个模块对象module都有一个属性：loaded。\n为false表示还没有加载，为true表示已经加载；\n\n结论三：如果有循环引入，那么加载顺序是什么？\n如果出现下面模块的引用关系，那么加载顺序是什么呢？\n\n这个其实是一种数据结构：图结构；\n图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）；\nNode采用的是深度优先算法：main -> aaa -> ccc -> ddd -> eee ->bbb\n\n多个模块的引入关系\n2.3. Node的源码解析Module类\n\nModule类\nModule.prototype.require函数\n\nrequire函数\nModule._load函数\n\n_load函数的实现\nAMD和CMD规范3.1. CommonJS规范缺点CommonJS加载模块是同步的：\n\n同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行；\n这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快；\n\n如果将它应用于浏览器呢？\n\n浏览器加载js文件需要先从服务器将文件下载下来，之后在加载运行；\n那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作；\n\n所以在浏览器中，我们通常不使用CommonJS规范：\n\n当然在webpack中使用CommonJS是另外一回事；\n因为它会将我们的代码转成浏览器可以直接执行的代码；\n\n在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD：\n\n但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换；\nAMD和CMD已经使用非常少了，所以这里我们进行简单的演练；\n\n3.2. AMD规范AMD主要是应用于浏览器的一种模块化规范：\n\nAMD是Asynchronous Module Definition（异步模块定义）的缩写；\n它采用的是异步加载模块；\n事实上AMD的规范还要早于CommonJS，但是CommonJS目前依然在被使用，而AMD使用的较少了；\n\n我们提到过，规范只是定义代码的应该如何去编写，只有有了具体的实现才能被应用：\n\nAMD实现的比较常用的库是require.js和curl.js；\n\n这里我们以require.js为例讲解：\n第一步：下载require.js\n\n下载地址：https://github.com/requirejs/requirejs\n找到其中的require.js文件；\n\n第二步：定义HTML的script标签引入require.js和定义入口文件：\n\ndata-main属性的作用是在加载完src的文件后会加载执行该文件\n\n&lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;require.js&quot; data-main&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n\n第三步：编写如下目录和代码\n├── index.html\n├── index.js\n├── lib\n│   └── require.js\n└── modules\n    ├── bar.js\n    └── foo.js\n\nindex.js\n(function() &#123;\n  require.config(&#123;\n    baseUrl: &#39;&#39;,\n    paths: &#123;\n      foo: &#39;.&#x2F;modules&#x2F;foo&#39;,\n      bar: &#39;.&#x2F;modules&#x2F;bar&#39;\n    &#125;\n  &#125;)\n \n  &#x2F;&#x2F; 开始加载执行foo模块的代码\n  require([&#39;foo&#39;], function(foo) &#123;\n\n  &#125;)\n&#125;)();\n\nmodules/bar.js\n\n如果一个模块不依赖其他，那么直接使用define(function)即可\n\ndefine(function() &#123;\n  const name &#x3D; &quot;coderwhy&quot;;\n  const age &#x3D; 18;\n  const sayHello &#x3D; function(name) &#123;\n    console.log(&quot;Hello &quot; + name);\n  &#125;\n\n  return &#123;\n    name,\n    age, \n    sayHello\n  &#125;\n&#125;)\n\nmodules/foo.js\ndefine([&#39;bar&#39;], function(bar) &#123;\n  console.log(bar.name);\n  console.log(bar.age);\n  bar.sayHello(&#39;kobe&#39;);\n&#125;)\n\n3.3. CMD规范CMD规范也是应用于浏览器的一种模块化规范：\n\nCMD 是Common Module Definition（通用模块定义）的缩写；\n它也采用了异步加载模块，但是它将CommonJS的优点吸收了过来；\n但是目前CMD使用也非常少了；\n\nCMD也有自己比较优秀的实现方案：\n\nSeaJS\n\n我们一起看一下SeaJS如何使用：\n第一步：下载SeaJS\n\n下载地址：https://github.com/seajs/seajs\n找到dist文件夹下的sea.js\n\n第二步：引入sea.js和使用主入口文件\n\nseajs是指定主入口文件的\n\n&lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;sea.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n  seajs.use(&#39;.&#x2F;index.js&#39;);\n&lt;&#x2F;script&gt;\n\n第三步：编写如下目录和代码\n├── index.html\n├── index.js\n├── lib\n│   └── sea.js\n└── modules\n    ├── bar.js\n    └── foo.js\n\nindex.js\ndefine(function(require, exports, module) &#123;\n  const foo &#x3D; require(&#39;.&#x2F;modules&#x2F;foo&#39;);\n&#125;)\n\nbar.js\ndefine(function(require, exports, module) &#123;\n  const name &#x3D; &#39;lilei&#39;;\n  const age &#x3D; 20;\n  const sayHello &#x3D; function(name) &#123;\n    console.log(&quot;你好 &quot; + name);\n  &#125;\n\n  module.exports &#x3D; &#123;\n    name,\n    age,\n    sayHello\n  &#125;\n&#125;)\n\nfoo.js\ndefine(function(require, exports, module) &#123;\n  const bar &#x3D; require(&#39;.&#x2F;bar&#39;);\n\n  console.log(bar.name);\n  console.log(bar.age);\n  bar.sayHello(&quot;韩梅梅&quot;);\n&#125;)\n\nES Module4.1. 认识ES ModuleJavaScript没有模块化一直是它的痛点，所以才会产生我们前面学习的社区规范：CommonJS、AMD、CMD等，所以在ES推出自己的模块化系统时，大家也是兴奋异常。\nES Module和CommonJS的模块化有一些不同之处：\n\n一方面它使用了import和export关键字；\n另一方面它采用编译期静态类型检测，并且动态引用的方式；\n\nES Module模块采用export和import关键字来实现模块化：\n\nexport负责将模块内的内容导出；\nimport负责从其他模块导入内容；\n\n了解：采用ES Module将自动采用严格模式：use strict\n\n如果你不熟悉严格模式可以简单看一下MDN上的解析；\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\n\n4.2. ES Module的使用4.2.1. 代码结构组件这里我在浏览器中演示ES6的模块化开发：\n代码结构如下：\n├── index.html\n├── main.js\n└── modules\n    └── foo.js\n\nindex.html中引入两个js文件作为模块：\n&lt;script src&#x3D;&quot;.&#x2F;modules&#x2F;foo.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;main.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;\n\n如果直接在浏览器中运行代码，会报如下错误：\n\n模块化运行\n这个在MDN上面有给出解释：\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules\n你需要注意本地测试 — 如果你通过本地加载Html 文件 (比如一个 file:// 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。\n你需要通过一个服务器来测试。\n\n我这里使用的VSCode，VSCode中有一个插件：Live Server\n\n通过插件运行，可以将我们的代码运行在一个本地服务中；\n\nimage-20201012153439900\n4.2.2. export关键字export关键字将一个模块中的变量、函数、类等导出；\nfoo.js文件中默认代码如下：\nconst name &#x3D; &#39;coderwhy&#39;;\nconst age &#x3D; 18;\nlet message &#x3D; &quot;my name is why&quot;;\n\nfunction sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\n我们希望将其他中内容全部导出，它可以有如下的方式：\n方式一：在语句声明的前面直接加上export关键字\nexport const name &#x3D; &#39;coderwhy&#39;;\nexport const age &#x3D; 18;\nexport let message &#x3D; &quot;my name is why&quot;;\n\nexport function sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\n方式二：将所有需要导出的标识符，放到export后面的 &#123;&#125;中\n\n注意：这里的 &#123;&#125;里面不是ES6的对象字面量的增强写法，&#123;&#125;也不是表示一个对象的；\n所以：export &#123;name: name&#125;，是错误的写法；\n\nconst name &#x3D; &#39;coderwhy&#39;;\nconst age &#x3D; 18;\nlet message &#x3D; &quot;my name is why&quot;;\n\nfunction sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\nexport &#123;\n  name,\n  age,\n  message,\n  sayHello\n&#125;\n\n方式三：导出时给标识符起一个别名\nexport &#123;\n  name as fName,\n  age as fAge,\n  message as fMessage,\n  sayHello as fSayHello\n&#125;\n\n4.2.3. import关键字import关键字负责从另外一个模块中导入内容\n导入内容的方式也有多种：\n方式一：import &#123;标识符列表&#125; from &#39;模块&#39;；\n\n注意：这里的&#123;&#125;也不是一个对象，里面只是存放导入的标识符列表内容；\n\nimport &#123; name, age, message, sayHello &#125; from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nconsole.log(name)\nconsole.log(message);\nconsole.log(age);\nsayHello(&quot;Kobe&quot;);\n\n方式二：导入时给标识符起别名\nimport &#123; name as wName, age as wAge, message as wMessage, sayHello as wSayHello &#125; from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\n方式三：将模块功能放到一个模块功能对象（a module object）上\nimport * as foo from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nconsole.log(foo.name);\nconsole.log(foo.message);\nconsole.log(foo.age);\nfoo.sayHello(&quot;Kobe&quot;);\n\n4.2.4. export和import结合如果从一个模块中导入的内容，我们希望再直接导出出去，这个时候可以直接使用export来导出。\nbar.js中导出一个sum函数：\nexport const sum &#x3D; function(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nfoo.js中导入，但是只是做一个中转：\nexport &#123; sum &#125; from &#39;.&#x2F;bar.js&#39;;\n\nmain.js直接从foo中导入：\nimport &#123; sum &#125; from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\nconsole.log(sum(20, 30));\n\n甚至在foo.js中导出时，我们可以变化它的名字\nexport &#123; sum as barSum &#125; from &#39;.&#x2F;bar.js&#39;;\n\n为什么要这样做呢？\n\n在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中；\n这样方便指定统一的接口规范，也方便阅读；\n这个时候，我们就可以使用export和import结合使用；\n\n4.2.4. default用法前面我们学习的导出功能都是有名字的导出（named exports）：\n\n在导出export时指定了名字；\n在导入import时需要知道具体的名字；\n\n还有一种导出叫做默认导出（default export）\n\n默认导出export时可以不需要指定名字；\n在导入时不需要使用 &#123;&#125;，并且可以自己来指定名字；\n它也方便我们和现有的CommonJS等规范相互操作；\n\n导出格式如下：\nexport default function sub(num1, num2) &#123;\n  return num1 - num2;\n&#125;\n\n导入格式如下：\nimport sub from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nconsole.log(sub(20, 30));\n\n注意：在一个模块中，只能有一个默认导出（default export）；\n4.2.5. import()通过import加载一个模块，是不可以在其放到逻辑代码中的，比如：\nif (true) &#123;\n  import sub from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n&#125;\n\n为什么会出现这个情况呢？\n\n这是因为ES Module在被JS引擎解析时，就必须知道它的依赖关系；\n由于这个时候js代码没有任何的运行，所以无法在进行类似于if判断中根据代码的执行情况；\n甚至下面的这种写法也是错误的：因为我们必须到运行时能确定path的值；\n\nconst path &#x3D; &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nimport sub from path;\n\n但是某些情况下，我们确确实实希望动态的来加载某一个模块：\n\n如果根据不懂的条件，动态来选择加载模块的路径；\n这个时候我们需要使用 import() 函数来动态加载；\n\naaa.js模块：\nexport function aaa() &#123;\n  console.log(&quot;aaa被打印&quot;);\n&#125;\n\nbbb.js模块：\nexport function bbb() &#123;\n  console.log(&quot;bbb被执行&quot;);\n&#125;\n\nmain.js模块：\nlet flag &#x3D; true;\nif (flag) &#123;\n  import(&#39;.&#x2F;modules&#x2F;aaa.js&#39;).then(aaa &#x3D;&gt; &#123;\n    aaa.aaa();\n  &#125;)\n&#125; else &#123;\n  import(&#39;.&#x2F;modules&#x2F;bbb.js&#39;).then(bbb &#x3D;&gt; &#123;\n    bbb.bbb();\n  &#125;)\n&#125;\n\n4.3. ES Module的原理4.3.1. ES Module和CommonJS的区别CommonJS模块加载js文件的过程是运行时加载的，并且是同步的：\n\n运行时加载意味着是js引擎在执行js代码的过程中加载 模块；\n同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行；\n\nconsole.log(&quot;main代码执行&quot;);\n\nconst flag &#x3D; true;\nif (flag) &#123;\n  &#x2F;&#x2F; 同步加载foo文件，并且执行一次内部的代码\n  const foo &#x3D; require(&#39;.&#x2F;foo&#39;);\n  console.log(&quot;if语句继续执行&quot;);\n&#125;\n\nCommonJS通过module.exports导出的是一个对象：\n\n导出的是一个对象意味着可以将这个对象的引用在其他模块中赋值给其他变量；\n但是最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改；\n\nES Module加载js文件的过程是编译（解析）时加载的，并且是异步的：\n\n编译时（解析）时加载，意味着import不能和运行时相关的内容放在一起使用：\n\n\n比如from后面的路径需要动态获取；\n\n\n比如不能将import放到if等语句的代码块中；\n\n所以我们有时候也称ES Module是静态解析的，而不是动态或者运行时解析的；\n\n异步的意味着：JS引擎在遇到import时会去获取这个js文件，但是这个获取的过程是异步的，并不会阻塞主线程继续执行；\n\n\n也就是说设置了 type=module 的代码，相当于在script标签上也加上了 async 属性；\n\n\n如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行；\n\n\n&lt;script src&#x3D;&quot;main.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;\n&lt;!-- 这个js文件的代码不会被阻塞执行 --&gt;\n&lt;script src&#x3D;&quot;index.js&quot;&gt;&lt;&#x2F;script&gt;\n\nES Module通过export导出的是变量本身的引用：\n\nexport在导出一个变量时，js引擎会解析这个语法，并且创建模块环境记录（module environment record）；\n模块环境记录会和变量进行 绑定（binding），并且这个绑定是实时的；\n而在导入的地方，我们是可以实时的获取到绑定的最新值的；\n\nexport和import绑定的过程\n所以我们下面的代码是成立的：\nbar.js文件中修改\nlet name &#x3D; &#39;coderwhy&#39;;\n\nsetTimeout(() &#x3D;&gt; &#123;\n  name &#x3D; &quot;湖人总冠军&quot;;\n&#125;, 1000);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(name);\n&#125;, 2000);\n\nexport &#123;\n  name\n&#125;\n\nmain.js文件中获取\nimport &#123; name &#125; from &#39;.&#x2F;modules&#x2F;bar.js&#39;;\n\nconsole.log(name);\n\n&#x2F;&#x2F; bar中修改, main中验证\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(name);\n&#125;, 2000);\n\n但是，下面的代码是不成立的：main.js中修改\nimport &#123; name &#125; from &#39;.&#x2F;modules&#x2F;bar.js&#39;;\n\nconsole.log(name);\n\n&#x2F;&#x2F; main中修改, bar中验证\nsetTimeout(() &#x3D;&gt; &#123;\n  name &#x3D; &#39;kobe&#39;;\n&#125;, 1000);\n\n导入的变量不可以被修改\n思考：如果bar.js中导出的是一个对象，那么main.js中是否可以修改对象中的属性呢？\n\n答案是可以的，因为他们指向同一块内存空间；（自己编写代码验证，这里不再给出）\n\n4.3.2. Node中支持 ES Module在Current版本中\n在最新的Current版本（v14.13.1）中，支持es module我们需要进行如下操作：\n\n方式一：在package.json中配置 type: module（后续再学习，我们现在还没有讲到package.json文件的作用）\n方式二：文件以 .mjs 结尾，表示使用的是ES Module；\n\n这里我们暂时选择以 .mjs 结尾的方式来演练：\nbar.mjs\nconst name &#x3D; &#39;coderwhy&#39;;\n\nexport &#123;\n  name\n&#125;\n\nmain.mjs\nimport &#123; name &#125; from &#39;.&#x2F;modules&#x2F;bar.mjs&#39;;\n\nconsole.log(name);\n\n在LTS版本中\n在最新的LST版本（v12.19.0）中，我们也是可以正常运行的，但是会报一个警告：\nlts版本的警告\n4.3.3. ES Module和CommonJS的交互CommonJS加载ES Module\n结论：通常情况下，CommonJS不能加载ES Module\n\n因为CommonJS是同步加载的，但是ES Module必须经过静态分析等，无法在这个时候执行JavaScript代码；\n但是这个并非绝对的，某些平台在实现的时候可以对代码进行针对性的解析，也可能会支持；\nNode当中是不支持的；\n\nES Module加载CommonJS\n结论：多数情况下，ES Module可以加载CommonJS\n\nES Module在加载CommonJS时，会将其module.exports导出的内容作为default导出方式来使用；\n这个依然需要看具体的实现，比如webpack中是支持的、Node最新的Current版本也是支持的；\n但是在最新的LTS版本中就不支持；\n\nfoo.js\nconst address &#x3D; &#39;foo的address&#39;;\n\nmodule.exports &#x3D; &#123;\n  address\n&#125;\n\nmain.js\nimport foo from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\nconsole.log(foo.address);\n","slug":"node/base/Node基础三","date":"2022-10-01T04:23:22.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"a6a1fb5bcb751ccc4e9548f88f960a7a","title":"Node基础二","content":"二.node基础1.1. JavaScript文件执行如果我们编写一个js文件，里面存放JavaScript代码，如何来执行它呢？\n&#x2F;&#x2F; 1.直接打印一段文字\nconsole.log(&quot;我是一段JavaScript代码&quot;);\n\n&#x2F;&#x2F; 2.定义一个函数, 调用这个函数\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nconst result &#x3D; sum(20, 30);\nconsole.log(&quot;计算结果:&quot;, result);\n\n&#x2F;&#x2F; 3.执行定时器代码\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;2s后执行的代码&quot;);\n&#125;, 2000);\n\n目前我们知道有两种方式可以执行：\n\n将代码交给浏览器执行；\n将代码载入到node环境中执行；\n\n演练一：浏览器执行\n如果我们希望把代码交给浏览器执行：\n\n需要通过让浏览器加载、解析html代码，所以我们需要创建一个html文件；\n在html中通过script标签，引入js文件；\n当浏览器遇到script标签时，就会根据src加载、执行JavaScript代码；\n\nindex.html文件：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script src&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n浏览器执行结果\n演练二：Node执行\n如果我们希望把js文件交给node执行：\n\n首先电脑上需要安装Node.js环境，安装过程中会自动配置环境变量；\n可以通过终端命令node js文件的方式来载入和执行对应的js文件；\n\nnode index.js\n\nNode执行结果\n1.2. Node的REPL什么是REPL呢？感觉挺高大上\n\nREPL是Read-Eval-Print Loop的简称，翻译为“读取-求值-输出”循环；\nREPL是一个简单的，交互式的编程环境；\n\n事实上，我们浏览器的console就可以看成一个REPL：\n浏览器控台\nNode也给我们提供了一个REPL环境，我们可以在其中演练简单的代码：\nREPL演练\n2.1. 给node程序传递参数正常情况下执行一个node程序，直接跟上我们对应的文件即可：\nnode index.js\n\n但是，在某些情况下执行node程序的过程中，我们可能希望给node传递一些参数：\nnode index.js env&#x3D;development coderwhy\n\n如果我们这样来使用程序，就意味着我们需要在程序中获取到传递的参数：\n\n获取参数其实是在process的内置对象中的；\n\n如果我们直接打印这个内置对象，它里面包含特别的信息：\n\n其他的一些信息，比如版本、操作系统等大家可以自行查看，后面用到一些其他的我们还会提到；\n\nprocess对象\n现在，我们先找到其中的argv属性：\n\n我们发现它是一个数组，里面包含了我们需要的参数；\n你可能有个疑问，为什么叫argv呢？\n\nargv属性\n在C&#x2F;C++程序中的main函数中，实际上可以获取到两个参数：\n\nargc：argument counter的缩写，传递参数的个数；\n\nargv：argument vector的缩写，传入的具体参数。\n\n\nvector翻译过来是矢量的意思，在程序中表示的是一种数据结构。\n\n\n在C++、Java中都有这种数据结构，是一种数组结构；\n\n在JavaScript中也是一个数组，里面存储一些参数信息；\n\n\n我们可以在代码中，将这些参数信息遍历出来，使用：\n&#x2F;&#x2F; 获取参数\nconsole.log(process.argv);\nprocess.argv.forEach(item &#x3D;&gt; &#123;\n  console.log(item);\n&#125;);\n\n&#x2F;&#x2F; 结果如下：\n&#x2F;&#x2F; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;02_给Node传递参数&#x2F;index.js\n&#x2F;&#x2F; ENV&#x3D;dev\n&#x2F;&#x2F; coderwhy\n\n2.2. node程序输出内容console.log\n最常用的输入内容的方式：console.log\nconsole.log(&quot;hello coderwhy&quot;);\n\nconsole.clear\n清空控制台：console.clear\nconsole.clear\n\nconsole.trace\n打印函数的调用栈：console.trace\nfunction test() &#123;\n  demo();\n&#125;\nfunction demo() &#123;\n  foo();\n&#125;\nfunction foo() &#123;\n  console.trace();\n&#125;\ntest();\n\nconsole.trace结果\n还有一些其他的方法，其他的一些console方法，可以自己在下面学习研究一下。\nimage-20201008163045395\n3.1. 常见的全局对象Node中给我们提供了一些全局对象，方便我们进行一些操作：\n\n这些全局对象，我们并不需要从一开始全部一个个学习；\n某些全局对象并不常用，某些全局对象我们会在后续学习中讲到；\n比如module、exports、require()会在模块化中讲到；\n比如Buffer后续会专门讲到；\n\n全局对象\n3.2. 特殊的全局对象为什么我称之为特殊的全局对象呢？\n\n这些全局对象可以在模块中任意使用，但是在命令行交互中是不可以使用的；\n包括：__dirname、__filename、exports、module、require()\n\n__dirname\n获取当前文件所在的路径：\n\n注意：不包括后面的文件名\n\nconsole.log(__dirname);\n\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;03_常见的全局变量\n\n__filename\n获取当前文件所在的路径和文件名称：\n\n注意：包括后面的文件名称\n\nconsole.log(__filename);\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;03_常见的全局变量&#x2F;global对象.js\n\n3.3. 常见的全局对象process对象\nprocess提供了Node进程中相关的信息：\n\n比如Node的运行环境、参数信息等；\n后面在项目中，我也会讲解，如何将一些环境变量读取到 process 的 env 中；\n\nconsole.log(process);\n\nconsole对象\n提供了简单的调试控制台，在前面讲解输入内容时已经学习过了。\n\n更加详细的查看官网文档：https://nodejs.org/api/console.html\n\n定时器函数\n在Node中使用定时器有好几种方式：\n\nsetTimeout(callback, delay[, ...args])：callback在delay毫秒后执行一次；\n\nsetInterval(callback, delay[, ...args])：callback每delay毫秒重复执行一次；\n\nsetImmediate(callback[, ...args])：callbackI &#x2F; O事件后的回调的“立即”执行；\n\n\n这里先不展开讨论它和setTimeout(callback, 0)之间的区别；\n\n\n因为它涉及到事件循环的阶段问题，我会在后续详细讲解事件循环相关的知识；\n\nprocess.nextTick(callback[, ...args])：添加到下一次tick队列中；\n\n\n具体的讲解，也放到事件循环中说明；\n\n\n\n代码演练：\n\n暂时不用关心执行顺序问题，在后续事件循环中我会讲到；\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimtout&quot;);\n&#125;, 1000);\n\nsetInterval(() &#x3D;&gt; &#123;\n  console.log(&#39;setInterval&#39;);\n&#125;, 1000);\n\nsetImmediate(() &#x3D;&gt; &#123;\n  console.log(&quot;setImmediate&quot;);\n&#125;);\n\nprocess.nextTick(() &#x3D;&gt; &#123;\n  console.log(&quot;process.nextTick&quot;);\n&#125;);\n\n当然，它们有对应的取消定时器的方法：\n\nclearTimeout(timeoutObject);\nclearInterval(intervalObject);\nclearImmediate(immediateObject)\n\nglobal对象\nglobal是一个全局对象，事实上前端我们提到的process、console、setTimeout等都有被放到global中：\nconsole.log(process);\nconsole.log(global.process);\n\n为什么结果是一样的呢？\nNode的源码\nglobal中还有哪些属性呢？\nglobal其他属性的查看\nwindow和global的区别是什么？\n在浏览器中，全局变量都是在window上的，比如有document、setInterval、setTimeout、alert、console等等\n在Node中，我们也有一个global属性，并且看起来它里面有很多其他对象。\n但是在浏览器中执行的JavaScript代码，如果我们在顶级范围内通过var定义的一个属性，默认会被添加到window对象上：\nvar name &#x3D; &#39;coderwhy&#39;;\nconsole.log(window.name); &#x2F;&#x2F; coderwhy\n\n但是在node中，我们通过var定义一个变量，它只是在当前模块中有一个变量，不会放到全局中：\nvar name &#x3D; &#39;coderwhy&#39;;\nconsole.log(global.name); &#x2F;&#x2F; undefined\n","slug":"node/base/Node基础二","date":"2022-10-01T04:06:20.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"16ea75a74e45c427c7de22a19d8e1e05","title":"Node基础一","content":"一.JavaScript运行原理1.1. Atwood定律官方对Node.js的定义：\n\nNode.js是一个基于V8 JavaScript引擎的JavaScript运行时环境。\n\n什么是JavaScript运行环境？\n\n为什么JavaScript需要特别的运行环境呢？\n\n什么又是JavaScript引擎？\n\n什么是V8？\n\n\n我们先来把这些概念搞清楚，再去看Node到底是什么？\nStack Overflow的创立者之一的 Jeff Atwood 在2007年提出了著名的 Atwood定律：\n\nAny application that can be written in JavaScript, will eventually be written in JavaScript.\n任何可以使用JavaScript来实现的应用都最终都会使用JavaScript实现\n\n但是在发明之初，JavaScript的目的是应用于在浏览器执行简单的脚本任务，对浏览器以及其中的DOM进行各种操作，所以JavaScript的应用场景非常受限。\n\nAtwood定律更像是一种美好的远景，在当时看来还没有实现的可能性。\n但是随着Node的出现，Atwood定律已经越来越多的被证实是正确的。\n\n但是为了可以理解Node.js到底是如何帮助我们做到这一点的，我们必须了解JavaScript是如何被运行的。\n1.2. 浏览器内核我们经常会说：不同的浏览器有不同的内核组成\n\nGecko：早期被Netscape和Mozilla Firefox浏览器浏览器使用；\nTrident：微软开发，被IE4~IE11浏览器使用，但是Edge浏览器已经转向Blink；\nWebkit：苹果基于KHTML开发、开源的，用于Safari，Google Chrome之前也在使用；\nBlink：是Webkit的一个分支，Google开发，目前应用于Google Chrome、Edge、Opera等；\n\n事实上，我们经常说的浏览器内核指的是浏览器的排版引擎：\n\n排版引擎（layout engine），也称为浏览器引擎（browser engine）、页面渲染引擎（rendering engine）或样版引擎。\n\nWebKit main flow\n但是在这个执行过程中，HTML解析的时候遇到了JavaScript标签，应该怎么办呢？\n\n会停止解析HTML，而去加载和执行JavaScript代码；\n\n当然，为什么不直接异步去加载执行JavaScript代码，而要在这里停止掉呢？\n\n这是因为JavaScript代码可以操作我们的DOM；\n所以浏览器希望将HTML解析的DOM和JavaScript操作之后的DOM放到一起来生成最终的DOM树，而不是频繁的去生成新的DOM树；\n\n那么，JavaScript代码由谁来执行呢？\n\nJavaScript引擎\n\n1.3. JavaScript引擎为什么需要JavaScript引擎呢？\n\n事实上我们编写的JavaScript无论你交给浏览器或者Node执行，最后都是需要被CPU执行的；\n但是CPU只认识自己的指令集，实际上是机器语言，才能被CPU所执行；\n所以我们需要JavaScript引擎帮助我们将JavaScript代码翻译成CPU指令来执行；\n\n比较常见的JavaScript引擎有哪些呢？\n\nSpiderMonkey：第一款JavaScript引擎，由Brendan Eich开发（也就是JavaScript作者）；\nChakra：微软开发，用于IT浏览器；\nJavaScriptCore：WebKit中的JavaScript引擎，Apple公司开发；\nV8：Google开发的强大JavaScript引擎，也帮助Chrome从众多浏览器中脱颖而出；\n\n这里我们先以WebKit为例，WebKit事实上由两部分组成的：\n\nWebCore：负责HTML解析、布局、渲染等等相关的工作；\nJavaScriptCore：解析、执行JavaScript代码；\n\nwebkit内核\n看到这里，学过小程序的同学有没有感觉非常的熟悉呢？\n\n在小程序中编写的JavaScript代码就是被JSCore执行的；\n\n\n另外一个强大的JavaScript引擎就是V8引擎。\n1.4. V8引擎我们来看一下官方对V8引擎的定义：\n\nV8是用C ++编写的Google开源高性能JavaScript和WebAssembly引擎，它用于Chrome和Node.js等。\n它实现ECMAScript和WebAssembly，并在Windows 7或更高版本，macOS 10.12+和使用x64，IA-32，ARM或MIPS处理器的Linux系统上运行。\nV8可以独立运行，也可以嵌入到任何C ++应用程序中。\n\nV8引擎本身的源码非常复杂，大概有超过100w行C++代码，但是我们可以简单了解一下它执行JavaScript代码的原理：\n\nParse模块会将JavaScript代码转换成AST（抽象语法树），这是因为解释器并不直接认识JavaScript代码；\n\n\n如果函数没有被调用，那么是不会被转换成AST的；\n\n\nParse的V8官方文档：https://v8.dev/blog/scanner\n\nIgnition是一个解释器，会将AST转换成ByteCode（字节码）\n\n\n同时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）；\n\n\n如果函数只调用一次，Ignition会执行解释执行ByteCode；\n\nIgnition的V8官方文档：https://v8.dev/blog/ignition-interpreter\n\nTurboFan是一个编译器，可以将字节码编译为CPU可以直接执行的机器码；\n\n\n如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能；\n\n\n但是，机器码实际上也会被还原为ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如sum函数原来执行的是number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码；\n\nTurboFan的V8官方文档：https://v8.dev/blog/turbofan-jit\n\n\nimage-20200924165143332\n上面是JavaScript代码的执行过程，事实上V8的内存回收也是其强大的另外一个原因，这里暂时先不展开讨论：\n\nOrinoco模块，负责垃圾回收，将程序中不需要的内存回收；\nOrinoco的V8官方文档：https://v8.dev/blog/trash-talk\n\n2.1. Node.js是什么？回顾：官方对Node.js的定义：\n\nNode.js是一个基于V8 JavaScript引擎的JavaScript运行时环境。\n\nimage-20200924193328076\n也就是说Node.js基于V8引擎来执行JavaScript的代码，但是不仅仅只有V8引擎：\n\n前面我们知道Node.js可以嵌入到任何C ++应用程序中，无论是Chrome还是Node.js，事实上都是嵌入了V8引擎来执行JavaScript代码；\n但是在Chrome浏览器中，还需要解析、渲染HTML、CSS等相关渲染引擎，另外还需要提供支持浏览器操作的API、浏览器自己的事件循环等；\n另外，在Node.js中我们也需要进行一些额外的操作，比如文件系统读&#x2F;写、网络IO、加密、压缩解压文件等操作；\n\n所以，我们可以简单理解规划出Node.js和浏览器的差异：\nChrome浏览器和Node架构区别\n这里也有一份单独的Node.js的架构图：\n\n我们编写的JavaScript代码会经过V8引擎，再通过Node.js的Bindings，将任务放到Libuv的事件循环中；\nlibuv（Unicorn Velociraptor—独角伶盗龙）是使用C语言编写的库；\nlibuv提供了事件循环、文件系统读写、网络IO、线程池等等内容；\n具体内部代码的执行流程，我会在后续专门讲解事件和异步IO的原理中详细讲解；\n\nWhat is Node.js? Where, when and how to use it with examples\n2.2. Node.js可以做什么？了解了Node.js的架构，那么使用它我们可以做什么呢？\n\n前面我们提到，Node.js的出现，真正让Atwood定律变成了现实，Node.js的应用场景也越来越多。\n\n我们可以使用基于Node.js的Electron开发出类似于VSCode这种强大的桌面应用程序。另外前端自动化、模块化打包工具gulp、webpack也是基于Node.js开发和使用的。\nNode.js的快速发展也让企业对Node.js技术越来越重视，在前端招聘中通常会对Node.js有一定的要求，特别对于高级前端开发工程师，Node.js更是必不可少的技能：\n前端工程师岗位需求\n目前前端开发的库都是以node包的形式进行管理；\n\nnpm、yarn工具成为前端开发使用最多的工具；\n越来越多的公司使用Node.js作为web服务器开发；\n大量项目需要借助Node.js完成前后端渲染的同构应用；\n资深前端工程师需要为项目编写脚本工具（前端工程师编写脚本通常会使用JavaScript，而不是Python或者shell）；\n很多企业在使用Electron来开发桌面应用程序；\n\n总结一下，目前Node.js到底有哪些应用场景呢？\n\n前后端页面渲染\n\n\n支持项目同构开发\n\n\n对于需要进行首屏优化、SEO的页面进行后端渲染\n\n开发命令行工具\n\n\nwebpack、gulp等都是基于Node\n\n\n开发自己独立的命令行工具（类似于shell、Python做的事情，对于前端更加友好）\n\n桌面应用的开发\n\n\n类似于VSCode这种强大的桌面应用\n\n\n甚至开发桌面端类似于wayward大型游戏\n\n进行服务器开发\n\n\n拥有类似express、koa等强大的web框架\n\n\n开发Web Socket等服务器\n\n\n所以，作为前端开发工程师，Node.js已经是我们必须掌握的核心技术。\n2.3. Node.js的安装2.3.1. Node.js下载安装Node.js是在2009年诞生的，目前最新的版本是分别是12.18.4以及14.12.0：\n\nLTS版本：相对稳定一些，推荐线上环境使用该版本；\nCurrent版本：最新的Node版本，包含很多新特性；\n\nnode的版本\n这些我们选择什么版本呢？\n\n如果你是学习使用，可以选择current版本；\n如果你是公司开发，建议选择LTS版本；\n\nNode的安装方式有很多：\n\n可以借助于一些操作系统上的软件管理工具，比如Mac上的homebrew，Linux上的yum、dnf等；\n也可以直接下载对应的安装包下载安装；\n\n我们选择下载安装，下载自己操作系统的安装包直接安装就可以了：\n\nwindow选择.msi安装包，Mac选择.pkg安装包，Linux会在后续部署中讲解；\n安装过程中会配置环境变量；\n并且安装node过程中会安装npm（Node Package Manager）工具；\n\n我当前电脑上的版本：\n\nnode版本是12.16.1；\nnpm版本是6.14.8；\n\n我的node版本\n你应该已经发现，我这里使用的版本并不是Node的最新版本，无论是LTS或者Current：\n\n正好借助这里，和大家讲一下node的版本升级；\n\n2.3.2. Node.js版本管理在实际开发学习中，我们只需要使用一个Node版本来开发或者学习即可。\n但是，如果你希望通过可以快速更新或切换多个版本时，可以借助于一些工具：\n\nnvm：Node Version Manager；\nn：Interactively Manage Your Node.js Versions（交互式管理你的Node.js版本）\n\n这里我演示管理工具：n\n\nn是TJ方便node的版本管理，专门开发的；\n官方介绍是：n -  Interactively Manage Your Node.js Versions（交互式管理你的Node.js版本）\n\n安装n：直接使用npm安装即可\n# 安装工具n\nnpm install -g n\n# 查看安装的版本\nn --version\n\n安装最新的lts版本：\n\n前面添加的sudo是权限问题；\n可以两个版本都安装，之后我们可以通过n快速在两个版本间切换；\n\n# 安装最新的lts版本\nn lts\n\n# 安装最新的版本\nn latest\n\n安装lts版本\n查看所有的版本，并且选择要使用的版本：\n\n可以上下选择想使用的版本\n\n# 查看所有的版本\nn\n\n查看和选择所有的版本\n查看当前Node的版本：\n查看当前的版本\n问题：这两个工具都不支持window\n\nn：n is not supported natively on Windows.\nnvm：nvm does not support Windows\n\nWindow的同学怎么办？\n\n1.并不是每个人都需要安装多个版本，在课堂上我会以最新的Current版本讲解几乎所有内容；\n2.接下来我会在Mac上面演练n工具的使用，windows上可以使用nvm-window来完成；\n\n","slug":"node/base/Node基础一","date":"2022-09-30T15:33:43.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"18dd7f629894be8963e8c1c6b1ef8456","title":"Nginx常用操作及配置","content":"Nginx常用操作及配置常用操作#强制停止Nginx\nkill -9 nginx \nstart nginx\nnginx -s quit\nnginx -s reload\n\n常见配置# 进程数量\nworker_processes 1;\n\nevents &#123;\n  # 最大连接数量\n  worker_connections 1024;\n&#125;\n\nhttp &#123;\n  include mime.types;\n  default_type application&#x2F;octet-stream;\n  sendfile on;\n  keepalive_timeout 65;\n\n  # 演示如何强制http跳转https\n  server &#123;\n    listen 80;\n    server_name test.com;\n\n    # http强制跳转到https\n    rewrite ^(.*)$ https:&#x2F;&#x2F;$server_name$1 permanent;\n  &#125;\n\n  # 演示如何配置微信支付的校验文件\n  server &#123;\n    listen 80;\n    server_name localhost;\n\n    # 默认根路径\n    location &#x2F; &#123;\n      root index.html;\n    &#125;\n    # 微信支付校验文件，可以直接配置访问名称\n    location ^~&#x2F;MP_verify_2g3uEjrB5B2LIbNl.txt &#123;\n      alias &#x2F;home&#x2F;MP_verify_2g3uEjrB5B2LIbNl.txt;\n    &#125;\n    # 微信支付校验文件，也可以通过正则配置\n    location ~^&#x2F;MP_verify_[a-zA-Z0-9]*\\.(txt)$ &#123;\n      root &#x2F;home&#x2F;;\n      rewrite ^&#x2F;home&#x2F;(.txt)$ &#x2F;home&#x2F;$1 last;\n    &#125;\n  &#125;\n\n  # 演示root和alias两种配置静态资源的区别\n  server &#123;\n    listen 80;\n    server_name localhost;\n\n    # 用root方式，location中的路径会拼加到root的地址后面\n    # 请求路径为：http:&#x2F;&#x2F;localhost:8080&#x2F;files&#x2F;index.jpg    实际访问为：&#x2F;home&#x2F;files&#x2F;index.jpg\n    location ~^&#x2F;files&#x2F; &#123;\n      root &#x2F;home&#x2F;;\n      index index.html index.htm;\n    &#125;\n    # 用alias方式，location中的路径不会拼加到alias的地址后面\n    # 这请求路径为：http:&#x2F;&#x2F;localhost:8080&#x2F;files&#x2F;index.jpg    实际访问为：&#x2F;home&#x2F;index.jpg\n    location ~^&#x2F;files&#x2F; &#123;\n      alias &#x2F;home&#x2F;;\n      index index.html index.htm;\n    &#125;\n  &#125;\n\n  # 演示请求后台接口代理配置\n  server &#123;\n    listen 8080;\n    server_name localhost;\n\n    #################### 第一种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;api&#x2F;getUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际指向为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;api&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n\n    #################### 第二种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;getUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n\n    #################### 第三种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;usergetUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n\n    #################### 第四种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;getUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n  &#125;\n\n  # 演示前端项目部署加访问前缀的nginx配置\n  server &#123;\n    listen 8090;\n    server_name localhost;\n\n    # 部署路径：&#x2F;home&#x2F;web&#x2F;my_demo\n    # 访问路径为：http:&#x2F;&#x2F;localhost:8090&#x2F;\n    location &#x2F; &#123;\n      try_files $uri $uri&#x2F; &#x2F;index.html;\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header Host $http_host;\n      root &#x2F;home&#x2F;web&#x2F;my_demo&#x2F;;\n      index index.html index.htm;\n    &#125;\n\n    # 部署路径：&#x2F;home&#x2F;web&#x2F;my_demo\n    # 访问路径为：http:&#x2F;&#x2F;localhost:8090&#x2F;my_demo&#x2F;\n    # 如果location路径最后没有配置斜杠，则浏览器输入访问地址后，路径最后会自动拼一个斜杠\n    location ^~&#x2F;my_demo&#x2F; &#123;\n      try_files $uri $uri&#x2F; &#x2F;my_demo&#x2F;index.html;\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header Host $http_host;\n      root &#x2F;home&#x2F;web&#x2F;;\n      index index.html index.htm;\n    &#125;\n  &#125;\n&#125;\n\n","slug":"nginx/Nginx常用操作及配置","date":"2022-09-30T15:24:15.000Z","categories_index":"Nginx","tags_index":"Nginx","author_index":"ChrisWood"}]