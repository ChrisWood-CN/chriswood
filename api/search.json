[{"id":"520d9ef32d48d23e17dd506965fbbd26","title":"毛中特","content":"毛中特1 毛泽东思想及其历史地位一、毛泽东思想的形成和发展毛泽东思想形成发展的历史条件时代背景：帝国主义战争和无产阶级革命\n实践基础： 中共的革命实践和建设实践\n毛泽东思想形成发展的过程1.初步形成：农村包围城市、武装夺取政权的思想——土地革命战争时期 1927-1937年\n逐步开辟了农村包围城市、武装夺取政权的革命道路\n\n2.走向成熟——抗日战争时期\n新民主主义革命理论的系统阐述，标志着毛泽东思想得到多方面展开而趋于成熟。\n1945年党的七大将毛泽东思想写入党章，确立为党必须长期坚持的指导思想。\n\n3.继续发展——解放战争和新中国成立后\n主要观点：人民民主专政理论，社会主义革命和社会主义建设的理论\n\n二、毛泽东思想的主要内容和活的灵魂毛泽东思想的主要内容1. 新民主主义革命理论2. 社会主义革命和建设理论3. 革命军队建设和军事战略的理论\n毛泽东系统解决了如何把以农民为主要成分的革命军队建设成为一支无产阶级性质的、具有严格纪律的、同人民群众保持亲密联系的新型人民军队的问题\n规定了是党指挥枪的原则（党对军队绝对领导的根本原则和制度，发端于南昌起义，奠基于三湾改编，定型于古田会议）\n全心全意为人民服务是人民军队的唯一宗旨\n\n4. 政策和策略理论5. 思想政治工作和文化工作的理论6. 党的建设理论毛泽东思想活的灵魂党的十一届六中全会《关于建国以来党的若干历史问题的决议》实事求是：党的根本思想路线\n延安整风，对实事求是的科学含义做了马克思主义的界定。《改造我们的学习》指出：实事就是客观存在着的一切事物，是就是客观事物的内部联系，即规律性，求就是我们去研究\n经过延安整风和党的七大，实事求是的思想路线在全党得到了确立\n党的十一届三中全会，重新确立了实事求是的思想路线\n党的思想路线：一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理\n实事求是既是党的思想路线的核心，也是马克思主义中国化两大理论成果的精髓\n\n群众路线：党的根本工作路线\n群众路线本质上体现了马克思主义人民群众是历史创造者这一基本原理\n\n独立自主：党的根本政治原则三、毛泽东思想的历史地位1.马克思主义中国化第一个重大理论成果2.中国革命和建设的科学指南3.中国共产党和中国人民宝贵的精神财富考试重点1.毛泽东思想形成发展的过程2.毛泽东思想活的灵魂3.毛泽东思想的历史地位2 新民主主义革命理论新民主主义革命理论形成的依据近代中国国情1.近代中国社会性质：半殖民地半封建中国2.主要矛盾：帝国主义和中华民族的矛盾、封建主义和人民大众的矛盾3.根本任务：推翻帝国主义、封建主义和官僚资本主义的统治近代中国革命的时代特征近代中国的社会性质和主要矛盾决定了中国革命仍然是资产\n阶级民主革命\n从鸦片战争到辛亥革命期间：中国反帝反封建的斗争属于旧\n式民主主义革命\n十月革命后：中国资产阶级民主主义革命属于世界无产阶级\n社会主义革命的一部分\n五四运动后，新民主主义革命进入新阶段，中国革命两步走：\n    第一步：反帝反封建的新民主主义革命\n    第二步：社会主义革命\n\n第一：旧民主主义革命的失败\n第二：新民主主义革命的实践探索\n两次国共合作——统一战线理论\n建立巩固农村根据地——中国革命道路理论\n革命战争——人民军队和军事战略理论\n党由小到大由弱到强——党的建设理论\n\n\n\n总路线和基本纲领新民主主义革命的总路线\n1939年毛泽东在《中国革命和中国共产党》一文中，第一次提出新民主主义革命的科学概念和总路线的内容\n1948年《在晋绥干部会议上的讲话》完整表述总路线的内容：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命\n1.新民主主义革命的对象 帝国主义、封建主义和官僚资本主义\n不同时期中国革命的对象  国民大革命：帝国主义支持下的北洋军阀  土地革命：国民党新军阀  抗日战争：日本帝国主义  解放战争：国民党反动派\n\n\n2.新民主主义革命的动力\n无产阶级：最基本的动力  农民阶级：主力军——农民问题是中国革命的基本  问题，新民主主义革命就是中国共产党领导下的  农民革命、农民战争  城市小资产阶级：同盟者  民族资产阶级：动力之一\n关于民族资产阶级——两面性：  一方面——革命性  另一方面——软弱性、妥协性  对于民族资产阶级要又斗争又联合\n\n\n\n\n3.新民主主义革命的领导\n（1）领导权的重要性\n无产阶级的领导权是中国革命的中心问题，也是新民  主主义革命理论的核心问题\n区别新旧两种不同范畴的民主主义革命，根本的标志  是革命的领导权掌握在无产阶级手中还是掌握在资产  阶级手中\n无产阶级及其政党——中国共产党的领导，是中国革命  取得胜利的根本保证\n\n\n（2）领导权取得的条件\n率领被领导者（同盟者）向着共同敌人作坚决的  斗争，并取得胜利；\n对被领导者给以物质福利，至少不损害其利益，  同时对被领导者给以政治教育\n\n\n（3）领导权实现的关键：建立以工农联盟为基础  的广泛的统一战线    \n（4）坚持领导权的基本策略：无产阶级在同资产  阶级建立统一战线时，必须坚持独立自主的原则，  保持党在思想上、政治上和组织上的独立性，实行  又联合又斗争的方针\n（5）保证领导权的坚强支柱：强大的革命武装\n（6）实现领导权的根本保证：加强无产阶级政党  的建设\n\n\n4.新民主主义革命的性质和前途：\n新旧民主主义革命相比  革命阵线&#x2F;革命阵营：世界无产阶级社会主义革命的一部分  领导力量：无产阶级及其中国共产党  指导思想：马克思列宁主义  革命前途：社会主义\n革命性质由革命任务决定，革命阵营由领导阶级决定\n新民主主义革命与社会主义革命的比较 ：\n互相联系：毛泽东把新民主主义革命和社会主  义革命比喻为文章的上篇和下篇。民主革命是  社会主义革命的必要准备，社会主义革命是民  主革命的必然趋势。\n性质不同：新民主主义革命属于资产阶级民主主义革命，  建立无产阶级领导的各革命阶级联合专政性质不同的两个阶段，  只有完成前一个阶段的革命才能进行下一个阶段的革命。不能“毕其功于一役”，搞“无间断革命”（“一次革命论”）；也不能搞“二次革命”\n“一次革命论”  ，王明为代表的“左”倾教条主义错误 ，  主张民主革命和社会主义革命“毕其功于一役”（反帝反  封建反资产阶级），混淆了民主革命与社会主义革命的界  限。这种观点只看到两者的联系，忽视了两者的区别。\n“二次革命论”  ，割裂两个革命之间的衔接，只看到两者  的区别，没有看到两者的联系，要在两个阶段之间硬插一  个资产阶级专政和发展资本主义的阶段，犯“右倾”错误。\n\n\n\n\n\n\n\n新民主主义的基本纲领\n新民主主义的政治纲领国体：各革命阶级联合专政\n政体：人民代表大会制度\n人民当家主是国家制度的核心内容和基本准则\n新民主主义的经济纲领1.没收封建阶级的土地归农民所有\n（新民主主义革命的主要内容）\n2.没收官僚资产阶级的垄断资本归新民主主\n义的国家所有\n（具有双重性质，具有民主革命的性质；从反对中国的大资产阶\n级的意义上看，具有社会主义革命的性质）\n3.保护民族工商业\n（但这种保护不是无条件的，需要\n保护和发展的资本主义：有利于而不是有害于国计\n民生的私人资本主义经济，不能操纵国计民生的资\n本主义）\n（2个没收1个保护）\n3.新民主主义的文化纲领无产阶级领导的人民大众的反帝反封建的文化\n，即民族的科学的大众的文化\n\n新民主主义革命道路和基本经验新民主主义革命的道路1.提出：农村包围城市、武装夺取政权2.新民主主义革命道路形成的必然性\n具体国情：半殖民地半封建中国内无民主外无独立只有武装斗争、农业大国农民是同盟军和主力军\n特殊国情：可能性第一，社会政治经济发展不平衡第二，群众基础好第三，革命形势发展为革命根据地提供了客观条件第四，相当力量的正式红军的坚强后盾第五，党的领导是重要的主观条件\n\n3.新民主主义革命道路的内容和形式\n中国革命走农村包围城市、武装夺取政权的道路根本在于处理好土地革命、武装斗争、农村根据地建设三者之间的关系\n土地革命是基本内容\n武装斗争是主要形式和强有力保证\n农村革命根据地是战略阵地\n\n\n\n新民主主义革命的三大法宝统一战线\n必要性：首先，中共半殖民地半封建社会的阶级状况决定的，两头小中间大：无产阶级和地主大资产阶级都只占少数，最广大的农民、城市小资产阶级以及其他的中间阶级其次，中国革命的长期性、残酷性及其发展不平衡性决定的\n可能性：在半殖民地半封建的中国社会，诸多矛盾交织在一起，客观上为建立和发展统一战线提供了可能性\n两个联盟：工农联盟、工人与非劳动人民的联盟\n策略方针：发展进步势力、争取中间势力、孤立顽固势力\n最根本的经验：处理好与资产阶级的关系\n\n武装斗争 中国革命的特点和优点之一\n经验：党对军队的绝对领导、全心全意为人民服务、正确的战略战术\n\n党的建设 思想建设、组织建设、作风建设\n三大作风：理论联系实际、密切联系群众、批评与自我批评\n\n三大法宝之间的关系：\n统一战线和武装斗争是中国革命的两个特点，是战胜敌人的两个基本武器，党的组织是掌握这两个武器冲锋陷阵的战士\n\n新民主主义革命理论的意义\n马克思主义中国化的重要理论成果，开辟了马克思主义中国化的发展道路\n\n考试重点1.新民主主义革命的总路线2.新民主主义革命的基本纲领3.新民主主义革命的道路4.新民主主义革命的三大法宝3 社会主义改造理论从新民主主义到社会主义的转变新民主主义社会的性质和特点性质：新民主主义社会是一个过渡的社会形态经济、政治特点\n经济特点：五种经济成分、两种过渡、主要是三种经济\n社会主义性质的国营经济、半社会主义性质的  合作社经济、农民和手工业者的个体经济、私  人资本主义经济和国家资本主义经济\n\n\n政治特点\n新民主主义社会的阶级构成：  工人阶级、农民阶级、其他小资产阶级和民族  资产阶级是新民主主义社会基本的阶级力量\n新民主主义社会的主要矛盾  资本主义和社会主义两条道路、资产阶级和工  人阶级两个阶级的矛盾（民族资产阶级的两面性：又团结又改造）\n\n\n\n党过渡时期的总路线和理论依据\n1953年6月毛泽东在中央政治局会议上提出：“一化三改”社会主义工业化、对个体农业、手工业和资本主义工商业的社会主义改造\n提出过渡时期总路线的必要性\n第一，中国应当建立社会主义社会这个目标，这是中国共产党在成立之初就确定的了。\n第二，1949-1952年期间，在着重完成民主革命遗留任务的同时，社会主义革命的任务也开始实行了\n第三，随着民主革命遗留任务的彻底完成，国内的阶级关系和主要矛盾发生了深刻的变化。主要矛盾是工人阶级与民族资产阶级的矛盾。\n第四，随着国民经济的恢复和初步发展，中国社会的经济成分发生了重要变化\n\n\n\n社会主义改造道路和历史经验适合中国特点的社会主义改造道路1.农业的社会主义改造道路及其基本经验遵循自愿互利、典型示范和国家帮助的原则\n（互助组，社会主义萌芽；初级社，半社会主义性质；高级社，完全的社会主义性质）\n\n2.手工业的社会主义改造 积极领导、稳步前进的方针\n（手工业供销小组，社会主义萌芽；手工业供销合作社，半社会主义性质；手工业生产合作社，社会主义性质的集体经济组织）\n\n3.资本主义工商业的社会主义改造：和平赎买\n（初级形式的国家资本主义，企业具有了社会主义因素；个别企业的公私合营，半社会主义性质；全行业的公私合营，社会主义国营性质的企业）\n和平赎买方式改造资本主义工商业，原因：\n第一，民族资产阶级具有两面性（既有剥削工人取得利润的一面，又有拥护宪法、愿意接受社会主义改造的一面。）\n第二，中国共产党与民族资产阶级长期保持统一战线的关系。\n第三，我国已经有了以工人阶级为领导、工农联盟为基础的人民民主专政的国家政权，建立了强大的社会主义国营经济并掌握了国家的经济命脉，这就造成私人资本主义在政治上、经济上对社会主义的依赖。\n\n\n第一，初级形式的国家资本主义。私营工业中实行委托加工、计划订货、统购包销、经销代销等私营商业中采取委托经销、代销等形式四马分肥：国家所得税、企业公积金、工人福利费、资方红利\n第二，高级形式的国家资本主义：个别企业的公私合营，全行业的公私合营（定息）\n\n社会主义改造的历史经验1.坚持社会主义工业化建设与社会主义改造同时并举2.采取积极引导、逐步过渡的方式3.用和平方法进行改造社会主义制度在中国确立社会主义基本制度的确立及其理论根据1.社会主义基本制度的确立  1956年三大改造完成\n标志着数千年的阶级剥削制度的结束，标志着社会主义制度在我国确立，标志我国进入社会主义初级阶段，标志着我国完成了从新民主主义向社会主义的过渡\n\n社会主义改造带来的深刻变化\n社会经济制度和社会经济结构、阶级关系\n\n确立社会主义制度的重大意义1.极大地提高了工人阶级和广大劳动人民的积极性\n和创造性，极大地促进了我国社会生产力的发展\n2.使广大劳动人民真正成为国家的主人\n3.使占世界人口四分之一的东方大国进入了社会主\n义社会，这是世界社会主义运动史上又一个历史性\n的伟大胜利\n考试重点1.新民主主义社会的性质和特点2.党在过渡时期总路线的提出3.适合中国特点的社会主义改造道路4.确立社会主义基本制度的重大意义4 社会主义建设道路初步探索的理论成果\n初步探索的重要思想成果\n一、调动一切积极因素为社会主义事业服务的思想\n十大关系涉及生产力和生产关系、经济基础和上层建筑的关系\n基本方针：调动国内外一切积极因素，为社会主  义服务。\n标志：开始探索\n\n\n二、正确认识和处理社会主义社会矛盾的思想\n1957年2月毛泽东《关于正确处理人民内部矛盾的问题》的报告：  主要矛盾：人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾，  人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的 状况之间的矛盾\n敌我矛盾——专政的方法\n人民内部矛盾——民主的方法\n政治思想领域：团结——批评——团结，\n物质分配领域：统筹兼顾适当安排，\n人民群众与政府机关：民主集中制，\n科学文化领域：百花齐放百家争鸣\n党派之间：长期共存互相监督\n民族之间：民族平等团结互助\n\n\n三、走中国工业化道路的思想\n1.明确战略目标和战略步骤\n2.采取正确的经济建设方针：党的八大提出既反保守又反冒进在综合平衡中稳步前进\n3.发展科学技术与文化教育\n4.重视知识分子工作\n5.调整和完善所有制结构：陈云三个主体三个补充\n6.探索适合我国情况的经济体制和运行机制：两参一改三结合\n\n\n\n\n初步探索的意义和经验\n意义\n1.巩固和发展了我国的社会主义制度\n2.为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础、制度基础\n3.丰富了科学社会主义的理论和实践\n\n\n经验教训\n1.必须把马克思主义与中国实际相结合\n2.必须正确认识主要矛盾和根本任务，集中力量发展生产力\n3.必须从实际出发，不能急于求成\n4.必须发展社会主义民主，健全社会主义法制\n5.必须坚持党的民主集中制，加强执政党建设\n6.必须坚持对外开放，不能关起门来搞建设\n\n\n\n\n\n考试重点1.《论十大关系》2.《关于正确处理人民内部矛盾的问题》3.走工业化道路的思想5 邓小平理论（注意92年南方谈话 2022年）邓小平理论的形成形成条件1.时代背景：和平与发展成为时代主题2.历史根据：社会主义建设的经验教训3.现实依据：改革开放和现代化建设的实践邓小平理论的形成过程1978-1982年为基本理论命题提出的阶段\n1978年12月召开的党的十一届三中全会，重新确立了解放思想、实事求是的思想路线，确定把全党工作的着重点转移到社会主义现代化建设\n1981年党的十一届六中全会作出的《关于建国以来党的若干历史问题的决议》，决议在系统总结三十二年正反两方面经验的基础上，提出了适合我国情况的社会主义现代化建设正确道路的十点经验。这十点经验，成为邓小平理论的雏形\n\n1982-1987年为理论形成基本轮廓的时期\n1982年邓小平在党的十二大开幕词中明确指出：把马克思主义的普遍真理同我国的具体实际结合起来，走自己的道路，建设有中国特色的社会主义\n1987年召开的党的十三大，第一次比较系统地论述了我国社会主义初级阶段理论，明确概括和全面阐发了党的“一个中心、两个基本点”的基本路线，第一次对中国特色社会主义理论的主要内容作了系统概括，标志着邓小平理论的初步形成\n\n1987-1992年为理论走向成熟，确立体系的时期\n1992年邓小平南方谈话，提出了一系列重要论断，如社会主义本质；“三个有利于”标准；社会主义可以搞市场经济；邓小平理论也逐步走向成熟\n1992-1997邓小平理论丰富和发展\n\n1992-1997年为理论进一步丰富和发展的时期\n1997年党的十五大正式将邓小平理论确定为党的指导思想\n1999年的宪法修正案正式将邓小平理论载入宪法\n\n邓小平理论的基本问题和主要内容\n基本问题\n什么是社会主义、怎样建设社会主义，是邓小  平在领导改革开放和现代化建设这一新的革命过  程中，不断提出和反复和思考的首要的基本的理  论问题\n1992年初，邓小平在南方谈话中对社会主义本  质作了总结性理论概括：“社会主义的本质，是  解放生产力，发展生产力，消灭剥削，消除两极  分化，最终达到共同富裕\n\n\n主要内容\n邓小平理论贯穿解放思想、实事求是的思想路线  ，围绕着“什么是社会主义、怎样建设社会主义”  这个基本的理论问题，第一次比较系统地初步回答  了建设中国特色社会主义的一系列基本问题\n包括社会主义初级阶段理论，党的基本路线，  社会主义根本任务的理论，  “三步走”战略，改  革开放理论，社会主义市场经济理论，  “两手抓  ，两手都要硬”“一国两制”  、中国的问题关键  在于党等，形成了一个比较完备的科学体系\n1.解放思想、实事求是的思想路线\n2.社会主义初级阶段理论\n（1）我国处在社会主义初级阶段，是邓小平和我  们党对当代中国基本国情的科学判断\n十三大召开前夕，邓小平第一提出“社会主义初级阶段”  这一特定内涵的新概念，第一次把社会主义初级阶段作  为事关全局的基本国情加以把握\n社会主义初级阶段的科学含义  第一，我国已经是社会主义社会（社会性质）  第二，处在初级阶段 （发展程度）\n\n\n（2）十三大：初级阶段理论\n（3）十五大：基本特征\n（4）十九大：两个没有变\n两个没有变：处于并将长期处于社会主义初级阶段的基本国情没有变，  我国是世界上最大发展中国家的国际地位没有变\n\n\n\n\n3.基本路线\n目标：建设“富强、民主、文明的社会主义现代化国家\n基本途径：“一个中心、两个基本点”是基本路线最重要内容，  是实现社会主义现代化奋斗目标的基本途径\n以经济建设为中心 坚持四项基本原则 坚持改革开放\n四项基本原则，坚持社会主义道路，坚持人民民主专政，  坚持共产党的领导，坚持马列主义、毛泽东思想\n\n\n领导和依靠力量：领导和团结全国各族人民\n根本立足点：自力更生，艰苦创业是实现社会主义初级阶段  奋斗目标的根本立足点\n\n\n4.社会主义根本任务 发展生产力\n5.“三步走”战略\n第一步，从1981年到1990年实现国民生产总值比1980年翻一番，  解决人民的温饱问题\n第二步，从1991年到20世纪末，使国民生产总值再增长一倍，  人民生活达到小康水平\n第三步，到21世纪中叶，人均国民生产总值达到中等发达国家水平，  人民生活比较富裕，基本实现现代化\n\n\n6.改革开放理论\n7.社会主义市场经济理论\n8.“两手抓，两手都要硬”（物质精神）\n9.“一国两制”\n10.中国问题的关键在于党\n\n\n\n\n改革是第二次革命\n所谓第二次革命，是与中国共产党领导的第一次革命相对而言的。  中国共产党领的的第一次革命把一个半殖民地半封建的旧中国变  成了一个社会主义新中国；中国共产党领导的第二次革命，将把  一个经济文化落后的社会主义中国变成现代化的社会主义国家\n改革作为一次新的革命，不是也不允许否定和抛弃我们建立起来  的社会主义基本制度，它是社会主义制度的自我完善和发展。改  革不是一个阶级推翻另一个阶级那种原来意义上的革命，也不是  原有经济体制的细枝末节的修补，而是对体制的根本性变革。改  革同革命一样，就目的而言，都是为了解放生产力\n\n\n社会主义市场经济理论\n计划经济和市场经济不是划分社会制度的标志；都是经济手段,本身不具有制度属性。\n社会主义市场经济，特色、优势所在是坚持社会主义制度与市场经济的结合。基本特征：在所有制结构上，以公有制为主体、多种所有制经济共同发展；在分配制度上，以按劳分配为主体，多种分配方式并存；在宏观调控上，以实现最广大人民利益为出发点和归宿\n\n邓小平理论的历史地位马克思列宁主义、毛泽东思想的继承和发展中国特色社会主义理论体系的开篇之作改革开放和社会主义现代化建设的科学指南考试重点1.邓小平理论的主要内容2.邓小平理论的历史地位6 “三个代表”重要思想 (读一遍即可)“三个代表”重要思想的形成形成条件1.世情：“三个代表”重要思想是在对冷战结束后国际局势科学判断的基础上形成的2.党情：“三个代表”重要思想是在科学判断党的历史方位和总结历史经验的基础上提出来的3.国情：“三个代表”重要思想是在建设中国特色社会主义伟大实践基础上形成的三个代表”重要思想的形成过程1.2000年2月25日，江泽民在广东省考察工作时讲话，第一次\n提出并阐述“三个代表”重要思想。\n2.2001年7月1日，江泽民在庆祝中国共产党成立80周年大会\n上的讲话中全面阐述了“三个代表”要求的科学内涵和基本\n内容。\n3.2002年5月31日，江泽民在中共中央党校省部级干部进修班\n毕业典礼上深刻阐述了“三个代表”重要思想的内在联系、\n贯彻要求（完整理论体系内在的逻辑体系）。\n4.十六大将“三个代表”确立为党必须长期坚持的指导思想。\n“三个代表”重要思想的核心观点和主要内容核心观点始终代表中国先进生产力的发展要求 (基础和前提)\n始终代表中国先进文化的前进方向（思想保证，精神动力和智力支持）\n始终代表中国最广大人民的根本利益（出发点、归宿）\n主要内容1. 发展是党执政兴国的第一要务\n2. 建立社会主义市场经济体制\n3. 全面建设小康社会\n4. 建设社会主义政治文明\n5. 推进党的建设新的伟大工程\n历史地位1. 中国特色社会主义理论体系的接续发展 。\n2. 加强和改进党的建设，推进中国特色社会主义事\n业的强大理论武器。\n基本问题：建设什么样的党、怎样建设党\n\n贯彻“三个代表”重要思想，关键是坚持与时俱进，\n核心在保持党的先进性，本质在坚持执政为民\n\n“三个代表”重要思想是中国特色社会主义理论体\n系重要组成部分，是我们党必须长期坚持的指导思\n想。\n7 科学发展观科学发展观的形成科学发展观的形成条件第一，科学发展观是在深刻把握我国基本国情和新的阶\n段性特征的基础上形成和发展的；\n第二，科学发展观是在深入总结改革开放以来特别是党\n的十六大以来实践经验的基础上形成和发展的；\n第三，科学发展观是在深刻分析国际形势、顺应世界发\n展趋势、借鉴国外发展经验的基础上形成和发展的\n科学发展观的形成过程2007年，党的十七大对科学发展观的理论定位、理论\n依据、理论内涵作了全面阐述。\n2012年，十八大把科学发展观确定为党的指导思想。\n围绕“实现什么样的发展、怎样发展\n科学发展观的科学内涵和主要内容科学发展观的科学内涵科学发展观的第一要义是发展，核心是以人为本，\n基本要求是全面协调可持续，根本方法是统筹兼顾\n科学发展观的主要内容加快转变**经济**发展方式、发展社会主义民主**政治**、\n推进社会主义**文化**强国建设、构建社会主义和谐**社\n会**、推进**生态**文明建设、全面提高**党的建设**科学化\n水平\n精神实质：解放思想、实事求是、与时俱进、求真务实\n科学发展观的历史地位一、中国特色社会主义理论体系的接续发展。\n二、发展中国特色社会主义必须长期坚持的指\n导思想\n8 习近平新时代中国特色社会主义思想及其历史地位中国特色社会主义进入新时代新时代标志我国发展新的历史方位1.从发展阶段看，党的十八大以来，改革开放和社会主义现\n代化建设取得历史性成就，我国发展站到了新的历史起点上，\n中国特色社会主义进入新的发展阶段。党的理论创新实现了新\n飞跃，党的执政方式和执政方略有重大创新，发展理念和发展\n方式有重大转变，发展环境和发展条件有重大变化，发展水平\n和发展要求变得更高。\n2.从社会主要矛盾看，我国社会主要矛盾已经转化为人民日\n益增长的美好生活需要和不平衡不充分的发展之间的矛盾\n3.从奋斗目标看，党的十九大到二十大是“两个一百年”奋\n斗目标的历史交汇期，我们既要全面建成小康社会、实现\n第一个百年奋斗目标，又要乘势而上开启全面建设社会主\n义现代化国家新征程，向第二个百年奋斗目标进军\n4.从国际地位看，当代中国正处于从大国走向强国的关键时\n期，已不再是国际秩序的被动接受者，而是积极的参与者、\n建设者、引领者\n社会主要矛盾的变化\n主要矛盾：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾\n第一，经过改革开放40年的发展，我们生产力水平总体上显  著提高，很多方面进入世界前列。\n第二，人民生活水平显著提高，对美好生活的向往更加强烈，  不仅对物质文化生活提出了更高的要求，而且在民主、法治、  公平、正义、安全、环境等方面的要求日益增长。\n第三，影响满足人们美好生活的因素很多，但主要是发展的  不平衡不充分问题。\n\n\n两个没有变：\n历史阶段——仍处于并将长期处于社会主义初级阶段的基本国情没有变\n国际地位——世界上最大的发展中国家的国际地位没有变\n\n\n新时代的内涵和意义  -内涵  - 承前启后、继往开来、在新的历史条件下继续夺取中国特色  社会主义伟大胜利的时代——我们要走什么样的道路：历史性  - 决胜全面建成小康社会、进而全面建设社会主义现代化强国  的时代——我们要建设什么样的国家：实践性  - 全国各族人民团结奋斗、不断创造美好生活、逐步实现全体  人民共同富裕的时代——我们要实现什么样的发展：人民性  - 全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦  的时代——我们要达到什么样的目标：民族性  - 我国日益走近世界舞台中央、不断为人类作出更大贡献的时  代——我们要做出什么样的贡献：世界性\n意义\n近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的  伟大飞跃，迎来了实现中华民族伟大复兴的光明前景——历史意  义：从中华民族复兴的历史进程看\n科学社会主义在二十一世纪的中国焕发出强大生机活力，在世界  上高高举起了中国特色社会主义伟大旗帜——政治意义：从科学  社会主义发展进程看\n中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展  中国家走向现代化的途径，给世界上那些既希望加快发展又希望保  持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献  了中国智慧和中国方案。——世界意义：从人类文明进程看\n\n\n\n\n\n习近平新时代中国特色社会主义思想的主要内容习近平新时代中国特色社会主义思想的核心要义和丰富内涵1.核心要义：坚持和发展中国特色社会主义，是改革 开放以来我们党全部理论\n和实践的鲜明主题，也是习 近平新时代中国特色社会主义思想的核心要义。\n2.丰富内涵：8个明确\n明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华名族伟大复兴\n明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾\n明确中国特色社会主义事业总布局是五位一体，战略布局是四个全面\n明确全面深化改革总目标是完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化\n明确全面推进依法治国总目标是建设中国特色社会主义法治体系，建设社会主义法治国家\n明确党在新时代的强军目标是建设一直听党指挥、能打胜仗、作风优良的人民军队，把人名军队建设成为世界一流军队\n明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体\n明确中国特色社会主义最本质的特征是中国共产党的领导，中国特色社会主义制度的最大优势是中国共产党的领导，党是最高政治领导力量，提出新时代的建设总要求，突出政治建设在党的建设中的重要地位\n十四个坚持\n新时代坚持和发展中国特色社会主义的基本方略\n坚持党对一切工作的领导         坚持在发展中保障和改善民生\n坚持以人民为中心               坚持人与自然和谐共生\n坚持全面深化改革               坚持总体国家安全观\n坚持新发展理念                 坚持党对人民军队的绝对领导\n坚持人民当家做主               坚持一国两制和推进祖国统一\n坚持全面依法治国               坚持推动构建人类命运共同体\n坚持社会主义核心价值体系        坚持全面从严治党\n习近平新时代中国特色社会主义思想的历史地位\n马克思主义中国化的最新成果，党和人民实践经验和集体智慧的结晶，是中国精神的时代精华，国家政治生活和社会生活的根本指针， 是当代中国马克思主义、21世纪马克思主义，是对共产党执政规律、 社会主义建设规律、人类社会发展规律的重大理论创新\n马克思主义中国化最新成果：开辟了马克思主义新境界，开辟了中国特色社会主义新境界，  开辟了治国理政新境界，开辟了管党治党新境界\n新时代的精神旗帜：是党和人民实践经验和集体智慧的结晶；是中国特色社会主义理论体  系的重要组成部分\n实现中华民族伟大复兴的行动指南\n\n\n十九届六中全会通过了《中共中央关于党的百年奋斗重大成就和 历史经验的决议》——最重要的成果：总结党的百年奋斗重大成就 和历史经验 习近平新时代中国特色社会主义思想是当代中国马克思主义、二 十一世纪马克思主义，是中华文化和中国精神的时代精华，实现 了马克思主义中国化新的飞跃\n第一，这一思想深刻回答了新时代的重大时代课题：实现了对中 国特色社会主义建设规律  认识的新跃升，指明了中国式现代化道 路的新图景，开辟了管党治党、兴党强党的新境界——  现实\n第二，这一思想提出了一系列原创性的治国理政新理念新思想新 战略：以全新视野深化了  对共产党执政规律、社会主义建设规律、 人类社会发展规律的认识，是马克思主义中国化的  最新成果——理论\n第三，这一思想是中华文化和中国精神的时代精华：是对中华优秀传统文化进行创造性转化  、创新性发展的典范——历史\n\n\n总体来讲，习近平新时代中国特色社会主义思想，是把马克思主 义基本原理同中国具体实际相结合、同中华优秀传统文化相结合 的重大理论成果，是党的十八大以来历史性成就和历史性变革的重要理论结晶，实现了马克思主义中国化的历史性飞跃和创造性升华。\n\n考试重点1.社会主要矛盾的变化2.新时代的内涵和意义3.习近平新时代中国特色社会主义思想的主要内容4.习近平新时代中国特色社会主义思想的历史地位9 坚持和发展中国特色社会主义的总任务10 “五位一体”总体布局11 “四个全面”战略布局12 全面推进国防和军队现代化13 中国特色大国外交14 坚持和加强党的领导","slug":"master/Politics/毛中特","date":"2022-10-23T11:35:25.000Z","categories_index":"考研政治","tags_index":"考研政治","author_index":"ChrisWood"},{"id":"0c2bac51f883840de61216bf9cb02da8","title":"马克思主义基本原理","content":"马克思主义基本原理导论（8&#x2F;1）第一章马克思主义的创立和发展什么是马克思主义\n马克思主义是由马克思、恩格斯创立并为后继者所不断发展的科学理论体系，是关于自然、社会人类思维发展一般规律的学说，是关于社会主义必然代替资本主义、最终实现共产主义的学说，是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说，是无产阶级政党和社会主义国家的指导思想，是指引人民创造美好生活的行动指南。\n马克思主义包括马克思主义哲学、马克思主义政治经济学和科学社会主义三个基本组成部分，马克思主义哲学是理论基础，政治经济学是主要内容，科学社会主义处于核心地位\n马克思主义基本原理 是马克思主义理论体系中最基本、最核心的内容\n基本：贯穿始终 理论前提\n\n马克思主义的创立\n马克思主义的产生\n1848年 共产党宣言的发表为标志\n\n\n1 经济社会根源 &gt; 资本主义经济的发展\n2 阶级基础 &gt; 现代无产阶级作为独立的政治力量登上历史舞台，无产阶级革命运动从自发走向自觉，迫切需要科学理论指导\n3-1直接理论渊源\n德国古典哲学 – 马克思主义哲学\n英国古典政治经济学 – 马克思主义政治经济学\n英法空想社会主义 – 科学社会主义\n\n\n3-2自然科学前提 &gt; 细胞学说 生物进化论 能量守恒和转化定律\n马恩 德法年鉴 完成了从唯心向唯物、革命民主向共产主义的转变，为创立马克思主义奠定了思想基础\n\n\n马克思恩格斯创立过程\n马克思 资本论第一卷 系统阐述了剩余价值学说\n马克思 法兰西内战、哥达纲领批判 进一步丰富了社会主义学说\n恩格斯 家庭私有制国家起源 发展了马克思主义\n\n\n\n马克思主义的发展\n列宁 使科学社会主义从理论开始变为现实\n中国化马克思主义\n毛泽东思想\n邓小平理论 三个代表重要思想 科学发展观\n习近平新时代中国特色社会主义思想\n\n\n\n马克思主义的鲜明特征科学性\n马克思主义是对自然、社会和人类思维发展本质和规律的正确反映。\n科学的世界观\n科学的方法论\n\n\n\n革命性\n马克思主义集中表现了彻底的批判精神和鲜明的无产阶级立场。\n\n实践性\n指马克思主义是从实践中来，到实践中去，在实践中接受检验，并随实践而不断发展的学说。实践性是马克思主义理论区别于其他理论的显著特征。\n\n人民性\n人民性是指人民至上是马克思主义的政治立场。马克思主义政党把人民放在心中最高位置，一切奋斗都致力于实现最广大人民的根本利益。\n\n发展性-发展性是指马克思主义是不断发展的学说，具有与时俱进的理论品质。\n开放性\n开放性是指马克思主义不断吸收人类历史上一切优秀思想文化成果而不断丰富自己。\n\n马克思主义的当代价值观察当代世界变化的认识工具指引当代中国发展的行动指南引领人类社会进步的科学真理考点1 马克思主义与马克思主义基本原理2 马克思主义的产生和发展3 马克思主义的本质特征4 马克思主义的当代价值备注:18 19 20 21 22每年考一分，单项选择题马克思主义哲学（80&#x2F;16-18）第二三四章导论哲学是系统化、理论化的世界观、又是方法论；哲学是对自然知识、社会知识和思维知识的概括和总结。马克思哲学体系\n两种根本对立的本体论  &gt;  唯物主义和唯心主义的对立\n两种根本对立的发展观  &gt;  辩证法与形而上学的对立\n两种根本对立的认识论 &gt; 反映论与先验论的对立\n两种根本对立的历史论 &gt; 唯物史观与唯心史观的对立\n\n辩证唯物主义（自然观）辩证唯物论 – 世界的本质 第二章第一节\n唯物唯心的区分标准\n世界的本原 物质和思维谁是第一性 &gt; 区分唯物唯心\n思维能否正确认识物质，即物质和思维有无同一性 &gt; 区分可知不可知（同一性：二者有没有联系有没有一致性）\n\n\n\n唯物主义又分朴素唯物主义  形而上学唯物主义 辩证唯物主义及历史唯物主义\n唯心主义又分为主观唯心和客观唯心\n\n\n物质及其存在形式\n物质观\n朴素唯物主义物质观  具体物质\n形而上学唯物主义物质观  原子\n辩证唯物主义物质观  客观实在性\n【备注】\n物质是标志客观实在的哲学范畴\n物质范畴是唯物主义哲学关于世界本原和统一性的最高抽象\n辩证唯物主义物质观的重大理论意义\n其一，坚持了唯物主义一元论，同唯心主义一元论和二元论划清了界限。\n其二，坚持了能动的反映论和可知论，批判了不可知论。\n其三，体现了唯物论和辩证法的统一，克服了形而上学唯物主义的缺陷。\n其四，体现了唯物主义自然观与唯物主义历史观的统一，为彻底的唯物主义奠定了理论基础。\n\n\n\n\n\n\n物质存在形态\n运动 物质的根本属性和存在方式\n运动是标志一切事物和现象的变化及其过程的哲学范\n物质与运动不可分割\n任何物质处于运动之中\n物质是运动的主体 承载者\n割裂物质和运动的关系必然导致 唯心主义或者形而上学唯物主义\n\n\n\n\n静止 运动是绝对的 静止是相对的；动中有静，静中有动\n静止是运动的特殊状态，在一定条件下暂时稳定和平衡状态的哲学范畴（2种状态：空间的相对位置暂时不变 事物的根本性质暂时不变）\n相对静止是物质存在和发展的必要条件；是人们认识和利用事物的前提；是理解和衡量运动的尺度\n\n\n时空观 时空是物质运动的存在形式\n时间 物质运动的持续性和顺序性 时间的特性是一维性\n空间 物质运动的广延性、伸张性 空间的特点三维性\n时空和物质运动的关系 形式和内容的关系\n时间和空间具有客观性\n时空是绝对和相对的统一\n时空是无限和有限的统一\n\n\n一切以时间、地点、条件为转移。具体问题具体分析\n\n\n\n\n\n\n意识观\n起源\n物质世界高度发展的产物（前提）\n一般反应-刺激感应-动物感觉和心理-人的意识\n\n\n社会劳动的产物\n劳动为意识的产生提供了客观需要和可能\n在劳动中人脑不断完善，并产生了语言\n语言是劳动中人脑产生的，是意识的物质外壳\n\n\n\n\n\n\n本质 \n人脑对物质世界的主观映像；\n意识是客观内容和主观形式的统一\n意识的内容是客观的：意识内容来自物质世界\n意识的形式是主观的：意识形式是主观世界特有的、不同主体之间的差别性、同一主体不同条件下的差别性\n\n\n\n\n\n\n物质与意识的辩证关系\n物质决定意识\n世界同一于物质原理内容\n其一，世界是统一的，即世界的本原是一个；\n其二，世界的统一性在于它的物质性，即世界统一的基础是物质\n其三，物质世界的统一性是多样性的统一，而不是单一的无差别的统一，坚持辩证法\n\n\n世界同一于物质原理的意义\n理论意义：马克思主义哲学基石\n实践意义：是我们从事一切工作的立足点，一切从实际出发是唯物主义一元论的根本要求\n\n\n\n\n意识对物质具有反作用（主观能动性和客观规律性的统一）\n意识能动性\n本质内涵 人类意识特有的能动地反映世界并通过实践能动地改造世界的能力和活动\n主要表现\n第一，意识活动具有目的性和计划性：\n第二，意识活动具有创造性；\n第三，意识具有指导实践改造客观世界的作用；\n第四，意识具有控制人的行为和生理活动的作用。\n\n\n\n\n客观规律\n定义 事物运动发展中的本质的必然的稳定的联系\n特点 规律是本质的联系、必然的联系、稳定的联系、客观的联系（客观 只能认识和利用）\n表现 自然规律和社会规律\n联系 自然规律和社会规律都具有不以人的意志为转移的客观性\n区别 自然规律是作为一种盲目的无意识的力量起作用；社会规律是通过抱有一定目的和意图的人的有意识的活动来实现的\n\n\n\n\n正确发挥主观能动性的条件\n从实际出发，努力认识和把握事物发展规律\n尊重客观规律是前提和基础\n发挥能动性是认识、利用的必要条件\n尊重和发挥是辩证统一的\n\n\n实践是发挥人的主观能动作用的基本途径\n主观能动作用的发挥，还依赖一定的物质条件和物质手段\n\n\n\n\n实践是自然存在和社会存在区分和统一的基础\n从实践出发理解社会生活的本质 实践是人的本质存在方式\n一方面，实践是使物质世界分化为自然界与人类社会的历史前提，又是使自然界与人类社会统一起来的现实基础。\n另一方面，实践是社会关系形成的基础，实践形成了社会生活的基本领域（物质生活、政治生活、精神生活领域），实践构成了社会发展的动力。\n\n\n社会生活的实践性\n第一，实践是社会关系形成的基础\n第二，实践形成了社会生活的基本领域\n第三，实践构成了社会发展的动\n\n\n\n\n备注\n决定和反作用关系  都具有前后关系\n三个统一 \n世界物质的统一性\n主观能动性和客观规律性的统一\n实践是自然存在和社会存在区分和统一的基础\n\n\n\n\n\n\n【备注】关键词关键句\n物质与意识 运动与静止 物质运动和时空 客观规律和主观能动性\n物质范畴是一切唯物主义哲学的理论基石\n世界的物质统一性是马哲的理论基石，是一切从实际出发的理论依据\n物质的唯一特性是客观实在性\n物质的根本属性和存在方式是运动\n意识产生过程中起决定作用的因素是社会劳动\n社会生活的本质是实践\n\n\n【备注】考点\n5.哲学的基本问题与基本派别\n6.物质范畴以及物质的根本属性和基本存在方式\n7.意识观：意识的起源于本质\n8.物质与意识的辩证关系\n9.世界的物质统一性原理\n10.主观能动性与客观规律性的统一\n11.实践是社会生活的本质\n\n\n\n唯物辩证法 – 世界的存在方式 第二章第二三节-    - 事物的联系和发展    - 唯物辩证法是认识和改造世界的根本方法    - 辩证法坚持用联系的、发展的观点看世界，认为发展的根本原因在于事物的内部矛盾    - 形而上学则坚持用孤立的、静止的观点看问题，否认事物内部矛盾的存在和作用\n\n两大特征 普遍联系与永恒发展\n\n联系\n定义：联系是指事物内部各要素之间和事物之间相互影响、相互制约和相互作用的关系。 世界的普遍联系是通过“中介”来实现。\n特点：\n客观性，事物本身固有的\n普遍性，内部 外部 中介\n多样性，事物是多样的\n条件性，条件是对事物存在和发展发生作用的诸要素的总和\n条件对事物的发展和人的活动具有支持或制约作用\n条件是可以改变的\n改变和创造条件必须符合客观规律\n\n\n\n\n意义：要求人们善于分析事物的具体联系，确立整体性、开放性观念\n\n\n发展\n实质是新事物的产生、旧事物的灭亡\n新事物必然战胜旧事物\n新事物是指符合客观规律和发展的前进方向、具有强大生命力和远大前途的事物\n新事物的结构和功能适合变化了的环境和条件\n新事物比旧事物优越\n在社会历史领域，新事物是符合广大人民群众的根本利益\n\n\n发展与过程 过程是指一切事物都有产生发展和转化为其他事物的历史\n要求我们用历史的观点看问题，把一切事物都如实的看作是变化、发展的过程\n\n\n\n\n\n\n五大环节\n\n内容与形式（要素与结构）\n定义 内容是构成事物一切要素的总和 形式是内容诸要素相互结合的结构和表现形式\n关系 相互依赖不可分割，相互作用相互依赖，内容决定形式，形式反作用于内容\n意义 重视内容作用，反对形式主义，善于运用形式，适时创造新形式\n\n\n本质与现象（内在联系与外在表现）\n定义 现象是指事物外部联系和表面特征；本质是事物的根本性质，是组成事物基本要素的内部联系\n区别 现象是感官感知 个性 丰富生动的 本质是思维能力把握 共性 普遍深刻的\n关系 任何事物都是现象和本质的统一体\n意义 透过现象看本质\n备注 现象包含真象 假象（歪曲表现事物的本质）  和错觉区分开，错觉是主观的\n\n\n原因与结果（前后相继。彼此制约）\n定义 事物或现象之间前后相继。彼此制约，即引起和被引起的关系\n关系 \n一个具体的因果联系中，二者不能混淆和颠倒。\n原因与结果相互依存，相互转化（一定条件下）\n原因和结果的关系不仅是客观普遍的，而且是复杂多样的（一因多果，同因异果与同果异因，多因多果与复合因果）\n\n\n意义 正确认识掌握事物的因果联系，增强实际工作中的自觉性、预测性和调控性\n\n\n必然与偶然（两种不同趋势）\n定义 必然性是指事物联系发展过程中一定发生、确定不移的趋势，偶然性是指非确定发生、不确认的趋势 必然性和偶然性同一个事物的2种不同趋势\n关系 必然性通过大量的偶然性表现出来，偶然性是必然性的表现形式和补充，在一定条件下可以相互转化\n意义 把握有利于事物发展的机遇，重视机遇的作用\n\n\n可能与现实（过去、现在与未来）\n定义\n可能性是指事物发展中潜在的东西，是包含在事物之中并预示着事物发展前途的种种趋势\n现实性是已经产生出来的，有内在依据、合乎必然性的存在\n可能性范畴\n区分可能和不可能   有没有客观依据\n区分现实的可能和抽象的可能   条件是否充分\n区分两种相反的可能  对现实的可能的定性分析\n区分可能性的程度  对现实的可能的定量分析\n\n\n\n\n关系 可能性是还没有成为现实的东西，现实性是已经实现了的可能，同时又孕育着新的可能，在一定条件下可以相互转化\n意义 立足于现实，发挥主观能动性，把有利的可能变成现实\n\n\n\n\n三大规律\n\n对立统一规律 事物发展的源泉和动力（核心）\n\n又叫矛盾规律\n矛盾是事物发展的源泉和的动力，矛盾具有普遍性和特殊性\n矛盾的同一性和斗争性及其在事物发展中的作用\n辩证矛盾是反映客观事物内部和事物之间既对立又统一关系的哲学范畴\n同一性和斗争性是矛盾的两个基本属性\n同一性 矛盾双方互相依存、互相贯通的性质和趋势\n斗争性 矛盾双方相互分离、相互排斥的性质和趋势\n关系 矛盾的同一性是相对的有条件的；斗争性是绝对的无条件的，同一是包含着差别对立的同一；斗争是统一体内部的斗争，一定条件下矛盾双方相互转化\n意义 同中求异 异种求同 一分为二看问题\n\n\n同一性和斗争性在事物发展中共同作用\n同一性的作用\n由于矛盾双方相互依存，互为存在的条件，矛盾双方可以利用对方的发展使自己获得发展\n由于矛盾双方相互包含，矛盾双方可以相互吸取有利于自身的因素而得到发展\n由于矛盾双方彼此相通，矛盾双方可以向着自己的对立面转化而得到发展，并规定着事物发展的方向\n\n\n斗争性的作用\n促进事物量变 推动矛盾双方力量对比发生变化\n完成事物质变 突破事物存在的限度，旧的矛盾统一体分解 新的矛盾统一体产生\n\n\n意义 事物的发展不仅相反相成 还表现为相辅相成 正确把握和谐的作用\n\n\n\n\n矛盾的普遍性和特殊性及其相互关系（5年内没有分析题，重视）\n普遍性 空间上无处不在，时间上无时不有 矛盾存在一切事物及每个事物发展过程中自始至终的矛盾运动\n在实际生活中，坚持矛盾分析法\n\n\n特殊性 每个事物所包含的矛盾及每个矛盾各个方面都有其特点\n具体表现\n不同事物的矛盾各有特点\n矛盾在同一事物不同发展过程和阶段各有特点\n不同矛盾不同方面各有不同性质、地位、作用\n根本矛盾（贯穿事物发展过程始终） 非根本矛盾\n主要矛盾（决定作用）和次要矛盾 主要方面（主导地位）和次要方面  矛盾的性质是由矛盾的主要方面决定的\n解决矛盾的形式的多样性\n一方克服另一方\n双方同归于尽\n双方形成协同运动的新形式\n双方融合成为一个新事物\n\n\n\n\n\n\n具体问题具体分析\n\n\n辩证关系\n区别 矛盾的普遍和特殊 是共性和个性 一般和个别的关系\n联系 普遍性从特殊性中概括出来；特殊性必然与普遍性相联系而存在；在一定条件下相互转化\n\n\n意义\n理论意义 是事物矛盾问题的精髓，是正确理解矛盾学说的关键\n实践意义 坚持马克思主义普遍真理与各国具体实践相结合的\n\n\n\n\n矛盾及其发展的不平衡性\n主次矛盾 支配地位、决定作用的是主要矛盾\n主要矛盾决定次要矛盾 次要影响主要 一定条件下相互转化\n\n\n主要方面 同一矛盾 主导地位的方面是主要方面\n主要方面支配次要方面 事物性质主要是由支配地位矛盾的主要方面决定 次要影响主要 一定条件下相互转化\n\n\n意义 两点论和重点论相结合 抓关键看主流\n\n\n总结\n矛盾的内涵 既对立又统一\n一 同中求异，异中求同（和而不同） 矛盾的基本属性 同一性和斗争性\n二 相辅相成与相反相成 同一性和斗争性的共同作用\n三 具体问题具体分析 普遍性和特殊性\n四 精髓原理 普遍性和特殊性的辩证关系，共性个性 \n五 不平衡性原理 主次矛盾 矛盾的主次方面\n\n\n\n\n质量互变规律 事物发展的形式或状态\n\n任何事物都呈现出量变质变两种形式，度是区分量变质变的尺度\n任何事物都是质和量的统一体\n质\n事物成为它自身并区别于其他事物的内在规定性\n质是认识的起点和基础\n\n\n量\n事物存在发展的规模、程度、速度以及其他构成空间上排列组合等可以用数量表示的规定性\n量是认识的深化和精确化\n\n\n度\n保持自己质的数量限度，是质和量的统一\n意义 坚持适度原则 防止过和不及\n\n\n\n\n量变质变及其辩证关系\n量变是事物数量的增减或场所变更\n质变是事物根本性质的变化\n区分的根本标志是事物的变化是否超出度\n辩证关系\n量变是质变的必要准备\n质变是量变的必然结果\n质变量变互相渗透的\n总的量变中有阶段性和局部性部分质变\n质变过程中包含着量的扩张，新质因素增长，旧质因素灭亡\n\n\n\n\n意义 既要有远大目标，又要注重量的积累\n\n\n\n\n否定之否定规律 事物发展的方向和道路\n\n辩证否定的实质是扬弃；任何事物的发展都是前进性和曲折性的统一\n肯定因素和否定因素（维持存在的因素 促成灭亡的因素）\n辩证的否定观\n否定是事物的自我否定，是事物内部矛盾运动的结果。\n否定是事物发展的环节。\n否定是新旧事物联系的环节。\n辩证否定的实质是“扬弃”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素。\n\n\n意义 对待一切事物采取科学分析的态度和方法 传统文化取弃 外国文化 不一概拒绝不全盘照搬\n事物发展前进性和曲折性的统一\n事物发展总趋势是前进的上升的，因为事物发展通过否荻定，每次否定都意味着一次扬弃\n道路迂回曲折 否定之否定阶段会重复肯定阶段某些特点，仿佛回到出发点，事物发展呈现出周期性\n意义 做好艰苦的努力 争取光明的前途\n\n\n\n\n\n\n四种辩证思维方法\n\n归纳与演绎\n分析与综合\n抽象与具体\n逻辑与历史相统一\n\n\n五大思维能力\n\n辩证思维\n唯物辩证法是认识和改造世界的根本方法\n唯物辩证法是客观辩证法和主观辩证法的统一，体现唯物主义、辩证法、认识论的统一\n客观辩证法 客观事物或客观存在的辩证法\n主观辩证法 人类认识和思维运动的辩证法\n主观辩证法是客观辩证法的反映 是反映与被反映 第二性和第一性的关系\n矛盾分析法在唯物辩证法中处于核心地位，是根本的认识方法\n联系  矛盾 重点  透过现象看本质\n\n\n历史思维\n战略思维\n底线思维\n创新思维\n\n\n习近平新时代中国特色社会主义思想对唯物辩证法的创造性运用和发展\n\n【备注】考点\n\n12.唯物辩证法两大特征\n13.唯物辩证法基本环节\n14.唯物辩证法实质和核心：对立统一规律\n15.质量互变规律\n16.否定之否定规律\n17.掌握辩证思维能力，增强辩证思维能力\n\n\n\n辩证唯物主义认识论 – 认识发展的一般规律 第三章\n认识的基础\n\n实践\n本质 人类能动地改造世界的客观物质性活动\n特点 直接现实性、自觉能动性、社会历史性\n基本结构\n主体 具备实践和认识能力，从事实践和认识活动的人\n客体 实践和认识活动指向的对象\n中介 各种形式的工具 手段 程序和方法\n主体和客体之间最基本的关系是实践关系（改造被改造），在此基础上才有认识关系（反映被反映） 价值关系（满足被满足）\n\n\n\n\n基本形式 物质生产实践（最基本的实践活动） 社会政治实践 科学文化实践\n\n\n认识的本质\n两条根本对立的认识路线\n唯物主义反映论：坚持“从物到感觉和思想“的认识路线\n唯心主义先验论：坚持“从感觉和思想到物“的认识路线\n\n\n直观反映论与能动反映论的对立\n旧唯物主义认识论 直观被动反映论\n第一，缺乏实践的观点；\n第二，缺乏辩证法的观点。\n\n\n辩证唯物主义认识论 能动革命反映论\n认识是主体在实践基础上对客体的能动反映。\n首先，反映具有摹写性。其次，反映具有创造性。最后，以实践为中介而实现的。\n\n\n\n\n即本质是 主体在实践基础上对客体的能动反映\n\n\n实践是认识的基础\n第一，实践是认识的唯一来源。 直接经验是源 间接经验是流\n第二，实践是认识发展的动力。\n实践的发展不断提出新课题\n实践为解决新问题提供必要经验材料，认识工具和技术手段，推动认识不断向深度和广度拓展\n实践推动人类思维水平不断提高\n\n\n第三，实践是认识的目的。\n第四，实践是检验认识的真理性的唯一标准。\n\n\n\n\n认识的运动规律\n\n两次飞跃\n第一次飞跃：在实践基础上从感性认识到理性认识的飞跃\n感性认识和理性认识的辩证关系\n感性认识 感官 外部联系 感觉、知觉、表象 初级阶段 直接性、形象性\n理性认识 思维 本质特征 概念、判断、推理 高级阶段间接性、抽象性\n感性认识和理性认识的辩证统一\n理性认识依赖于感性认识。\n感性认识有待于发展深化为理性认识。\n感性认识和理性认识相互渗透、有机统一。\n\n\n飞跃的条件\n必须尽可能获得十分丰富、合乎实际（全面、正确）的感性材料\n必须运用科学的思维方法对丰富的感性材料加以去粗取精、去伪存真、由此及彼、由表及里的改造（2去2由）\n\n\n理性因素和非理性因素在认识过程中共同起作用\n理性因素 人的理性思维能力，即认知  在认识活动中发挥指导作用、解释作用、预见作用\n非理性因素 人的情感、意志，以及以非逻辑形式出现的非理智、非认知的精神因素 在认识活动中起到动力作用、诱导作用、激发作用\n\n\n\n\n第二次飞跃 从认识到实践\n第二次飞跃比第一次飞跃更重要、意义更伟大\n第一，认识世界的目的是为了改造世界。\n第二，认识的真理性只有在实践中才能得到检验和发展。\n\n\n实现由认识向实践的飞跃，需要经过一定的中介环节，包括确定实践目的、形成实践理念、制定实践方案、进行中间实验、运用科学实践方法等。\n对人民群众进行组织和宣传，让理论为群众所掌握，并转化为改造世界的物质力量\n\n\n\n\n多次反复和无限发展\n认识发展的总过程：“实践、认识、再实践、再认识”，本质上体现了认识发展的一般规律\n认识过程之所以多次反复：受到主客观条件限制，往往不是一次完成\n从主观方面看，人们总是受到自己的认识能力和实践活动范围的限制\n从客观方面看，事物的各个侧面及其本质的暴露有一个过程；受到所处时代科学技术条件的限制\n\n\n认识过程之所以无限发展：因为物质世界及其发展是无限的，因而人们的认识运动永远不会终结\n\n\n一个原则：坚持主观和客观、认识和实践具体的历史的相统一的原则\n具体的统一 特定的时间、地点和条件下\n历史的统一 随着实践的不断发展而相应的变化发展\n\n\n\n\n认识的结果\n\n真理与谬误\n真理是人们对客观事物及其规律的正确反映。\n谬误是人们对客观事物及其规律的歪曲反映。\n真理和谬误又是相互联系的。真理和谬误相比较而存在，相斗争而发展。在一定条件下，真理和谬误相互转化。\n真理的客观性、绝对性和相对性\n本质特征：真理的客观性（真理问题上的唯物论问题）\n第一，真理的内容是客观的\n第二，检验真理的标准，即社会实践也是客观的\n\n\n真理的客观性决定了真理的一元性\n真理的绝对性和相对性及其辩证关系原理\n真理的绝对性也称为绝对真理，是指真理的无条件性、无限性\n真理的相对性也称为相对真理，是指真理的有条件性、有限性。\n第一，从认识的广度上看，有待于扩展。\n第二，从认识的深度上看，有待于深化。\n\n\n真理是一个从相对真理走向绝对真理，接近绝对真理的过程。绝对真理是通过相对真理表现出来的，在一定条件下相互转化。\n意义 正确对待马克思主义的态度是：一要坚持，二要发展。\n\n\n\n\n实践是检验真理的唯一标准\n实践是检验真理的唯一标准，这是由真理的本性和实践的特点所决定的。\n真理的本性是主观和客观相符合，实践是把主观与客观联结起来的“桥梁”。\n实践的直接现实性决定了只有实践才能成为检验真理的标准，实践具有直接现实性，不仅它本身是直接现实，而且它能够使理论成为现实\n\n\n实践标准的确定性和不确定性\n实践标准的确定性或绝对性：实践是检验真理的唯一和最终标准。\n实践标准的不确定性或相对性：任何实践都是一定社会历史条件下的实践，都要受到特定的社会历史条件的制约或影响。实践对认识的检验也要有一个多次反复的过程。\n\n\n\n\n\n\n真理与价值\n价值、价值评价、价值观\n价值：反映客体与主体需要之间满足和被满足关系的范畴\n价值的特点：客观性、主体性、社会历史性、多维性\n价值评价是一种关于价值现象的认识活动\n特点： \n第一，评价以主客体的价值关系为认识对象。一是知识性认识，追求的是“真”；一是评价性认识，追求的是“善和美”。\n第二，评价结果依主体的客观存在状态，包括主体的需要、特点以及其它规定性而转移的。\n第三，评价结果的正确与否依赖于相关的知识性认识。\n\n\n标准：只有与人民、人类整体的要求和利益相一致，才是正确的价值评价。\n功能：推动实践不断实现价值的精神驱动力量、规范性要素、导向要素。\n\n\n\n\n真理与价值在实践中的辩证统一\n真理原则：人们必须按照世界的本来面目去认识世界和改造世界，追求和服从真理。\n物的尺度 条件制约性 认识过程中的统一性\n\n\n价值原则：人们必须按照自己的需要去认识和改造世界，创造和实现价值。\n人的尺度 目的性和能动性 社会活动中的多样性\n\n\n意义 \n第一，成功的实践必然是以真理和价值的辩证统一为前提的。是合规律性和合目的性的统一。只有把“按科学规律办事”与“满足人的需要”结合起来的实践，才是成功的实践。\n第二，价值的形成和实现以坚持真理为前提，而真理又必然是具有价值的。\n第三，二者在实践和认识活动中是相互制约、相互引导、相互促进的。\n\n\n\n\n\n\n\n\n认识世界和改造世界\n\n认识世界与改造世界及其辩证关系\n\n认识世界与改造世界\n认识世界和改造世界是人类创造历史的两种基本活动。\n认识世界和改造世界的过程，既是认识和改造客观世界的过程，也是认识和改造主观世界的过程。改造客观世界，包括改造自然界和改造人类社会；改造主观世界，核心是改造世界观。\n改造客观世界与改造主观世界辩证统一，二者相辅相成、相互促进。\n\n\n从必然走向自由的过程\n自由是对必然的认识和对客观世界的改造。\n必然王国和自由王国是人类在客观世界面前所处的两种不同的社会活动状态。\n必然王国，人受物支配的社会状态；自由王国，人支配物的社会状态。\n自由是历史发展的产物。自由是有条件的：一是认识条件；二是实践条件\n认识必然和争取自由，是人类认识世界和改造世界的根本目标，是一个永无止境的历史性的过程\n\n\n\n\n\n\n一切从实际出发，实事求是\n\n实现理论创新和实践创新的良性互动\n\n实践创新为理论创新提供不竭的动力源泉，理论创新为实践创新提供科学的行动指南\n实践创新是理论创新的决定性因素。理论创新对实践的发展具有指导作用\n\n\n实践基础上的理论创新是社会发展和变革的先导\n理论创新与实践创新的良性互动，二者之间形成相互激发、共同促进的因果关系。\n\n\n\n\n考点\n\n18.实践是认识的基础\n19.认识运动的基本规律\n20.坚持整理，修正错误\n21.真理的客观性绝对性和相对性及其辩证关系原理\n22.检验真理与谬误的标准及其检验标准的确定性和不确定性的统一\n23.真实与价值在实践中的辩证统一\n24.认识世界和改造世界\n25.马克思主义认识论和党的思想路线\n\n\n\n历史唯物主义（历史观）- 人类社会发展的一般规律 第四章两种根本对立的历史观\n社会存在和社会意识的关系问题是划分两种历史观的标准\n历史唯物主义坚持社会存在决定社会意识，把社会历史发展的根源、动力和决定性力量归结为物质和经济因素的\n社会存在与社会意识辩证关系原理\n社会存在及其在社会发展中的作用\n社会存在\n本质内涵：社会生活的物质方面，是社会实践和物质生活各种条件的总和\n构成要素：包括地理环境、人口要素和物质资料的生产方式\n地理环境：人类生存和发展所依赖的各种自然条件的总和。自然地理环境提供了社会生活和生产资料的来源；自然地理环境的优劣对社会发展起促进或延缓的作用。\n正确处理人与自然之间的关系。合理调节人与自然之间的物质变换。坚持人与自然和谐共生。\n人口因素则是从事生产实践活动的有生命的个人的总和。人口的数量和质量等因素对生产发展和社会进步起加速或延缓的作用。适度的人口对社会发展起加速作用。\n自然地理环境和人口因素，人类社会产生和存在的必要条件，都不能决定社会的性质和社会形态的更替\n\n\n核心要素：其中，主要是指物质资料生产方式\n生产方式：是人们为了获取物质资料而改造自然的劳动方式，是生产力和生产关系的统一。它集中体现了人类社会的物质性。\n生产方式在社会发展中起决定作用\n生产方式是人类社会赖以存在和发展的基础。\n生产方式决定了社会的结构、性质和基本面貌，决定了整个社会生活\n生产方式的变化发展，最终决定着社会历史的变化发展，决定着社会形态的更替。\n\n\n\n\n\n\n社会意识及其构成\n社会意识 社会生活的精神方面 包括政治思想、法律思想、道德、宗教、艺术、哲学和科学在内的各种社会意识形式\n社会意识的构成\n按主体分 个人意识：个人独特实践经验的反映；群体意识：一定群体（家庭、民族、阶级）\n按水平（层次）分 低：社会心理（风俗习惯）高：社会意识形式（根据有无阶级性又分社会意识形态、非社会意识形态） 政治、法律、道德、宗教、艺术、哲学和科学\n\n\n\n\n社会存在与社会意识的关系\n社会存在决定社会意识，社会意识是社会存在的反映\n社会意识具有相对独立性，在社会存在决定社会意识的前提下，社会意识一旦产生，还具有自身的能动性和独特的发展规律。\n社会意识相对独立性的表现\n社会意识与社会存在发展的\n不完全同步性：社会意识既可能落后也可能超前于社会存在；\n不平衡性：有些经济上相对落后的国家，社会意识某些方面却可以领先于经济上先进的国家，反之也成立。\n\n\n社会意识\n横向：内部各种形式之间的相互影响\n纵向：各自具有的历史继承性。\n\n\n社会意识对社会存在具有能动的反作用。（相对独立性最突出、最重要的表现）\n\n\n\n\n这一原理理论意义和实践意义\n理论意义\n唯物史观对历史观基本问题的科学回答，宣告了唯心史观的彻底破产。\n两个划分 从社会生活的各种领域中划分出经济领域，从一切社会关系中划分出生产关系\n生产关系是其余一切关系的基本的、原始的关系\n\n\n两个归结：将一切社会关系归结于生产关系，将生产关系归结于生产力发展的髙度\n\n\n\n\n实践意义\n先进文化为社会发展提供 思想保证&#x2F;精神动力&#x2F;凝聚力量&#x2F;智力支持\n\n\n\n\n\n\n\n\n\n\n\n人类社会发展的基本规律\n生产力与生产关系的矛盾运动及其规律\n\n生产力\n\n人类征服自然和改造自然，获得物质生活资料的客观能力，揭示了人与自然的关系\n实体性因素： \n劳动者 主导作用，生产力的首要因素\n劳动资料 生产工具是标志生产力水平的客观尺度，是划分社会经济时期的物质标志\n劳动对象 指劳动者在生产过程中加工的一切对象\n\n\n渗透性因素：科学技术是第一生产力\n\n\n生产关系：是人们在物质生产过程中形成的人与人之间的经济关系。生产关系是人们全部社会关系中最本质、最基本的关系\n\n生产关系的构成\n生产资料所有制关系\n生产中人与人之间的关系\n产品的分配关系\n\n\n生产资料所有制关系是基本的方面，构成全部生产关系的基础（生产资料私有制、公有制）\n\n\n生产关系一定要适合生产力状况规律\n\n第一，生产力决定生产关系。\n第二，生产关系反作用于生产力。\n第三，生产力和生产关系的相互作用构成了二者的矛盾运动，生产关系对生产力是由基本适合到基本不适合，再到新的基础上的基本适合循环往复的过程，每一个矛盾运动过程都使社会发展到高一级的程度，表现出生产关系一定要适合生产力状况的趋势\n\n\n正确认识这一规律的意义\n\n理论意义：第一次科学地确立了生产力发展是“社会进步的最高标准”。\n实践意义：是马克思主义政党制定方针和政策的重要依据。\n\n\n\n\n经济基础与上层建筑的矛盾运动及其规律\n\n经济基础：与社会生产力一定发展阶段相适应的（占主导地位的）生产关系的总和。\n其实质是社会一定发展阶段上的基本经济制度\n与经济体制有内在联系\n\n\n上层建筑：建立在一定社会经济基础之上的政治法律制度及其设施，以及与之相应的社会意识形态的总和。\n政治上层建筑，包括政治法律制度及其设施，如军队、警察、法庭、监狱、政治机构等；\n观念上层建筑（思想上层建筑），即社会意识形态，如政治、法律、艺术、道德、宗教、哲学等。\n政治上层建筑居主导地位，国家政权是核心。\n国家是阶级矛盾矛盾不可调和的产物。\n其实质是一个阶级统治另一个阶级的暴力工具。\n\n\n\n\n经济基础与上层建筑的矛盾运动及其规律\n第一，经济基础决定上层建筑。\n第二，上层建筑对经济基础的反作用。\n服务方向有助于自身经济基础的建立并保护其发展\n服务方式通过对社会物质生活和精神生活的控制\n服务效果反作用的性质取决于它所服务的经济基础的性质\n\n\n第三，经济基础和上层建筑的相互作用构成了它们之间的矛盾运动，把社会形态不断从低级推向高级的发展阶段\n\n\n方法论意义：这一规律对于我们进行社会主义政治体制改革和建设社会主义精神文明具有重要的指导意义\n\n\n\n社会形态更替的一般规律及特殊形式\n社会形态：同生产力发展的一定阶段相适应的经济基础和上层建筑的统一体。经济基础是社会的“骨骼系统”，上层建筑是社会的“血肉系统”\n社会形态更替的统一性；根据生产关系的不同性质，社会形态依次更替为原始社会、奴隶社会、封建社会、资本主义社会和共产主义社会\n社会发展道路的多样性；各个国家和民族历史发展的特殊性\n社会形态更替的必然性与人们的历史选择性\n第一，社会发展的客观必然性构成了一定历史阶段社会发展的基本趋势，为人们的历史选择提供了基础、范围和可能性空间。\n第二，社会形态更替的过程也是一个合目的性与合规律性相统一的过程。\n人们的历史选择性，归根结底是人民群众的选择性。\n\n\n社会形态更替的前进性与曲折性\n\n社会历史发展的动力系统\n社会基本矛盾是社会发展的根本动力\n\n生产力和生产关系的矛盾、经济基础和上层建筑的矛盾构成人类社会的基本矛盾\n根本动力：\n第一，生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量\n第二，社会基本矛盾特别是生产力和生产关系的矛盾，是“一切历史冲突的根源”，决定着社会中其他矛盾的存在和发展。\n第三，社会基本矛盾具有不同的表现形式和解决方式，并从根本上影响和促进社会形态的变化和发展。无论是阶级斗争、社会革命还是改革，其根源都是社会基本矛盾\n\n\n社会主要矛盾在历史发展中的作用\n事物的性质主要的是由主要矛盾的主要方面决定的\n\n\n\n\n阶级斗争是阶级社会发展的直接动力\n\n阶级是一个历史范畴，也是一个经济范畴，还是一个社会范畴\n阶级是在一定社会生产关系中处于不同经济地位的社会集团，其中一个集团能够占有另一个集团的劳动\n阶级斗争的根源是物质利益的根本对立\n阶级斗争推动社会发展的作用，突出地表现在社会形态更替的质变过程中\n\n\n社会革命的实质、根源及作用\n\n广义 社会基本矛盾运动基础上的社会生活的全面变革\n狭义 社会革命主要是指社会形态的变更\n革命的根本问题是政权问题。社会基本矛盾尖锐化是革命的根源。\n\n\n改革的实质及改革在社会发展中的作用\n\n改革的实质\n改革是同一种社会形态发展过程中的量变，通过调整、变革不适合生产力发展要求的生产关系和上层建筑的某些部分和环节，实现社会形态的自我发展和自我完善*\n\n\n改革的作用\n改革在一定程度上解决社会基本矛盾，促进生产力的发展，推动社会进步的有效途径和手段\n\n\n\n\n科学技术在社会发展中的作用以及科学技术作用的两重性\n\n科学：对客观世界的认识，是反映客观事实和客观规律的知识体系及其相关活动。科学主要分为自然科学、社会科学和思维科学。\n技术：生产技术，即人类改造自然、进行生产的方法与手段。\n作用\n科学技术革命是推动经济和社会发展的强大杠杆\n第一，科学技术的发展极大地促进了社会生产方式的变革。\n改变了社会生产力的构成因素。劳动力结构向智能化发展；\n劳动方式由机械自动化走向智能自动化的根本性变革。\n改变了社会经济结构，特别是产业结构发生变革。\n\n\n第二，科学技术的发展推动了生活方式的变革。\n提高了人们的物质生活条件和精神生活质量，改变了人们的消费方式、活动方式、交往方式等，为人的全面发展创造了条件\n\n\n第三，科学技术的发展引起了思维方式的变革。\n通过影响思维主体、思维客体和思维工具，引起了思维方式的变革\n\n\n\n\n是人类社会进步的重要标志。\n\n\n科学技术社会作用具有两重性，其对积极作用是主要的、基本的方面\n一是对自然规律和人与自然关系认识不够，缺乏对消极后果强有力的控制手段；\n二是在一定程度上，与社会制度有关。\n\n\n\n\n\n人民群众及个人在历史发展中的作用\n两种历史观在历史创造者问题上的根本对立\n\n唯心史观与唯物史观表现为英雄史观与群众史观的根本对立\n\n\n唯物史观考察历史创造者的原则\n\n首先，唯物史观立足于现实的人及其本质来把握历史的创造者。\n从人的生存与发展的基础来看，劳动是最基本的实践活动，也是人类最基本的存在方式\n从人与人之间的关系来看，人的现实本质是一切社会关系的总和，人的本质属性是社会属性；人的本质属性表现在各种社会关系中。\n其次，唯物史观立足于整体的社会历史过程来探究谁是历史的创造者。\n再次，唯物史观从社会历史发展的必然性入手来考察和说明谁是历史的创造者。\n最后，唯物史观从人与历史关系的不同层次上考察谁是历史的创造者。人与历史的关系具有类与历史、群体与历史、个体与历史三层关系。\n\n\n人民群众在创造历史过程中的决定作用\n\n人民群众，推动社会历史发展的社会大多数成员的总和。\n人民群众本身也是个历史范畴；（不同阶段性质不同）\n劳动群众始终是人民群众最稳定的主体。\n\n\n人民群众是推动历史前进的决定力量\n是社会物质财富的创造者。\n是社会精神财富的创造者。\n是社会变革的决定力量。\n\n\n人民群众创造历史的制约性：\n创造活动总是受着一定历史时期的经济、政治和思想文化条件的制约\n\n\n群众观点：\n第一，坚信人民群众自己解放自己的观点。\n第二，全心全意为人民服务的观点。\n第三，一切向人民群众负责的观点。\n第四，虚心向人民群众学习的观点。\n\n\n群众路线：\n一切为了群众，一切依靠群众 是党的政治路线、组织路线；\n从群众中来，到群众中去 是党的领导方法和工作方法。\n一是领导和群众相结合，二是一般号召和个别指导相结合。\n\n\n\n\n个人在社会历史发展中的作用\n\n个人、历史人物、杰出人物、无产阶级领袖\n根据其在社会历史发展中作用的大小，个人可以区分为普通个人和历史人物。历史人物是指在社会历史发展中起过重大影响的人物\n历史人物依据其在历史发展中作用的性质，又可区分为正面的历史人物与反面的历史人物，前者被称之为杰出人物\n\n\n评价历史人物的科学方法\n第一，评价历史人物必须坚持历史分析方法。对历史人物的是非功过进行具体的、全面的考察。\n第二，在阶级社会里，评价历史人物必须坚持阶级分析方法。\n\n\n习近平关于运用历史唯物主义方法评价历史人物的论述\n无产阶级领袖不同于一般的杰出人物，他们所代表的是历史上最革命、最先进的阶级，他们在革命建设中发挥了重要作用；无产阶级领袖也会犯错误\n评价无产阶级领袖，同样应坚持历史分析方法和阶级分析\n\n\n\n\n\n考点\n26.两种根本对立的社会历史观：唯物史观与唯心史观的对立\n27.社会存在与社会意识辩证关系原理\n28.生产关系一定要适合生产力状况的规律\n29.上层建筑一定要适合经济基础状况的规律\n30.社会形态更替的一般规律及特殊形式\n31.社会历史发展的动力\n32.人民群众及个人在历史发展中的作用\n\n政治经济学（62&#x2F;3-6）第五六章资本主义的本质及规律商品经济和价值规律（劳动价值论）商品经济产生的历史条件\n商品经济是以交换为目的而进行生产的经济形式，是商品生产和商品流通的统一\n产生条件\n一是社会分工的出现，这是商品生产产生的前提条件；\n二是生产资料和劳动产品分属于不同的所有者，这是商品生产和商品经济产生的决定性条件。\n\n\n\n商品的二因素：价值和使用价值\n商品定义：商品是用来交换的能满足人们某种需要的劳动产品\n商品的使用价值和价值是商品的二因素\n使用价值 自然属性 有用性\n价值 社会属性（本质属性） 价格 交换价值外在表现\n\n\n\n劳动二重性：抽象劳动和具体劳动\n具体劳动：生产一定使用价值的具体形式的劳动，它是劳动的自然属性\n抽象劳动：撇开一切具体形式的无差别的一般人类劳动，它是劳动的社会属性。\n关系：二者是同一劳动的两个方面，它们在时间上和空间上是统一的。具体劳动是劳动的自然属性；而抽象劳动是劳动的社会属性。\n劳动的二重性决定了商品的二因素\n\n商品的价值量的决定以及与劳动生产率的关系（没考过，关注）\n商品的价值量，即凝结在商品中的劳动的量。\n商品的价值量大小取决于生产该商品所耗费的社会必要劳动时间。\n社会必要劳动时间：是在现有的社会正常的生产条件下，在社会平均的劳动熟练程度和劳动强度下制造某种使用价值所需要的劳动时间\n形成商品价值量的社会必要劳动时间，是以简单劳动为尺度来计量的。同类商品生产者的竞争中实现的。\n\n\n商品的价值量与生产商品所耗费的劳动时间成正比，与劳动生产率成反比\n影响劳动生产率的因素\n劳动者的平均熟练程度\n科学技术的发展程度及其在生产中的应用\n生产过程的社会结合\n生产资料的规模和效能以及自然条件\n\n\n\n价值形式的发展与货币的产生、本质和职能\n货币是固定充当一般等价物的特殊商品，它体现着商品生产者之间的社会关系。\n商品价值形式的发展 \n简单的或偶然的价值形式\n总和的或扩大的价值形式\n一般价值形式\n货币形式\n\n\n货币的职能 价值尺度（一手交钱，一手交货）、流通手段、贮藏手段、支付手段（赊购赊销、清偿债务、租金缴纳）、世界货币\n货币的作用\n随着货币的产生，商品内在的使用价值和价值的矛盾发展成为外在的商品和货币的矛盾\n货币的出现有利于解决商品交换的困难，促进了商品经济的发展\n货币的出现没有也不可能解决商品经济的基本矛盾，即私人劳动和社会劳动的矛盾，反而使矛盾更加扩大和加深了\n\n\n\n价值规律及其作用（5年内没考过，关注）\n内容：商品的价值量由生产商品的社会必要劳动时间决定；商品交换以商品的价值量为基础，实行等价交换\n形式：商品的价格围绕价值自发波动。（供求关系）\n作用：\n积极作用\n自发地调节生产资料和劳动力在社会各部门的分配比例\n自发地刺激社会生产力的发展\n自发地调节社会收入的分配\n\n\n消极作用\n可能导致垄断的发生，阻碍技术进步\n可能引起商品生产者两极分化\n可能出现社会生产的比例失调，造成社会资源的浪费\n\n\n\n\n\n马克思劳动价值论的意义以及科学认识马克思劳动价值论\n理论意义和现实意义\n第一，马克思的劳动价值论为剩余价值学说的创立奠定了基础；是“理解政治经济学的枢纽”。（2018&#x2F;4），马克思劳动价值论揭示了私有制条件下商品经济的基本矛盾，为从物与物的关系背后揭示人与人的关系提供了理论依据。\n第二，这对我们科学认识商品经济的本质，正确理解商品经济的运动规律及其影响，清除商品拜物教和货币拜物教观念，具有十分重要的理论意义和现实意义。\n第三，这一理论对于我国深化经济体制改革，完善社会主义市场经济体制，实现社会主义现代化建设的宏伟目标，具有重要的现实意义。\n\n\n科学认识马克思劳动价值论（没考过，关注）\n第一，深化对创造价值的劳动的认识，对生产性劳动作出新的界定。应充分肯定服务性劳动也是创造价值的劳动\n第二，深化对科技人员，经营管理人员在社会生产和价值创造中所起作用的认识。\n第三，深化对价值创造与价值分配关系的认识。价值创造属于生产领域的问题，而价值分配是属于分配领域的问题。价值创造是价值分配的前提和基础，但价值分配又不仅仅取决于价值创造，价值分配首先是由生产资料所有制关系决定的。\n\n\n\n资本主义经济制度的本质（剩余价值论）前资本主义社会形态的演进和更替\n前资本主义社会形态的演进和更替\n社会形态  生产工具\n原始社会  石器\n奴隶社会  金属工具\n封建社会  封建主占有土地等生产资料和不完全占有农民\n\n\n\n资本主义生产关系的产生\n资本主义生产关系产生的基本途径\n一是从小商品经济分化出来的；\n二是从商人和高利贷者转化而成。\n\n\n资本主义生产关系产生的经济条件：\n第一，大批自由劳动者存在，但他们没有生产资料和生活资料；\n第二，大量货币财富集中在少数人手中。\n\n\n\n资本原始积累\n资本原始积累的途径： （2017&#x2F;19）\n一是用暴力手段剥夺农民的土地。\n二是用暴力手段掠夺货币财富。\n\n\n资本原始积累的结果：\n小生产者被迫与生产资料相分离，转化为雇佣工人；\n小生产者的分散的生产资料转化为资本家集中的生产资料，转化为资本。\n\n\n资本原始积累的实质：资产阶级的发家史就是一部罪恶的掠夺史。\n\n资本主义生产方式的确立\n根本原因：封建生产关系同生产力的矛盾。\n政治条件：资产阶级大革命。\n生产力条件：大机器生产。\n\n资本主义所有制及其本质以及资本主义生产过程的两重性\n资本主义所有制及其本质：资本家与劳动者之间是资本雇佣劳动的关系。\n资本主义劳动过程的特点：\n第一，工人在资本家的监督和指挥下进行劳动；\n第二，劳动产品归资本家所有。\n\n\n资本主义生产过程的两重性：是劳动过程和价值增殖过程的统一。\n\n劳动力成为商品与货币转化为资本(剩余价值生产的前提)\n劳动力成为商品的条件\n劳动力是指人的劳动能力，是人的体力和脑力的总和。劳动力的使用即劳动。\n劳动力成为商品的条件：劳动者具有人身自由；劳动者丧失了生产资料。\n\n\n劳动力商品的特点\n劳动力的价值，是由维持和延续劳动力所必需的生活必需品的价值决定的。\n劳动力的使用价值，即劳动力商品的特殊性：\n劳动力商品的使用价值是价值的源泉，\n它在消费过程中能够创造新的价值，(-&gt;剩余价值)\n而且这个新的价值比劳动力本身的价值更大。\n\n\n\n\n货币转化为资本：劳动力成为商品为前提\n一旦货币购买的劳动力能够带来超过自身价值的价值，即带来剩余价值，货币也就变成了资本，它反映了资本家和雇佣工人之间剥削与被剥削关系\n\n\n\n生产剩余价值是资本主义生产方式的绝对规律\n剩余价值的实质\n雇佣工人创造的并被资本家无偿占有的超过劳动力价值的那部分价值，体现了资本家与雇佣工人之间剥削与被剥削的关系\n剩余价值的唯一来源是雇佣工人的剩余劳动\n价值增殖过程，即剩余价值的生产过程。\n在价值增殖过程中，雇佣工人的劳动分为必要劳动时间和剩余劳动时间，用于再生产劳动力的价值和无偿地为资本家生产剩余价值。\n\n\n\n\n资本、不变资本和可变资本的区分\n资本：可以带来剩余价值的价值。\n依据资本在价值增殖过程中所起的不同作用：\n不变资本（C）：是以生产资料形态存在的资本。—— 机器、厂房、原材料，等等\n可变资本（V）：用于购买劳动力的那部分资本。\n\n\n区分不变资本和可变资本的意义。\n一是揭示了剩余价值产生的真正来源，即剩余价值的真正源泉是可变资本。它表明，雇佣劳动者的剩余劳动是剩余价值产生的唯一源泉。\n二是为反映资本家对雇佣劳动的剥削程度提供了科学依据。资本家对工人的剥削程度，可以用剩余价值率表示。\n剩余价值率（m′）：&#x3D; 剩余价值（m）&#x2F;可变资本（v ）  &#x3D; 剩余劳动时间&#x2F;必要劳动时间\n\n\n\n\n剩余价值生产理论\n绝对剩余价值生产：是指在必要劳动时间不变的条件下，由于延长工作日，从而相应延长剩余劳动时间而进行的剩余价值生产\n相对剩余价值生产：是指在工作日长度不变的条件下，通过缩短必要劳动时间，而相对延长剩余劳动时间的方法生产的剩余价值。\n超额剩余价值：个别资本家提高劳动生产率，使自己商品的个别价值低于社会价值而得到的更多的剩余价值。\n超额剩余价值是暂时的，其必然导致整个社会劳动生产率的提高，为资本家阶级普遍带来相对剩余价值。\n\n\n生产自动化条件下剩余价值的来源\n生产自动化是资本家获取超额剩余价值的手段，技术和科学本身不能创造剩余价值\n雇佣工人的剩余劳动是剩余价值的唯一源泉\n\n\n\n\n资本积累理论（剩余价值积累理论）\n简单再生产：物质资料再生产和资本主义生产关系再生产的统一\n资本主义再生产的特点是扩大再生产\n2个源泉\n资本积累是资本主义扩大再生产的源泉\n剩余价值是资本积累的源泉。\n资本积累规模的大小取决于 资本家对工人的剥削程度；劳动生产率的高低；所用资本和所费资本之间的差额；资本家垫付资本的大小\n\n\n资本有机构成 由资本的技术构成决定并反映技术构成变化的资本价值构成\n资本技术构成（自然形式、物质形态、实物形态） （由生产的技术水平所决定的）生产资料与劳动力之间的比例\n资本价值构成：从价值形式看，不变资本与可变资本价值之间的比例。\n\n\n在资本主义生产过程中，资本有机构成的提高是一般趋势。\n生产唯一动机：通过改进技术、提高劳动生产率，追求更多的剩余价值。\n扩大生产规模：通过资本集聚和资本集中。\n资本集聚：个别资本家通过剩余价值资本化来增大资本的总量。\n资本集中：个别资本家通过结合而形成较大的资本。竞争和信用是资本集中最强有力的杠杆\n资本积累是资本集聚的基础，资本集聚是资本积累的直接结果\n\n\n\n\n资本有机构成提高—— 其结果不可避免地造成大量工人失业，形成相对过剩人口\n之所以是相对的，是由于它不为资本价值增殖所需要\n形式：流动的、潜伏的、停滞的过剩人口\n经常性的庞大的失业人口的存在，是资本主义的痼疾\n\n\n资本积累的历史趋势\n资本主义制度的必然灭亡和社会主义制度的必然胜利\n\n\n\n\n资本的循环周转与再生产(剩余价值流通理论)\n循环\n产业资本循环的三个阶段及三种职能形式\n第一阶段  购买阶段（生产资料和劳动力）  货币资本\n第二阶段  生产阶段（生产资料和劳动力按一定比例） 生产资本\n第三阶段  销售阶段（转化为货币资本） 商品资本\n\n\n产业资本连续循环的条件：\n产业资本的三种职能形式在空间上同时并存；在时间上继起。\n\n\n周转\n资本周转及其速度：资本周转越快，在一定时期内带来的剩余价值就越多。\n影响资本周转快慢的关键因素\n一是资本周转的时间；（没考过）\n资本周转时间\n生产时间 劳动时间 自然力作用时间 生产资料储备时间 正常停工时间\n流通时间 购买时间 销售时间\n\n\n\n\n二是生产资本的固定资本和流动资本的构成。加快流动资本的周转速度\n固定资本 一次投入、多次使用 价值多次逐渐收回\n流动资本 一次投入、一次使用 价值一次全部收回\n\n\n\n\n\n\n再生产\n社会再生产的核心问题是社会总产品的实现问题，即社会总产品的价值补偿和实物补偿问题\n前提：价值补偿，是指社会总产品各个组成部分的价值，如何通过商品的出售以货币形式收回，用以补偿生产过程消耗的预付的不变资本和可变资本，并且还要获得剩余价值，以便继续预付资本进行再生产。\n关键：实物补偿，是指社会总产品的各个组成部分通过出售转化为货币形式以后，如何重新买到新的生产资料和消费资料，补偿或替换消耗了的生产资料和消费资料。\n\n\n社会总产品的实现，是指社会总产品通过销售，取得货币，实现了价值和剩余价值。\n社会再生产的实现条件\n两大部类，在规模和结构上保持一定的比例关系\n第一部类（Ⅰ）由生产资料的部门所构成，其产品进入生产领域\n第二部类（Ⅱ），由生产消费资料的部门所构成，其产品进入生活消费资料\n两大部类失衡，严重后果导致经济危机的爆发\n\n\n\n\n\n\n\n\n工资与剩余价值的分配（剩余价值分配理论）\n工人的工资：是劳动力的价值或价格\n当剩余价值被看作是全都预付资本的产物或增加额时，便取得了利润的形态\n剩余价值是利润的本质，利润是剩余价值的转化形式。\n两者是内容和形式的关系\n\n\n利润形态歪曲了剩余价值的真正来源，掩盖了资本主义剥削的关系\n\n\n利润平均化\n不同生产部门的利润率是不同的，其结果必然是各部门的利润率趋于平均化\n利润转化为平均利润，价值也就转化为生产价格\n商品不再以价值而是以生产价格为基础进行交换，市场价格的变动不再以价值为中心，而是以生产价格为中心\n生产价格 &#x3D; （2017&#x2F;3）生产成本（不变资本+可变资本）+平均利润\n\n\n剩余价值的分配：产业资本(产业利润)、商业资本(商业利润)、银行资本(银行利润)、土地资本(地租)\n\n\n\n\n马克思剩余价值理论的意义\n剩余价值理论是马克思主义经济理论的基石\n由于唯物史观和剩余价值的发现，社会主义由空想变为科学\n\n\n\n资本主义的基本矛盾与经济危机\n资本主义的基本矛盾\n私人劳动与社会劳动的矛盾构成私有制商品经济的基本矛盾\n生产资料资本主义私人占有和生产社会化之间的矛盾，是资本主义的基本矛盾，是生产力和生产关系之间的矛盾在资本主义社会的具体体现\n资本主义越发展，生产社会化的程度越高，资本、生产资料、劳动产品就越来越集中在少数资本家手中，资本主义基本矛盾尖锐化不可避免\n\n\n资本主义经济危机的实质、根源、具体表现和周期性\n本质特征：生产相对过剩。\n相对于劳动人民有支付能力的需求来说社会生产的商品显得过剩，而不是与劳动人民的实际需要相比较的绝对过剩\n\n\n根本原因：资本主义的基本矛盾\n具体表现\n第一，生产无限扩大的趋势和劳动人民支付能力相对缩小的矛盾。\n第二，个别企业内部生产的有组织性和整个社会生产的无政府状态之间的矛盾。\n\n\n主要特点：呈现出“危机——萧条——复苏——高涨”周期性的特点。其中，危机阶段是基本阶段\n主要作用：既是资本主义基本矛盾尖锐化的产物，同时又是这一矛盾在资本主义范围内暂时的、强制性的解决生产和消费暂时平衡的形式\n\n\n\n资本主义的政治制度和意识形态（点到为止）资本主义政治制度及其本质\n资本主义国家的职能和本质\n资本主义国家的职能是以服务于资本主义制度和资产阶级利益为根本内容。\n资本主义国家的对内职能主要是政治统治的职能。此外，国家还具有社会公共管理职能。\n资本主义国家的对外职能主要表现为国际交往与维护国家安全和利益的职能。\n资本主义国家的本质是资产阶级进行政治统治的工具。\n\n\n资本主义政治制度\n资本主义政治制度包括民主与法制制度、政权组织形式、选举制度、政党制度等\n资本主义政治制度的本质是为资产阶级服务的，是服从于资产阶级进行统治和压迫需要的政治工具-资本主义政治制度的进步作用和局限性\n进步作用\n第一，资本主义政治制度在战胜封建社会，保护、促进、完善资本主义生产方式方- 面起着重要作用。\n第二，人们群众享有了比在封建社会专制主义条件下更多的社会政治自由，促进了- 人类的发展。\n第三，资本主义政治制度在其历史发展进程中，积累了相当丰富的政治统治和社会- 管理经验，对于社会进步具有积极意义。\n\n\n局限性\n第一，资本主义的民主是金钱操纵下的民主，实际是资产阶级精英统治下的民主；\n第二，法律名义上的平等掩盖着事实上的不平等；\n第三，资本主义国家的政党制是一种维护资产阶级统治的政治制度。\n第四，政党恶斗相互掣肘，决策效率低下，激化社会矛盾。\n\n\n\n\n\n资本主义意识形态及其本质\n资本主义意识形态是在反对封建专制主义和宗教神学中形成的\n资本主义意识形态的本质：\n资本主义意识形态是在资本主义国家中占统治地位的、反映了作为统治阶级的资产阶级的利益和要求的各种思想理论和观念的总和。\n\n\n对于资本主义的意识形态，应该历史地、辩证地来分析。\n\n考点33. 商品经济产生的历史条件34. 商品的二因素和生产商品的劳动二重性\n商品经济的产生：分工；分属不同的所有者（2121&#x2F;19）\n商品二因素：价值和使用价值(2013&#x2F;3、2012&#x2F;19)\n劳动二重性：抽象劳动和具体劳动\n\n35. 商品价值量的决定以及与劳动生产率的关系(2020&#x2F;3)36. 价值规律及其作用：商品经济的基本规律37. 马克思劳动价值论的意义以及科学认识马克思劳动价值论38. 前资本主义社会形态的演进与资本主义生产关系的产生39. 资本的原始积累与资本主义生产方式的确立40. 资本主义所有制的本质以及资本主义生产过程的特点41. 剩余价值生产的前提：劳动力成为商品与货币转化为资本42. 生产剩余价值是资本主义生产方式的绝对规律43. 资本积累理论：简单再生产与扩大再生产44. 资本的循环周转与再生产45. 工资与剩余价值的分配46. 马克思剩余价值理论的意义47. 资本主义基本矛盾的形成及其尖锐化与资本主义经济危机理论经济危机48. 资本主义的政治制度核心、本质、作用49. 资本主义意识形态的形成及其本质资本主义的发展及其趋势垄断资本主义的形成与发展垄断的形成：资本主义从自由竞争到垄断\n私人垄断资本主义\n资本主义发展的两个阶段：自由资本主义和垄断资本主义\n19世纪70年代以前。自由竞争阶段，主要依靠市场机制调节经济，政府对经济活动基本采取“自由放任”政策\n垄断资本主义发展的两种形式：私人垄断资本主义和国家垄断资本主义\n19世纪末20世纪初，垄断取代自由竞争在资本主义经济中占据统治地位\n\n\n生产集中与资本集中到一定阶段必然引起垄断\n垄断的目的：为了获得高额利润，对商品的生产和销售进行操纵与控制\n垄断产生的原因： 第一，获得高额利润；第二，避免两败俱伤；第三，生产高度集中，少数大企业自然占据垄断地位。  垄断组织：最简单的、初级的垄断组织形式是短期价格协定。常见的垄断组织有卡特尔、辛迪加、托拉斯和康采恩等\n\n\n垄断条件下的竞争：规模大、时间长、手段残酷、程度更加激烈，具有更大的破坏性\n垄断资本主义阶段存在竞争的主要原因：(没考过)\n一是垄断没有消除产生竞争的经济条件。\n二是垄断必须通过竞争来维持。\n三是不存在囊括一切部门、一切社会生产的绝对垄断。\n\n\n垄断条件下竞争的新特点\n自由资本主义  利润或超额利润  经济手段  经济领域、国内\n垄断资本主义  高额垄断利润  经济和非经济手段  各个领域、国外\n\n\n\n\n金融资本与金融寡头\n金融资本是由工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本。\n金融资本形成的主要途径包括金融联系、资本参与和人事参与\n\n\n金融寡头是指操纵国民经济命脉，并在实际上控制国家政权的少数垄断资本家或垄断资本家集团。\n在经济中的统治，主要是通过“参与制” ；\n在政治上对国家机器的控制主要是通过同政府的“个人联合” 。\n在文化上通过建立政策咨询机构，掌握新闻科教文化等上层建筑的各个领域，以左右国家的内政外交与社会生活。\n\n\n\n\n垄断资本的实质在于获取垄断利润\n垄断利润的来源\n第一，来自对本国无产阶级和其他劳动人民剥削的加强；\n第二，由于垄断资本可以通过垄断高价和垄断低价来控制市场，使得它能获得一些其他企业特别是非垄断企业的利润；\n第三，通过加强对其他国家劳动人民的剥削和掠夺从国外获取利润；\n第四，通过资本主义国家政权进行有利于垄断资本的再分配，从而将劳动人民创造的国民收入的一部分变成垄断资本的收入。\n\n\n垄断利润主要是通过垄断组织制定的垄断价格来实现的 垄断价格&#x3D;成本价格+平均利润+垄断利润\n包括垄断高价和垄断低价两种形式\n\n\n\n\n国家垄断资本主义\n国家垄断资本主义是国家政权和私人垄断资本融合在一起的垄断资本主义。\n国家垄断资本主义的主要形式、\n一是国家所有并直接经营的企业。\n二是国家与私人共有、合营企业。\n三是国家通过多种形式参与私人垄断资本的再生产过程，包括国家向私人垄断企业订货、提供补贴等。\n四是宏观调节。国家运用财政政策、货币政策等经济手段，对社会总供求进行调节。以实现经济快速增长、充分就业、物价稳定和国际收支平衡的基本目标。\n五是微观规制。国家运用法律手段规范市场秩序，限制垄断，保护竞争，维护社会公众的合法权益。微观规制主要有三种类型：反托拉斯法、公共事业规制、社会经济规制\n\n\n国家垄断资本主义对资本主义经济的发展产生了积极的作用。\n一定程度上有利于社会生产力的发展\n一定范围内突破了私人垄断资本的狭隘界限，适应了社会化大生产的要求，有利于缓解资本主义生产的无政府状态\n通过国家的收入再分配手段，使劳动人民生活水平有所改善和提高\n在国家垄断资本主义的参与和干预下，各主要资本主义国家的产业升级和优化，加快了这些国家的现代化进程\n\n\n金融垄断资本的发展\n20世纪70年代初，金融自由化与金融创新是金融垄断资本得以形成和壮大的重要制度条件\n金融化程度不断提高：金融业在国民经济中的地位大幅上升，导致金融资本急剧膨胀；制造业就业人数严重减少；虚拟经济越来越脱离实体经济\n金融垄断资本的发展：一方面，促进了资本主义的发展，另一方面，造成了经济过度虚拟化，导致金融危机频发发生\n\n\n垄断资本在世界范围的扩展及其后果\n垄断资本向世界范围扩展的经济动因：\n一是将国内过剩的资本输出，以在别国谋求高额利润；\n二是将部分非要害技术转移到国外，以取得在别国的垄断优势；\n三是争夺商品销售市场；\n四是确保原材料和能源的可靠来源。\n\n\n垄断资本向世界范围扩展的基本形式：\n借贷资本输出；生产资本输出；商品资本输出。\n从输出资本的来源看 ：私人资本输出和国家资本输出。\n\n\n后果\n资本输出国\n资本输出为其带来了巨额利润，带动和扩大了商品输出，大大改善了国际收支状况，对发展中国家的经济命脉形成控制。\n\n\n资本输入国\n积极作用：吸收了资金，引进了较为先进的机器设备和工艺技术，培训了技术和管理人才，利用外贸和技术办厂，促进经济发展，扩大就业、外贸等；\n不利影响：付出了较大的经济代价和环境资源代价，冲击本国民族工业，债务加重，加大对国际资本的依赖性。\n\n\n\n\n\n\n垄断资本国际化条件下的垄断组织\n各资本主义国家的垄断组织，通过订立协议建立起国际垄断资本的联盟，即国际垄断同盟，以便在世界范围形成垄断，并在经济上瓜分世界。而协议的订立、瓜分的结果又以经济实力为后盾和基础\n国家垄断资本主义的国际联盟，是国际垄断同盟的高级形式\n此外，国家垄断资本还建立起国际经济协调机制。国际货币基金组织、世界银行和世界贸易组织。\n\n\n垄断资本主义的基本特征和实质（列宁：帝国主义的基本特征）\n五大特征：\n（1）垄断组织在经济生活中起决定作用；\n（2）在金融资本的基础上形成金融寡头的统治；\n（3）资本输出有了特別重要的意义；\n（4）瓜分世界的资本家国际垄断同盟已经形成；\n（5）最大资本主义列强已把世界上的领土分割完毕。\n\n\n集中体现了垄断资本主义的实质：—— 垄断资本凭借垄断地位，获取高额垄断利润。\n\n\n\n\n\n经济全球化：表现、动因及其后果\n经济全球化是指在生产不断发展、科技加速进歩、社会分工和国际分工不断深化、生产的社会化和国际化程度不断提高的情况下，世界各国、各地区的经济活动越来越超出一国和地区的范围而相互联系、相互依赖的一体化过程\n表现\n国际分工进一步深化。\n贸易全球化。\n金融全球化。\n企业生产经营全球化。\n\n\n经济全球化的动因\n第一，科学技术的进步和生产力的发展为经济全球化提供了坚实的物质基础和根本的推动力。\n第二，跨国公司的发展为经济全球化提供了适宜的企业组织形式；\n第三，各国经济体制的变革，为国际资本的流动、国际贸易的扩大、国际生产的大规模进行提供了适宜的体制环境和政策条件。\n\n\n经济全球化的后果\n积极效应与消极后果：\n发达国家与发展中国家之间的差距扩大；\n环境恶化与经济全球化有可能同时发生；\n各国内部和国际社会都可能出现不同程度的治理危机；\n它既为一国经济竞争力的提高提供了条件，同时也存在着对别国形成依赖的危险。\n\n\n如何使经济全球化成为世界各国“双赢”的经济全球化、世界各国平等、公平、共存的经济全球化，是国际社会共同面临的重大课题\n\n\n\n正确认识当代资本主义的新变化第二次世界大战后资本主义变化的新特点\n当代资本主义经济政治新变化：表现\n之一：生产资料所有制的变化（2017&#x2F;4）\n资本主义早期个体资本所有制;19世纪末、20世纪初私人股份资本所有制;二战以后法人资本所有制（企业法人和结构法人）\n\n\n之二：劳资关系和分配关系的变化(2013&#x2F;20)\n随着社会生产力的发展和工人阶级反抗力量的不断壮大，资本家及其代理人开始采取一些缓和劳资关系的激励制度：\n诸如职工参与决策，终身雇佣，职工持股制度，促使工人自觉地服从资本家的意志。\n此外，社会福利制度的健全也在一定程度上保证劳动者维持最低生活水平，改善了劳动者的社会状况。\n\n\n之三：社会阶层、阶级结构的变化(2022&#x2F;4、2018&#x2F;20)\n一是资本家的地位和作用发生了很大的变化。资本所有权和经营权发生分离。\n二是高级职业经理成为大公司经营活动的实际控制者。（2022&#x2F;4）\n三是知识型和服务型劳动者的数量不断增加，劳动方式发生了新变化。\n\n\n之四：经济调节机制和经济危机形态的变（2014&#x2F;20）  二战后 国家干预不断增强  20世纪70年代 强化市场、弱化政府\n去工业化和产业空心化日趋严重，产业竞争力下降；\n经济高度金融化，虚拟经济与实体经济严重脱节；\n财政严重债务化，债务危机频繁爆发；\n两极分化和社会对立加剧；\n经济增长乏力，发展活力不足，周期性危机与结构性危机交织在一起；\n金融危机频发，全球经济屡受打击。\n\n\n之五：政治制度的变化\n首先，国家行政机构的权限不断加强。\n其次，政治制度出现多元化的趋势，公民权利有所扩大。\n再次，法制建设得到重视和加强。\n最后，改良主义政党在政治舞台上的影响日益扩大。\n\n\n\n\n新变化原因\n第一，科学技术革命和生产力的发展，是资本主义变化的根本推动力量。\n第二，工人阶级争取自身权力和利益斗争的作用，是推动资本主义变化的重要力量。\n第三，社会主义制度初步显示的优越性对资本主义产生了一定影响。\n第四，主张改良主义的政党对资本主义制度的改革，对资本主义的变化发挥了重要作用。\n\n\n新变化实质\n首先，当代资本主义发生的变化从根本上说是人类社会发展一般规律和资本主义经济规律作用的结果\n其次，当代资本主义发生的变化是在资本主义制度基本框架内的变化\n\n\n\n2008年国际金融危机以来资本主义的矛盾和冲突（没考过）\n第一，经济发展“失调”\n虚拟经济与实体经济发展失衡。\n福利风险增加。\n债务负担沉重。\n\n\n第二，政治体制“失灵”\n一是西式选举往往难以选贤。\n二是政党利益可能凌驾于国家利益之上。\n三是“民主陷阱”会阻碍国家治理。\n四是传统精英政治走向衰落。\n\n\n第三，社会融合机制“失效”\n一是社会极端思潮抬头。\n二是社会流动性退化。（阶层固化）\n三是社会矛盾激化。\n\n\n\n资本主义的历史地位和发展趋势资本主义的历史地位\n首先，资本主义将科学技术转变为强大的生产力。\n其次，资本追求剩余价值的内在动力和竞争的外在压力推动了社会生产力的迅速发展。（2022&#x2F;21）\n最后，资本主义的意识形态和政治制度作为上层建筑在保护、促进和完善资本主义生产方式方面起着重要作用，从而推动了社会生产力的迅速发展。\n\n资本主义为社会主义所代替的历史必然性\n资本主义的内在矛盾决定了资本主义必然被社会主义所代替\n首先，资本主义基本矛盾“包含着现代的一切冲突的萌芽”。\n其次，资本积累推动资本主义基本矛盾不断激化并最终否定资本主义自身。\n再次，国家垄断资本主义是资本社会化的更高形式，将成为社会主义的前奏。\n最后，无产阶级必将彻底推翻资本主义和资产阶级的统治，逐步建立消灭一切阶级、确保人人得以自由发展的联合体。\n\n\n从资本主义向社会主义过渡的复杂性和长期性\n首先，任何社会形态的存在都有相对稳定性，从产生到衰亡都要经过相当长的时间跨度。\n其次，资本主义发展的不平衡性决定了过渡的长期性。\n最后，当代资本主义的发展，还显示出生产关系对生产力容纳的空间，说明资本主义为社会主义所代替尚需长期的过程\n\n\n\n考点50. 私人垄断资本主义：从自由竞争资本主义到垄断资本主义51. 国家垄断资本主义：垄断资本主义的发展：国家垄断资本主义的形成、主要形式及作用52. 经济全球化：表现、动因及其后果（2016&#x2F;20）53. 第二次世界大战后资本主义经济政治新变化的表现和特点54. 2008年国际金融危机以来资本主义的矛盾与冲突55. 资本主义为社会主义所代替的历史必然性、复杂性和长期性科学社会主义（18&#x2F;1-2）第七八章考点56．空想社会主义的产生、发展和局限性以及科学社会主义的创立（2011&#x2F;20)（2016&#x2F;20）\n空想社会主义\n积极意义： 对资本主义制度的批判，包含许多击中要害的见解；对社会主义制度的描绘，闪烁着诸多天才的火花。\n局限性： 未能揭示资本主义必然灭亡的经济根源；看不到埋藏资本主义的力量；找不到通往理想社会的现实道路。\n\n\n科学社会主义的创立\n唯物史观和剩余价值学说是科学社会主义诞生的理论基础\n1848年2月《共产党宣言》的发表，标志着科学社会主义的诞生\n\n\n\n57．第一国际和巴黎公社（2021&#x2F;21）\n第一国际\n1864年，国际工人协会（第一国际）应运而生。马克思是第一国际的灵魂。第一国际促进了马克思主义的传播和与国际工人运动的结合，初步确立了马克思主义在工人运动中的指导地位\n马克思、恩格斯在指导建立无产阶级政党过程中，阐述了各国无产阶级政党相互关系的重要原则\n一是坚持无产阶级的国际联合 第一国际只是各国工人运动联络和合作中心，而不是指挥中心。\n二是坚持各国党的独立自主和完全平等\n\n\n\n\n巴黎公社（2021&#x2F;21）\n1871年3月18日至5月28日的巴黎工人起义，以及建立起来的巴黎公社，是无产阶级革命和无产阶级专政的第一次伟大尝试\n公社取消征兵制和常备军，以人民武装国民自卫军作为唯一的武装力量。\n特别是公社采取了两项重要措施，用以防止国家机关工作人员由社会公仆变为社会主人：\n一是规定所有公职人员无论职位高低，实行全面的选举制和撤换制；\n二是取消高薪制，规定任何工作人员年薪不得超过熟练工人的工薪水平。\n\n\n巴黎公社经验\n指出无产阶级革命取得成功并保持胜利果实的首要条件是要有革命的武装；\n必须打碎旧的国家机器，建立无产阶级的新型国家；\n无产阶级政权是为人民服务的机关；\n必须建立无产阶级政党，发挥党的政治领导作用。\n\n\n\n\n\n58. 十月革命胜利与第一个社会主义国家的建立 (11&#x2F;4）(14&#x2F;21)（17&#x2F;21）\n列宁是坚定的马克思主义者。1915年，他在《论欧洲联邦口号》一文中明确指出：“经济和政治发展的不平衡是资本主义的绝对规律。由此就应得出结论：社会主义可能首先在少数甚至在单独一个资本主义国家内获得胜利。”\n在这一理论的基础上，将这一理论付诸实践，在革命形势成熟的条件下，领导了俄国十月革命。1917年11月7日（俄历10月25日），取得了十月社会主义革命的胜利。\n十月革命实现了社会主义从理想到现实的伟大飞跃，开辟了人类历史的新纪元。它从根本上推翻了人剥削人、人压迫人的制度，建立起世界上第一个人民当家作主的社会主义国家\n十月革命的胜利，特别是列宁关于殖民地半殖民地民族解放的思想：\n极大地推动了受帝国主义、殖民主义欺凌压迫的国家人民的觉醒，\n促进了民族解放力量的崛起，\n有力推动了殖民地半殖民地国家的民族解放运动，\n加速了世界范围内帝国主义殖民体系的整体瓦解，\n深刻改变了国际力量对比和世界格局。\n\n\n列宁领导的苏维埃俄国对社会主义道路的探索（2020&#x2F;4）\n进一步巩固苏维埃政权时期\n战时共产主义时期  以余粮收集制和取消商品货币关系为主要特征\n新经济政策时期 以发展商品经济为主要特征的新经济政策\n新经济政策的主要内容：\n用粮食税制取代余粮收集制，允许私人自由贸易，恢复商品货币关系，允许私人小工业企业发展，采取一些国家资本主义的形式来发展生产。（2017&#x2F;21）（2014&#x2F;21）\n新经济政策表明，标志着列宁正在探索一条符合俄国国情的建设社会主义的道路。（2011&#x2F;4）\n新经济政策的实施，扭转了国家的严重危机，活跃了苏维埃的城乡经济，发展了生产，大大加强了苏维埃的社会主义经济基础，也改善了工人、农民和其他劳动者的物质文化生活。\n\n\n特别是实行新经济政策期间，列宁对苏维埃俄国如何建设社会主义进行了深刻的理论思考\n首先，把建设社会主义作为一个长期探索、不断实践的过程。\n其次，把大力发展生产力、提高劳动生产率放在首要地位。\n再次，在多种经济成分并存的条件下，利用商品、货币和市场发展经济。\n最后，利用资本主义建设社会主义。\n\n\n列宁晚年，在口授的《日记摘录》…等被人们称为“政治遗嘱”的文章和书信中，对十月革命以来所走过的道路进行了深入的思考，提出了建设社会主义的新构想\n用合作社的形式将农民引向社会主义道路；发展大工业，实现工业化和电气化；\n学习和利用资本主义一切有价值的东西；\n进行文化革命，大力发展文化教育事业；\n进行党和国家机构的改革，努力提高干部的素质和能力；\n必须反对官僚主义，健全社会主义民主和法制；\n维护党的团结，特别是党中央领导核心的团结等。\n\n\n\n\n\n59. 社会主义在苏联一国的实践（2020&#x2F;4）以及社会主义发展到多个国家\n苏联模式的形成及其作用\n苏联模式的优势：是在特定的历史条件下产生的，曾经促进了社会主义制度的巩固和发展，推动过社会生产力的高速度发展，确保了重工业，特别是国防工业的发展\n苏联模式的弊端：集中过多，管的过死，否定市场作用，严重束缚企业和劳动者积极性。\n\n\n中国革命的胜利，是继十月革命之后20世纪最重大的事件\n\n60．社会主义在中国焕发出强大生机活力(毛中特中考)\n俄国十月革命的胜利，给中国人民送来了马克思列宁主义。1921年7月，中国共产党成立，并成为中国社会主义运动的领导力量。党领导的中国社会主义事业经过了从新民主主义革命到社会主义革命、建设、改革的发展过程，在近百年的奋斗中不断发展壮大，在21世纪焕发出勃勃生机。\n中国共产党领导人民经过28年艰苦卓绝的革命斗争，于1949年10月1日成立了新中国。毛泽东提出要以苏联的经验教训为鉴戒，独立探索适合中国国情的社会主义建设道路。\n1978年12月，党的十一届三中全会重新确立了解放思想、实事求是的思想路线，作出了进行改革开放的重大决策，开创了社会主义建设新时期。\n党的十八大以来，中国特色社会主义进入新时代，意味着近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的伟大飞跃，迎来了实现中华民族伟大复兴的光明前景；意味着科学社会主义在21世纪的中国焕发出强大生机活力，在世界上高高举起了中国特色社会主义伟大旗帜；意味着中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献了中国智慧和中国方案。\n\n61. 科学社会主义一般原则：主要内容、正确把握（2019&#x2F;21）\n科学社会主义一般原则及其主要内容\n第一，人类社会发展规律和资本主义基本矛盾是“资本主义必然灭亡、社会  主义必然胜利”的根本依据\n马克思恩格斯在《共产党宣言》中指出：“资产阶级的灭亡和无产阶级的胜  利是同样不可避免的”。这就是我们常说的资本主义必然灭亡和社会主义必  然胜利的“两个必然”。\n马克思在1859年发表的《〈政治经济学批判〉序言》中提出：“无论哪一个  社会形态，在它所能容纳的全部生产力发挥出来以前，是决不会灭亡的；而  新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是  决不会出现的。”这就是人们通常所说的“两个决不会”\n忘记“两个必然”，则会动摇社会主义必胜的信念，丧失根本、迷失方向；  忽略“两个决不会”，则可能脱离实际，犯急躁冒进的错误\n\n\n第二，无产阶级是最先进最革命的阶级，肩负着推翻资本主义旧世界、建立社会主义和共产  主义新世界的历史使命。\n第三，无产阶级革命是无产阶级进行斗争的最高形式，以建立无产阶级专政的国家为目的。\n第四，社会主义社会要在生产资料公有制基础上组织生产，以满足全体社会成员的需要为生  产的根本目的。\n第五，社会主义社会要对社会生产进行有计划的指导和调节，实行按劳分配原则。\n第六，社会主义社会要合乎自然规律地改造和利用自然，努力实现人与自然的和谐共生。\n第七，社会主义社会必须坚持科学的理论指导，大力发展社会主义先进文化。\n第八，无产阶级政党是无产阶级的先锋队，社会主义事业必须始终坚持无产阶级政党的领导。\n第九，社会主义社会要大力解放和发展生产力，逐步消灭剥削和消除两极分化，实现共同富裕和社会全面进步，并最终向共产主义社会过渡。\n\n\n正确把握科学社会主义一般原则\n第一，必须始终坚持科学社会主义一般原则，反对任何背离科学社会主义一般原则的错误倾向。\n第二，要善于把科学社会主义一般原则与本国实际相结合，创造性地回答和解决革命、建设、改革中的重大问题。\n第三，紧跟时代和实践的发展，在不断总结新鲜经验中进一步丰富和发展科学社会主义一般原则。\n\n\n\n62．经济文化相对落后国家走向社会主义的长期性（2013&#x2F;21）\n第一，生产力发展状况的制约。\n第二，经济基础和上层建筑发展状况的制约。发展公有经济，改造小农经济，建立、巩固和完善社会主义的经济基础，成为无产阶级政权的艰巨任务。经济文化相对落后必然影响社会主义民主政治、文化建设。\n第三，国际环境的严峻挑战。社会主义制度有了长足进步之后，其进攻方式则往往转变为以“和平演变”为主。其主要手段，一是通过强硬的军事、政治压力和有限制的经济、科技的合作，迫使社会主义国家屈从其经济政治发展战略的要求，并达到促使社会主义国家改变制度的目的；二是通过强大的文化机器和文化产品进行文化渗透。\n第四，马克思主义执政党对社会主义发展道路的探索和对社会主义建设规律的认识，需要一个长期的过程。\n\n63．社会主义发展道路多样性的原因（2018&#x2F;21）\n第一，各个国家的生产力发展状况和社会发展阶段决定了社会主义发展道路的具有不同的特点；\n第二，历史文化传统的差异性是造成社会主义发展道路多样性的重要条件；\n第三，时代和实践的不断发展，是造成社会主义发展道路的多样性的现实原因。\n\n64. 努力探索适合本国国情的社会主义发展道路（重要）\n第一，探索社会主义道路，必须坚持对待马克思主义的科学态度。坚持马克思主义对于研究未来社会制度的科学方法。\n第二，探索社会主义发展道路，必须从当时当地的历史条件出发，坚持“走自己的路”。立足本国国情，走自己的路，是社会主义历史经验的总结，是马克思主义的一条基本原则。\n第三，探索社会主义发展道路，必须充分吸收人类一切文明成果。\n\n65. 社会主义在实践探索中开拓前进\n在实践中开拓前进是社会主义事业发展的必然要求。\n首先，社会主义是亿万人民群众的伟大实践。\n其次，社会主义实践是一个不断探索的过程。\n再次，实践探索中出现某种曲折并不改变社会主义的前进趋势。\n最后，推进社会主义实践发展必须有开拓奋进的精神状态。\n\n\n以自信担当、开拓奋进的姿态走向社会主义光明未来。\n首先，正确认识21世纪世界社会主义的形势。东欧剧变、苏联解体使世界社会主义进入低潮时期。但苏联、东欧社会主义的失败，只是苏联模式的失败，而不是社会主义本身的失败。\n其次，充分估计中国特色社会主义的成功实践对世界社会主义发展的意义。\n最后，坚定信心，振奋精神，以开拓奋进的姿态走向社会主义光明未来。\n\n\n\n66. 预见未来社会的方法论原则\n第一，在揭示人类社会发展一般规律的基础上指明社会发展的方向。\n第二，在剖析资本主义社会旧世界中阐发未来新世界的特点。\n第三，在社会主义社会发展中不断深化对未来共产主义社会的认识\n第四，立足于揭示未来社会的一般特征，而不可能对各种细节作具体描绘。\n\n67. 共产主义社会的基本特征\n第一，物质财富极大丰富，消费资料按需分配。\n第二，社会关系高度和谐，人们精神境界极大提高。\n第三，每个人自由而全面的发展，人类从必然王国向自由王国的飞跃。\n\n68. 实现共产主义是历史发展的必然\n共产主义理想的实现是历史规律的必然要求\n实现共产主义是人类最伟大的事业\n\n69. 实现共产主义是长期的历史过程（2019&#x2F;20）\n从理论上讲马克思主义所揭示的社会形态发展与更替的规律，是只有在漫长的历史过程中才能显现出来的规律性。从资本主义到共产主义的转变，是对整个社会的根本改造，必然是长期艰难的过程。\n实现共产主义必须经历许多历史阶段。社会主义是资本主义到共产主义的过渡阶段；社会主义本身也是一个长期的历史过程；从不发达的社会主义到发达的社会主义，再到共产主义，其历史过程一定是漫长的。\n\n70. 共产主义远大理想与中国特色社会主义共同理想\n坚持远大理想与共同理想的辩证统一。\n建设中国特色社会主义是中华民族走向共产主义的必由之路。我们的远大理想和最终目标是实现共产主义；中国特色社会主义共同理想是共产主义远大理想在我国社会主义初级阶段的现实体现，是实现共产主义远大理想的必经阶段。\n\n\n正确认识和把握共产主义远大理想与中国特色社会主义共同理想的关系\n从时间上看，最终理想与阶段性理想的关系。\n从层次上看，最高纲领与最低纲领的关系。\n从范围来看，全人类理想与全体中国人民理想的关系。\n\n\n\n","slug":"master/Politics/马克思主义基本原理","date":"2022-10-21T13:19:36.000Z","categories_index":"考研政治","tags_index":"考研政治","author_index":"ChrisWood"},{"id":"a2fa7d6a410e794ddee545d12d179c3a","title":"英语词根词缀整理","content":"ag ＝to do 做 做；代理；引导-ent n. ＝person 人\n\nagent ［ag ＝to do 做；-ent n. ＝person 人→“person who does 办事者”→］\nn. person who works for another person or organization 代理人／We need some sales agents in this city. 我们在本市需要一些代售商。\n\n∇agential ［agent; -i- ; -al a. ］a. 代理人的；起媒介作用的\n\n-ency n. ＝the quality or state 表性质或状态\n\nagency［ag＝to do 做；-ency n. ＝the quality or state 表性质或状态→“the ability or place of doing business 办事的能力或场所”→］\nn.① power or force which causes a result 力量；作用\nhuman agency 人力 \n② the office of an agent; service organization 代理处；机构\nI have booked the hotel through a local travel agency. 我已经通过当地的旅行社预定了宾馆。\n\n-enda（-a表复数）n.＝things 事情\n\nagenda［ag＝to do 做；-enda（-a表复数）n.＝things 事情→“things to be done 要办的事项”→］\n [əˈdʒendə] n.list of things to be discussed or decided upon 议事日程\nThe most important item on the agenda today is what you proposed. 你的提议是今天议事日程的首项。\n\n-ile a.＝able 能…的\n\nagile［ag＝to do 做；-ile a.＝able 能…的→“able to do 能干的”→］\n[ˈædʒl] a. able to do or move quickly or easily 敏捷的；灵活的\nThe actor is as agile as a monkey. 那个演员像猴子般灵活。\n\n∇agility［agil(e); -ity］[əˈdʒɪləti] n.敏捷；灵活\n\n-ate v.＝to make or cause 使…\n\nagitate［ag＝to drive or keep moving 驱使，使运动；-it-；-ate v.＝to make or cause 使…→“to cause to keep moving steadily 引起不断的动荡”→］\n [ˈædʒɪteɪt]  v.disturb 鼓动\nThe audience were agitated by his fiery speech. 听众被他的热情的演说所鼓动。\n\n∇agitation［agitat(e); -ion n.］n.鼓动；激动；不安\n\nagitator［agitat(e); -or n.］n.鼓动者；煽动者\nact＝to do 做act［act＝to do 做→“to do what is required 做要求之事”→］\nⅠv.① do sth required 行动，做某事／We must act at once. 我们必须立刻行动。\n② function 起作用／The brakes wouldn&#39;t act. 刹车失灵。\n③ take part in a play or film 演出，扮演／Who is acting Hamlet? 谁演哈姆雷特呢？→\nⅡn.\n ① sth done 行为／No act of kindness is ever wasted. 善有善报。\n ② process of doing 行为过程，行动／The thief was caught in the act. 那小偷是当场被捉的。\n\n∇actor［act v.; -or n.］n.男演员；行动者\n\nactress［act v.; -ress n.］n.女演员\n\nacting［act v.; -ing n.］n.行为\n\nre-act［re-; act v.］v.重做，再做；重演，再演\n\noveract［over-; act v.］v.演得过于夸张\n\n-ion n.＝process or result of 表过程或结果\n\naction［act＝to do 做；-ion n.＝process or result of 表过程或结果 →］n.\n ① process of doing, or deed 行动，活动\n Actions speak louder than words. 行动比言语更有力。\n ② result of doing, or effect 作用\n This experiment shows the action of an acid on metal. 该实验说明酸对金属的作用。\n ③ charge 诉讼\n If he doesn&#39;t pay us, we have to bring an action against him. 他如果不还债，我们只好起诉他。\n\n∇actionable［action 诉讼；-able a.］a.可控诉的\n\n-ive a.＝able to ~ 会…的\n\nactive［act＝to do 做；-ive a.＝able to ~ 会…的 →］\na.able to do 活跃的，积极的，能动的\nAlthough he is over 70, he is still active. 他虽然年过70，但依然很活跃。\n\n∇activate［activ(e); -ate v.］v.使活动\n\nactivism［activ(e); -ism n.］n.［哲］能动主义；积极，活跃\n\nactivist［activ(e); -ist n.］n.活动分子，积极分子\n\nactivity［activ(e); -ity n.］n.能动性；活跃；［复］活动\n\n-al a.＝the act or fact of 表行为或事实\n\nactual［act＝to do 做；-u-；-al a.＝the act or fact of 表行为或事实 →］\na.existing in fact；real 实际的；现实的\nThe actual amount of money was not known. 实际金额尚不得而知。\n\n∇actuality［actual; -ity n.］n.事实，现存情况；现实性\n\nactualize［actual; -ize v.］v.实行，使现实化\n\n-ate v.＝to make or cause 使\n\nactuate［act＝to do 做；-u-；-ate v.＝to make or cause 使…→］\nv. cause to do 驱动，激励／He was actuated by the best of motives. 驱使他行为的动机是非常善良的。\n\n∇actuation［actuat(e); -ion n.］n.驱动，激励；开动\n\nactuator［actuat(e); -or n.］n.［机］促动器；传动机构\n\nex-＝out 出\n\nexact［ex-＝out 出；act＝to drive 驱使→“to drive out；driven out 逼出来；逼出来的”→］\nⅠv.demand or obtain by force 强求，索取\nHe exacted obedience from the residents. 他强求居民服从他。→\nⅡa.correct and without mistake 准确的；精确的\nHe is extremely exact in conduct. 他的行为一丝不苟。\n\n∇exacting［exact v.; -ing a.］a.苛求的，严厉的；强索的\n\nexaction［exact v.; -ion n.］n.强索；勒索；榨取\n\nexactitude［exact a.; -i-; -tude n.］n.精确（性）；严格，严谨\n\nre-＝back 回返\n\nreact［re-＝back 回返；act＝to do 做 →］\nv.① do or act in reply 反应\nShe was slow to react. 她反应迟钝。\n② do against 反动，反作用\nThe villagers reacted against oppression by an uprising. 村民们举行暴动反抗压迫。\n\n∇reaction［react; -ion n.］n.反应；反作用；反动\n\nreactor［react; -or n.］n.引起反应的人或物；［原］反应堆\n\nreactive［react; -ive a.］a.反应的；反动的\n\nreactant［react; -ant n.］n.［化］反应物\n\ninter-＝between 在…之间；\n\ninteract［inter-＝between 在…之间；act＝to do 做→“to do between two things 在两者之间互动”→］\nv.have an effect on each other 互相作用，互相影响\nAll things are inter-related and interacted on each other. 一切事物都是既互相联系又互相影响的。\n\n∇interaction［interact; -ion n.］n.相互作用；相互\n\ninteractive［interact; -ive a.］a.互相作用的；［计］交互的\n\ntrans-＝across or through 穿过\n\ntransact［trans-＝across or through 穿过；act＝to drive 驱使→“to drive through 使通过”→］\nv.carry on；manage 执行，办理\nHe transacted some business at bank. 他在银行处理一些事务。\n\n∇transaction［transact; -ion n.］n.办理，处理；交易，业务\n\ntransactor［transact; -or n.］n.办事人；处理者\n\nam(at)［L］&#x3D; to love 爱常用词amiable和amateur分别来自同源异形根am 和amat 。am 是拉丁动词amare 的现在词干；amat 是这个动词的分词词干，意思都相当于to love（爱）。\nable a.＝capable of 可…的\n\namiable［am＝to love 爱；-i-；-able a.＝capable of 可…的→“capable of being loved 可爱的”→］\na.lovable, or kindly 可爱的；和蔼的\n\n-eur（-er）n.＝person 人\n\namateur［amat＝to love； -eur（-er）n.＝person 人→“person who does sth for loving it（rather than for money）因爱好（而不是金钱）从事某项活动者”→］\nn.person who practices an art, sport or science for his own pleasure（艺术、体育、科学等）业余爱好者\n\n∇amateurism［amateur; -ism n.］n.业余活动\n\namateurish［amateur; -ish a.］a.不老练的\n\namicable［amic（来自同根名词amicus）&#x3D; person one loves, or friend 亲爱者，朋友；-able a.＝able to be 能当…的→“able to be one&#39;s friend 能做朋友的”→］\n a.in a friendly spirit, or peaceable 友好的；和睦的\n\n∇amicability［amicab(le); -ility n.］n.友好；和睦\n\n-our n.＝the state or result of 表状态或结果\n\namour［am＝to love 爱；-our n.＝the state or result of 表状态或结果→“loving or the result of loving 恋爱或恋爱的结果”→］\nn.① love 恋爱 \n② love affair, especially discreditable one 不正当的男女关系，桃色事件\n\n∇amorous［amo(u)r; -ous a.］a.恋爱的；多情的\n\nen- v.＝to cause to be 使\n\nenamor［en- v.＝to cause to be 使；amo(u)r n.＝love 恋爱→“to cause to be in love 使恋爱”→］\nv.inflame with love; charm 使倾心；使迷恋\n\n∇enamored［enamor; -ed a.］a.倾心的\n\namatory［amat＝to love 爱；-ory a.＝related to 与…有关的→］\na. related to loving; expressing love 恋爱的；爱慕的\n\nen-表示相反；em是am的变体\nenemy\n\nanim ［L］&#x3D; life 生命anim 是常用词animal的词根，源于拉丁名词anima ，它包含有mind（思想）、spirit（精神）、soul（灵魂）、life（生存）等与生命现象有关的概念，可以看成英语基本词life（生命）的对等词。\nanimal［anim＝life 生命；-al n.＝thing characterized by 具有…特征的东西→“thing characterized by having life 有生命的东西”→］\nn.① any creature 动物\n② any creature other than man 除人以外的任何动物\n③ any creature other than a man, bird, fish or insect 兽类\n\n∇animalism［animal; -ism n.］n.动物性；兽欲\n\nanimalize［animal; -ize v.］v.使动物化\n\n-ate a.＝having 有…的\n\nanimate［anim＝life 生命；-ate a.＝having 有…的→“having life or spirits 有生命的，有精神的”→］\nⅠa.① living 有生命的\n② full of life or spirits 生气勃勃的\nⅡv.give life to, or make alive 使活跃\n\n∇animation［animat(e) v.; -ion n.］n.活跃；生气\n\nreanimate［re-; animate v.］v.使复活；激励\n\nanimosity［anim＝life, spirit 生命，精神；-osity（-ous＋-ity）n.＝the special state or quality 表特殊的状态或性质→“special spirit 特别的精神”→“strong feeling 强烈的感情”→］\nn.strong dislike; hatred 敌意；仇恨\n\nmagnanimity［magn＝great 大；anim＝spirit 精神；-ity n.＝the quality 表性质→“the greatness of spirit or mind 精神上的大度”→］\n[ˌmæɡnəˈnɪməti] n.the spirit of being unusually generous, or generosity 宽宏大量\n\n∇magnanimous［magn; anim; -ous a.］a.宽宏大量的\n\nequanimity［equ＝even 平衡的；anim＝spirit 精神；-ity n.＝the quality 表性质→“the spirit with an even quality 平稳的精神品质”→］\n[ˌekwəˈnɪməti] n.calmness or steadiness of mind 平静；沉着；镇定\n\n∇equanimous［equ; anim; -ous a.］a.沉着的；镇定的\n\nlonganimity［long（longus）&#x3D; long 长久的；anim＝spirit 精神；-ity n.＝the quality 表性质→“the spirit with the quality of enduring long 能长久忍耐的精神品质”→］\nn.endurance; forbearance 忍耐性；坚韧性\n\n∇longanimous［long; anim; -ous a.］a.坚韧的；忍耐的\n\nunanimous［un＝one 一；anim＝mind 思想；-ous a.＝having 有…的 →］\na. having one mind or sharing the same view 思想一致的；观点统一的\n\n∇unanimity［un; anim; -ity n.］n.全体一致；无异议\n\n\nann, enn［L］&#x3D; year 年词根ann 来自拉丁名词annus ，意思为year（年）；词根enn 是ann 在添加前缀时产生的音变异体。ann 在构词中常跟着连接字母-i- 或-u- 。\nvers＝to turn 转\n\nanniversary［ann＝year 年；-i-；vers＝to turn 转；-ary n.＝thing 物→“the day connected with the turning of a year 与时间周转一年相关的日子”→］\nn.the day of a year on which sth happened 周年纪念日\n\nannual［ann＝year 年；-u-；-al a.＝of …的→］\nⅠa.of one year； yearly 一年的；每年的\nⅡn.book or pamphlet issued once a year 年鉴；年刊\n\nannals［ann＝year 年；-al n.＝thing 物；-s表复数→“many things happened in a year 一年中发生的许多事情”→］\nn.（pl.）yearly records; historical records 编年史；历史记载\n\n∇annalist［annal(s); -ist n.］n.编年史作者\n\nper-＝through\n\nperennial［per-＝through 通；enn＝year 年；-i-；-al a.＝of …的→“of the time through a year 贯通一年时间的”→］\na.① lasting through the year 长年不断的\n② everlasting 长久的\n\n∇perenniality［perennial; -ity n.］n.常年性；长久性\n\nannuity［ann＝year 年；-u-；-ity n.＝thing connected with 与…有关的事物→“money connected with one year 按一年时间计算的钱”→］\nn.① yearly allowance or income 年金；年收入\n② investment insurance which pays interest sum yearly 年金保险投资\n\n∇annuitant［annuit(y); -ant n.］n.领受年金者\n\nsuperannuate［super-＝over 超；ann＝year or age 年，年龄；-u-； -ate v.＝to cause to be 使成为→“to cause sb to be over-aged 使某人成为超龄者”→］\nv. make to retire when one is over a certain age 因超过规定年龄而令其退休\n\nannu与enni还能与表示数目的前缀构成专门表示以“年”为单位的时间的派生词。以下是常见的几个\n\nsemiannual［semi-＝half 半；annu＝year 年；-al a.＝of …的→］\na of a half year 半年的；半年一度的\n\nbiannual［bi-＝two, twice 二，两次；annu＝year 年；-al a.＝of …的→］\n [baɪˈænjuəl]a.occurring twice a year 每年两度的\n\nbiennial［bi-＝two 二；enni＝year 年；-al a.＝of …的→“of two years 两年的”→］\n [baɪˈeniəl] a.lasting two years; once every two years 持续两年的；两年一度的\n\n∇biennium［bi-; enni; -um n.］n.两年时间\n\n词缀 \nco- ＝together \ncounter- ＝against\nretro- ＝backward\n\n","slug":"master/English/英语词根词缀整理","date":"2022-10-19T23:49:39.000Z","categories_index":"","tags_index":"英语","author_index":"ChrisWood"},{"id":"2daf5b5a74686be842f9f5c6d964e1fb","title":"Nginx日志按天切割","content":"Nginx日志按天切割Nginx默认的发布不支持对日志文件按日期或者按日志量来分割，此处实现的功能：在每天凌晨00:00把前⼀天的Nginx⽇志（access.log和error.log）分别重命名为access-yyyy-mm-dd.log和log-xxxx-xx-xx.log格式，例如：access-2022-10-18.log，error-2022-10-18.log\nLinux环境脚本vim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;auto_cut_log.sh\n#!&#x2F;bin&#x2F;bash\n#Nginx⽇志⽂件所在⽬录\nLOG_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;\n#获取昨天的⽇期\nYESTERDAY&#x3D;$(date -d &quot;yesterday&quot; +%Y-%m-%d)\n#nginx服务的pid⽂件路径\nPID&#x3D;&#x2F;run&#x2F;nginx.pid\n#分割⽇志\nmv $&#123;LOG_PATH&#125;access.log $&#123;LOG_PATH&#125;access-$&#123;YESTERDAY&#125;.log\nmv $&#123;LOG_PATH&#125;error.log $&#123;LOG_PATH&#125;error-$&#123;YESTERDAY&#125;.log\n#向Nginx主进程发送USR1信号，重新打开⽇志⽂件\nkill -USR1 &#96;cat $&#123;PID&#125;&#96;\n\n\n\n\n\n\n\n\n\n有关USR1的介绍：USR是User-defined的缩写，即用户定义的,USR1通常被用来告知应用程序重载配置文件\n增加脚本文件执行权限chmod +x &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;auto_cut_log.sh\n\n添加定时任务crontab -e\n00 00 * * * &#x2F;bin&#x2F;bash &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;auto_cut_log.sh\n\n\n\n\n\n\n\n\n\n参考链接：https://blog.csdn.net/klipse/article/details/125019896\n","slug":"nginx/Nginx日志按天切割","date":"2022-10-18T08:20:26.000Z","categories_index":"Nginx","tags_index":"Nginx","author_index":"ChrisWood"},{"id":"f608ca61f1cd18e3f4abde5dcaf441ba","title":"开发环境配置","content":"开发环境配置篇nodewindowsnvm for windows\n\nGitHub地址: https://github.com/coreybutler/nvm-windows/releases推荐使用nvm-setup.exe 自动创建环境变量NVM_HOME和NVM_SYMLINK\n配置nvm settings.txt文件# 增加镜像地址\nnode_mirror: https:&#x2F;&#x2F;npmmirror.com&#x2F;mirrors&#x2F;node&#x2F;\nnpm_mirror: https:&#x2F;&#x2F;npmmirror.com&#x2F;mirrors&#x2F;npm&#x2F;\n# 或者使用其他镜像\nnode_mirror: https:&#x2F;&#x2F;registry.npmjs.org&#x2F;mirrors&#x2F;node&#x2F;\nnpm_mirror: https:&#x2F;&#x2F;registry.npmjs.org&#x2F;mirrors&#x2F;npm&#x2F;\n3.nvm 常用命令推荐nvm -h,自己列出命令行,说明都很全# 查看node版本可用列表\nnvm ls available\n# 安装具体版本\nnvm install 16.18.0\n# 使用具体版本\nnvm use 14.6.0\n# 查看已安装版本\nnvm ls\n配置npm 全局安装文件夹跟全局缓存文件夹 \n\n\n\n\n\n\n\n\n成功安装node版本后，在nvm安装目录下创建”node_global”和“node_cache”两个文件夹默认情况是不用修改，但是如果你觉得放在C盘不好，\n\n\n# 设置全局模块的安装路径\nnpm config set prefix &quot;D:\\nvm\\node_global&quot;\n# 设置缓存到node_cache文件夹\nnpm config set cache &quot;D:\\nvm\\node_cache&quot;\n# 还要把node_global路径加入到系统环境变量path中，方便直接使用命令行运行\n\n\n\n\n\n\n\n\n\n参考文章：https://www.jianshu.com/p/685e36ac2668\npythonwindowspyenv-win\n\nGitHub地址: https://github.com/pyenv-win/pyenv-win推荐直接下载源码master分支的zip包\n解压后放到需要放的位置，pyenv-win-master重命名为.pyenv\n配置环境变量:\n\n\n系统环境变量 PYENV &#x2F;path&#x2F;to&#x2F;pyenv-win（eg:”E:\\develop.pyenv\\pyenv-win”）\nPATH %PYENV%\\bin %PYENV%\\shims\n\n\npyenv 常用命令\n\n\n修改源pyenv-win文件夹下.versions_cache.xmlhttps://www.python.org/ftp/python替换为https://npm.taobao.org/mirrors/python# 查看所有pyenv可以安装的版本\npyenv install --list\n# 安装\npyenv install 3.10.7\n# 查看pyenv下所有的python安装版本\npyenv versions\n# 跳转到对应版本\npyenv local 3.9.0\n#从查看当前对应版本\npyenv version\n\n\n\n\n\n\n\n\n\n参考文章：https://baijiahao.baidu.com/s?id=1742653008854467791&amp;wfr=spider&amp;for=pc\n\n\njavawindowsJEnv-for-Windows\n\nGitHub地址: https://github.com/FelixSelter/JEnv-for-Windows下载已经打了tag的版本\n解压后放到需要放的位置\n配置环境变量:\n\n\n系统环境变量 JENV_HOME &#x2F;path&#x2F;to&#x2F;JEnv-for-Windows（eg:”E:\\develop\\JEnv-for-Windows-2.0.3”）\nPATH %JENV_HOME%\n\n\nJEnv-for-Windows 常用命令# 首先需要手动增加java版本\njenv add &lt;name&gt; &lt;path&gt;\n# 移除版本\njenv remove &lt;name&gt;\n# 查看所有添加好的java环境\njenv list\n# 全局使用\njenv change jdk17\n# 临时使用\njenv use jdk8\n# 临时使用后释放\njenv use remove\n# 文件夹下始终使用\njenv local jdk15\n# 文件夹下释放\njenv local remove\n# 使用当前java环境下的其他命令\njenv link javac\n\n","slug":"common/开发环境配置","date":"2022-10-16T02:36:44.000Z","categories_index":"","tags_index":"python node java","author_index":"ChrisWood"},{"id":"fd6db9879e8a7f6e92c3104daa24218a","title":"docker环境部署集群前后端分离项目","content":"docker环境部署集群前后端分离项目一、基础1.Docker虚拟机常用命令1.先更新软件包\nscriptyum -y update\n2.安装Docker虚拟机\nscriptyum install -y docker\n3.运行、重启、关闭Docker虚拟机\nscriptservice docker start\nservice docker start\nservice docker stop\n4.搜索镜像\nscriptdocker search 镜像名称\n5.下载镜像\nscriptdocker pull 镜像名称\n6.查看镜像\nscriptdocker images\n7.删除镜像\nscriptdocker rmi 镜像名称\n8.运行容器\nscriptdocker run 启动参数  镜像名称\n9.查看容器列表\nscriptdocker ps -a\n10.停止、挂起、恢复容器\nscriptdocker stop 容器ID\ndocker pause 容器ID\ndocker unpase 容器ID\n11.查看容器信息\nscriptdocker inspect 容器ID\n12.删除容器\nscriptdocker rm 容器ID\n13.数据卷管理\nscriptdocker volume create 数据卷名称  #创建数据卷\ndocker volume rm 数据卷名称  #删除数据卷\ndocker volume inspect 数据卷名称  #查看数据卷\n14.网络管理\nscriptdocker network ls 查看网络信息\ndocker network create --subnet&#x3D;网段 网络名称\ndocker network rm 网络名称\n15.避免VM虚拟机挂起恢复之后，Docker虚拟机断网\nscriptvi &#x2F;etc&#x2F;sysctl.conf\n文件中添加net.ipv4.ip_forward=1这个配置\nscript#重启网络服务\nsystemctl  restart network\n2.PXC集群1.安装PXC镜像\nscriptdocker pull percona&#x2F;percona-xtradb-cluster\n# 镜像名称太长，修改一下\ndocker tag percona&#x2F;percona-xtradb-cluster pxc\n# 删除之前的\ndocker rmi percona&#x2F;percona-xtradb-cluster\n2.创建内部网络\nscriptdocker network create --subnet&#x3D;172.18.0.0&#x2F;16 net1\n# 查看net1网段：\ndocker inspect net1\n# 如果要删除使用删除命令\ndocker network rm net1\n3.创建数据卷\n\n\n\n\n\n\n\n\n\n因为pxc不支持映射目录，所以采用映射数据卷的方式。创建数据卷叫v1，这里5个节点，所以创建5个数据卷：\nscriptdocker volume create --name v1\ndocker volume create --name v2\ndocker volume create --name v3\ndocker volume create --name v4\ndocker volume create --name v5\n# 查看v1数据卷在宿主机的位置\ndocker inspect v1\n# 删除数据卷v1\ndocker volume rm v1\n4.创建备份数据卷（用于热备份数据）\nscriptdocker volume create --name backup\n5.创建5节点的PXC集群\n\n\n\n\n\n\n\n\n\n注意，每个MySQL容器创建之后，因为要执行PXC的初始化和加入集群等工作，耐心等待1分钟左右再用客户端连接MySQL。另外，必须第1个MySQL节点启动成功，用MySQL客户端能连接上之后，再去创建其他MySQL节点。\n\n\n\n\n\n\n\n\n\n命令参数说明：端口3306，密码123456，集群名称PXC，同步数据密码123456，映射数据目录到宿主机的v1数据卷，给予最高权限，名称叫node1，网段为net1，ip指定为172.18.0.2，运行的镜像是pxc。\nscript#创建第1个MySQL节点\ndocker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -e CLUSTER_NAME&#x3D;PXC -e XTRABACKUP_PASSWORD&#x3D;123456 -v v1:&#x2F;var&#x2F;lib&#x2F;mysql -v backup:&#x2F;data --privileged --name&#x3D;node1 --net&#x3D;net1 --ip 172.18.0.2 pxc\n#创建第2个MySQL节点\ndocker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -e CLUSTER_NAME&#x3D;PXC -e XTRABACKUP_PASSWORD&#x3D;123456 -e CLUSTER_JOIN&#x3D;node1 -v v2:&#x2F;var&#x2F;lib&#x2F;mysql --privileged --name&#x3D;node2 --net&#x3D;net1 --ip 172.18.0.3 pxc\n#创建第3个MySQL节点\ndocker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -e CLUSTER_NAME&#x3D;PXC -e XTRABACKUP_PASSWORD&#x3D;123456 -e CLUSTER_JOIN&#x3D;node1 -v v3:&#x2F;var&#x2F;lib&#x2F;mysql --privileged --name&#x3D;node3 --net&#x3D;net1 --ip 172.18.0.4 pxc\n#创建第4个MySQL节点\ndocker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -e CLUSTER_NAME&#x3D;PXC -e XTRABACKUP_PASSWORD&#x3D;123456 -e CLUSTER_JOIN&#x3D;node1 -v v4:&#x2F;var&#x2F;lib&#x2F;mysql --privileged --name&#x3D;node4 --net&#x3D;net1 --ip 172.18.0.5 pxc\n#创建第5个MySQL节点\ndocker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -e CLUSTER_NAME&#x3D;PXC -e XTRABACKUP_PASSWORD&#x3D;123456 -e CLUSTER_JOIN&#x3D;node1 -v v5:&#x2F;var&#x2F;lib&#x2F;mysql --privileged --name&#x3D;node5 --net&#x3D;net1 --ip 172.18.0.6 pxc\n\n\n\n\n\n\n\n\n\n验证PXC集群: navicat或者其他工具连接5个数据库节点,在DB1中新建一个数据库一张表并插入数据，提交后，看其它四个节点是否同步。\n6.安装Haproxy镜像\nscriptdocker pull haproxy\n7.宿主机上编写Haproxy配置文件\nscriptvi &#x2F;home&#x2F;soft&#x2F;haproxy&#x2F;haproxy.cfg \n#vi &#x2F;data&#x2F;software&#x2F;haproxy&#x2F;haproxy.cfg\n配置文件如下：\nscriptglobal\n\t#工作目录\n\tchroot &#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy\n\t#日志文件，使用rsyslog服务中local5日志设备（&#x2F;var&#x2F;log&#x2F;local5），等级info\n\tlog 127.0.0.1 local5 info\n\t#守护进程运行\n\tdaemon\n\ndefaults\n\tlog\tglobal\n\tmode\thttp\n\t#日志格式\n\toption\thttplog\n\t#日志中不记录负载均衡的心跳检测记录\n\toption\tdontlognull\n    #连接超时（毫秒）\n\ttimeout connect 5000\n    #客户端超时（毫秒）\n\ttimeout client  50000\n\t#服务器超时（毫秒）\n    timeout server  50000\n\n#监控界面\t\nlisten  admin_stats\n\t#监控界面的访问的IP和端口\n\tbind  0.0.0.0:8888\n\t#访问协议\n    mode        http\n\t#URI相对地址\n    stats uri   &#x2F;dbs\n\t#统计报告格式\n    stats realm     Global\\ statistics\n\t#登陆帐户信息\n    stats auth  admin:123456\n#数据库负载均衡\nlisten  proxy-mysql\n\t#访问的IP和端口\n\tbind  0.0.0.0:3306  \n    #网络协议\n\tmode  tcp\n\t#负载均衡算法（轮询算法）\n\t#轮询算法：roundrobin\n\t#权重算法：static-rr\n\t#最少连接算法：leastconn\n\t#请求源IP算法：source \n    balance  roundrobin\n\t#日志格式\n    option  tcplog\n\t#在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测\n    option  mysql-check user haproxy\n    server  MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000  \n    server  MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000  \n\tserver  MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000 \n\tserver  MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000\n\tserver  MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000\n\t#使用keepalive检测死链\n    option  tcpka  \n\n\n\n\n\n\n\n\n\n注意：1）、option部分，记得在MySQL创建一个没有权限的用户haproxy；CREATE USER ‘haproxy‘@’%’ IDENTIFIED BY ‘’;2）、server部分，记得这里3306是容器的端口，不是宿主机的端口。\n8.创建两个Haproxy容器\nscript#创建第1个Haproxy负载均衡服务器\ndocker run -it -d -p 4001:8888 -p 4002:3306 -v &#x2F;home&#x2F;soft&#x2F;haproxy:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy --name h1 --privileged --net&#x3D;net1 --ip 172.18.0.7 haproxy\n#进入h1容器，启动Haproxy\ndocker exec -it h1 bash\nhaproxy -f &#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg\n#创建第2个Haproxy负载均衡服务器\ndocker run -it -d -p 4003:8888 -p 4004:3306 -v &#x2F;home&#x2F;soft&#x2F;haproxy:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy --name h2 --privileged --net&#x3D;net1 --ip 172.18.0.8 haproxy\n#进入h2容器，启动Haproxy\ndocker exec -it h2 bash\nhaproxy -f &#x2F;usr&#x2F;local&#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg\n9.Haproxy容器内安装Keepalived，设置虚拟IP\n\n\n\n\n\n\n\n\n\n注意事项：云主机不支持虚拟IP，另外很多公司的网络禁止创建虚拟IP（回家创建）,还有宿主机一定要关闭防火墙和SELINUX，很多同学因为这个而失败的，切记\nscript#进入h1容器\ndocker exec -it h1 bash\n#更新软件包\napt-get update\n#安装VIM\napt-get install vim\n#安装Keepalived\napt-get install keepalived\n#编辑Keepalived配置文件（参考下方配置文件）\nvim &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf\n#启动Keepalived\nservice keepalived start\n#宿主机执行ping命令\nping 172.18.0.201\n配置文件内容如下\nscriptvrrp_instance  VI_1 &#123;\n       state  MASTER\n       interface  eth0\n       virtual_router_id  51\n       priority  100\n       advert_int  1\n       authentication &#123;\n           auth_type  PASS\n           auth_pass  123456\n       &#125;\n       virtual_ipaddress &#123;\n           172.18.0.201\n       &#125;\n   &#125;\n","slug":"docker/docker环境部署集群前后端分离项目","date":"2022-10-12T08:05:29.000Z","categories_index":"docker","tags_index":"docker","author_index":"ChrisWood"},{"id":"ab71b7b05749a5527c735a9fb6d5af98","title":"Java高并发专题-JUC线程池","content":"线程池Executor框架接口\nExecutors.newCachedThreadPool() 创建缓存线程池public class ThreadPoolExample1 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;\nExecutors.newFixedThreadPool(3) 创建定长线程池public class ThreadPoolExample2 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(3);\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;\nExecutors.newSingleThreadExecutor() 创建单线程线程池public class ThreadPoolExample3 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor();\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;\nExecutors.newScheduledThreadPool(1) 创建定长线程池，支持定时，周期性的任务执行public class ThreadPoolExample4 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ScheduledExecutorService executorService &#x3D; Executors.newScheduledThreadPool(1);\n\n        executorService.scheduleAtFixedRate(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                log.warn(&quot;schedule run&quot;);\n            &#125;\n        &#125;, 1, 3, TimeUnit.SECONDS);\n        \n&#x2F;&#x2F;        executorService.shutdown();\n\n        Timer timer &#x3D; new Timer();\n        timer.schedule(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                log.warn(&quot;timer run&quot;);\n            &#125;\n        &#125;, new Date(), 5 * 1000);\n    &#125;\n&#125;\n前面三种线程池都是直接创建ThreadPoolExecutor类的对象。ScheduledThreadPool 因为要实现定时功能，创建的是 ScheduledThreadPoolExecutor 类的对象。但 ScheduledThreadPoolExecutor 也是继承自ThreadPoolExecutor 。下面这个构造方法是参数最全的一个创建线程池的源码。&#x2F;**\n * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial\n * parameters.\n *\n * @param corePoolSize 线程池中维持的线程数量。\n *                     当线程数量不超过这个数时，即使线程处于空闲状态也不会被销毁，会一直等待任务到来。\n *                     但是如果设置 allowCoreThreadTimeOut 为 true，corePoolSize 就不再有效了。\n * @param maximumPoolSize 线程池中线程的最大数量。\n * @param keepAliveTime 当线程数量超过了 corePoolSize 时，多余的线程销毁前等待的时间。\n * @param unit keepAliveTime 的时间单位\n * @param workQueue 用来管理待执行任务的队列。\n * @param threadFactory 创建线程的工厂。\n * @param handler RejectedExecutionHandler 接口的实现对象。用于处理任务被拒绝执行的情况。\n *                被拒绝的原因可能是所有线程正在执行任务而任务队列容量又满了\n *&#x2F;\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) &#123;\n    ...\n&#125;\n\n","slug":"java/concurrent/Java高并发专题-JUC线程池","date":"2022-10-08T08:55:43.000Z","categories_index":"Java高并发专题","tags_index":"Java高并发专题","author_index":"ChrisWood"},{"id":"38ca70cafbfd87b7f0418630bd7d0ad1","title":"springboot配置文件","content":"springboot配置文件在springboot 项目中一般默认的配置文件是application.properties,但是实际项目中我们一般会使用application.yml文件\nyml文件读取顺序存放目录SpringBoot配置文件默认可以放到以下目录中，可以自动读取到：\n\n项目根目录中config目录下\n项目根目录下\n项目resources目录中config目录下\n项目的resources目录下\n\n读取顺序在不同的目录中存在多个配置文件，它的读取顺序是：1、config&#x2F;application.properties（项目根目录中config目录下）2、config&#x2F;application.yml3、application.properties（项目根目录下）4、application.yml5、resources&#x2F;config&#x2F;application.properties（项目resources目录中config目录下）6、resources&#x2F;config&#x2F;application.yml7、resources&#x2F;application.properties（项目的resources目录下）8、resources&#x2F;application.yml\n\n\n\n\n\n\n\n\n\n注意：1、如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。2、如果同一个配置属性，在多个配置文件都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。3、创建SpringBoot项目时，一般的配置文件放置在“项目的resources目录下\nyml文件读取方式yml文件规则\nyml文件的好处，天然的树状结构，一目了然，实质上跟properties是差不多\n不支持tab缩进\n可以使用 “-小写字母” 或 “_小写字母”来 代替 “大写字母”,如 userName 与 user-name ,user_name 含义是一样的,key: value 格式书写key,后面跟着冒号,再后面跟着一个空格,然后是值\n\n几种数据格式的表示方式1.普通的值（数字，字符串，布尔）key: value ,如:\nage: 18\nname: zhangsan\n\n\n\n\n\n\n\n\n\n注意：字符串默认不用加上单引号或者双引号；“”：双引号不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi‘’：单引号会转义特殊字符，特殊字符最终只是一个普通的字符串数据name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi\n2.对象、Map（属性和值）（键值对）person:\n    age: 18\n    name: mysgk\nmap:  \n  name: 刘德华  \n  age: 10\n3.数组（List、Set）hands:\n    - left\n    - right\nlist: 列表1,列表2,列表3\nset: [集合1,集合2,集合3]\n读取配置的方式1.@Value直接在对应的变量上添加@Value注解即可，此时配置的key可以不与变量名相同\nserver:\n  port: 8081\n@Value(&quot;$&#123;server.port&#125;&quot;)\npublic String serverPort;\n2.@ConfigurationProperties新增一个Student类，同时添加@ConfigurationProperties注解\nstudent:  \n  name: 刘德华  \n  age: 40\n@Data\n@ConfigurationProperties(prefix &#x3D; &quot;student&quot;)\npublic class Student &#123;    \n    String name;    \n    int age;\n&#125;\n3.@Environment用的很少，了解即可\ntest:\n    msg: aaa\n@Autowired\nprivate Environment env\n\npublic static void main() &#123;\n    System.out.println(env.getProperty(&quot;test.msg&quot;));\n&#125;\n","slug":"springboot/springboot配置文件","date":"2022-10-08T07:55:43.000Z","categories_index":"springboot","tags_index":"springboot","author_index":"ChrisWood"},{"id":"e92c64341ee2ef385eda6a1d1f832be9","title":"Mysql基础","content":"Mysql常见数据库\nMYSQL：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费。\nOracle：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。\nDB2 ：IBM公司的数据库产品,收费的。常应用在银行系统中.\nSQLServer：MicroSoft 公司收费的中型的数据库。C#、.net等语言常使用。\nSyBase：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。\nSQLite：嵌入式的小型数据库，应用在手机端。\n常用数据库：MYSQL，Oracle\nSQL语句SQL分类：\n数据定义语言：简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列等。关键字：create，alter，drop等\n数据操作语言：简称DML(Data Manipulation Language)，用来对数据库中表的记录进行更新。关键字：insert，delete，update等\n数据控制语言：简称DCL(Data Control Language)，用来定义数据库的访问权限和安全级别，及创建用户\n数据查询语言：简称DQL(Data Query Language)，用来查询数据库中表的记录。关键字：select，from，where等\nint（integer） 整数类型\nbigint （long） 整数类型\ndouble 小数类型\ndecimal（m,d） 指定整数位与小数位长度的小数类型\ndate 日期类型，格式为yyyy-MM-dd，包含年月日，不包含时分秒\ndatetime 日期类型，格式为 YYYY-MM-DD HH:MM:SS，包含年月日时分秒\ntimestamp 日期类型，时间戳\nvarchar（M） 文本类型， M为0~65535之间的整数\njson 8.0以上版本支持json数据类型\n\nDDL操作语言(3%)数据库操作：database\n#创建数据库\ncreate database 数据库名;\ncreate database 数据库名 character set 字符集;\n#查看所有数据库\nshow databases;\n#查看某个数据库的定义的信息\nshow create database 数据库名;\n#删除数据库\ndrop database 数据库名;\n#查看正在使用的数据库\nselect database();\n#切换数据库\nuse 数据库名;\n\n表操作：table\n#创建表\ncreate table 表名(\n字段名 类型(长度) [约束],##[ ]代表可以省略\n字段名 类型(长度) [约束],\n&#x2F;*约束 对某列数据进行限制\n主键约束--限制某列数据既不能为空也不能重复\n唯一约束--限制某列数据不能重复\n非空约束--限制某列数据不能为空\n*&#x2F;\n...\n字段名 类型(长度) [约束]\n);\nCREATE TABLE category (\ncid INT primary key, #分类ID\ncname VARCHAR(100) #分类名称\n);\n#查看数据库中的所有表\nshow tables;\n#查看表结构\ndesc 表名;\n#删除表\ndrop table 表名;\n#修改表结构格式\n&#x2F;*添加列*&#x2F;  alter table 表名 add 列名 类型(长度) [约束];\n&#x2F;*修改列的类型长度及约束*&#x2F;  alter table 表名 modify 列名 类型(长度) 约束;\n&#x2F;*修改列名*&#x2F; alter table 表名 change 旧列名 新列名 类型(长度) 约束;\n&#x2F;*删除列*&#x2F; alter table 表名 drop 列名;#列中数据一起删除\n&#x2F;*修改表名*&#x2F;rename table 表名 to 新表名;\n&#x2F;*修改表的字符集*&#x2F;alter table 表名 character set 字符集(了解);\n\nDML操作语言(7%)#插入表记录：insert\n-- 向表中插入某些字段\ninsert into 表 (字段1,字段2,字段3..) values (值1,值2,值3..);\n-- 向表中插入所有字段,字段的顺序为创建表时的顺序 \ninsert into 表 values (值1,值2,值3..);#数值类型外其他的字段类型的值必须使用引号(建议单引号)\ninsert into 表 values (值1,值2,值3..),(值1,值2,值3..); #批量插入\ninsert into 表 values [[值1,值2,值3..],[值1,值2,值3..]]; #批量插入\n-- 涉及自增的可以这样用,自增数值会自动覆盖null\ninsert into 表 values (null,值2,值3...);\n#更新表记录：update\nupdate 表名 set 字段名&#x3D;值,字段名&#x3D;值,...;\nupdate 表名 set 字段名&#x3D;值,字段名&#x3D;值,... where 条件;\n#删除符合条件记录：delete  from 表名 [where 条件] 逐行删除,不重置主键自增,再添加数据继续用之前的主键\n#删除表中所有记录: truncate table 表名  把表也删除,重新创建新表,会重置主键自增,重新开始\ndelete from 表名 [where 条件];\n\n扩展\nshow variables like &#39;character%&#39;; #查看所有mysql的编码\nset names gbk;#临时方案 当前窗口有效\n#安装目录下修改my.ini文件，重启服务所有地方生效。\n\nSQL约束主键约束\n#设置主键约束\nfirstname int PRIMARY KEY -- 1.创建表时，在字段描述处，声明指定字段为主键\nCONSTRAINT pk_personID PRIMARY KEY (firstname,lastname)\n-- 2.创建表时，在constraint约束区域，声明指定字段为主键  格式： [constraint 名称] primary key (字段列表)\n-- 关键字constraint可以省略，如果需要为主键命名，constraint不能省略，主键名称一般没用\n-- 字段列表需要使用小括号括住，如果有多字段需要使用逗号分隔。声明两个以上字段为主键，我们称为联合主键\nALTER TABLE persons ADD PRIMARY KEY (firstname,lastname)-- 3.创建表之后，通过修改表结构，声明指定字段为主键\n\n#删除主键约束\nALTER TABLE persons DROP PRIMARY KEY;#扩展 小bug 删除主键约束之后会保留非空约束\n\n自动增长列\n&#x2F;* auto_increment（自动增长列）关键字，自动增长列类型必须是整形，自动增长列必须为键(一般是主键)。*&#x2F;\np_id int PRIMARY KEY AUTO_INCREMENT,\n#扩展：默认AUTO_INCREMENT 的开始值是 1，如果希望修改起始值，请使用下列 SQL 语法\nALTER TABLE persons AUTO_INCREMENT&#x3D;100\n#删除方式：\n#delete 一条一条删除，不清空auto_increment记录数。\n#truncate 直接将表删除，重新建表，auto_increment将置为零，从新开始。\n\n非空约束\n# NOT NULL 约束强制列不接受 NULL 值\nid_p int NOT NULL,\nlastname varchar(255) NOT NULL\n\n唯一约束\n&#x2F;*UNIQUE约束唯一标识数据库表中的每条记录.UNIQUE和PRIMARY KEY约束均为列或列集合提供了唯一性的保\n证.PRIMARY KEY拥有自动定义的UNIQUE约束.!!每个表可以有多个UNIQU约束，但是每个表只能有一个PRIMARY KEY约束。*&#x2F;\nid_p int UNIQUE, -- 1.创建表时，在字段描述处声明唯一\nCONSTRAINT 名称 UNIQUE (id_p)-- 2.创建表时，在约束区域声明唯一\nALTER TABLE persons ADD [CONSTRAINT 名称] UNIQUE (id_p)-- 3.创建表后，修改表结构，声明字段唯一\n#如果值为null,则失去了unique约束的意义\n#删除唯一约束\nALTER TABLE persons DROP INDEX 字段名&#x2F;唯一约束名;\n\n默认约束\n#方式一,创建表,列数据类型后面 default &#39;默认值&#39;\ncity varchar(20) default &#39;北京&#39;\n#方式二,修改表结构\nalter table persons modify city varchar(20) default &#39;北京&#39;\n#删除默认约束\nalter table persons modify city varchar(20)\n\n数据库密码重置(扩展)\n停止mysql服务器运行输入services.msc 停止mysql服务\n\n在cmd下,输入mysqld –console –skip-grant-tables 启动服务器,出现一下页面,不要关闭该窗口\n\n新打开cmd,输入mysql -uroot 不需要密码\nuse mysql;\nupdate user set password&#x3D;password(&#39;abc&#39;) WHERE user&#x3D;&#39;root&#39;;#新密码为abc\n\n关闭两个cmd窗口\n\n\nSQL语句(DQL)简单查询语句\n&#x2F;* 格式一 查询指定的列 select 列名,列名 from 表名;\n*&#x2F;\nSELECT pid,pname FROM product;\n&#x2F;* 格式二 查询所有列的数据 \n select 列出所有列名 from 表名;\n select * from 表名 &#x2F;&#x2F;工作中很少用,查询数据多,效率慢\n*&#x2F;\nSELECT * FROM product;\n&#x2F;* 格式三 过滤重复的数据 \nselect distinct 字段1,字段二.. from 表名;\ndistinct关键字之后只有一个字段,就会过滤掉这个字段中重复的数据\ndistinct关键字之后又多个字段,多个字段同时满足才会过滤掉\n*&#x2F;\n-- 查询商品价格 过滤掉重复的价格\nSELECT DISTINCT price FROM product;\n-- 查询商品名称和价格 过滤掉名称和价格同时重复的数据\nSELECT DISTINCT pname,price FROM product;\n&#x2F;* 格式四 别名查询 \n1.给表起一个别名:多表查询时使用\n\tselect *|字段 from 表名 [as] 别名;\n2.给表中的字段起别名\n\tselect 字段1 [as] 别名,...字段n [as] 别名 from 表名;\n注意:别名只是对查询结果临时起一个名字,不会改变表中原有的名字;别名中如有特殊符号或者空格,必须用引号包裹起来\n*&#x2F;\nSELECT * FROM product AS p;\nSELECT pname AS 商品名称,price AS 商品价格 FROM product;\nSELECT pname  商品名称,price  &#39;商品 价格&#39; FROM product;\n&#x2F;*\n查询语句中可以直接进行数据计算\n*&#x2F;\nSELECT (1&#x3D;1+1);-- 2\n-- 查询商品名称和商品价格,把价格在查询时+10000\nSELECT pname  商品名称,price+10000  商品价格 FROM product;\n\n条件查询\n&#x2F;*\n比较运算符 &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;(!&#x3D;);between...and...显示在某一区间的值含头含尾;in(set)显示在in列表中的值;like&#39;_a%&#39;模糊查询,_代表一个字符%代表零个或多个任意字符;is null判断是否为空\n逻辑运算符 and or not\n*&#x2F;\n\n排序查询\n&#x2F;*通过order by语句，可以将查询出的结果进行排序。暂时放置在select语句的最后。\nSELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;\n#ASC 升序 (默认)\n#DESC 降序\n*&#x2F;\nSELECT * FROM product ORDER BY price DESC,category_id DESC;\n\n聚合查询\n&#x2F;*\n之前的查询都是横向查询，都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。\n五个聚合函数\ncount：统计指定列不为NULL的记录行数；\nsum：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；\nmax：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；\nmin：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；\navg：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；\n*&#x2F;\nSELECT count(*) FROM product\n\n分组查询\nSELECT 被份组的字段1,(求和,平均值,个数,最大,最小) FROM 表名 [where 条件 ]GROUP BY 被分组字段 HAVING 分组条件;\n#分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条件。\n&#x2F;*\nhaving与where的区别:\nhaving是在分组后对数据进行过滤\nwhere是在分组前对数据进行过滤\nhaving后面可以使用分组函数(统计函数)\nwhere后面不可以使用分组函数\n*&#x2F;\n\n分页查询\n在工作中不是把所有满足条件的数据全部查询出来,效率低下,对数据进行分页查询,\n&#x2F;*\n分页查询语句 关键字 limit\n格式: \n只要n条数据 select *|字段 from 表名 limit n;\nselect *|字段 from 表名 limit m n; m表示每页开始的行的索引(变化的) n表示每页的数量(不变的)\n注意:数据库行的索引从0开始,列的索引从1开始\n*&#x2F;\n\n多表操作一对多关系建表原则:从表使用主表的主键作为外键\n&#x2F;*\n外键约束的作用:保证数据的准确和完整\n主表中有的数据,从表可以有也可以没有\n主表中没有的数据,从表也不能有\n删除主表的数据,必须保证从表没有使用\n*&#x2F;\n#声明外键约束\nalter table 从表 add [constraint][外键名称] foreign key (从表外键字段名) references 主表 (主表的主键);\n#删除外键约束\nalter table 从表 drop foreign key 外键名称\n\n多对多关系需要创建一张中间表(商品主键–订单主键),中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键\n一对多操作多对多操作多表关系实战#实战1：省和市 \n&#x2F;*\n省和市实例\n*&#x2F;\nCREATE DATABASE day03;\nUSE day03;\n-- 创建主表\nCREATE TABLE province(\n  pid INT PRIMARY KEY AUTO_INCREMENT,\n  pname VARCHAR(20),\n  description VARCHAR(50)\n);\nINSERT INTO province(pname,description) VALUES (&#39;河北&#39;,&#39;雾霾&#39;),(&#39;内蒙古&#39;,&#39;草原&#39;),(&#39;广东&#39;,&#39;经济特区&#39;);\n-- 创建从表\nCREATE TABLE city(\n  cid INT PRIMARY KEY AUTO_INCREMENT,\n  cname VARCHAR(20),\n  description VARCHAR(50),\n-- 所属省份 外键\n  province_pid INT\n);\nALTER TABLE city ADD FOREIGN KEY (province_pid) REFERENCES province(pid);\nSHOW TABLES;\nINSERT INTO city VALUES (NULL,&#39;石家庄&#39;,&#39;雾霾之最&#39;,1),(NULL,&#39;承德&#39;,&#39;避暑山庄&#39;,1);\nINSERT INTO city VALUES (NULL,&#39;包头&#39;,&#39;草原钢城&#39;,2),(NULL,&#39;赤峰&#39;,&#39;红山文化&#39;,2);\nINSERT INTO city VALUES (NULL,&#39;深圳&#39;,&#39;经济特区&#39;,3),(NULL,&#39;东莞&#39;,&#39;服务行业&#39;,3);\n-- 城市表添加主表省份不存在的数据\nINSERT INTO city VALUES (NULL,&#39;澳门&#39;,&#39;博彩娱乐&#39;,4);-- 报错\n\n自关联的一对多关系(了解)本表的外键使用本表的主键,工作中很少用\n\n\n\n地区主键\n地区名称\n地区描述\n所属省份\n\n\n\n1\n河北\n雾霾\nnull\n\n\n2\n内蒙古\n草原\nnull\n\n\n3\n石家庄\n雾霾之最\n1\n\n\n4\n承德\n避暑山庄\n1\n\n\n5\n包头\n草原钢城\n2\n\n\n6\n赤峰\n红山文化\n2\n\n\n#实战2\n&#x2F;*\n用户和角色\n*&#x2F;\n创建用户表\n创建角色表\n创建中间表 添加外键(直接在创建表时声明或者alter table 从表名 add foreign key (从表字段名) references 主表(主表字段名))\n\n多表查询#交叉连接查询(很少用,有错误数据,笛卡尔积)\nselect * from 表A,表B\n#内连接查询,在交叉连接查询的基础上,使用外键约束作为查询条件\n&#x2F;*隐式内连接 ,不使用关键字 [inner] join on*&#x2F;\nselect * from 表A,表B where 表A.主键&#x3D;表B.外键;\n&#x2F;*显式内连接 ,使用关键字 [inner] join on    on的后面可继续写where条件*&#x2F;\nselect * from 表A  [inner] join 表B on 表A.主键&#x3D;表B.外键;\n#外连接,在交叉查询的基础上,使用外键约束作为查询条件\n&#x2F;*左外连接 ,使用关键字 left [outer] join on*&#x2F;\nselect * from 表A  left [outer] join 表B on 表A.主键&#x3D;表B.外键;\n-- 左外连接查询以左边表为主,左边有的数据右边没有就使用null代替,左边没有的数据,右边也不能出现\n&#x2F;*右外连接 ,使用关键字 right [outer] join on*&#x2F;\nselect * from 表A  right [outer] join 表B on 表A.主键&#x3D;表B.外键;\n-- 右外连接和左外连接相反\n\n#子查询 sql语句的嵌套\n&#x2F;*一条sql语句的查询结果,作为另一条sql语句的查询条件*&#x2F;\nselect * from 表B where 字段&#x3D;(select 字段 from 表A [where条件])\n&#x2F;*一条sql语句的查询结果,作为另一条sql语句的另一张表(隐式内连接查询,先过滤数据)*&#x2F;\nselect * from (select * from 表A [where条件]),表B where 表A.主键&#x3D;表B.外键\n\n事务操作事务指的是逻辑上的一组操作,组成这组操作的各个单元要么全都成功,要么全都失败事务作用：保证在一个事务中多次SQL操作要么全都成功,要么全都失败\nmysql事务操作 start transaction开启事务 commit提交事务 rollback回滚事务\n事务总结事务特性ACID\n原子性(Atomicity)指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生\n一致性(Consistency)事务前后数据的完整性必须保持一致\n隔离性(Isolation)事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。\n持久性(Durability)持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。\n\n并发访问问题\n脏读：一个事务读到了另一个事务未提交的数据\n不可重复读：一个事务读到了另一个事务已经提交(update)的数据。引发另一个事务，在事务中的多次查询结果不一致\n虚读 &#x2F;幻读：一个事务读到了另一个事务已经提交(insert)的数据。导致另一个事务，在事务中多次查询的结果不一致\n\n隔离级别(解决问题)数据库规范规定了4种隔离级别，分别用于描述两个事务并发的所有情况\n1.read uncommitted 读未提交，一个事务读到另一个事务没有提交的数据,可能存在脏读、不可重复读、虚读\n2.read committed 读已提交，一个事务读到另一个事务已经提交的数据，可能存在不可重复读、虚读\n3.repeatable read 可重复读，在一个事务中读到的数据始终保持一致，无论另一个事务是否提交，可能存在虚读\nserializable 串行化，同时只能执行一个事务，相当于事务中的单线程，三个问题都没有了\n安全性： serializable[8]&gt;repeatable read[4]&gt;read committed[2 ]&gt;read uncommitted[1]\n性能对比刚好和安全性相反\n常见数据库的默认隔离级别：MySql: repeatable read   Oracle: read committed\nmysql统计技巧-- 统计前六个月的数据\nSELECT month_table.monthValue as month, temp.countValue as count FROM\n(SELECT\n\tdate_format( @lastDay :&#x3D; last_day( date_add( @lastDay, INTERVAL 1 MONTH ) ), &#39;%Y-%m&#39; ) monthValue \nFROM\n\t( SELECT @lastDay :&#x3D; date_add( curdate( ), INTERVAL - 6 MONTH ) FROM mysql.help_topic LIMIT 6 ) a) month_table\nLEFT JOIN\n(select DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;) as monthValue, count(*) as countValue from sys_user u GROUP BY DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;)) temp ON temp.monthValue &#x3D; month_table.monthValue\nORDER BY month_table.monthValue\n-- 原理 1 制作前六个月的月份表\nSELECT\n\tdate_format( @lastDay :&#x3D; last_day( date_add( @lastDay, INTERVAL 1 MONTH ) ), &#39;%Y-%m&#39; ) monthValue \nFROM\n\t( SELECT @lastDay :&#x3D; date_add( curdate( ), INTERVAL - 6 MONTH ) FROM mysql.help_topic LIMIT 6 ) a\n-- 原理 2 制作目标表的按月分组的统计数据\nselect DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;) as monthValue, count(*) as countValue from sys_user u GROUP BY DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;)\n-- 使用外链接合并两张临时表，并查询出需要的字段\n\n-- 统计近30天的数据\n-- 1 生成30天的表\nSELECT\n\t\t@s :&#x3D; @s + 1 AS indexs,\n\t\tDATE_FORMAT( DATE( DATE_SUB( CURRENT_DATE, INTERVAL @s DAY ) ), &#39;%Y-%m-%d&#39; ) AS dates \n\tFROM\n\t\tmysql.help_topic,\n\t\t( SELECT @s :&#x3D; -1 ) temp  #不想包含当天，@s:&#x3D;0\n\tWHERE\n\t\t@s &lt; 30 \n\tORDER BY\n\t\tdates\n-- 制作目标表按天的统计数据\n-- 使用外链接合并两张临时表，并查询出需要的字段\n\nMySQL日期格式化MySQL日期格式化DATE_FORMAT()取值范围。\n值     含义\n%S、%s 秒        两位数字形式的秒（ 00,01, ..., 59）\n%I、%i 分       两位数字形式的分（ 00,01, ..., 59）\n%H    小时     24小时制，两位数形式小时（00,01, ...,23）\n%h    12小时制，两位数形式小时（00,01, ...,12）\n%k    24小时制，数形式小时（0,1, ...,23）\n%l    12小时制，数形式小时（0,1, ...,12）\n%T    24小时制，时间形式（HH:mm:ss）\n%r    12小时制，时间形式（hh:mm:ss AM 或 PM）\n%p    AM上午或PM下午 \n%W    周      一周中每一天的名称（Sunday,Monday, ...,Saturday）\n%a    一周中每一天名称的缩写（Sun,Mon, ...,Sat） \n%w     以数字形式标识周（0&#x3D;Sunday,1&#x3D;Monday, ...,6&#x3D;Saturday） \n%U    数字表示周数，星期天为周中第一天\n%u    数字表示周数，星期一为周中第一天\n%d     天     两位数字表示月中天数（01,02, ...,31）\n%e      数字表示月中天数（1,2, ...,31）\n%D    英文后缀表示月中天数（1st,2nd,3rd ...） \n%j    以三位数字表示年中天数（001,002, ...,366） \n%M     月  英文月名（January,February, ...,December） \n%b     英文缩写月名（Jan,Feb, ...,Dec） \n%m     两位数字表示月份（01,02, ...,12）\n%c     数字表示月份（1,2, ...,12） \n%Y    年     四位数字表示的年份（2015,2016...）\n%y      两位数字表示的年份（15,16...）\n%文字   文字输出       直接输出文字内容\n\n","slug":"mysql/base/Mysql基础","date":"2022-10-01T04:55:09.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"ChrisWood"},{"id":"c5c39a45409b6c5284d037b63eb17322","title":"Node基础十二","content":"十二.数据库MySQL认识数据库1.1. 为什么要使用数据库任何的软件系统都需要存放大量的数据，这些数据通常是非常复杂和庞大的：\n\n比如用户信息包括姓名、年龄、性别、地址、身份证号、出生日期等等；\n比如商品信息包括商品的名称、描述、价格（原价）、分类标签、商品图片等等；\n比如歌曲信息包括歌曲的名称、歌手、专辑、歌曲时长、歌词信息、封面图片等等；\n\n那么这些信息不能直接存储到文件中吗？可以，但是文件系统有很多的缺点：\n\n很难以合适的方式组织数据（多张表之前的关系合理组织）；\n并且对数据进行增删改查中的复杂操作（虽然一些简单确实可以），并且保证单操作的原子性；\n很难进行数据共享，比如一个数据库需要为多个程序服务，如何进行很好的数据共享；\n需要考虑如何进行数据的高效备份、迁移、恢复；\n等等…\n\n数据库通俗来讲就是一个存储数据的仓库，数据库本质上就是一个软件、一个程序。\n1.2. 常见的数据库有哪些？通常我们将数据划分成两类：\n\n关系型数据库：MySQL、Oracle、DB2、SQL Server、Postgre SQL等；\n\n\n关系型数据库通常我们会创建很多个二维数据表；\n\n\n数据表之间相互关联起来，形成一对一、一对多、多对对等关系；\n\n之后可以利用SQL语句在多张表中查询我们所需的数据；\n\n支持事物，对数据的访问更加的安全；\n\n非关系型数据库：MongoDB、Redis、Memcached、HBse等；\n\n\n非关系型数据库的英文其实是Not only SQL，也简称为NoSQL；\n\n\n相当而已非关系型数据库比较简单一些，存储数据也会更加自由（甚至我们可以直接将一个复杂的json对象直接塞入到数据库中）；\n\nNoSQL是基于Key-Value的对应关系，并且查询的过程中不需要经过SQL解析，所以性能更高；\n\nNoSQL通常不支持事物，需要在自己的程序中来保证一些原子性的操作；\n\n\n如何在开发中选择他们呢？具体的选择会根据不同的项目进行综合的分析，我这里给一点点建议：\n\n目前在公司进行后端开发（Node、Java、Go等），还是以关系型数据库为主；\n比较常用的用到非关系型数据库的，在爬取大量的数据进行存储时，会比较常见；\n\n我们的课程是开发自己的后端项目，所以我们以关系型数据库MySQL作为主要内容。\nMySQL的介绍：\n\nMySQL原本是一个开源的数据库，原开发者为瑞典的MySQL AB公司；\n在2008年被Sun公司收购；在2009年，Sun被Oracle收购；\n所以目前MySQL归属于Oracle；\n\nMySQL是一个关系型数据库，其实本质上就是一款软件、一个程序：\n\n这个程序中管理着多个数据库；\n每个数据库中可以有多张表；\n每个表中可以有多条数据；\n\n关系型数据库\n1.3. MySQL的下载和安装第一步：下载MySQL软件\n下载地址：https://dev.mysql.com/downloads/mysql/\n\n根据自己的操作系统下载即可；\n\n推荐大家直接下载安装版本，在安装过程中会配置一些环境变量；\n\n\nWindows推荐下载MSI的版本；\n\n\nMac推荐下载DMG的版本；\n\n这里我安装的是MySQL最新的版本：8.0.22（不再使用旧的MySQL5.x的版本）\n\n\nWindows：\n\n下载下面的，不需要联网安装；\n\nWindows下载的版本\nMac：\nMac下载的版本\n第二步：安装的过程\n安装的过程，基本没有太复杂的操作。\n有一个需要着重说明的是MySQL8，可以采用一种更新的、安全性更高的密码和加密方式：\n\n最新的加密方式有可能会被一些比较老的软件驱动不支持；\n所以要根据情况来选择，但是我这里选择最新的加密方式了；\n\nWindows的安装过程：\nServer Only\n执行\n安装一个依赖\n下一步\n配置端口号\n选择密码加密方式\n填写一个复杂的密码\n配置服务的名称\n应用所有配置\n完成即可\n第三步：启动mysql\n在Windows启动MySQL：\nimage-20201109171443817\n在Mac中启动MySQL是在系统偏好设置中：\nMac启动MySQL\n1.4. mysql的连接和操作打开终端，查看MySQL的安装：\n\n这里会显示找不到命令；\n\nmysql --version\n\n在Windows上配置环境变量：\nWindows上配置环境变量\n在Mac上配置环境变量：\n手动执行下面的终端命令，将MySQL配置到环境变量中：\n# 添加环境变量\nexport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin\n# 再次执行mysql版本\nmysql --version\n\n1.4.1. 终端连接数据库我们如果想要操作数据，需要先和数据建立一个连接，最直接的方式就是通过终端来连接；\n有两种方式来连接：\n\n两种方式的区别在于输入密码是直接输入，还是另起一行以密文的形式输入；\n\n# 方式一：\nmysql -uroot -pCoderwhy888.\n# 方式二：\nmysql -uroot -p\nEnter password: your password\n\n输入成功后，会进入到mysql的REPL（交互式的编程环境）：\nMySQL的REPL\n我们可以直接在REPL中对数据库进行操作。\n1.4.2. 终端操作数据库我们说过，一个数据库软件中，可以包含很多个数据库：\n\ninfomation_schema：信息数据库，其中包括MySQL在维护的其他数据库、表、列、访问权限等信息；\nperformance_schema：性能数据库，记录着MySQL Server数据库引擎在运行过程中的一些资源消耗相关的信息；\nmysql：用于存储数据库管理者的用户信息、权限信息以及一些日志信息等；\nsys：相当于是一个简易版的performance_schema，将数据汇总成更容易理解的形式；\n\n注意：这里我只是在终端简单演练数据库，并没有详细讲解每一个命令，也没有完全按照SQL格式规范；\n\n这些在后面会详细讲解的；\n\n查看所有的数据库：\nshow databases;\n\nimage-20201108165132702\n在终端直接创建一个属于自己的新的数据库coderhub（一般情况下一个新的项目会对应一个新的数据库）。\ncreate database coderhub;\n\n创建一个数据库\n使用我们创建的数据库coderhub：\nuse coderhub;\n\n在数据库中创建自己的表：\ncreate table user(\n\tname varchar(20),\n\tage int,\n\theight double\n);\n\n创建用户表\n在user表中插入自己的数据：\ninsert into user (name, age, height) values (&#39;why&#39;, 18, 1.88);\ninsert into user (name, age, height) values (&#39;kobe&#39;, 40, 1.98);\n\n插入两条数据\n查看user表中所有的数据：\nselect * from user;\n\n查询表中的数据\n1.5. GUI工具操作数据库我们会发现在终端操作数据库有很多不方便的地方：\n\n语句写出来没有高亮，并且不会有任何的提示；\n复杂的语句分成多行，格式看起来并不美观，很冗余出现错误；\n终端中查看所有的数据库或者表非常的不直观和不方便；\n等等…\n\n所以在开发中，我们可以借助于一些GUI工具来帮助我们连接上数据库，之后直接在GUI工具中操作就会非常方便。\n常见的MySQL的GUI工具有很多，这里推荐几款：\n\nNavicat：个人最喜欢的一款工作，但是是收费的（有免费的试用时间，或者各显神通）；\nSQLYog：一款免费的SQL工具；\nTablePlus：常用功能都可以使用，但是会多一些限制（比如只能开两个标签页）；\n\n这里我选择使用Navicat。\n连接数据库\n查看所有的数据库、表、表中的数据：\nNavicat界面\n编写SQL语句，并且执行；\nNavicat编写SQL\nSQL语句2.1. 认识SQL语句我们希望操作数据库（特别是在程序中），就需要有和数据库沟通的语言，这个语言就是SQL：\n\nSQL是Structured Query Language，称之为结构化查询语言，简称SQL；\n使用SQL编写出来的语句，就称之为SQL语句；\nSQL语句可以用于对数据库进行操作；\n\n事实上，常见的关系型数据库SQL语句都是比较相似的，所以你学会了MySQL中的SQL语句，之后去操作比如Oracle或者其他关系型数据库，也是非常方便的。\nSQL语句的常用规范：\n\n通常关键字是大写的，比如CREATE、TABLE、SHOW等等；\n一条语句结束后，需要以 ; 结尾；\n如果遇到关键字作为表明或者字段名称，可以使用&#96;&#96;包裹;\n\n常见的SQL语句我们可以分成四类：\n\nDDL（Data Definition Language）：数据定义语言；\n\n\n可以通过DDL语句对数据库或者表进行：创建、删除、修改等操作；\n\n\nDML（Data Manipulation Language）：数据操作语言；\n\n\n可以通过DML语句对表进行：添加、删除、修改等操作；\n\n\nDQL（Data Query Language）：数据查询语言；\n\n\n可以通过DQL从数据库中查询记录；（重点）\n\n\nDCL（Data Control Language）：数据控制语言；\n\n\n对数据库、表格的权限进行相关访问控制操作；\n\n\n\n接下来我们对他们进行一个个的学习和掌握。\n2.2. DDL语句2.2.1. 数据库的操作查看当前的数据库：\n# 查看所有的数据SHOW DATABASES;# 使用某一个数据USE coderhub;# 查看当前正在使用的数据库SELECT DATABASE();\n\n创建新的数据：\n# 创建数据库语句CREATE DATABASE bilibili;CREATE DATABASE IF NOT EXISTS bilibili;CREATE DATABASE IF NOT EXISTS bilibili DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci;\n\n创建数据库时，可以设置字符串和字符排序（我们可以直接使用默认的）：\n\n字符集：utf8mb4在我们需要插入emoji表情时要用到；\n排序规则：ai表示不区分重音；ci表示不区分大小写；\n\nimage-20201108210407214\n删除数据库：\n# 删除数据库DROP DATABASE bilibili;DROP DATABASE IF EXIT bilibili;\n\n修改数据库：\n# 修改数据库的字符集和排序规则ALTER DATABASE bilibili CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_unicode_ci;\n\n2.2.2. 数据表的操作查看数据表\n# 查看所有的数据表SHOW TABLES;# 查看某一个表结构DESC user;\n\n创建数据表\nCREATE TABLE IF NOT EXISTS &#96;users&#96;(\tname VARCHAR(20),\tage INT,\theight DOUBLE);\n\n2.3. 创建表细节2.3.1. SQL数据类型我们知道不同的数据会划分为不同的数据类型，在数据库中也是一样：\n\nMySQL支持的数据类型有：数字类型，日期和时间类型，字符串（字符和字节）类型，空间类型和 JSON数据类型。\n\n数字类型\nMySQL的数字类型有很多：\n\n整数数字类型：INTEGER，INT，SMALLINT，TINYINT，MEDIUMINT，BIGINT；\n\n整数类型\n\n精确数字类型：DECIMAL，NUMERIC（DECIMAL是NUMERIC的实现形式）；\n\nsalary DECIMAL(5,2)\n\n\n浮点数字类型：FLOAT，DOUBLE\n\n\nFLOAT是4个字节，DOUBLE是8个字节；\n\n\n\n日期类型\nMySQL的日期类型也很多：\n\nYEAR以*YYYY*格式显示值\n\n\n范围 1901到2155，和 0000。\n\n\nDATE类型用于具有日期部分但没有时间部分的值：\n\n\nDATE以格式*YYYY-MM-DD*显示值 ；\n\n\n支持的范围是 &#39;1000-01-01&#39; 到 &#39;9999-12-31&#39;；\n\nDATETIME类型用于包含日期和时间部分的值：\n\n\nDATETIME以格式’YYYY-MM-DD hh:mm:ss‘显示值；\n\n\n支持的范围是1000-01-01 00:00:00到9999-12-31 23:59:59;\n\nTIMESTAMP数据类型被用于同时包含日期和时间部分的值：\n\n\nTIMESTAMP以格式’YYYY-MM-DD hh:mm:ss‘显示值；\n\n\n但是它的范围是UTC的时间范围：&#39;1970-01-01 00:00:01&#39;到&#39;2038-01-19 03:14:07&#39;;\n\n另外：DATETIME或TIMESTAMP 值可以包括在高达微秒（6位）精度的后小数秒一部分\n\n\n比如DATETIME表示的范围可以是&#39;1000-01-01 00:00:00.000000&#39;到&#39;9999-12-31 23:59:59.999999&#39;;\n\n\n\n字符串类型\nMySQL的字符串类型表示方式如下：\n\nCHAR类型在创建表时为固定长度，长度可以是0到255之间的任何值；\n\n\n在被查询时，会删除后面的空格；\n\n\nVARCHAR类型的值是可变长度的字符串，长度可以指定为0到65535之间的值；\n\n\n在被查询时，不会删除后面的空格；\n\n\nBINARY和VARBINARY 类型用于存储二进制字符串，存储的是字节字符串；\n\n\nhttps://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html\n\n\nBLOB用于存储大的二进制类型；\n\nTEXT用于存储大的字符串类型；\n\n\n2.3.2. 表的约束主键：PRIMARY KEY\n一张表中，我们为了区分每一条记录的唯一性，必须有一个字段是永远不会重复，并且不会为空的，这个字段我们通常会将它设置为主键：\n\n主键是表中唯一的索引；\n并且必须是NOT NULL的，如果没有设置 NOT NULL，那么MySQL也会隐式的设置为NOT NULL；\n主键也可以是多列索引，PRIMARY KEY(key_part, …)，我们一般称之为联合主键；\n建议：开发中主键字段应该是和业务无关的，尽量不要使用业务字段来作为主键；\n\n唯一：UNIQUE\n某些字段在开发中我们希望是唯一的，不会重复的，比如手机号码、身份证号码等，这个字段我们可以使用UNIQUE来约束：\n\n使用UNIQUE约束的字段在表中必须是不同的；\n对于所有引擎，UNIQUE 索引允许NULL包含的列具有多个值NULL。\n\n不能为空：NOT NULL\n某些字段我们要求用户必须插入值，不可以为空，这个时候我们可以使用 NOT NULL 来约束；\n默认值：DEFAULT\n某些字段我们希望在没有设置值时给予一个默认值，这个时候我们可以使用 DEFAULT来完成；\n自动递增：AUTO_INCREMENT\n某些字段我们希望不设置值时可以进行递增，比如用户的id，这个时候可以使用AUTO_INCREMENT来完成；\n外键约束也是最常用的一种约束手段，我们再讲到多表关系时，再进行讲解；\n# 创建表CREATE TABLE IF NOT EXISTS &#96;users&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\tage INT DEFAULT 0,\ttelPhone VARCHAR(20) DEFAULT &#39;&#39; UNIQUE NOT NULL,\tcreateTime TIMESTAMP DEFAULT CURRENT_TIMESTAMP);\n\n删除数据表\n# 删除表DROP TABLE &#96;moment&#96;;DROP TABLE IF EXISTS &#96;moment&#96;;\n\n修改数据表\n# 1.修改表名ALTER TABLE &#96;moments&#96; RENAME TO &#96;moment&#96;;# 2.添加一个新的列ALTER TABLE &#96;moment&#96; ADD &#96;publishTime&#96; DATETIME;ALTER TABLE &#96;moment&#96; ADD &#96;updateTime&#96; DATETIME;# 3.删除一列数据ALTER TABLE &#96;moment&#96; DROP &#96;updateTime&#96;;# 4.修改列的名称ALTER TABLE &#96;moment&#96; CHANGE &#96;publishTime&#96; &#96;publishDate&#96; DATE;# 5.修改列的数据类型ALTER TABLE &#96;moment&#96; MODIFY &#96;id&#96; INT;\n\n2.3. DML语句新建一张商品表：\nCREATE TABLE IF NOT EXISTS &#96;products&#96;(\t&#96;id&#96; INT PRIMARY KEY AUTO_INCREMENT,\t&#96;title&#96; VARCHAR(20),\t&#96;description&#96; VARCHAR(200),\t&#96;price&#96; DOUBLE,\t&#96;publishTime&#96; DATETIME);\n\n2.3.1. 插入数据INSERT INTO &#96;products&#96; (&#96;title&#96;, &#96;description&#96;, &#96;price&#96;, &#96;publishTime&#96;) \t\t\t\t\t\t\t\tVALUES (&#39;iPhone&#39;, &#39;iPhone12只要998&#39;, 998.88, &#39;2020-10-10&#39;); INSERT INTO &#96;products&#96; (&#96;title&#96;, &#96;description&#96;, &#96;price&#96;, &#96;publishTime&#96;) \t\t\t\t\t\t\t\tVALUES (&#39;huawei&#39;, &#39;iPhoneP40只要888&#39;, 888.88, &#39;2020-11-11&#39;);\n\n2.3.2. 删除数据# 删除数据# 会删除表中所有的数据DELETE FROM &#96;products&#96;;# 会删除符合条件的数据DELETE FROM &#96;products&#96; WHERE &#96;title&#96; &#x3D; &#39;iPhone&#39;;\n\n2.3.3. 修改数据# 修改数据# 会修改表中所有的数据UPDATE &#96;products&#96;  SET &#96;title&#96; &#x3D; &#39;iPhone12&#39;, &#96;price&#96; &#x3D; 1299.88;# 会修改符合条件的数据UPDATE &#96;products&#96;  SET &#96;title&#96; &#x3D; &#39;iPhone12&#39;, &#96;price&#96; &#x3D; 1299.88 WHERE &#96;title&#96; &#x3D; &#39;iPhone&#39;;\n\n如果我们希望修改完数据后，直接可以显示最新的更新时间：\nALTER TABLE &#96;products&#96; ADD &#96;updateTime&#96; TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;\n\n2.4. DQL语句SELECT用于从一个或者多个表中检索选中的行（Record）。\nSELECT select_expr [, select_expr]...\t[FROM table_references]\t[WHERE where_condition]\t[ORDER expr [ASC | DESC]]\t[LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]\t[GROUP BY expr]\t[HAVING where_condition]\n\n我们先准备一张表：\nCREATE TABLE IF NOT EXISTS &#96;products&#96; (\tid INT PRIMARY KEY AUTO_INCREMENT,\tbrand VARCHAR(20),\ttitle VARCHAR(100) NOT NULL,\tprice DOUBLE NOT NULL,\tscore DECIMAL(2,1),\tvoteCnt INT,\turl VARCHAR(100),\tpid INT);\n\n我们在其中插入一些数据：\nconst mysql &#x3D; require(&#39;mysql2&#39;); const connection &#x3D; mysql.createConnection(&#123;  host: &#39;localhost&#39;,  port: 3306,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;,  database: &#39;coderhub&#39;&#125;);const statement &#x3D; &#96;INSERT INTO products SET ?;&#96;const phoneJson &#x3D; require(&#39;.&#x2F;phone.json&#39;);for (let phone of phoneJson) &#123;  connection.query(statement, phone);&#125;\n\nimage-20201111103013994\n2.4.1. 基本查询查询所有的数据并且显示所有的字段：\nSELECT * FROM &#96;products&#96;;\n\n查询title、brand、price：\nSELECT title, brand, price FROM &#96;products&#96;;\n\n我们也可以给字段起别名：\n\n别名一般在多张表或者给客户端返回对应的key时会使用到；\n\nSELECT title as t, brand as b, price as p FROM &#96;products&#96;;\n\n2.4.2. 条件查询在开发中，我们希望根据条件来筛选我们的数据，这个时候我们要使用条件查询：\n\n条件查询会使用 WEHRE查询子句；\n\nWHERE的比较运算符\n# 查询价格小于1000的手机SELECT * FROM &#96;products&#96; WHERE price &lt; 1000;# 查询价格大于等于2000的手机SELECT * FROM &#96;products&#96; WHERE price &gt;&#x3D; 2000;# 价格等于3399的手机SELECT * FROM &#96;products&#96; WHERE price &#x3D; 3399;# 价格不等于3399的手机SELECT * FROM &#96;products&#96; WHERE price &#x3D; 3399;# 查询华为品牌的手机SELECT * FROM &#96;products&#96; WHERE &#96;brand&#96; &#x3D; &#39;华为&#39;;\n\nWHERE的逻辑运算符\n# 查询品牌是华为，并且小于2000元的手机SELECT * FROM &#96;products&#96; WHERE &#96;brand&#96; &#x3D; &#39;华为&#39; and &#96;price&#96; &lt; 2000;SELECT * FROM &#96;products&#96; WHERE &#96;brand&#96; &#x3D; &#39;华为&#39; &amp;&amp; &#96;price&#96; &lt; 2000;# 查询1000到2000的手机（不包含1000和2000）SELECT * FROM &#96;products&#96; WHERE price &gt; 1000 and price &lt; 2000;# OR: 符合一个条件即可# 查询所有的华为手机或者价格小于1000的手机SELECT * FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39; or price &lt; 1000;# 查询1000到2000的手机（包含1000和2000）SELECT * FROM &#96;products&#96; WHERE price BETWEEN 1000 and 2000;# 查看多个结果中的一个SELECT * FROM &#96;products&#96; WHERE brand in (&#39;华为&#39;, &#39;小米&#39;);\n\nWHERE的模糊查询\n模糊查询使用LIKE关键字，结合两个特殊的符号：\n\n%表示匹配任意个的任意字符；\n_表示匹配一个的任意字符；\n\n# 查询所有以v开头的titleSELECT * FROM &#96;products&#96; WHERE title LIKE &#39;v%&#39;;# 查询带M的titleSELECT * FROM &#96;products&#96; WHERE title LIKE &#39;%M%&#39;;# 查询带M的title必须是第三个字符SELECT * FROM &#96;products&#96; WHERE title LIKE &#39;__M%&#39;;\n\n2.4.3. 查询排序当我们查询到结果的时候，我们希望讲结果按照某种方式进行排序，这个时候使用的是ORDER BY；\nORDER BY有两个常用的值：\n\nASC：升序排列；\nDESC：降序排列；\n\nSELECT * FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39; or price &lt; 1000 ORDER BY price ASC;\n\n2.4.4. 分页偏移当数据库中的数据非常多时，一次性查询到所有的结果进行显示是不太现实的：\n\n在真实开发中，我们都会要求用户传入offset、limit或者page等字段；\n它们的目的是让我们可以在数据库中进行分页查询；\n它的用法有[LIMIT[offset,] row_countrow_count OFFSET offset]\n\nSELECT * FROM &#96;products&#96; LIMIT 30 OFFSET 0;SELECT * FROM &#96;products&#96; LIMIT 30 OFFSET 30;SELECT * FROM &#96;products&#96; LIMIT 30 OFFSET 60;# 另外一种写法：offset, row_countSELECT * FROM &#96;products&#96; LIMIT 90, 30;\n\n2.4.5. 聚合函数聚合函数表示对值集合进行操作的组（集合）函数。\n聚合查询\n我们这里学习最常用的一些聚合函数：\n# 华为手机价格的平均值SELECT AVG(price) FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39;;# 计算所有手机的平均分SELECT AVG(score) FROM &#96;products&#96;;# 手机中最低和最高分数SELECT MAX(score) FROM &#96;products&#96;;SELECT MIN(score) FROM &#96;products&#96;;# 计算总投票人数SELECT SUM(voteCnt) FROM &#96;products&#96;;# 计算所有条目的数量SELECT COUNT(*) FROM &#96;products&#96;;# 华为手机的个数SELECT COUNT(*) FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39;;\n\n事实上聚合函数相当于默认将所有的数据分成了一组：\n\n我们前面使用avg还是max等，都是将所有的结果看成一组来计算的；\n那么如果我们希望划分多个组：比如华为、苹果、小米等手机分别的平均价格，应该怎么来做呢？\n这个时候我们可以使用 GROUP BY；\n\nGROUP BY通常和聚合函数一起使用：\n\n表示我们先对数据进行分组，再对每一组数据，进行聚合函数的计算；\n\n我们现在来提一个需求：\n\n根据品牌进行分组；\n计算各个品牌中商品的个数、平均价格、最高价格、最低价格、平均评分；\n\nSELECT brand, \t\t\tCOUNT(*) as count, \t\t\tROUND(AVG(price),2) as avgPrice,\t\t\tMAX(price) as maxPrice,\t\t\tMIN(price) as minPrice,\t\t\tAVG(score) as avgScoreFROM &#96;products&#96; GROUP BY brand;\n\n如果我们还希望筛选出平均价格在4000以下，并且平均分在7以上的品牌：\nSELECT brand, \t\t\tCOUNT(*) as count, \t\t\tROUND(AVG(price),2) as avgPrice,\t\t\tMAX(price) as maxPrice,\t\t\tMIN(price) as minPrice,\t\t\tAVG(score) as avgScoreFROM &#96;products&#96; GROUP BY brand HAVING avgPrice &lt; 4000 and avgScore &gt; 7;\n\n2.5. 外键约束2.5.1. 创建多张表假如我们的上面的商品表中，对应的品牌还需要包含其他的信息：\n\n比如品牌的官网，品牌的世界排名，品牌的市值等等；\n\n如果我们直接在商品中去体现品牌相关的信息，会存在一些问题：\n\n一方面，products表中应该表示的都是商品相关的数据，应该有另外一张表来表示brand的数据；\n另一方面，多个商品使用的品牌是一致时，会存在大量的冗余数据；\n\n所以，我们可以将所有的批评数据，单独放到一张表中，创建一张品牌的表：\nCREATE TABLE IF NOT EXISTS &#96;brand&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\twebsite VARCHAR(100),\tworldRank INT);\n\n插入模拟的数据：\n\n这里我是刻意有一些商品数据的品牌是没有添加的；\n并且也可以添加了一些不存在的手机品牌；\n\nINSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;华为&#39;, &#39;www.huawei.com&#39;, 1);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;小米&#39;, &#39;www.mi.com&#39;, 10);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;苹果&#39;, &#39;www.apple.com&#39;, 5);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;oppo&#39;, &#39;www.oppo.com&#39;, 15);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;京东&#39;, &#39;www.jd.com&#39;, 3);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;Google&#39;, &#39;www.google.com&#39;, 8);\n\n2.5.2. 创建外键我们先给products添加一个brand_id字段：\n将两张表联系起来，我们可以将products中的brand_id关联到brand中的id：\n\n如果是创建表添加外键约束：\nFOREIGN KEY (brand_id) REFERENCES brand(id)\n\n如果是表已经创建好，额外添加外键：\nALTER TABLE &#96;products&#96; ADD FOREIGN KEY (brand_id) REFERENCES brand(id);\n\n现在我们可以将products中的brand_id关联到brand中的id的值：\nUPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 1 WHERE &#96;brand&#96; &#x3D; &#39;华为&#39;;UPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 4 WHERE &#96;brand&#96; &#x3D; &#39;OPPO&#39;;UPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 3 WHERE &#96;brand&#96; &#x3D; &#39;苹果&#39;;UPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 2 WHERE &#96;brand&#96; &#x3D; &#39;小米&#39;;\n\n2.5.3. 删除和更新我们来思考一个问题：\n\n如果products中引用的外键被更新了或者删除了，这个时候会出现什么情况呢？\n\n我们来进行一个更新操作：比如将华为的id更新为100\nUPDATE &#96;brand&#96; SET id &#x3D; 100 WHERE id &#x3D; 1;\n\n这个时候执行代码是报错的：\n不可以更新和删除，因为有一个外键引用\n如果我希望可以更新呢？我们可以给更新时设置几个值：\n\nRESTRICT（默认属性）：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话会报错的，不允许更新或删除；\n\nNO ACTION：和RESTRICT是一致的，是在SQL标准中定义的；\n\nCASCADE：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话：\n\n\n更新：那么会更新对应的记录；\n\n\n删除：那么关联的记录会被一起删除掉；\n\nSET NULL：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话，将对应的值设置为NULL；\n\n\n如果修改外键的更新时的动作呢？\n第一步：查看表结构：\n# 执行命令SHOW CREATE TABLE &#96;products&#96;;# 结果如下：CREATE TABLE &#96;products&#96; (  &#96;id&#96; int NOT NULL AUTO_INCREMENT,  &#96;brand&#96; varchar(20) DEFAULT NULL,  &#96;title&#96; varchar(100) NOT NULL,  &#96;price&#96; double NOT NULL,  &#96;score&#96; decimal(2,1) DEFAULT NULL,  &#96;voteCnt&#96; int DEFAULT NULL,  &#96;url&#96; varchar(100) DEFAULT NULL,  &#96;pid&#96; int DEFAULT NULL,  &#96;brand_id&#96; int DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;),  KEY &#96;brand_id&#96; (&#96;brand_id&#96;),  CONSTRAINT &#96;products_ibfk_1&#96; FOREIGN KEY (&#96;brand_id&#96;) REFERENCES &#96;brand&#96; (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;109 DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci\n\n这个时候，我们可以知道外键的名称是products_ibfk_1。\n第二步：删除之前的外键\nALTER TABLE &#96;products&#96; DROP FOREIGN KEY products_ibfk_1;\n\n第三步：添加新的外键，并且设置新的action\nALTER TABLE &#96;products&#96; ADD FOREIGN KEY (brand_id) REFERENCES brand(id) ON UPDATE CASCADE ON DELETE CASCADE;\n\n2.6. 多表查询2.6.1. 多表查询如果我们希望查询到产品的同时，显示对应的品牌相关的信息，因为数据是存放在两张表中，所以这个时候就需要进行多表查询。\n如果我们直接通过查询语句希望在多张表中查询到数据，这个时候是什么效果呢？\nSELECT * FROM &#96;products&#96;, &#96;brand&#96;;\n\n查询结果\n我们会发现一共有648条数据，这个数据量是如何得到的呢？\n\n第一张表的108条 * 第二张表的6条数据；\n也就是说第一张表中每一个条数据，都会和第二张表中的每一条数据结合一次；\n这个结果我们称之为 笛卡尔乘积，也称之为直积，表示为 X*Y；\n\n但是事实上很多的数据是没有意义的，比如华为和苹果、小米的品牌结合起来的数据就是没有意义的，我们可不可以进行筛选呢？\n\n使用where来进行筛选；\n这个表示查询到笛卡尔乘积后的结果中，符合products.brand_id = brand.id条件的数据过滤出来；\n\nSELECT * FROM &#96;products&#96;, &#96;brand&#96; WHERE &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n事实上我们想要的效果并不是这样的，而且表中的某些特定的数据，这个时候我们可以使用 SQL JOIN 操作：\n\n左连接\n右连接\n内连接\n全连接\n\nSQL JOIN\n2.6.2. 左连接如果我们希望获取到的是左边所有的数据（以左表为主）：\n\n这个时候就表示无论左边的表是否有对应的brand_id的值对应右边表的id，左边的数据都会被查询出来；\n这个也是开发中使用最多的情况，它的完整写法是LEFT [OUTER] JOIN，但是OUTER可以省略的；\n\n\nSELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n如果我们查询的是左连接部分中，和右表无关的数据：\n\n也非常简单，只需要加上一个条件即可：B表中的数据为空\n\n\nSELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE brand.id IS NULL;\n\n2.6.3. 右连接如果我们希望获取到的是右边所有的数据（以由表为主）：\n\n\n这个时候就表示无论左边的表中的brand_id是否有和右边表中的id对应，右边的数据都会被查询出来；\n右连接在开发中没有左连接常用，它的完整写法是RIGHT [OUTER] JOIN，但是OUTER可以省略的；\n\nSELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n如果我们查询的是右连接部分中，和左表无关的数据：\n\n也非常简单，只需要加上一个条件即可：A表中的数据为空；\n\n\nSELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE products.id IS NULL;\n\n2.6.4. 内连接事实上内连接是表示左边的表和右边的表都有对应的数据关联：\nSELECT * FROM &#96;products&#96; INNER JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n我们会发现它和之前的下面写法是一样的效果：\nSELECT * FROM &#96;products&#96;, &#96;brand&#96; WHERE &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n但是他们代表的含义并不相同：\n\nSQL语句一：内连接，代表的是在两张表连接时就会约束数据之间的关系，来决定之后查询的结果；\nSQL语句二：where条件，代表的是先计算出笛卡尔乘积，在笛卡尔乘积的数据基础之上进行where条件的筛选；\n\n内连接在开发中偶尔也会常见使用，看自己的场景。\n内连接有其他的写法：CROSS JOIN或者 JOIN都可以；\n2.6.5. 全连接SQL规范中全连接是使用FULL JOIN，但是MySQL中并没有对它的支持，我们需要使用 UNION 来实现：\n\n(SELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id)UNION(SELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id);\n\n如果我们希望查询的是下面的结果：\n\n(SELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE &#96;brand&#96;.id IS NULL)UNION(SELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE &#96;products&#96;.id IS NULL);\n\n2.7. 多对多关系2.7.1. 准备多张表在开发中我们还会遇到多对多的关系：\n\n比如学生可以选择多门课程，一个课程可以被多个学生选择；\n这种情况我们应该在开发中如何处理呢？\n\n这个时候我们通常是会建三张表来建立它们之间的关系的：\n# 创建学生表CREATE TABLE IF NOT EXISTS &#96;students&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\tage INT);# 创建课程表CREATE TABLE IF NOT EXISTS &#96;courses&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\tprice DOUBLE NOT NULL);\n\n我们在两张表中插入一些数据：\nINSERT INTO &#96;students&#96; (name, age) VALUES(&#39;why&#39;, 18);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;tom&#39;, 22);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;lilei&#39;, 25);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;lucy&#39;, 16);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;lily&#39;, 20);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;英语&#39;, 100);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;语文&#39;, 666);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;数学&#39;, 888);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;历史&#39;, 80);\n\n2.7.2. 创建关系表我们需要一个关系表来记录两张表中的数据关系：\n# 创建关系表CREATE TABLE IF NOT EXISTS &#96;students_select_courses&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tstudent_id INT NOT NULL,\tcourse_id INT NOT NULL,\tFOREIGN KEY (student_id) REFERENCES students(id) ON UPDATE CASCADE,\tFOREIGN KEY (course_id) REFERENCES courses(id) ON UPDATE CASCADE);\n\n我们插入一些数据：\n# why 选修了 英文和数学INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (1, 1);INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (1, 3);# lilei选修了 语文和数学和历史INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (3, 2);INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (3, 3);INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (3, 4);\n\n2.7.3. 多表数据查询查询多条数据：\n# 查询所有的学生选择的所有课程SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id; # 查询所有的选手选课情况SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu LEFT JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id LEFT JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id;\n\n查询单个学生的课程：\n# why同学选择了哪些课程SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id \tWHERE stu.id &#x3D; 1; # lily同学选择了哪些课程SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu LEFT JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id LEFT JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id \tWHERE stu.id &#x3D; 5;\n\n查询哪些学生没有选择和哪些课程没有被选择：\n# 哪些学生是没有选课的SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stuLEFT JOIN &#96;students_select_courses&#96; ssc\tON stu.id &#x3D; ssc.student_idLEFT JOIN &#96;courses&#96; cs\tON ssc.course_id &#x3D; cs.id\tWHERE cs.id IS NULL;# 查询哪些课程没有被学生选择SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stuRIGHT JOIN &#96;students_select_courses&#96; ssc\tON stu.id &#x3D; ssc.student_idRIGHT JOIN &#96;courses&#96; cs\tON ssc.course_id &#x3D; cs.id\tWHERE stu.id IS NULL;\n\nNode操作MySQL3.1.对象和数组3.1.1. 一对多 - 对象前面我们学习的查询语句，查询到的结果通常是一张表，比如查询手机+品牌信息：\nSELECT * FROM products LEFT JOIN brand ON products.brand_id &#x3D; brand.id;\n\n查询结果\n但是在真实开发中，实际上红色圈起来的部分应该放入到一个对象中，那么我们可以使用下面的查询方式：\n\n这个时候我们要用 JSON_OBJECT;\n\nSELECT products.id as id, products.title as title, products.price as price, products.score as score, \t\t\t\tJSON_OBJECT(&#39;id&#39;, brand.id, &#39;name&#39;, brand.name, &#39;rank&#39;, brand.phoneRank, &#39;website&#39;, brand.website) as brandFROM products LEFT JOIN brand ON products.brand_id &#x3D; brand.id;\n\n查询结果\n3.1.2. 多对多 - 数组在多对多关系中，我们希望查询到的是一个数组：\n\n比如一个学生的多门课程信息，应该是放到一个数组中的；\n数组中存放的是课程信息的一个个对象；\n这个时候我们要 JSON_ARRAYAGG和JSON_OBJECT结合来使用；\n\nSELECT stu.id, stu.name, stu.age, \t\t   JSON_ARRAYAGG(JSON_OBJECT(&#39;id&#39;, cs.id, &#39;name&#39;, cs.name)) as courses FROM students stuLEFT JOIN students_select_courses ssc ON stu.id &#x3D; ssc.student_idLEFT JOIN courses cs ON ssc.course_id &#x3D; cs.idGROUP BY stu.id;\n\n查询结果\n3.2. mysql2的使用3.2.1. 认识mysql2前面我们所有的操作都是在GUI工具中，通过执行SQL语句来获取结果的，那真实开发中肯定是通过代码来完成所有的操作的。\n那么如何可以在Node的代码中执行SQL语句来，这里我们可以借助于两个库：\n\nmysql：最早的Node连接MySQL的数据库驱动；\nmysql2：在mysql的基础之上，进行了很多的优化、改进；\n\n目前相对来说，我更偏向于使用mysql2，mysql2兼容mysql的API，并且提供了一些附加功能\n\n更快&#x2F;更好的性能；\n\nPrepared Statement（预编译语句）：\n\n\n提高性能：将创建的语句模块发送给MySQL，然后MySQL编译（解析、优化、转换）语句模块，并且存储它但是不执行，之后我们在真正执行时会给?提供实际的参数才会执行；就算多次执行，也只会编译一次，所以性能是更高的；\n\n\n防止SQL注入：之后传入的值不会像模块引擎那样就编译，那么一些SQL注入的内容不会被执行；or 1 = 1不会被执行；\n\n支持Promise，所以我们可以使用async和await语法\n\n等等….\n\n\n所以后续的学习中我会选择mysql2在node中操作数据。\n安装\nnpm install mysql2\n\n3.2.2. mysql2基本使用mysql2的使用过程如下：\n\n第一步：创建连接（通过createConnection），并且获取连接对象；\n第二步：执行SQL语句即可（通过query）；\n\nconst mysql &#x3D; require(&#39;mysql2&#39;);&#x2F;&#x2F; 创建连接const connection &#x3D; mysql.createConnection(&#123;  host: &#39;localhost&#39;,  database: &#39;coderhub&#39;,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;&#125;);&#x2F;&#x2F; 执行SQL语句connection.query(&#39;SELECT title, price FROM products WHERE price &gt; 9000;&#39;, (err, results, fields) &#x3D;&gt; &#123;  console.log(err);  console.log(&#39;----------&#39;);  console.log(results);  console.log(&#39;----------&#39;);  console.log(fields);&#125;)\n\n通常我们的连接建立之后是不会轻易断开的，因为我们需要这个连接持续帮助我们查询客户端过来的请求。\n但是如果我们确实希望断开连接，可以使用 end 方法：\nconnection.end();\n\n3.2.3. 预编译语句Prepared Statement（预编译语句）：\n\n提高性能：将创建的语句模块发送给MySQL，然后MySQL编译（解析、优化、转换）语句模块，并且存储它但是不执行，之后我们在真正执行时会给?提供实际的参数才会执行；就算多次执行，也只会编译一次，所以性能是更高的；\n防止SQL注入：之后传入的值不会像模块引擎那样就编译，那么一些SQL注入的内容不会被执行；or 1 = 1不会被执行；\n\nconst statement &#x3D; &#39;SELECT * FROM products WHERE price &gt; ? and brand &#x3D; ?;&#39;;connection.execute(statement, [1000, &#39;华为&#39;], (err, results) &#x3D;&gt; &#123;  console.log(results);&#125;);\n\n强调：如果再次执行该语句，它将会从LRU（Least Recently Used） Cache中获取获取，省略了编译statement的时间来提高性能。\n3.2.4. 连接池前面我们是创建了一个连接（connection），但是如果我们有多个请求的话，该连接很有可能正在被占用，那么我们是否需要每次一个请求都去创建一个新的连接呢？\n\n事实上，mysql2给我们提供了连接池（connection pools）；\n连接池可以在需要的时候自动创建连接，并且创建的连接不会被销毁，会放到连接池中，后续可以继续使用；\n我们可以在创建连接池的时候设置LIMIT，也就是最大创建个数；\n\nconst mysql &#x3D; require(&#39;mysql2&#39;);const pool &#x3D; mysql.createPool(&#123;  host: &#39;localhost&#39;,  database: &#39;coderhub&#39;,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;,  connectionLimit: 10&#125;);const statement &#x3D; &#39;SELECT * FROM products WHERE price &gt; ? and brand &#x3D; ?;&#39;;pool.execute(statement, [1000, &#39;华为&#39;], (err, results) &#x3D;&gt; &#123;  console.log(results);&#125;);\n\n为什么Node执行JavaScript时单线程的，还需要连接池呢？\n\n这是因为Node中操作数据库，本质上是通过Libuv进行了的数据库操作；\n而在libuv中是可以有多个线程的，多个线程也是可以同时去建立连接来操作数据库的；\n\n3.2.5. promises目前在JavaScript开发中我们更习惯Promise和await、async的方式，mysql2同样是支持的：\nconst mysql &#x3D; require(&#39;mysql2&#39;);const pool &#x3D; mysql.createPool(&#123;  host: &#39;localhost&#39;,  database: &#39;coderhub&#39;,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;,  connectionLimit: 5&#125;);const statement &#x3D; &#39;SELECT * FROM products WHERE price &gt; ? and brand &#x3D; ?;&#39;;pool.promise().execute(statement, [1000, &#39;华为&#39;]).then(([results]) &#x3D;&gt; &#123;  console.log(results);&#125;);\n\n3.3. ORM的sequelize3.3.1. 认识ORM对象关系映射（英语：Object Relational Mapping，简称ORM，或O&#x2F;RM，或O&#x2F;R mapping），是一种程序设计的方案：\n\n从效果上来讲，它提供了一个可在编程语言中，使用 虚拟对象数据库 的效果；\n比如在Java开发中经常使用的ORM包括：Hibernate、MyBatis；\n\nNode当中的ORM我们通常使用的是 sequelize;\n\nSequelize是用于Postgres，MySQL，MariaDB，SQLite和Microsoft SQL Server的基于Node.js 的 ORM；\n它支持非常多的功能；\n\n如果我们希望将Sequelize和MySQL一起使用，那么我们需要先安装两个东西：\n\nmysql2：sequelize在操作mysql时使用的是mysql2；\nsequelize：使用它来让对象映射到表中；\n\nnpm install sequelize mysql2\n\n3.3.2. Sequelize的使用Sequelize的连接数据库：\n\n第一步：创建一个Sequelize的对象，并且制定数据库、用户名、密码、数据库类型、主机地址等；\n第二步：测试连接是否成功；\n\nconst &#123;Sequelize, DataTypes, Model, Op&#125; &#x3D; require(&#39;sequelize&#39;);const sequelize &#x3D; new Sequelize(&#39;coderhub&#39;, &#39;root&#39;, &#39;Coderwhy888.&#39;, &#123;  host: &#39;localhost&#39;,  dialect: &#39;mysql&#39;&#125;);sequelize.authenticate().then(() &#x3D;&gt; &#123;  console.log(&quot;sequelize连接成功~&quot;);&#125;).catch(err &#x3D;&gt; &#123;  console.log(&quot;sequlize连接失败~&quot;, err);&#125;);\n\nSequelize映射关系表：\nclass Student extends Model &#123;&#125;Student.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  name: &#123;    type: DataTypes.STRING,    allowNull: false  &#125;,  age: DataTypes.INTEGER&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false&#125;)\n\n测试增删改查的操作：\nasync function queryStudent() &#123;  &#x2F;&#x2F; 1.查询所有的学生  const result1 &#x3D; await Student.findAll(&#123;&#125;);  console.log(result1);  &#x2F;&#x2F; 2.查询年龄大于等于20岁的学生  const result2 &#x3D; await Student.findAll(&#123;    where: &#123;      age: &#123;        [Op.gte]: 20      &#125;    &#125;  &#125;);  console.log(result2);  &#x2F;&#x2F; 3.创建用户  const result3 &#x3D; await Student.create(&#123;    name: &#39;hmm&#39;,    age: 22  &#125;);  console.log(result3);  &#x2F;&#x2F; 4.更新用户  const result4 &#x3D; await Student.update(&#123;    age: 25  &#125;, &#123;    where: &#123;      id: 6    &#125;  &#125;);  console.log(result4);&#125;queryStudent();\n\n3.3.3. 多对多关系第一步：连接数据库\nconst &#123; Sequelize, DataTypes, Model, Op &#125; &#x3D; require(&#39;sequelize&#39;);const sequelize &#x3D; new Sequelize(&#39;coderhub&#39;, &#39;root&#39;, &#39;Coderwhy888.&#39;, &#123;  host: &#39;localhost&#39;,  dialect: &#39;mysql&#39;&#125;);\n\n第二步：创建映射关系\nclass Student extends Model &#123;&#125;Student.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  name: &#123;    type: DataTypes.STRING,    allowNull: false  &#125;,  age: DataTypes.INTEGER&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false&#125;)class Course extends Model &#123;&#125;Course.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  name: &#123;    type: DataTypes.STRING(20),    allowNull: false  &#125;,  price: &#123;    type: DataTypes.DOUBLE,    allowNull: false  &#125;&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false&#125;);class StudentCourse extends Model &#123;&#125;;StudentCourse.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  studentId: &#123;    type: DataTypes.INTEGER,    references: &#123;      model: Student,      key: &#39;id&#39;    &#125;,    field: &#39;student_id&#39;,  &#125;,  courseId: &#123;    type: DataTypes.INTEGER,    references: &#123;      model: Course,      key: &#39;id&#39;    &#125;,    field: &#39;course_id&#39;,  &#125;&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false,  tableName: &#39;students_select_courses&#39;&#125;);\n\n第三步：建立多对多的联系\nStudent.belongsToMany(Course, &#123;  through: StudentCourse,   foreignKey: &#39;student_id&#39;,   otherKey: &#39;course_id&#39;,&#125;);Course.belongsToMany(Student, &#123;  through: StudentCourse,   foreignKey: &#39;course_id&#39;,   otherKey: &#39;student_id&#39;&#125;);\n\n第四步：执行多对多查询操作：\nasync function queryStudent() &#123;  &#x2F;&#x2F; 查询结果  const result &#x3D; await Student.findAll(&#123;    include: &#123;      model: Course    &#125;\n\nhttp协议1.超文本传输协议\n规定了如何从网站服务器传输超文本到本地浏览器,基于客户端服务器架构工作,是客户端和服务器端请求和应答标准\n\n2.报文   过程中传递的数据块\n请求报文:1.请求方式 req.method获取请求方式   GET POST\n\t\t2.请求地址 req.url获取请求地址\n\t\t3.请求报文 req.headers[&#39;键名&#39;]获取请求报文\n\t\t\n请求组成:请求行 方式 资源 协议版本\n\t\t请求头 键值对\n\t\t请求体 post有请求参数 get请求参数不在请求体中,在url地址后面\n\t\t\n\n响应报文:1.http状态码   200成功 404没找到 500服务器端错误 400客户端请求语法错\n\t\t2.内容类型 text&#x2F;html text&#x2F;css application&#x2F;javascript image&#x2F;jpeg application&#x2F;json\n\t\t3. 内容长度 内容..\n\t\tres.writeHead(状态码,&#123;&#39;content-type&#39;:&#39;text&#x2F;plain&#39;&#125;) 内容类型默认纯文本\n\t\tres.end(&#39;...&#39;)响应内容\n\t\t\n响应组成:响应行 http协议 状态码 其他状态码(成功2xx 重定向 3xx 客户端4xx 服务器端错误5xx)\n\t\t响应头 键值对\n\t\t响应体 post有请求参数 get请求参数不在请求体中,在url地址后面\n\nhttp请求与响应处理8种请求方式 OPTIONS HEAD  GET POST PUT DELETE TRACE \n\n请求参数GET\n使用url模块,用于处理url地址   \nurl.parse(req.url) 返回一个对象\nurl.parse(req.url,true)把查询参数解析成对象\nurl.parse(req.url,true).query得到这个对象  通过这个对象.键名得到参数值\n\n解构赋值 &#123; query, pathname&#125; &#x3D; url.parse(req.url,true) 得到参数对象和请求地址\n\nwindow释放端口1.cmd\n2.netstat -ano | findstr 9090 查询端口9090使用情况\n3.tasklist | findstr +进程ID  查询端口被进程占用的程序\n4.taskkill &#x2F;f &#x2F;t &#x2F;im  +进程ID或程序  杀死进程\n\nNPMnpm常用命令# 临时\n$ npm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install 插件名\n# 配置\n$ npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org\n\n# 查看 npm 的版本 \n$ npm -v  \n# 查看各个命令的简单用法\n$ npm -l \n# 查看 npm 命令列表\n$ npm help\n# 查看 npm 的配置\n$ npm config list -l\n# 查看插件的版本\nnpm view 插件名 versions\n# 创建模块\nnpm init\n#当前项目安装的所有模块\n$npm list\n#列出全局安装的模块 带上[--depth 0] 不深入到包的支点 更简洁\n$ npm list -g --depth 0\n\n# 读取package.json里面的配置单安装  \n$ npm install \n&#x2F;&#x2F;可简写成 npm i\n\n# 默认安装指定模块的最新(@latest)版本\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt; \n&#x2F;&#x2F;eg:npm install gulp\n\n# 安装指定模块的指定版本\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt;@&lt;version&gt;\n&#x2F;&#x2F;eg: npm install gulp@3.9.1\n\n# 安装指定指定版本范围内的模块\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt;@&lt;version range&gt;\n&#x2F;&#x2F;eg: npm install vue@&quot;&gt;&#x3D;1.0.28 &lt; 2.0.0&quot;\n\n# 安装指定模块的指定标签 默认值为(@latest)\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt;@&lt;tag&gt;\n&#x2F;&#x2F;eg:npm install sax@0.1.1\n\n# 通过Github代码库地址安装\n$ npm install &lt;tarball url&gt;\n&#x2F;&#x2F;eg:npm install git:&#x2F;&#x2F;github.com&#x2F;package&#x2F;path.git\n\n#卸载当前项目或全局模块 \n$ npm uninstall &lt;name&gt; [-g] \n\n#升级当前项目或全局的指定模块\n$ npm update &lt;name&gt; [-g]\n\n# 引用依赖 有些包是全局安装了，在项目里面只需要引用即可。\n$ npm link [&lt;@scope&gt;&#x2F;]&lt;pkg&gt;[@&lt;version&gt;]\n&#x2F;&#x2F;eg: 引用   npm link gulp gulp-ssh gulp-ftp\n&#x2F;&#x2F;eg: 解除引用 npm unlink gulp\n\n# 未注册 申请注册一个用户 直接在https:&#x2F;&#x2F;www.npmjs.com&#x2F;注册一样\n$ npm adduser\n&#x2F;&#x2F;执行后 填写几个问题 Username、Password、Email\n\n#已注册\n$ npm login \n\n#发布\n$ npm publish\n\nNPM私库搭建npm+git1.新建私有git仓库\n2.clone仓库\n3.npm init\n4.按npm规范开发完。push到仓库即可\n\nverdaccio(https://www.jianshu.com/p/0c905e4a8b70)\n云服务器安装node环境,nginx\n\n\n\n\n\n\n\n\n1 云服务器安装verdaccio(轻量级开源私有npm代理注册表)npm i verdaccio -g\n\n\n\n\n\n\n\n\n\n2 启动服务：verdaccio\n\n\n\n\n\n\n\n\n\n3 配置config.yaml\n1、vim &#x2F;home&#x2F;yg&#x2F;.config&#x2F;verdaccio&#x2F;config.yaml 进入编辑配置文件\n\n# This is the default config file. It allows all users to do anything,\n# so don&#39;t use it on production systems.\n#\n# Look here for more config file examples:\n# https:&#x2F;&#x2F;github.com&#x2F;verdaccio&#x2F;verdaccio&#x2F;tree&#x2F;master&#x2F;conf\n#\n\n# path to a directory with all packages\n# 所有包缓存的目录\nstorage: .&#x2F;storage\n# path to a directory with plugins to include\n# 插件目录\nplugins: .&#x2F;plugins\n\n# 开启web服务，能够通过web访问\nweb:\n  # WebUI is enabled as default, if you want disable it, just uncomment this line\n  #enable: false\n  title: Verdaccio\n\n# 验证信息\nauth:\n  htpasswd:\n    # 用户信息存储目录\n    file: .&#x2F;htpasswd\n    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.\n    # You can set this to -1 to disable registration.\n    #max_users: 1000\n\n# a list of other known repositories we can talk to\n# 公有仓库配置\nuplinks:\n  npmjs:\n    url: https:&#x2F;&#x2F;registry.npmjs.org&#x2F;\n\npackages:\n  &#39;@*&#x2F;*&#39;:\n    # scoped packages\n    access: $all\n    publish: $authenticated\n    # 代理，表示没有的仓库去这个npmjs里边去找\n    # npmjs 又指向 https:&#x2F;&#x2F;registry.npmjs.org&#x2F; ,就是上面的 uplinks 配置\n    proxy: npmjs\n\n  &#39;**&#39;:\n    # allow all users (including non-authenticated users) to read and\n    # publish all packages\n    #\n    # you can specify usernames&#x2F;groupnames (depending on your auth plugin)\n    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;\n    # 三种身份所有人，匿名用户，认证（登录用户）\n    # 是否可访问所需的权限\n    access: $all\n\n    # allow all known users to publish packages\n    # (anyone can register by default, remember?)\n    # 发布package的权限\n    publish: $authenticated\n\n    # if package is not available locally, proxy requests to &#39;npmjs&#39; registry\n    # 如果package不存在，就向代理的上游服务器发起请求\n    proxy: npmjs\n\n# To use &#96;npm audit&#96; uncomment the following section\nmiddlewares:\n  audit:\n    enabled: true\n\n# 监听端口，重点，不配置这个只能本机可以访问\nlisten: 0.0.0.0:4873\n\n# log settings\nlogs:\n  - &#123;type: stdout, format: pretty, level: http&#125;\n  #- &#123;type: file, path: verdaccio.log, level: info&#125;\n\n\n\n\n\n\n\n\n\n\n4.启动  pm2 start verdaccio   这是后就可以通过http://xxx（ip地址）去访问了\n\n\n\n\n\n\n\n\n\n5.如何使用\n#当前npm 服务指向本地 \nnpm set registry http:&#x2F;&#x2F;localhost:4873\n# 注册用户 在本地注册一个用户然后指向我们的地址然后我们就可以发布包了\nnpm adduser --registry http:&#x2F;&#x2F;xxx:4873\nUsername: xxx\nPassword: xxx\nPassword:  xxx\nEmail: (this IS public) xxx\nLogged in as yg-ui on http:&#x2F;&#x2F;xxx&#x2F; （你的ip地址）这时候我们就注册一个用户，我们可以用这个用户名和密码去登录去上图窗口去登录\n\n\n与私服连接\n\nnpm set registry http:&#x2F;&#x2F;xxx：4873 (失败试试：npm config set registry http:&#x2F;&#x2F;xxx:4873 ，然后查看是否配置成功npm config edit）\n把下载镜像源的地址切换到从我们的服务器上下载。这里的npmrc文件里面内地址也就会易主\n\n\n安装nrm\n\nnrm是 npm registry 管理工具, 能够查看和切换当前使用的registry。不安装也可以，安装会更高效。\n1、安装 npm install -g nrm\n2、添加私服地址到nrm管理工具\n\n3、这里的 yg-ui是我们给自己的私服地址起的别名，为了切换和使用方便。\n   nrm add yg-ui http:&#x2F;&#x2F;xxx:4873 成功后如下\n     add registry my50 success\n4、将npm包的下载地址改到my50的私服。\n   nrm use yg-ui 成功后如下\n     verb config Skipping project config: &#x2F;home&#x2F;yg&#x2F;.npmrc.\n     Registry has been set to: http:&#x2F;&#x2F;xxx:4873&#x2F;\n5、使用nrm ls可查到我们可以使用的所有镜像源地址，* 后面是当前使用的，如果我们不想从私服上下载包，就可以用上一步骤的nrm use命令，use其它的地址，将下载地址改到别的服务器。\n   \n   输入 nrm ls 成功后如下\n   npm ---- https:&#x2F;&#x2F;registry.npmjs.org&#x2F;\n   cnpm --- http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;\n   taobao - https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;\n   nj ----- https:&#x2F;&#x2F;registry.nodejitsu.com&#x2F;\n   rednpm - http:&#x2F;&#x2F;registry.mirror.cqupt.edu.cn&#x2F;\n   npmMirror  https:&#x2F;&#x2F;skimdb.npmjs.com&#x2F;registry&#x2F;\n   edunpm - http:&#x2F;&#x2F;registry.enpmjs.org&#x2F; \n   * yg-ui --- http:&#x2F;&#x2F;xxx:4873&#x2F;\n\n   其实nrm只是个npm registry 管理工具，有了它可以让我们切换和查看registry 地址更方便快捷，即便没有它，我们直接用npm的set命令也可以切换地址，用type命令也可以查看地址，只不过用nrm更便捷，用不用随你了，觉得方便就用。\n\n\n发布包\n\n1、新建一个npmtest 目录，里边放一个文件\n2、进入目录 npm init 生成package.json\n3、npm publish           # 第二次发包已经切换到我们私服地址的情况下\n   npm publish --registry http:&#x2F;&#x2F;xxx:4873   #未切换到我们的私服时，直接加后缀可以发布到私服上。\n  第二次发包我们需要npm login 输入用户密码以及邮箱即可（这里需要注意的是\n\n\n下载包\n\n1、新建.npmrc文件\n   registry&#x3D;http:&#x2F;&#x2F;xxx:4873&#x2F;#&#x2F;detail&#x2F;ui-test\n   &#x2F;&#x2F;xxx&#x2F;:_authToken&#x3D;&quot;EF+Q227aTInBu2cvmkDyiozkm&#x2F;Z&#x2F;nOz9m1mWK&#x2F;PlgoA&#x3D;&quot;\n   &#x2F;&#x2F;localhost:4873&#x2F;:_authToken&#x3D;&quot;OTmT9IjKXStdvRwV8RRf6g&#x3D;&#x3D;&quot;\n   package-lock&#x3D;false\n   npm config edit  可以查看到_authToken\n2、npm install npmtest --save\n\n   这个命令是默认下载当前定位文件夹下package.json文件中需要的所有包，包括其间接依赖的包。第一次下载\n\n   之后的包都会缓存在我们的私服上，然后后期下载的时候从私服下载，就不会再从npmjs上下载包，但是它下\n\n   载每个包的时候都会再走一遍npmjs去检查包的版本，即便不下载资源，但这无疑也浪费了时间。经验证发\n\n   现，我们的package-lock.json文件在此刻起了大作用，因为package-lock.json文件本来就是更新node库后自\n\n   动生成的文件，里面包含了node库中所有包的下载地址当前版本以及包之间的依赖关系，既然package-\n\n   lock.json稳定了版本，所以当我们项目中包含了这个文件时，我们下包时就会根据package-lock.json的稳定版\n\n   本来，就不会再去npmjs上去检查了，这样会极大的提升下载包的速度。所以项目中一定要有稳定的\n\n   package.json和package-lock.json文件，并及时更新这两个文件。\n   package.json里边配置\n   &quot;publishConfig&quot;: &#123;\n     &quot;registry&quot;: &quot;http:&#x2F;&#x2F;xxx&#x2F;repository&#x2F;npmself&#x2F;&quot;\n   &#125;,\n\n\n删除包\n\n$ cd &#x2F;home&#x2F;yg&#x2F;.config&#x2F;verdaccio\n$ ls \nconfig.yaml  htpasswd  storage\n$ cd storage\n$ ls\n$ rm -rf  ui-test\n\n","slug":"node/base/Node基础十二","date":"2022-10-01T04:32:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"52153482f8bb5490978c774dade2918c","title":"Node基础十一","content":"十一.koa开发web服务器Koa初体验1.1. 认识Koa前面我们已经学习了express，另外一个非常流行的Node Web服务器框架就是Koa。\nKoa官方的介绍：\n\nkoa：next generation web framework for node.js；\nkoa：node.js的下一代web框架；\n\n事实上，koa是express同一个团队开发的一个新的Web框架：\n\n目前团队的核心开发者TJ的主要精力也在维护Koa，express已经交给团队维护了；\nKoa旨在为Web应用程序和API提供更小、更丰富和更强大的能力；\n相对于express具有更强的异步处理能力（后续我们再对比）；\nKoa的核心代码只有1600+行，是一个更加轻量级的框架，我们可以根据需要安装和使用中间件；\n\n1.2. koa初体验因为学习过了express，它们的基本开发模式是比较相似的。\n我们来体验一下koa的Web服务器：\nconst Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(&quot;middleware 01&quot;);\n  next();\n&#125;)\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(&quot;middleware 02&quot;);\n  ctx.response.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动成功~&quot;);\n&#125;);\n\nkoa注册的中间件提供了两个参数：\n\nctx：上下文（Context）对象；\n\n\nkoa并没有像express一样，将req和res分开，而是将它们作为ctx的属性；\n\n\nctx代表依次请求的上下文对象；\n\nctx.request：获取请求对象；\n\nctx.response：获取响应对象；\n\nnext：本质上是一个dispatch，类似于之前的next；\n\n\n后续我们学习Koa的源码，来看一下它是一个怎么样的函数；\n\n\n\nkoa通过创建的app对象，注册中间件只能通过use方法：\n\nKoa并没有提供methods的方式来注册中间件；\n也没有提供path中间件来匹配路径；\n\n但是真实开发中我们如何将路径和method分离呢？\n\n方式一：根据request自己来判断；\n方式二：使用第三方路由中间件；\n\n方式一：根据request自己判断\napp.use((ctx, next) &#x3D;&gt; &#123;\n  if (ctx.request.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;users&#39;) &#123;\n    if (ctx.request.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      ctx.response.body &#x3D; &quot;Create User Success~&quot;;\n    &#125; else &#123;\n      ctx.response.body &#x3D; &quot;Users List~&quot;;\n    &#125;\n  &#125; else &#123;\n    ctx.response.body &#x3D; &quot;Other Request Response&quot;;\n  &#125;\n&#125;)\n\n整个代码的逻辑是非常复杂和混乱的，真实开发中我们会使用路由。\n1.3. 路由的使用koa官方并没有给我们提供路由的库，我们可以选择第三方库：koa-router\n1.3.1. 安装koa-router因为是第三方的库，所以我们需要单独下项目中安装：\nnpm install koa-router\n\n1.3.2. koa-router基本使用我们可以先封装一个 user.router.js 的文件：\nconst Router &#x3D; require(&#39;koa-router&#39;);\n\nconst userRouter &#x3D; new Router();\n\nuserRouter.get(&#39;&#x2F;users&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;user list~&quot;;\n&#125;);\n\nuserRouter.post(&#39;&#x2F;users&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;create user info~&quot;;\n&#125;);\n\nmodule.exports &#x3D; userRouter;\n\n在app中将router.routes()注册为中间件：\napp.use(userRouter.routes());\napp.use(userRouter.allowedMethods());\n\n注意：allowedMethods用于判断某一个method是否支持：\n\n如果我们请求 get，那么是正常的请求，因为我们有实现get；\n如果我们请求 put、delete、patch，那么就自动报错：Method Not Allowed，状态码：405；\n如果我们请求 link、copy、lock，那么就自动报错：Not Implemented，状态码：501；\n\n1.3.3. router的前缀通常一个路由对象是对一组相似路径的封装，那么路径的前缀都是一直的，所以我们可以直接在创建Router时，添加前缀：\nconst userRouter &#x3D; new Router(&#123;prefix: &#39;&#x2F;users&#39;&#125;);\n\nuserRouter.get(&#39;&#x2F;&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;user list~&quot;;\n&#125;);\n\nuserRouter.post(&#39;&#x2F;&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;create user info~&quot;;\n&#125;);\n\nmodule.exports &#x3D; userRouter;\n\n1.4. 请求解析客户端传递到服务器参数的方法常见的是5种：\n\n方式一：通过get请求中的URL的params；\n方式二：通过get请求中的URL的query；\n方式三：通过post请求中的body的json格式；\n方式四：通过post请求中的body的x-www-form-urlencoded格式；\n方式五：通过post请求中的form-data格式；\n\n1.4.1. 方式一：params请求地址：http://localhost:8000/users/123\n获取params：\nconst userRouter &#x3D; new Router(&#123;prefix: &quot;&#x2F;users&quot;&#125;)\n\nuserRouter.get(&quot;&#x2F;:id&quot;, (ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.params.id);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.2. 方式二：query请求地址：http://localhost:8000/login?username=why&amp;password=123\n获取query：\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.query);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.3. 方式三：json请求地址：http://localhost:8000/login\nbody是json格式：\n&#123;\n    &quot;username&quot;: &quot;coderwhy&quot;,\n    &quot;password&quot;: &quot;123&quot;\n&#125;\n\n获取json数据：\n\n安装依赖：npm install koa-bodyparser;\n使用 koa-bodyparser的中间件；\n\napp.use(bodyParser());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.4. 方式四：x-www-form-urlencoded请求地址：http://localhost:8000/login\nbody是x-www-form-urlencoded格式：\nx-www-form-urlencoded\n获取json数据：(和json是一致的)\n\n安装依赖：npm install koa-bodyparser;\n使用 koa-bodyparser的中间件；\n\napp.use(bodyParser());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.5. 方式五：form-data请求地址：http://localhost:8000/login\nbody是form-data格式：\nform-data\n解析body中的数据，我们需要使用multer\n\n安装依赖：npm install koa-multer;\n使用 multer中间件；\n\nconst upload &#x3D; multer(&#123;\n&#125;);\n\napp.use(upload.any());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.req.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;);\n\n我们知道multer还可以实现文件的上传：\nconst storage &#x3D; multer.diskStorage(&#123;\n  destination: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, &quot;.&#x2F;uploads&#x2F;&quot;)\n  &#125;,\n  filename: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, Date.now() + path.extname(file.originalname))\n  &#125;\n&#125;)\n\nconst upload &#x3D; multer(&#123;\n  storage\n&#125;);\n\nconst fileRouter &#x3D; new Router();\n\nfileRouter.post(&quot;&#x2F;upload&quot;, upload.single(&#39;avatar&#39;), (ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.req.file);\n&#125;)\n\napp.use(fileRouter.routes());\n\n1.5. 响应方式输出结果：body\n将响应主体设置为以下之一：\n\nstring ：字符串数据\nBuffer ：Buffer数据\nStream ：流数据\nObject|| Array：对象或者数组\nnull ：不输出任何内容\n\n如果response.status尚未设置，Koa会自动将状态设置为200或204。\n比较常见的输出方式：\nctx.response.body &#x3D; &quot;Hello World&quot;;\nctx.body &#x3D; &#123;\n  name: &quot;why&quot;,\n  age: 18,\n  height: 1.88\n&#125;;\nctx.body &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];\n\n疑惑：ctx.response.body和ctx.body之间的区别：\n\n事实上，我们访问ctx.body时，本质上是访问ctx.response.body；\n我们可以看到源码中，我们访问 proto（这里就是ctx），其实是访问proto中的response的属性；\n\nimage-20201104155927483\n请求状态：status\n请求状态我们可以直接给ctx设置，或者给ctx.response设置也是一样的效果：\nctx.status &#x3D; 201;\nctx.response.status &#x3D; 204;\n\n1.6. 错误处理const Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  ctx.app.emit(&#39;error&#39;, new Error(&quot;哈哈哈&quot;), ctx);\n&#125;)\n\napp.on(&#39;error&#39;, (err, ctx) &#x3D;&gt; &#123;\n  console.log(err.message);\n  ctx.response.body &#x3D; &quot;哈哈哈&quot;;\n&#125;)\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;错误处理服务启动成功~&quot;);\n&#125;)\n\n1.7. 静态服务器koa并没有内置部署相关的功能，所以我们需要使用第三方库：\nnpm install koa-static\n\n部署的过程类似于express：\nconst Koa &#x3D; require(&#39;koa&#39;);\nconst static &#x3D; require(&#39;koa-static&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use(static(&#39;.&#x2F;build&#39;));\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;静态服务器启动成功~&quot;);\n&#125;);\n\n1.8. 源码解析视频里面有讲解，这里不再截图\n二. 和express对比在学习了两个框架之后，我们应该已经可以发现koa和express的区别：\n从架构设计上来说：\n\nexpress是完整和强大的，其中帮助我们内置了非常多好用的功能；\n\nkoa是简洁和自由的，它只包含最新的功能，并不会对我们使用其他中间件进行任何的限制。\n\n\n甚至是在app中连最基本的get、post都没有给我们提供；\n\n\n我们需要通过自己或者路由来判断请求方式或者其他功能；\n\n\n因为express和koa框架他们的核心其实都是中间件：\n\n但是他们的中间件事实上，它们的中间件的执行机制是不同的，特别是针对某个中间件中包含异步操作时；\n所以，接下来，我们再来研究一下express和koa中间件的执行顺序问题；\n\n我通过一个需求来演示所有的过程：\n\n假如有三个中间件会在一次请求中匹配到，并且按照顺序执行；\n\n我希望最终实现的方案是：\n\n\n注意：是middleware1中；\n\n\n在middleware1中，在req.message中添加一个字符串 aaa；\n\n在middleware2中，在req.message中添加一个 字符串bbb；\n\n在middleware3中，在req.message中添加一个 字符串ccc；\n\n当所有内容添加结束后，在middleware1中，通过res返回最终的结果；\n\n\n2.1. 同步执行顺序假如我们获取的所有数据，是可以同步获取的；\n我们先通过express实现这个过程：\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\n\nconst middleware1 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;ccc&#39;;\n&#125;\n\napp.use(middleware1, middleware2, middleware3);\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;启动成功~&quot;);\n&#125;)\n\n最终的结果是：aaabbbccc，没问题；\n我们再通过koa实现这个过程：\nconst Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\nconst middleware1 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  next();\n  console.log(&quot;aaaa&quot;);\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  console.log(&quot;bbbb&quot;);\n  next();\n&#125;\n\nconst middleware3 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;ccc&#39;;\n&#125;\n\napp.use(middleware1);\napp.use(middleware2);\napp.use(middleware3);\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;启动成功~&quot;);\n&#125;)\n\n最终的结果也是：aaabbbccc，也没问题；\n2.2. 异步执行顺序但是，如果我们最后的ccc中的结果，是需要异步操作才能获取到的，是否会产生问题呢？\n2.2.1. express中遇到异步操作express有异步操作（没有在next前，加async、await）：\nconst middleware1 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  req.message &#x3D; req.message + result.data.lrc.lyric;\n  console.log(req.message);\n&#125;\n\n最终的结果aaabbb，是不正确。\nexpress有异步操作（有在next前，加async、await）：\nconst middleware1 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  await next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  await next();\n&#125;\n\nconst middleware3 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  req.message &#x3D; req.message + result.data.lrc.lyric;\n  console.log(req.message);\n&#125;\n\n最终的结果也是aaabbb，也是不正确。\n为什么呢？\n\n原因是本质上的next()和异步没有任何关系；\n它本身就是一个同步函数的调用，所以它不会等到你异步有结果之后，再继续执行后续的操作；\n\nimage-20201106175205300\n2.2.2. koa中遇到异步操作koa有异步操作（没有在next前，加async、await）：\nconst middleware1 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  next();\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  ctx.message &#x3D; ctx.message + result.data.lrc.lyric;\n&#125;\n\n最终的结果也是aaabbb，也是不正确。\n\n这是因为虽然next函数是一个返回promise的异步操作，但是在前面不加await的情况，是不同等待结果的返回，就会继续向后执行了；\n\nkoa有异步操作（有在next前，加async、await）：\nconst middleware1 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  await next();\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  await next();\n&#125;\n\nconst middleware3 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  ctx.message &#x3D; ctx.message + result.data.lrc.lyric;\n&#125;\n\n最终的结果是aaabbb+歌词信息，是正确。\n\n这是因为，当我们在koa中的next前面加await时，它会等到后续有一个确定结果时，在执行后续的代码；\n\n","slug":"node/base/Node基础十一","date":"2022-10-01T04:31:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"c2943d2fce9c96d8a973d43b491afc6a","title":"Node基础十","content":"十.express开发web服务器Express初体验1.1. 认识Web框架前面我们已经学习了使用http内置模块来搭建Web服务器，为什么还要使用框架？\n\n原生http在进行很多处理时，会较为复杂；\n有URL判断、Method判断、参数处理、逻辑代码处理等，都需要我们自己来处理和封装；\n并且所有的内容都放在一起，会非常的混乱；\n\n目前在Node中比较流行的Web服务器框架是express、koa；\n\n我们先来学习express，后面再学习koa，并且对他们进行对比；\n\nexpress早于koa出现，并且在Node社区中迅速流行起来：\n\n我们可以基于express快速、方便的开发自己的Web服务器；\n并且可以通过一些实用工具和中间件来扩展自己功能；\n\nexpress中文网连接: https://www.expressjs.com.cn/\n1.2. express的安装express的使用过程有两种方式：\n\n方式一：通过express提供的脚手架，直接创建一个应用的骨架；\n方式二：从零搭建自己的express应用结构；\n\n方式一：安装express-generator\nnpm install -g express-generator\n\n创建项目：\nexpress express-demo\n\n项目目录如下：\n├── app.js\n├── bin\n│   └── www\n├── package-lock.json\n├── package.json\n├── public\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes\n│   ├── index.js\n│   └── users.js\n└── views\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n\n我们可以安装依赖，将程序跑起来：\nnpm install\nnode bin&#x2F;www\n\n方式二：从零学习搭建\n刚才创建的项目express项目，很多内容可能我们并不认识，所以刚开始我们最好从零来学习。\n初始化一个新的项目\nnpm init -y\n\nexpress的安装：\n\n目前最新的 release 版本是4.17.1，我们使用该版本；\n\nnpm install express\n\n1.3. express初体验我们来创建自己的第一个express程序：\nconst express &#x3D; require(&#39;express&#39;);\n\n&#x2F;&#x2F; 创建服务器\nconst app &#x3D; express();\n\n&#x2F;&#x2F; &#x2F;home的get请求处理\napp.get(&quot;&#x2F;home&quot;, (req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Home&quot;);\n&#125;);\n\n&#x2F;&#x2F; &#x2F;login的post请求处理\napp.post(&quot;&#x2F;login&quot;, (req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Login&quot;);\n&#125;);\n\n&#x2F;&#x2F; 开启监听\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动成功~&quot;);\n&#125;)\n\n我们会发现，之后的开发过程中，可以方便的将请求进行分离：\n\n无论是不同的URL，还是get、post等请求方式；\n这样的方式非常方便我们已经进行维护、扩展；\n\n当然，这只是初体验，接下来我们来探索更多的用法；\n1.4. 请求和响应请求的路径中如果有一些参数，可以这样表达：\n\n/users/:userId；\n在request对象中要获取可以通过 req.params.userId;\n\n返回数据，我们可以方便的使用json：\n\nres.json(数据)方式；\n可以支持其他的方式，可以自行查看文档；\nhttps://www.expressjs.com.cn/guide/routing.html\n\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\napp.get(&#39;&#x2F;users&#x2F;:userId&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.params.userId);\n  res.json(&#123;username: &quot;coderwhy&quot;, level: 99&#125;);\n&#125;);\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;静态服务器启动成功~&quot;);\n&#125;)\n\n二. Express中间件2.1. 认识中间件Express是一个路由和中间件的Web框架，它本身的功能非常少：\n\nExpress应用程序本质上是一系列中间件函数的调用；\n\n中间件是什么呢？\n\n中间件的本质就是一个回调函数；\n\n这个回调函数接受三个参数：\n\n\n请求对象（request对象）；\n\n\n响应对象（response对象）；\n\nnext函数（在express中定义的用于执行下一个中间件的函数）；\n\n\n中间件中可以执行哪些任务呢？\n\n执行任何代码；\n更改请求（request）和响应（response）对象；\n结束请求-响应周期（返回数据）；\n调用栈中的下一个中间件；\n\n如果当前中间件功能没有结束请求-响应周期，则必须调用next()将控制权传递给下一个中间件功能，否则，请求将被挂起。\n中间件函数调用的元素：\nimage-20201101205333843\n2.2. 应用中间件那么，如何将一个中间件应用到我们的应用程序中呢？\n\nexpress主要提供了两种方式：app/router.use和app/router.methods；\n可以是 app，也可以是router，router我们后续再学习:\nmethods指的是常用的请求方式，比如：app.get或app.post等；\n\n我们先来学习use的用法，因为methods的方式本质是use的特殊情况；\n案例一：最普通的中间件\n之所以称之为最普通的中间件，是因为无论是什么path、methods都会应用该中间件；\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware 01&quot;);\n  next();\n&#125;)\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware 02&quot;);\n  res.end(&quot;Hello Common Middleware~&quot;);\n&#125;)\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;中间件服务器启动成功~&quot;);\n&#125;)\n\n中间件的执行顺序：\n\n在匹配上的情况下，中间件按照注册的顺序执行；\n\n案例二：path匹配中间件\n如果我们希望匹配一个明确的路径，也可以使用use方法：\n&#x2F;&#x2F; 案例二: 路径匹配中间件\napp.use(&#39;&#x2F;home&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;home middleware 01&quot;);\n  next();\n&#125;);\n\napp.use(&#39;&#x2F;home&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;home middleware 02&quot;);\n  next();\n  res.end(&quot;Hello Home middleware&quot;);\n&#125;);\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware&quot;);\n&#125;);\n\n案例三：path和method匹配中间件\n&#x2F;&#x2F; 案例三: method匹配中间件\napp.get(&#39;&#x2F;home&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;home get middleware&quot;);\n  next();\n&#125;)\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;login post middleware&quot;);\n  next();\n&#125;);\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware&quot;);\n&#125;);\n\n案例四：注册多个中间件\n&#x2F;&#x2F; 案例四: 注册多个中间件\nconst homeMiddleware1 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  console.log(&#39;home middleware 01&#39;);\n  next();\n&#125;\n\nconst homeMiddleware2 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  console.log(&#39;home middleware 02&#39;);\n  next();\n&#125;\n\nconst homeHandle &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Home~&quot;);\n&#125;\n\napp.get(&#39;&#x2F;home&#39;, homeMiddleware1, homeMiddleware2, homeHandle);\n\n2.3. 应用其他中间件并非所有的中间件都需要我们从零去编写：\n\nexpress有内置一些帮助我们完成对request解析的中间件；\nregistry仓库中也有很多可以辅助我们开发的中间件；\n\n2.3.1. request解析中间件在客户端发送post请求时，会将数据放到body中：\n\n客户端可以通过json的方式传递；\n也可以通过form表单的方式传递；\n\n我们这里先使用json传递给服务器body：\njson传递body\n不进行解析时的操作：\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  req.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n    console.log(data.toString());\n  &#125;)\n  req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n    res.end(&quot;登录成功~&quot;);\n  &#125;);\n&#125;);\n\n我们也可以自己编写中间件来解析JSON：\napp.use((req, res, next) &#x3D;&gt; &#123;\n  if (req.headers[&#39;content-type&#39;] &#x3D;&#x3D;&#x3D; &#39;application&#x2F;json&#39;) &#123;\n    req.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n      const userInfo &#x3D; JSON.parse(data.toString());\n      req.body &#x3D; userInfo;\n    &#125;)\n    req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n      next();\n    &#125;)\n  &#125; else &#123;\n    next();\n  &#125;\n&#125;)\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n  res.end(&quot;登录成功~&quot;);\n&#125;);\n\n但是，事实上我们可以使用express内置的中间件或者使用body-parser来完成：\napp.use(express.json());\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n  res.end(&quot;登录成功~&quot;);\n&#125;);\n\n如果我们解析的是 application/x-www-form-urlencoded：\nform传递body\n我们可以使用express自带的 urlencoded函数来作为中间件：\n\n传入的extended用于表示使用哪一种解析方式：\n\n\ntrue：使用qs第三方模块；\n\n\nfalse：使用querystring内置模块；\n\n备注：它们之间的区别这里不展开讲解；\n\n\napp.use(express.json());\napp.use(express.urlencoded(&#123;extended: true&#125;));\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n  res.end(&quot;登录成功~&quot;);\n&#125;);\n\n2.3.2. 日志记录中间件如果我们希望将请求日志记录下来，那么可以使用express官网开发的第三方库：morgan\n安装morgan：\nnpm install morgan\n\n直接作为中间件使用即可：\nconst loggerWriter &#x3D; fs.createWriteStream(&#39;.&#x2F;log&#x2F;access.log&#39;, &#123;\n  flags: &#39;a+&#39;\n&#125;)\napp.use(morgan(&#39;combined&#39;, &#123;stream: loggerWriter&#125;));\n\n2.3.3. 上传文件中间件图片上传我们可以使用express官方开发的第三方库：multer\nnpm install multer\n\n上传文件，并且默认文件名：\nconst upload &#x3D; multer(&#123;\n  dest: &quot;uploads&#x2F;&quot;\n&#125;)\n\napp.post(&#39;&#x2F;upload&#39;, upload.single(&#39;file&#39;), (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.file.buffer);\n  res.end(&quot;文件上传成功~&quot;);\n&#125;)\n\n添加文件名后缀：\nconst storage &#x3D; multer.diskStorage(&#123;\n  destination: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, &quot;uploads&#x2F;&quot;)\n  &#125;,\n  filename: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, Date.now() + path.extname(file.originalname));\n  &#125;\n&#125;)\n\nconst upload &#x3D; multer(&#123;\n  storage\n&#125;)\n\napp.post(&#39;&#x2F;upload&#39;, upload.single(&#39;file&#39;), (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.file.buffer);\n  res.end(&quot;文件上传成功~&quot;);\n&#125;)\n\n我们也可以上传多张图片：\napp.use(&#39;&#x2F;upload&#39;, upload.array(&#39;files&#39;), (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.files);\n&#125;);\n\n如果我们希望借助于multer帮助我们解析一些form-data中的普通数据，那么我们可以使用any：\n\n请求如下：\n\nimage-20201104165039444\napp.use(upload.any());\n\napp.use(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n&#125;);\n\n2.4. 请求和响应客户端传递到服务器参数的方法常见的是5种：\n\n方式一：通过get请求中的URL的params；\n方式二：通过get请求中的URL的query；\n方式三：通过post请求中的body的json格式（中间件中已经使用过）；\n方式四：通过post请求中的body的x-www-form-urlencoded格式（中间件使用过）；\n方式五：通过post请求中的form-data格式（中间件中使用过）；\n\n2.4.1. 请求解析方式一：params\n请求地址：http://localhost:8000/login/abc/why\n获取参数：\napp.use(&#39;&#x2F;login&#x2F;:id&#x2F;:name&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.params);\n  res.json(&quot;请求成功~&quot;);\n&#125;)\n\n方式二：query\n请求地址：http://localhost:8000/login?username=why&amp;password=123\n获取参数：\napp.use(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.query);\n\n  res.json(&quot;请求成功~&quot;);\n&#125;)\n\n2.4.2. 响应方式end方法\n类似于http中的response.end方法，用法是一致的\nres.end(&quot;Hello World&quot;);\n\njson方法\njson方法中可以传入很多的类型：object、array、string、boolean、number、null等，它们会被转换成json格式返回；\nres.json(&#123;name: &quot;why&quot;, age: 18&#125;);\n\nstatus方法\n用于设置状态码：\nres.status(204);\n\n三. 其他支持补充3.1. 路由的使用如果我们将所有的代码逻辑都写在app中，那么app会变得越来越复杂：\n\n一方面完整的Web服务器包含非常多的处理逻辑；\n\n另一方面有些处理逻辑其实是一个整体，我们应该将它们放在一起：比如对users相关的处理\n\n\n获取用户列表；\n\n\n获取某一个用户信息；\n\n创建一个新的用户；\n\n删除一个用户；\n\n更新一个用户；\n\n\n我们可以使用 express.Router来创建一个路由处理程序：\n\n一个Router实例拥有完整的中间件和路由系统；\n因此，它也被称为 迷你应用程序（mini-app）；\n\n&#x2F;&#x2F; 用户相关的处理\nconst userRouter &#x3D; express.Router();\n\nuserRouter.get(&#39;&#x2F;&#39;, (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;用户列表&quot;);\n&#125;);\n\nuserRouter.post(&#39;&#x2F;&#39;, (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;创建用户&quot;);\n&#125;);\n\nuserRouter.delete(&#39;&#x2F;&#39;, (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;删除用户&quot;);\n&#125;);\n\napp.use(&#39;&#x2F;users&#39;, userRouter);\n\n当然，我们可以配置更多的路由，并且将所有的逻辑放到一个单独的文件中。\n3.2. 静态资源服务器部署静态资源我们可以选择很多方式：\n\nNode也可以作为静态资源服务器，并且express给我们提供了方便部署静态资源的方法；\n\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\napp.use(express.static(&#39;.&#x2F;build&#39;));\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;静态服务器启动成功~&quot;);\n&#125;)\n\n3.3. 错误处理方式app.use((req, res, next) &#x3D;&gt; &#123;\n  next(new Error(&quot;USER DOES NOT EXISTS&quot;));\n&#125;);\n\napp.use((err, req, res, next) &#x3D;&gt; &#123;\n  const message &#x3D; err.message;\n\n  switch (message) &#123;\n    case &quot;USER DOES NOT EXISTS&quot;:\n      res.status(400).json(&#123;message&#125;)\n  &#125;\n\n  res.status(500)\n&#125;)\n\n3.4. 源码分析3.4.1. 创建app的过程express函数的本质其实是createApplication：\nimage-20201102161803339\n当我们调用app.listen的时候，本质上是调用proto中的listen\n\n因为上面有进行 mixin 的操作；\n\nimage-20201102161939032\n3.4.2. 注册中间件比如我们通过use来注册一个中间件，源码中发生了什么？\n\n我们会发现无论是app.use还是app.methods都会注册一个主路由；\n我们会发现app本质上会将所有的函数，交给这个主路由去处理的；\n\nimage-20201102162627758\n我们来看一下router.use中又做了什么事情？\n\n本质上一个函数会创建一个layer，并且会被放入到stack中；\n\nimage-20201102162749391\n3.4.3. 请求的处理过程如果有一个请求过来，那么从哪里开始呢？\n\napp函数被调用开始的；\n\nimage-20201102162943190\napp.handle本质上会去调用router.handle：\nimage-20201102163035566\nrouter.handle中做的什么事情呢？\nimage-20201102163153121\nimage-20201102163314862\n","slug":"node/base/Node基础十","date":"2022-10-01T04:30:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"b171402bc406b8e8ddf1dcd5f712137e","title":"Node基础九","content":"九.http开发web服务器\n\n\n\n\n\n\n\n\n什么是Web服务器？\n当应用程序（客户端）需要某一个资源时，可以向一个台服务器，通过Http请求获取到这个资源；提供服务器的这个服务器，就是一个Web服务器；\nWeb服务器\n目前有很多开源的Web服务器：Nginx、Apache（静态）、Apache Tomcat（静态、动态）、Node.js\n一. Http模板基本使用1.1. 如何创建服务1.1.1. Web服务器初体验创建一个Web服务器的初体验：\nconst http &#x3D; require(&#39;http&#39;);\n\nconst HTTP_PORT &#x3D; 8000;\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello World&quot;);\n&#125;);\n\nserver.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&#96;🚀服务器在$&#123;HTTP_PORT&#125;启动~&#96;)\n&#125;)\n\n1.1.2. 创建服务器创建服务器对象，我们是通过 createServer 来完成的\n\nhttp.createServer会返回服务器的对象；\n底层其实使用直接 new Server 对象。\n\nfunction createServer(opts, requestListener) &#123;\n  return new Server(opts, requestListener);\n&#125;\n\n那么，当然，我们也可以自己来创建这个对象：\nconst server2 &#x3D; new http.Server((req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Server2&quot;);\n&#125;);\n\nserver2.listen(9000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动成功~&quot;);\n&#125;)\n\n上面我们已经看到，创建Server时会传入一个回调函数，这个回调函数在被调用时会传入两个参数：\n\nreq：request请求对象，包含请求相关的信息；\nres：response响应对象，包含我们要发送给客户端的信息；\n\n1.1.3. 监听端口和主机Server通过listen方法来开启服务器，并且在某一个主机和端口上监听网络请求：\n\n也就是当我们通过 ip:port的方式发送到我们监听的Web服务器上时；\n我们就可以对其进行相关的处理；\n\nlisten函数有三个参数：\n\n端口port: 可以不传, 系统会默认分配端, 后续项目中我们会写入到环境变量中；\n\n主机host: 通常可以传入localhost、ip地址127.0.0.1、或者ip地址0.0.0.0，默认是0.0.0.0；\n\n\n监听IPV4上所有的地址，再根据端口找到不同的应用程序；\n\n\n比如我们监听 0.0.0.0时，在同一个网段下的主机中，通过ip地址是可以访问的；\n\n正常的数据库包经常 应用层 - 传输层 - 网络层 - 数据链路层 - 物理层 ；\n\n而回环地址，是在网络层直接就被获取到了，是不会经常数据链路层和物理层的；\n\n比如我们监听 127.0.0.1时，在同一个网段下的主机中，通过ip地址是不能访问的；\n\nlocalhost：本质上是一个域名，通常情况下会被解析成127.0.0.1；\n\n127.0.0.1：回环地址（Loop Back Address），表达的意思其实是我们主机自己发出去的包，直接被自己接收；\n\n0.0.0.0：\n\n回调函数：服务器启动成功时的回调函数；\n\n\nserver.listen(() &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动~🚀&quot;);\n&#125;)\n\n1.2. request请求对象在向服务器发送请求时，我们会携带很多信息，比如：\n\n本次请求的URL，服务器需要根据不同的URL进行不同的处理；\n本次请求的请求方式，比如GET、POST请求传入的参数和处理的方式是不同的；\n本次请求的headers中也会携带一些信息，比如客户端信息、接受数据的格式、支持的编码格式等；\n等等…\n\n这些信息，Node会帮助我们封装到一个request的对象中，我们可以直接来处理这个request对象：\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; request对象\n  console.log(req.url);\n  console.log(req.method);\n  console.log(req.headers);\n\n  res.end(&quot;Hello World&quot;);\n&#125;);\n\n1.2.1. URL的处理客户端在发送请求时，会请求不同的数据，那么会传入不同的请求地址：\n\n比如 http://localhost:8000/login；\n比如 http://localhost:8000/products;\n\n服务器端需要根据不同的请求地址，作出不同的响应：\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  const url &#x3D; req.url;\n  console.log(url);\n\n  if (url &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n    res.end(&quot;welcome Back~&quot;);\n  &#125; else if (url &#x3D;&#x3D;&#x3D; &#39;&#x2F;products&#39;) &#123;\n    res.end(&quot;products&quot;);\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);\n\n那么如果用户发送的地址中还携带一些额外的参数呢？\n\nhttp://localhost:8000/login?name=why&amp;password=123;\n这个时候，url的值是 /login?name=why&amp;password=123；\n\n我们如何对它进行解析呢？\n\n使用内置模块url；\n\nconst url &#x3D; require(&#39;url&#39;);\n\n&#x2F;&#x2F; 解析请求\nconst parseInfo &#x3D; url.parse(req.url);\nconsole.log(parseInfo);\n\n解析结果：\nUrl &#123;\n  protocol: null,\n  slashes: null,\n  auth: null,\n  host: null,\n  port: null,\n  hostname: null,\n  hash: null,\n  search: &#39;?name&#x3D;why&amp;password&#x3D;123&#39;,\n  query: &#39;name&#x3D;why&amp;password&#x3D;123&#39;,\n  pathname: &#39;&#x2F;login&#39;,\n  path: &#39;&#x2F;login?name&#x3D;why&amp;password&#x3D;123&#39;,\n  href: &#39;&#x2F;login?name&#x3D;why&amp;password&#x3D;123&#39;\n&#125;\n\n我们会发现 pathname就是我们想要的结果。\n但是 query 信息如何可以获取呢？\n\n方式一：截取字符串；\n方式二：使用querystring内置模块；\n\nconst &#123; pathname, query &#125; &#x3D; url.parse(req.url);\nconst queryObj &#x3D; qs.parse(query);\nconsole.log(queryObj.name);\nconsole.log(queryObj.password);\n\n1.2.2. Method的处理在Restful规范（设计风格）中，我们对于数据的增删改查应该通过不同的请求方式：\n\nGET：查询数据；\nPOST：新建数据；\nPATCH：更新数据；\nDELETE：删除数据；\n\n所以，我们可以通过判断不同的请求方式进行不同的处理。\n比如创建一个用户：\n\n请求接口为 /users；\n请求方式为 POST请求；\n携带数据 username和password；\n\n创建用户请求\n在我们程序中如何进行判断以及获取对应的数据呢？\n\n这里我们需要判断接口是 /users，并且请求方式是POST方法去获取传入的数据；\n获取这种body携带的数据，我们需要通过监听req的 data事件来获取；\n\nif (req.url.indexOf(&#39;&#x2F;users&#39;) !&#x3D;&#x3D; -1) &#123;\n  if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n  \n    &#x2F;&#x2F; 可以设置编码，也可以在下方通过 data.toString() 获取字符串格式\n    req.setEncoding(&#39;utf-8&#39;);\n\n    req.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n      const &#123;username, password&#125; &#x3D; JSON.parse(data);\n      console.log(username, password);\n    &#125;);\n\n    res.end(&quot;create user success&quot;);\n  &#125; else &#123;\n    res.end(&quot;users list&quot;);\n  &#125;\n&#125; else &#123;\n  res.end(&quot;error message&quot;);\n&#125;\n\n将JSON字符串格式转成对象类型，通过JSON.parse方法即可。\n1.2.3. header属性在request对象的header中也包含很多有用的信息：\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  console.log(req.headers);\n\n  res.end(&quot;Hello Header&quot;);\n&#125;);\n\n浏览器会默认传递过来一些信息：\n&#123;\n  &#39;content-type&#39;: &#39;application&#x2F;json&#39;,\n  &#39;user-agent&#39;: &#39;PostmanRuntime&#x2F;7.26.5&#39;,\n  accept: &#39;*&#x2F;*&#39;,\n  &#39;postman-token&#39;: &#39;afe4b8fe-67e3-49cc-bd6f-f61c95c4367b&#39;,\n  host: &#39;localhost:8000&#39;,\n  &#39;accept-encoding&#39;: &#39;gzip, deflate, br&#39;,\n  connection: &#39;keep-alive&#39;,\n  &#39;content-length&#39;: &#39;48&#39;\n&#125;\n\ncontent-type是这次请求携带的数据的类型：\n\napplication/json表示是一个json类型；\ntext/plain表示是文本类型；\napplication/xml表示是xml类型；\nmultipart/form-data表示是上传文件；\n\ncontent-length：\n\n文件的大小和长度\n\nkeep-alive：\n\nhttp是基于TCP协议的，但是通常在进行一次请求和响应结束后会立刻中断；\n\n在http1.0中，如果想要继续保持连接：\n\n\n浏览器需要在请求头中添加 connection: keep-alive；\n\n\n服务器需要在响应头中添加 connection:keey-alive；\n\n当客户端再次放请求时，就会使用同一个连接，直接一方中断连接；\n\n在http1.1中，所有连接默认是 connection: keep-alive的；\n\n\n不同的Web服务器会有不同的保持 keep-alive的时间；\n\n\nNode中默认是5s中；\n\n\naccept-encoding：\n\n告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip编码，对应 .gz文件；\n\naccept：\n\n告知服务器，客户端可接受文件的格式类型；\n\nuser-agent：\n\n客户端相关的信息；\n\n1.3. 响应对象response1.3.1. 返回响应结果如果我们希望给客户端响应的结果数据，可以通过两种方式：\n\nWrite方法：这种方式是直接写出数据，但是并没有关闭流；\nend方法：这种方式是写出最后的数据，并且写出后会关闭流；\n\nconst http &#x3D; require(&#39;http&#39;);\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n\n  &#x2F;&#x2F; 响应数据的方式有两个:\n  res.write(&quot;Hello World&quot;);\n  res.write(&quot;Hello Response&quot;);\n  res.end(&quot;message end&quot;);\n&#125;);\n\nserver.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动🚀~&quot;)\n&#125;);\n\n如果我们没有调用 end和close，客户端将会一直等待结果，所以客户端在发送网络请求时，都会设置超时时间。\n1.3.2. 返回状态码Http状态码（Http Status Code）是用来表示Http响应状态的数字代码：\n\nHttp状态码非常多，可以根据不同的情况，给客户端返回不同的状态码；\n常见的状态码是下面这些（后续项目中，也会用到其中的状态码）；\n\n状态码\n设置状态码常见的有两种方式：\nres.statusCode &#x3D; 400;\nres.writeHead(200);\n\n1.3.3. 响应头文件返回头部信息，主要有两种方式：\n\nres.setHeader：一次写入一个头部信息；\nres.writeHead：同时写入header和status；\n\nres.setHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;utf8&quot;);\n\nres.writeHead(200, &#123;\n  &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;utf8&quot;\n&#125;)\n\nHeader设置 Content-Type有什么作用呢？\n\n默认客户端接收到的是字符串，客户端会按照自己默认的方式进行处理；\n\n比如，我们返回的是一段HTML，但是没有指定格式：\nres.end(&#39;&lt;h2&gt;Hello World&lt;&#x2F;h2&gt;&#39;)\n\nimage-20201030154312050\n但是，如果我们指定了格式：\nres.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html;charset&#x3D;utf8&quot;);\nres.end(&#39;&lt;h2&gt;Hello World&lt;&#x2F;h2&gt;&#39;)\n\nimage-20201030154404172\n如果我们希望返回一段JSON数据，应该怎么做呢？\nres.writeHead(200, &#123;\n  &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;utf8&quot;\n&#125;)\n\nconst data &#x3D; &#123;\n  name: &quot;王红元&quot;,\n  age: 18,\n  height: 1.88\n&#125;;\n\nres.end(JSON.stringify(data));\n\n二. Web其他补充2.1. 文件上传的使用如果是一个很大的文件需要上传到服务器端，服务器端进行保存应该如何操作呢？\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;upload&#39;) &#123;\n    if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      const fileWriter &#x3D; fs.createWriteStream(&#39;.&#x2F;foo.png&#39;);\n      req.pipe(fileWriter);\n\n      const fileSize &#x3D; req.headers[&#39;content-length&#39;];\n      let curSize &#x3D; 0;\n      console.log(fileSize);\n\n      req.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n        curSize +&#x3D; data.length;\n        console.log(curSize);\n        res.write(&#96;文件上传进度: $&#123;curSize&#x2F;fileSize * 100&#125;%\\n&#96;);\n      &#125;);\n\n      req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n        res.end(&quot;文件上传完成~&quot;);\n      &#125;)\n    &#125;\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);\n\n这个时候我们发现文件上传成功了，但是文件却打不开：\n\n这是因为我们写入的数据，里面包含一些特殊的信息；\n这些信息打开的软件并不能很好的解析；\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;upload&#39;) &#123;\n    if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      &#x2F;&#x2F; 图片文件必须设置为二进制的\n      req.setEncoding(&#39;binary&#39;);\n\n      &#x2F;&#x2F; 获取content-type中的boundary的值\n      var boundary &#x3D; req.headers[&#39;content-type&#39;].split(&#39;; &#39;)[1].replace(&#39;boundary&#x3D;&#39;,&#39;&#39;);\n      \n      &#x2F;&#x2F; 记录当前数据的信息\n      const fileSize &#x3D; req.headers[&#39;content-length&#39;];\n      let curSize &#x3D; 0;\n      let body &#x3D; &#39;&#39;;\n\n      &#x2F;&#x2F; 监听当前的数据\n      req.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n        curSize +&#x3D; data.length;\n        res.write(&#96;文件上传进度: $&#123;curSize&#x2F;fileSize * 100&#125;%\\n&#96;);\n        body +&#x3D; data;\n      &#125;);\n\n      &#x2F;&#x2F; 数据结构\n      req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 切割数据\n        const payload &#x3D; qs.parse(body, &quot;\\r\\n&quot;, &quot;:&quot;);\n        &#x2F;&#x2F; 获取最后的类型(image&#x2F;png)\n        const fileType &#x3D; payload[&quot;Content-Type&quot;].substring(1);\n        &#x2F;&#x2F; 获取要截取的长度\n        const fileTypePosition &#x3D; body.indexOf(fileType) + fileType.length;\n        let binaryData &#x3D; body.substring(fileTypePosition);\n        binaryData &#x3D; binaryData.replace(&#x2F;^\\s\\s*&#x2F;, &#39;&#39;);\n\n        &#x2F;&#x2F; binaryData &#x3D; binaryData.replaceAll(&#39;\\r\\n&#39;, &#39;&#39;);\n        const finalData &#x3D; binaryData.substring(0, binaryData.indexOf(&#39;--&#39;+boundary+&#39;--&#39;));\n\n        fs.writeFile(&#39;.&#x2F;boo.png&#39;, finalData, &#39;binary&#39;, (err) &#x3D;&gt; &#123;\n          console.log(err);\n          res.end(&quot;文件上传完成~&quot;);\n        &#125;)\n      &#125;)\n    &#125;\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);\n\n2.2. http发送网络请求axios库可以在浏览器中使用，也可以在Node中使用：\n\n在浏览器中，axios使用的是封装xhr；\n在Node中，使用的是http内置模块；\n\n所以http模块是可以在Node中直接发送网络请求的。\n发送get请求：\nhttp.get(&quot;http:&#x2F;&#x2F;localhost:8000&quot;, (res) &#x3D;&gt; &#123;\n  res.on(&#39;data&#39;, data &#x3D;&gt; &#123;\n    console.log(data.toString());\n    console.log(JSON.parse(data.toString()));\n  &#125;)\n&#125;);\n\n发送post请求：\nconst req &#x3D; http.request(&#123;\n  method: &#39;POST&#39;,\n  hostname: &quot;localhost&quot;,\n  port: 8000\n&#125;, (res) &#x3D;&gt; &#123;\n  res.on(&#39;data&#39;, data &#x3D;&gt; &#123;\n    console.log(data.toString());\n    console.log(JSON.parse(data.toString()));\n  &#125;)\n&#125;)\n\nreq.on(&#39;error&#39;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\n\nreq.end();\n","slug":"node/base/Node基础九","date":"2022-10-01T04:29:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"adefcce4d4f2d80811a82b2ac8c91417","title":"Node基础八","content":"八. 深入事件循环事件循环是什么？事实上我把事件循环理解成我们编写的JavaScript和浏览器或者Node之间的一个桥梁。\n浏览器的事件循环是一个我们编写的JavaScript代码和浏览器API调用(setTimeout&#x2F;AJAX&#x2F;监听事件等)的一个桥梁, 桥梁之间他们通过回调函数进行沟通。\nNode的事件循环是一个我们编写的JavaScript代码和系统调用（file system、network等）之间的一个桥梁, 桥梁之间他们通过回调函数进行沟通的.\n浏览器的事件循环1.1. 进程和线程线程和进程是操作系统中的两个概念：\n\n进程（process）：计算机已经运行的程序；\n线程（thread）：操作系统能够运行运算调度的最小单位；\n\n听起来很抽象，我们直观一点解释：\n\n进程：我们可以认为，启动一个应用程序，就会默认启动一个进程（也可能是多个进程）；\n线程：每一个进程中，都会启动一个线程用来执行程序中的代码，这个线程被称之为主线程；\n所以我们也可以说进程是线程的容器；\n\n再用一个形象的例子解释：\n\n操作系统类似于一个工厂；\n工厂中里有很多车间，这个车间就是进程；\n每个车间可能有一个以上的工人在工厂，这个工人就是线程；\n\n操作系统、线程、进程\n操作系统是如何做到同时让多个进程（边听歌、边写代码、边查阅资料）同时工作呢？\n\n这是因为CPU的运算速度非常快，它可以快速的在多个进程之间迅速的切换；\n当我们的进程中的线程获取获取到时间片时，就可以快速执行我们编写的代码；\n对于用于来说是感受不到这种快速的切换的；\n\n你可以在Mac的活动监视器或者Windows的资源管理器中查看到很多进程：\n活动监视器\n1.2. 浏览器和JavaScript我们经常会说JavaScript是单线程的，但是JavaScript的线程应该有自己的容器进程：浏览器或者Node。\n浏览器是一个进程吗，它里面只有一个线程吗？\n\n目前多数的浏览器其实都是多进程的，当我们打开一个tab页面时就会开启一个新的进程，这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出；\n每个进程中又有很多的线程，其中包括执行JavaScript代码的线程；\n\n但是JavaScript的代码执行是在一个单独的线程中执行的：\n\n这就意味着JavaScript的代码，在同一个时刻只能做一件事；\n如果这件事是非常耗时的，就意味着当前的线程就会被阻塞；\n\n分析下面代码的执行过程：\n\n定义变量name；\n执行log函数，函数会被放入到调用栈中执行；\n调用bar()函数，被压入到调用栈中，但是执行未结束；\nbar因为调用了sum，sum函数被压入到调用栈中，获取到结果后出栈；\nbar获取到结果后出栈，获取到结果result；\n将log函数压入到调用栈，log被执行，并且出栈；\n\nconst name &#x3D; &quot;coderwhy&quot;;\n\n&#x2F;&#x2F; 1.将该函数放入到调用栈中被执行\nconsole.log(name);\n\n&#x2F;&#x2F; 2. 调用栈\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nfunction bar() &#123;\n  return sum(20, 30);\n&#125;\n\nconsole.log(bar());\n\n1.3. 浏览器的事件循环如果在执行JavaScript代码的过程中，有异步操作呢？\n\n中间我们插入了一个setTimeout的函数调用；\n这个函数被放到入调用栈中，执行会立即结束，并不会阻塞后续代码的执行；\n\nconst name &#x3D; &quot;coderwhy&quot;;\n\n&#x2F;&#x2F; 1.将该函数放入到调用栈中被执行\nconsole.log(name);\n\n&#x2F;&#x2F; 2.调用栈\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nfunction bar() &#123;\n  return sum(20, 30);\n&#125;\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;settimeout&quot;);\n&#125;, 1000);\n\nconst result &#x3D; bar();\n\nconsole.log(result);\n\n那么，传入的一个函数（比如我们称之为timer函数），会在什么时候被执行呢？\n\n事实上，setTimeout是调用了web api，在合适的时机，会将timer函数加入到一个事件队列中；\n事件队列中的函数，会被放入到调用栈中，在调用栈中被执行；\n\n浏览器的事件循环\n1.4. 宏任务和微任务但是事件循环中并非只维护着一个队列，事实上是有两个队列：\n\n宏任务队列（macrotask queue）：ajax、setTimeout、setInterval、DOM监听、UI Rendering等\n微任务队列（microtask queue）：Promise的then回调、 Mutation Observer API、queueMicrotask()等\n\n那么事件循环对于两个队列的优先级是怎么样的呢？\n\n1.main script中的代码优先执行（编写的顶层script代码）；\n\n2.在执行任何一个宏任务之前（不是队列，是一个宏任务），都会先查看微任务队列中是否有任务需要执行\n\n\n也就是宏任务执行之前，必须保证微任务队列是空的；\n\n\n如果不为空，那么就优先执行微任务队列中的任务（回调）；\n\n\n我们来看一个面试题：执行结果如何？\nsetTimeout(function () &#123;\n  console.log(&quot;set1&quot;);\n\n  new Promise(function (resolve) &#123;\n    resolve();\n  &#125;).then(function () &#123;\n    new Promise(function (resolve) &#123;\n      resolve();\n    &#125;).then(function () &#123;\n      console.log(&quot;then4&quot;);\n    &#125;);\n    console.log(&quot;then2&quot;);\n  &#125;);\n&#125;);\n\nnew Promise(function (resolve) &#123;\n  console.log(&quot;pr1&quot;);\n  resolve();\n&#125;).then(function () &#123;\n  console.log(&quot;then1&quot;);\n&#125;);\n\nsetTimeout(function () &#123;\n  console.log(&quot;set2&quot;);\n&#125;);\n\nconsole.log(2);\n\nqueueMicrotask(() &#x3D;&gt; &#123;\n  console.log(&quot;queueMicrotask1&quot;)\n&#125;);\n\nnew Promise(function (resolve) &#123;\n  resolve();\n&#125;).then(function () &#123;\n  console.log(&quot;then3&quot;);\n&#125;);\n\n执行结果：\npr1\n2\nthen1\nqueueMicrotask1\nthen3\nset1\nthen2\nthen4\nset2\n\nasync、await是Promise的一个语法糖：\n\n我们可以将await关键字后面执行的代码，看做是包裹在(resolve, reject) =&gt; &#123;函数执行&#125;中的代码；\nawait的下一条语句，可以看做是then(res =&gt; &#123;函数执行&#125;)中的代码；\n\n今日头条的面试题：\nasync function async1 () &#123;\n  console.log(&#39;async1 start&#39;)\n  await async2();\n  console.log(&#39;async1 end&#39;)\n&#125;\n \nasync function async2 () &#123;\n  console.log(&#39;async2&#39;)\n&#125;\n\nconsole.log(&#39;script start&#39;)\n \nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout&#39;)\n&#125;, 0)\n \nasync1();\n \nnew Promise (function (resolve) &#123;\n  console.log(&#39;promise1&#39;)\n  resolve();\n&#125;).then (function () &#123;\n  console.log(&#39;promise2&#39;)\n&#125;)\n\nconsole.log(&#39;script end&#39;)\n\n执行结果如下：\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n\nNode的事件循环2.1. Node的事件循环浏览器中的EventLoop是根据HTML5定义的规范来实现的，不同的浏览器可能会有不同的实现，而Node中是由libuv实现的。\n我们来看在很早就给大家展示的Node架构图：\n\n我们会发现libuv中主要维护了一个EventLoop和worker threads（线程池）；\nEventLoop负责调用系统的一些其他操作：文件的IO、Network、child-processes等\n\nNode的架构图\nlibuv到底是什么呢？\n\nlibuv is a multi-platform support library with a focus on asynchronous I&#x2F;O. It was primarily developed for use by Node.js, but it’s also used by Luvit, Julia, pyuv, and others.\nlibuv是一个多平台的专注于异步IO的库，它最初是为Node开发的，但是现在也被使用到Luvit、Julia、pyuv等其他地方；\n\nlibuv到底帮助我们做了什么事情呢？\n\n我们以文件操作为例，来讲解一下它内部的结构；\n\n2.2. 阻塞IO和非阻塞IO如果我们希望在程序中对一个文件进行操作，那么我们就需要打开这个文件：通过文件描述符。\n\n我们思考：JavaScript可以直接对一个文件进行操作吗？\n看起来是可以的，但是事实上我们任何程序中的文件操作都是需要进行系统调用（操作系统封装了文件系统）；\n事实上对文件的操作，是一个操作系统的IO操作（输入、输出）；\n\n操作系统为我们提供了阻塞式调用和非阻塞式调用：\n\n阻塞式调用： 调用结果返回之前，当前线程处于阻塞态（阻塞态CPU是不会分配时间片的），调用线程只有在得到调用结果之后才会继续执行。\n非阻塞式调用： 调用执行之后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。\n\n所以我们开发中的很多耗时操作，都可以基于这样的 非阻塞式调用：\n\n比如网络请求本身使用了Socket通信，而Socket本身提供了select模型，可以进行非阻塞方式的工作；\n比如文件读写的IO操作，我们可以使用操作系统提供的基于事件的回调机制；\n\n但是非阻塞IO也会存在一定的问题：我们并没有获取到需要读取（我们以读取为例）的结果\n\n那么就意味着为了可以知道是否读取到了完整的数据，我们需要频繁的去确定读取到的数据是否是完整的；\n这个过程我们称之为轮训操作；\n\n那么这个轮训的工作由谁来完成呢？\n\n如果我们的主线程频繁的去进行轮训的工作，那么必然会大大降低性能；\n并且开发中我们可能不只是一个文件的读写，可能是多个文件；\n而且可能是多个功能：网络的IO、数据库的IO、子进程调用；\n\nlibuv提供了一个线程池（Thread Pool）：\n\n线程池会负责所有相关的操作，并且会通过轮训等方式等待结果；\n当获取到结果时，就可以将对应的回调放到事件循环（某一个事件队列）中；\n事件循环就可以负责接管后续的回调工作，告知JavaScript应用程序执行对应的回调函数；\n\nEvent loop in node.js\n阻塞和非阻塞，同步和异步有什么区别？\n\n阻塞和非阻塞是对于被调用者来说的；\n\n\n在我们这里就是系统调用，操作系统为我们提供了阻塞调用和非阻塞调用；\n\n\n同步和异步是对于调用者来说的；\n\n\n在我们这里就是自己的程序；\n\n\n如果我们在发起调用之后，不会进行其他任何的操作，只是等待结果，这个过程就称之为同步调用；\n\n如果我们再发起调用之后，并不会等待结果，继续完成其他的工作，等到有回调时再去执行，这个过程就是异步调用；\n\n\n2.3. Node事件循环的阶段我们最前面就强调过，事件循环像是一个桥梁，是连接着应用程序的JavaScript和系统调用之间的通道：\n\n无论是我们的文件IO、数据库、网络IO、定时器、子进程，在完成对应的操作后，都会将对应的结果和回调函数放到事件循环（任务队列）中；\n事件循环会不断的从任务队列中取出对应的事件（回调函数）来执行；\n\n但是一次完整的事件循环Tick分成很多个阶段：\n\n定时器（Timers）：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。\n待定回调（Pending Callback）：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到ECONNREFUSED。\nidle, prepare：仅系统内部使用。\n轮询（Poll）：检索新的 I&#x2F;O 事件；执行与 I&#x2F;O 相关的回调；\n检测：setImmediate() 回调函数在这里执行。\n关闭的回调函数：一些关闭的回调函数，如：socket.on(&#39;close&#39;, ...)。\n\n一次tick的事件循环阶段\n我们会发现从一次事件循环的Tick来说，Node的事件循环更复杂，它也分为微任务和宏任务：\n\n宏任务（macrotask）：setTimeout、setInterval、IO事件、setImmediate、close事件；\n微任务（microtask）：Promise的then回调、process.nextTick、queueMicrotask；\n\n但是，Node中的事件循环不只是 微任务队列和 宏任务队列：\n\n微任务队列：\n\n\nnext tick queue：process.nextTick；\n\n\nother queue：Promise的then回调、queueMicrotask；\n\n宏任务队列：\n\n\ntimer queue：setTimeout、setInterval；\n\n\npoll queue：IO事件；\n\ncheck queue：setImmediate；\n\nclose queue：close事件；\n\n\n所以，在每一次事件循环的tick中，会按照如下顺序来执行代码：\n\nnext tick microtask queue；\nother microtask queue；\ntimer queue；\npoll queue；\ncheck queue；\nclose queue；\n\n2.4. Node代码执行面试面试题一：\nasync function async1() &#123;\n  console.log(&#39;async1 start&#39;)\n  await async2()\n  console.log(&#39;async1 end&#39;)\n&#125;\n\nasync function async2() &#123;\n  console.log(&#39;async2&#39;)\n&#125;\n\nconsole.log(&#39;script start&#39;)\n\nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout0&#39;)\n&#125;, 0)\n\nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout2&#39;)\n&#125;, 300)\n\nsetImmediate(() &#x3D;&gt; console.log(&#39;setImmediate&#39;));\n\nprocess.nextTick(() &#x3D;&gt; console.log(&#39;nextTick1&#39;));\n\nasync1();\n\nprocess.nextTick(() &#x3D;&gt; console.log(&#39;nextTick2&#39;));\n\nnew Promise(function (resolve) &#123;\n  console.log(&#39;promise1&#39;)\n  resolve();\n  console.log(&#39;promise2&#39;)\n&#125;).then(function () &#123;\n  console.log(&#39;promise3&#39;)\n&#125;)\n\nconsole.log(&#39;script end&#39;)\n\n执行结果如下：\nscript start\nasync1 start\nasync2\npromise1\npromise2\nscript end\nnextTick\nasync1 end\npromise3\n\nsetTimeout0\nsetImmediate\nsetTimeout2\n\n面试题二：\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimeout&quot;);\n&#125;, 0);\n\nsetImmediate(() &#x3D;&gt; &#123;\n  console.log(&quot;setImmediate&quot;);\n&#125;);\n\n执行结果：\n情况一：\nsetTimeout\nsetImmediate\n\n情况二：\nsetImmediate\nsetTimeout\n\n为什么会出现不同的情况呢？\n\n在Node源码的deps&#x2F;uv&#x2F;src&#x2F;timer.c中141行，有一个 uv__next_timeout的函数；\n这个函数决定了，poll阶段要不要阻塞在这里；\n阻塞在这里的目的是当有异步IO被处理时，尽可能快的让代码被执行；\n\nint uv__next_timeout(const uv_loop_t* loop) &#123;\n  const struct heap_node* heap_node;\n  const uv_timer_t* handle;\n  uint64_t diff;\n\n  &#x2F;&#x2F; 计算距离当前时间节点最小的计时器\n  heap_node &#x3D; heap_min(timer_heap(loop));\n  &#x2F;&#x2F; 如果为空, 那么返回-1,表示为阻塞状态\n  if (heap_node &#x3D;&#x3D; NULL)\n    return -1; &#x2F;* block indefinitely *&#x2F;\n\n  &#x2F;&#x2F; 如果计时器的时间小于当前loop的开始时间, 那么返回0\n  &#x2F;&#x2F; 继续执行后续阶段, 并且开启下一次tick\n  handle &#x3D; container_of(heap_node, uv_timer_t, heap_node);\n  if (handle-&gt;timeout &lt;&#x3D; loop-&gt;time)\n    return 0;\n\n  &#x2F;&#x2F; 如果不大于loop的开始时间, 那么会返回时间差\n  diff &#x3D; handle-&gt;timeout - loop-&gt;time;\n  if (diff &gt; INT_MAX)\n    diff &#x3D; INT_MAX;\n\n  return (int) diff;\n&#125;\n\n和上面有什么关系呢？\n\n情况一：如果事件循环开启的时间(ms)是小于 setTimeout函数的执行时间的；\n\n\n也就意味着先开启了event-loop，但是这个时候执行到timer阶段，并没有定时器的回调被放到入 timer queue中；\n\n\n所以没有被执行，后续开启定时器和检测到有setImmediate时，就会跳过poll阶段，向后继续执行；\n\n这个时候是先检测 setImmediate，第二次的tick中执行了timer中的 setTimeout；\n\n情况二：如果事件循环开启的时间(ms)是大于 setTimeout函数的执行时间的；\n\n\n这就意味着在第一次 tick中，已经准备好了timer queue；\n\n\n所以会直接按照顺序执行即可；\n\n\n","slug":"node/base/Node基础八","date":"2022-10-01T04:28:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"9cc987ed6425e4445f09c1cfe9b13abf","title":"Node基础七","content":"七.脚手架开发目前前端工程化开发过程中，我们会使用各种各样的脚手架，vue-cli、create-react-app，当然也包括webpack、gulp、rollup、vite等工具。\n这些工具是怎么开发出来的呢？当我们执行一个命令时，它们做了什么事情？是怎么样完成的一系列操作？\n这里我开发了一个coderwhy的脚手架：一个帮助你快速搭建和开发前端项目的CLI。\n文档内容分成两部分：\n第一部分：coderwhy使用说明；\n第二部分：coderwhy脚手架开发过程；\n如何安装？\nnpm install coderwhy -g\n\n使用说明一. 创建项目目前支持Vue，后期会支持React，Angular考虑中~\nvue项目模块已经帮你配置：\n\n常用的目录结构（你可以在此基础上修改）\nvue.config.js（其中配置了别名，你可以自行修改和配置更多）\naxios（网络请求axios的安装以及二次封装）\nvue-router（router的安装和配置，另外有路由的动态加载，后面详细说明）\nvuex（vuex的安装和配置，另外有动态加载子模块，后面详细说明）\n\n创建项目\ncoderwhy create your_project_name\n\n自动拉取项目模板、安装项目依赖、打开浏览器 http://localhost:8080/、自动启动项目\n二. 项目开发项目开发目前提供三个功能：\n\n创建Vue组件\n创建Vue页面，并配置路由\n创建Vuex子模块\n\n2.1. 创建Vue组件：coderwhy addcpn YourComponentName # 例如coderwhy add NavBar，默认会存放到src&#x2F;components文件夹中\ncoderwhy addcpn YourComponentName -d src&#x2F;pages&#x2F;home # 也可以指定存放的具体文件夹\n\n2.2. 创建Vue页面，并配置路由coderwhy addpage YourPageName # 例如coderwhy addpage Home，默认会放到src&#x2F;pages&#x2F;home&#x2F;Home.vue中，并且会创建src&#x2F;page&#x2F;home&#x2F;router.js\ncoderwhy addpage YourPageName -d src&#x2F;views # 也可以指定文件夹，但需要手动集成路由\n\n为什么会创建router.js文件：\n\nrouter.js文件是路由的其中一个配置；\n创建该文件中 src/router/index.js中会自动加载到路由的 routes配置中，不需要手动配置了（如果是自己配置的文件夹需要手动配置）\n\nsrc/router/index.js中已经完成如下操作：\n&#x2F;&#x2F; 动态加载pages中所有的路由文件\nconst files &#x3D; require.context(&#39;@&#x2F;pages&#39;, true, &#x2F;router\\.js$&#x2F;);\nconst routes &#x3D; files.keys().map(key &#x3D;&gt; &#123;\n  const page &#x3D; require(&#39;@&#x2F;pages&#39; + key.replace(&#39;.&#39;, &#39;&#39;));\n  return page.default;\n&#125;)\n\n2.3. 创建Vuex子模块coderwhy addstore YourVuexChildModuleName # 例如coderwhy addstore home，默认会放到src&#x2F;store&#x2F;modules&#x2F;home&#x2F;index.js和types.js\ncoderwhy addstore YourVuexChildModuleName -d src&#x2F;vuex&#x2F;modules # 也可以指定文件夹\n\n创建完成后，不需要手动配置，已经动态将所有子模块集成进去：\n&#x2F;&#x2F; 动态加载modules\nconst modules &#x3D; &#123;&#125;\nconst files &#x3D; require.context(&#39;.&#x2F;&#39;, true, &#x2F;index\\.js$&#x2F;);\nfiles.keys().filter(key &#x3D;&gt; &#123;\n  if (key &#x3D;&#x3D;&#x3D; &#39;.&#x2F;index.js&#39;) return false;\n  return true\n&#125;).map(key &#x3D;&gt; &#123;  \n  &#x2F;&#x2F; 获取名字\n  const modulePath &#x3D; key.replace(&#39;.&#x2F;modules&#x2F;&#39;, &#39;&#39;);\n  const moduleName &#x3D; modulePath.replace(&#39;&#x2F;index.js&#39;, &#39;&#39;);\n  const module &#x3D; require(&#96;$&#123;key&#125;&#96;);\n\n  modules[&#96;$&#123;moduleName&#125;&#96;] &#x3D; module.default;\n&#125;)\n\n脚手架开发过程一. 创建文件创建index.js\nconsole.log(&quot;Hello Coderwhy&quot;)\n\n创建package.json\n&#123;\n  &quot;name&quot;: &quot;coderwhy&quot;,\n  &quot;version&quot;: &quot;1.1.0&quot;,\n  &quot;description&quot;: &quot;CLI front-end development tools&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;bin&quot;: &#123;\n    &quot;coderwhy&quot;: &quot;index.js&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [\n    &quot;vue&quot;,\n    &quot;react&quot;,\n    &quot;CLI&quot;,\n    &quot;component&quot;\n  ],\n  &quot;author&quot;: &quot;coderwhy&quot;,\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;,\n  &quot;repository&quot;: &#123;\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;chalk&quot;: &quot;^4.1.0&quot;,\n    &quot;commander&quot;: &quot;^6.1.0&quot;,\n    &quot;download-git-repo&quot;: &quot;^3.0.2&quot;,\n    &quot;ejs&quot;: &quot;^3.1.5&quot;,\n    &quot;open&quot;: &quot;^7.3.0&quot;\n  &#125;\n&#125;\n\n最终的目录结构：\n├── LICENSE\n├── index.js\n├── lib\n│   ├── config\n│   │   └── repo_config.js\n│   ├── core\n│   │   ├── actions.js\n│   │   ├── create.js\n│   │   └── help.js\n│   ├── template\n│   │   ├── component.vue.ejs\n│   │   ├── vue-router.js.ejs\n│   │   ├── vue-store.js.ejs\n│   │   └── vue-types.js.ejs\n│   └── utils\n│       ├── file.js\n│       ├── log.js\n│       └── terminal.js\n├── package-lock.json\n├── package.json\n└── readme.md\n\n二. 创建coderwhy的命令自动在你的环境变量中查找node\n注意：必须放在第一行\n#!&#x2F;usr&#x2F;bin&#x2F;env node\n\n修改package.json\n&quot;bin&quot;: &#123;\n  &quot;coderwhy&quot;: &quot;index.js&quot;\n&#125;\n\n执行npm link\n三. commander用法3.1. 定义版本号#!&#x2F;usr&#x2F;bin&#x2F;env node\nconst cmd &#x3D; require(&#39;commander&#39;);\n&#x2F;&#x2F; 定义显示模块的版本号\ncmd.version(require(&#39;.&#x2F;package.json&#39;).version);\n&#x2F;&#x2F; 解析终端指令\ncmd.parse(process.argv);\n\n3.2. 给help增加其他选项添加单个选项\nprogram.option(&#39;-s --src &lt;src&gt;&#39;, &#39;a source folder&#39;);\nprogram.option(&#39;-d --dest &lt;dest&gt;&#39;, &#39;a destination folder&#39;);\nprogram.option(&#39;-f --framework &lt;framework&gt;&#39;, &#39;your framework name&#39;);\n\n监听help指令\nprogram.on(&#39;--help&#39;, function() &#123;\n  console.log(&quot;&quot;);\n  console.log(&quot;usage&quot;);\n  console.log(&quot;   coderwhy -v&quot;);\n  console.log(&quot;   coderwhy -version&quot;);\n&#125;)\n\n四. 创建项目指令&#x2F;&#x2F; 创建命令\nprogram\n  .command(&#39;create &lt;project&gt; [otherArgs...]&#39;)\n  .description(&#39;clone a repository into a newly created directory&#39;)\n  .action((project, otherArgs) &#x3D;&gt; &#123;\n    console.log(project);\n    console.log(otherArgs);\n   &#x2F;&#x2F; 调用封装的函数\n   createProject(project, otherArgs)\n  &#125;)\n\n在actions中封装创建过程：\nconst downloadRepo &#x3D; promisify(require(&#39;download-git-repo&#39;));\n\nconst createProject &#x3D; async (project, otherArg) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 1.提示信息\n  console.log(&#39;coderwhy helps you create your project, please wait a moment~&#39;);\n\n  &#x2F;&#x2F; 2.clone项目从仓库\n  await downloadRepo(repoConfig.vueGitRepo, project, &#123; clone: true &#125;);\n\n  &#x2F;&#x2F; 3.执行终端命令npm install\n  &#x2F;&#x2F; terminal.exec(&#39;npm install&#39;, &#123;cwd: &#96;.&#x2F;$&#123;project&#125;&#96;&#125;);\n  const npm &#x3D; process.platform &#x3D;&#x3D;&#x3D; &#39;win32&#39; ? &#39;npm.cmd&#39; : &#39;npm&#39;;\n  await terminal.spawn(npm, [&#39;install&#39;], &#123; cwd: &#96;.&#x2F;$&#123;project&#125;&#96; &#125;);\n\n  &#x2F;&#x2F; 4.打开浏览器\n  open(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;&#39;);\n\n  &#x2F;&#x2F; 5.运行项目\n  await terminal.spawn(npm, [&#39;run&#39;, &#39;serve&#39;], &#123; cwd: &#96;.&#x2F;$&#123;project&#125;&#96; &#125;);\n&#125;\n\n配置的Git地址如下：\n\n后续会开发一个设置自己地址的指令\n\nconst vueGitRepo &#x3D; &quot;direct:https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;hy-vue-temp.git&quot;;\n\nmodule.exports &#x3D; &#123;\n  vueGitRepo\n&#125;\n\n封装执行终端命令的过程：\nconst &#123; spawn, exec &#125; &#x3D; require(&#39;child_process&#39;);\n\nconst spawnCommand &#x3D; (...args) &#x3D;&gt; &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    const childProcess &#x3D; spawn(...args);\n    childProcess.stdout.pipe(process.stdout);\n    childProcess.stderr.pipe(process.stderr);\n    childProcess.on(&#39;close&#39;, () &#x3D;&gt; &#123;\n      resolve();\n    &#125;);\n  &#125;)\n&#125;\n\nprocess和child_process使用process在Node.js中每个应用程序都是一个进程类的实例对象。使用process对象代表应用程序,这是一个全局对象，可以通过它来获取Node.jsy应用程序以及运行该程序的用户、环境等各种信息的属性、方法和事件\n进程中几个重要的属性\nstdin 标准输入可读流\nstdout 标准输入可写流\nstderr 标准错误输出流\nargv 终端输入参数数组\nenv 操作系统环境信息\npid 应用程序进程id\n\n进程方法\nprocess.memoryUsage() 查看内存使用信息\nprocess.nextTick() 当前eventloop执行完毕执行回调函数\nprocess.chdir() chdir方法用于修改Node.js应用程序中使用的当前工作目录\nprocess.cwd() 进程当前工作目录\nprocess.kill() 杀死进程\nprocess.uncaughtException() 当应用程序抛出一个未被捕获的异常时触发进程对象的uncaughtException事件\n\nchild_process在Node.js中，提供了一个child_process模块,通过它可以开启多个子进程，在多个子进程之间可以共享内存空间，可以通过子进程的互相通信来实现信息的交换,child_process模块给予node任意创建子进程的能力，node官方文档对于child_proces模块给出了四种方法，映射到操作系统其实都是创建子进程。但对于开发者而已，这几种方法的api有点不同\nchild_process.exec(command[, options][, callback]) 启动子进程来执行shell命令,可以通过回调参数来获取脚本shell执行结果\nchild_process.execfile(file[, args][, options][, callback]) 与exec类型不同的是，它执行的不是shell命令而是一个可执行文件\nchild_process.spawn(command[, args][, options])仅仅执行一个shell命令，不需要获取执行结果\\\nchild_process.fork(modulePath[, args][, options]) 可以用node执行的.js文件，也不需要获取执行结果。fork出来的子进程一定是node进程\n\n&#x2F;&#x2F;exec用法:\n&#x2F;&#x2F;执行shell脚本, 使用管道符也是可以的\n&#x2F;&#x2F;exec也是可以执行文件的，只不过不能传参数\n&#x2F;&#x2F;适合开销比较小的任务\nconst cp &#x3D; require(&#39;child_process&#39;)\ncp.exec(&#39;ls -al|grep node_modules&#39;, &#123; \n  timeout: 0, &#x2F;&#x2F; 超时时间\n  cwd: process.cwd(), &#x2F;&#x2F; 可以改变当前的执行路径\n  &#125;, function (err, stdout, stderr) &#123;\n  &#x2F;&#x2F; 执行结果\n&#125;)\n\n&#x2F;&#x2F;execFile用法:\n&#x2F;&#x2F;可以执行文件，也可以执行语句，可传参\n&#x2F;&#x2F;适合开销比较小的任务\n&#x2F;&#x2F; 执行文件,参数\ncp.execFile(&#39;ls&#39;, [&#39;-al&#39;], function (err, stdout, std,err) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 执行结果\n&#125;)\n&#x2F;&#x2F; 让execFile执行ls -al|grep node_modules这种语句\n&#x2F;&#x2F;test.shell:\n  ls -al|grep node_modules\n  echo $1 &#x2F;&#x2F; 打印参数\n  echo $2\n&#x2F;&#x2F;index.js:\ncp.execFile(path.resolve(__dirname, &#39;test.shell&#39;), [&#39;-al&#39;, &#39;bl&#39;], \nfunction(err,   stdout, stderr) &#123;\n&#125;)\n\n&#x2F;&#x2F;fork用法\n&#x2F;&#x2F;用node执行, 耗时操作且用node实现，如下载文件\n\n&#x2F;&#x2F; cp.fork(模块路径)\n&#x2F;&#x2F; 和require一样把文件执行起来\nconst child &#x3D; cp.fork(path.resolve(__dirname, &#39;child_process_demo&#39;))\nconsole.log(process.pid)\n&#x2F;&#x2F; 主进程向子进程通信\nchild.send(&#39;hello child_process&#39;, () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; child.disconnent() &#x2F;&#x2F; 如果不断开，两边会出现等待的情况\n&#125;)\n&#x2F;&#x2F; 子进程向主进程通信\nchild.on(&#39;message&#39;, msg &#x3D;&gt; &#123;\n  \n&#125;)\n\n&#x2F;&#x2F; child_process_demo.js:\nconsole.log(&#39;aaa&#39;, process.pid)\nprocess.on(&#39;message&#39;, msg &#x3D;&gt; &#123;\n  console.log(msg)\n  &#x2F;&#x2F; 很容易出现死循环\n&#125;)\nprocess.send(&#39;send msg to parent&#39;)\n&#x2F;&#x2F; 进程不一样,完全独立，本质也是调用spawn\n\n\n&#x2F;&#x2F;spawn 用法\n&#x2F;&#x2F;spawn: 流式的，没有回调，适合耗时任务(比如：npm install), 需要不断打印日志(不断给用户输出日志\ncp.spawn(file, args, options) &#x2F;&#x2F; 不支持回调, exec,execFile底层都是spwan\nconst childProcess &#x3D; cp.spawn(path.resolve(__dirname, &#39;test.shell&#39;), [&#39;-al&#39;, &#39;-bl&#39;], &#123;\n  cwd: path.resolve(&#39;..&#39;),\n&#125;) &#x2F;&#x2F; 返回的是子进程\nconsole.log(childProcess.pid, childProcess.pid)\n&#x2F;&#x2F; 监听成功\nchildProcess.stdout.on(&#39;data&#39;, function(chunk) &#123;\n  console.log(chunk.toString())\n&#125;)\n&#x2F;&#x2F; 监听失败\nchildProcess.stderr.on(&#39;data&#39;, function(chunk) &#123;\n  console.log(chunk.toString())\n&#125;)\n\nconst code &#x3D; &#96;require(&#39;$&#123;rootFile&#125;&#39;).call(null, $&#123;JSON.stringify(args)&#125;)&#96;\n &#x2F;&#x2F; cp.spawn(&#39;cmd&#39;, [&#39;&#x2F;c&#39;, &#39;node&#39;, &#39;-e&#39;, code]) &#x2F;&#x2F; win下是这种结构\n const childProcess &#x3D; spawn(&#39;node&#39;, [&#39;-e&#39;, code], &#123;\n   cwd: process.cwd(), &#x2F;&#x2F; 当前执行未知的cwd\n   stdio: &#39;inherit&#39;, &#x2F;&#x2F; 默认是pipe,pipe必须通过on来接收信息，inherit不需要，实时反馈\n &#125;)\n childProcess.on(&#39;error&#39;, e &#x3D;&gt; &#123;\n   log.error(e.message)\n   process.exit(1)\n &#125;)\nchildProcess.on(&#39;exit&#39;, e &#x3D;&gt; &#123;\n  log.verbose(&#39;命令执行成功&#39;, e)\n  process.exit(e)\n&#125;)\n\n\n\n五. 添加组件指令5.1. 封装ejs模板组件模块如下：\n&lt;%_ if(data) &#123; _%&gt;\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&lt;%&#x3D; data.lowerName %&gt;&quot;&gt;\n    &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n  export default &#123;\n    name: &quot;&lt;%&#x3D; data.name %&gt;&quot;,\n    components: &#123;\n\n    &#125;,\n    mixins: [],\n    props: &#123;\n\n    &#125;,\n    data: function() &#123;\n      return &#123;\n        message: &quot;Hello &lt;%&#x3D; data.name %&gt;&quot;\n      &#125;\n    &#125;,\n    created: function() &#123;\n\n    &#125;,\n    mounted: function() &#123;\n\n    &#125;,\n    computed: &#123;\n\n    &#125;,\n    methods: &#123;\n\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n  .&lt;%&#x3D; data.lowerName %&gt; &#123;\n    \n  &#125;\n&lt;&#x2F;style&gt;\n\n&lt;%_ &#125; _%&gt;\n\n路由模板：\n\n组件模板，直接使用上面的即可\nrouter.js模板\n\n&lt;%_ if (data) &#123; _%&gt;\n&#x2F;&#x2F; 普通加载路由\n&#x2F;&#x2F; import &lt;%&#x3D; data.name %&gt; from &#39;.&#x2F;&lt;%&#x3D; data.name %&gt;.vue&#39;\n&#x2F;&#x2F; 懒加载路由\nconst &lt;%&#x3D; data.name %&gt; &#x3D; () &#x3D;&gt; import(&#39;.&#x2F;&lt;%&#x3D; data.name %&gt;.vue&#39;)\nexport default &#123;\n  path: &#39;&#x2F;&lt;%&#x3D; data.lowerName %&gt;&#39;,\n  name: &#39;&lt;%&#x3D; data.name %&gt;&#39;,\n  component: &lt;%&#x3D; data.name %&gt;,\n  children: [\n  ]\n&#125;\n&lt;%_ &#125; _%&gt;\n\nvuex模块的模板\n\nindex.js模板\ntypes.js模板\n\nindex.js模块\nimport * as types from &#39;.&#x2F;types.js&#39;\nexport default &#123;\n  namespaced: true,\n  state: &#123;\n  &#125;,\n  mutations: &#123;\n  &#125;,\n  actions: &#123;\n  &#125;,\n  getters: &#123;\n  &#125;\n&#125;\n\ntypes.js模块\nexport &#123;\n  \n&#125;\n\n5.2. 封装ejs解析封装ejs的编译过程：\nconst ejsCompile &#x3D; (templatePath, data&#x3D;&#123;&#125;, options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    ejs.renderFile(templatePath, &#123;data&#125;, options, (err, str) &#x3D;&gt; &#123;\n      if (err) &#123;\n        reject(err);\n        return;\n      &#125;\n      resolve(str);\n    &#125;)\n  &#125;)\n&#125;\n\n封装创建文件夹的过程：\nconst mkdirSync &#x3D; (dirname) &#x3D;&gt; &#123;\n  if (fs.existsSync(dirname)) &#123;\n    return true\n  &#125; else &#123;\n    &#x2F;&#x2F; 不存在,判断父亲文件夹是否存在？\n    if (mkdirSync(path.dirname(dirname))) &#123;\n      &#x2F;&#x2F; 存在父亲文件，就直接新建该文件\n      fs.mkdirSync(dirname)\n      return true\n    &#125;\n  &#125;\n&#125;\n\n封装写入文件的过程：\nconst writeFile &#x3D; (path, content) &#x3D;&gt; &#123;\n  if (fs.existsSync(path)) &#123;\n    log.error(&quot;the file already exists~&quot;)\n    return;\n  &#125;\n  return fs.promises.writeFile(path, content);\n&#125;\n\n封装ejs到文件的转化过程：\nconst handleEjsToFile &#x3D; async (name, dest, template, filename) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 1.获取模块引擎的路径\n  const templatePath &#x3D; path.resolve(__dirname, template);\n  const result &#x3D; await ejsCompile(templatePath, &#123;name, lowerName: name.toLowerCase()&#125;);\n\n  &#x2F;&#x2F; 2.写入文件中\n  &#x2F;&#x2F; 判断文件不存在,那么就创建文件\n  mkdirSync(dest);\n  const targetPath &#x3D; path.resolve(dest, filename);\n  writeFile(targetPath, result);\n&#125;\n\n5.3. 创建添加指令添加指令\nprogram\n  .command(&#39;addcpn &lt;name&gt;&#39;)\n  .description(&#39;add vue component, 例如: coderwhy addcpn NavBar [-d src&#x2F;components]&#39;)\n  .action(name &#x3D;&gt; addComponent(name, program.dest || &#39;src&#x2F;components&#39;))\n\nprogram\n  .command(&#39;addpage &lt;name&gt;&#39;)\n  .description(&#39;add vue page, 例如: coderwhy addpage Home [-d dest]&#39;)\n  .action(name &#x3D;&gt; &#123;\n  addPage(name, program.dest || &#96;src&#x2F;pages&#x2F;$&#123;name.toLowerCase()&#125;&#96;)\n&#125;)\n\nprogram\n  .command(&#39;addstore &lt;name&gt;&#39;)\n  .description(&#39;add vue store, 例如: coderwhy addstore favor [-d dest]&#39;)\n  .action(name &#x3D;&gt; &#123;\n  addStore(name, program.dest || &#96;src&#x2F;store&#x2F;modules&#x2F;$&#123;name.toLowerCase()&#125;&#96;)\n&#125;)\n\n封装对应的action\nconst addComponent &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;component.vue.ejs&#39;, &#96;$&#123;name&#125;.vue&#96;);\n&#125;\n\nconst addPage &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  addComponent(name, dest);\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-router.js.ejs&#39;, &#39;router.js&#39;)\n&#125;\n\nconst addStore &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-store.js.ejs&#39;, &#39;index.js&#39;)\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-types.js.ejs&#39;, &#39;types.js&#39;)\n&#125;\n\n六. 发布工具注册npm账号：\n\nhttps://www.npmjs.com/\n选择sign up\n\nsign up注册\n在命令行登录：\nnpm login\n# 输入账号、密码、邮箱\n\n修改好package.json文件：\n&quot;keywords&quot;: [\n  &quot;vue&quot;,\n  &quot;react&quot;,\n  &quot;CLI&quot;,\n  &quot;component&quot;\n],\n&quot;author&quot;: &quot;coderwhy&quot;,\n&quot;license&quot;: &quot;MIT&quot;,\n&quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;,\n&quot;repository&quot;: &#123;\n  &quot;type&quot;: &quot;git&quot;,\n  &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;\n&#125;,\n\n发布到npm registry中\nnpm publish\n\n更新registry\n# 1.修改版本号(最好符合semver规范)\n# 2.重新发布\n\n删除发布的包：\nnpm unpublish\n\n过期发布的包：\nnpm deprecate\n","slug":"node/base/Node基础七","date":"2022-10-01T04:27:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"2625758c12baaaa025e1a25440bca02f","title":"Node基础六","content":"六.Buffer的使用1.1. 数据的二进制计算机中所有的内容：文字、数字、图片、音频、视频最终都会使用二进制来表示。\nJavaScript可以直接去处理非常直观的数据：比如字符串，我们通常展示给用户的也是这些内容。\n不对啊，JavaScript不是也可以处理图片吗？\n\n事实上在网页端，图片我们一直是交给浏览器来处理的；\nJavaScript或者HTML，只是负责告诉浏览器一个图片的地址；\n浏览器负责获取这个图片，并且最终将这个图片渲染出来；\n\n但是对于服务器来说是不一样的：\n\n服务器要处理的本地文件类型相对较多;\n比如某一个保存文本的文件并不是使用 utf-8进行编码的，而是用 GBK，那么我们必须读取到他们的二进制数据，再通过GKB转换成对应的文字；\n比如我们需要读取的是一张图片数据（二进制），再通过某些手段对图片数据进行二次的处理（裁剪、格式转换、旋转、添加滤镜），Node中有一个Sharp的库，就是读取图片或者传入图片的Buffer对其再进行处理；\n比如在Node中通过TCP建立长连接，TCP传输的是字节流，我们需要将数据转成字节再进行传入，并且需要知道传输字节的大小（客服端需要根据大小来判断读取多少内容）；\n\n我们会发现，对于前端开发来说，通常很少会和二进制打交道，但是对于服务器端为了做很多的功能，我们必须直接去操作其二进制的数据；\n所以Node为了可以方便开发者完成更多功能，提供给了我们一个类Buffer，并且它是全局的。\n1.2. Buffer和二进制我们前面说过，Buffer中存储的是二进制数据，那么到底是如何存储呢？\n\n我们可以将Buffer看成是一个存储二进制的数组；\n这个数组中的每一项，可以保存8位二进制：00000000\n\n为什么是8位呢？\n\n在计算机中，很少的情况我们会直接操作一位二进制，因为一位二进制存储的数据是非常有限的；\n所以通常会将8位合在一起作为一个单元，这个单元称之为一个字节（byte）；\n也就是说 1byte = 8bit，1kb=1024byte，1M=1024kb;\n比如很多编程语言中的int类型是4个字节，long类型是8个字节；\n比如TCP传输的是字节流，在写入和读取时都需要说明字节的个数；\n比如RGB的值分别都是255，所以本质上在计算机中都是用一个字节存储的；\n\n也就是说，Buffer相当于是一个字节的数组，数组中的每一项对于一个字节的大小：\n如果我们希望将一个字符串放入到Buffer中，是怎么样的过程呢？\nconst buffer01 &#x3D; new Buffer(&quot;why&quot;);\n\nconsole.log(buffer01);\n\n字符串存储buffer的过程\n当然目前已经不希望我们这样来做了：\nVSCode的警告\n那么我们可以通过另外一个创建方法：\nconst buffer2 &#x3D; Buffer.from(&quot;why&quot;);\nconsole.log(buffer2);\n\n如果是中文呢？\nconst buffer3 &#x3D; Buffer.from(&quot;王红元&quot;);\nconsole.log(buffer3);\n&#x2F;&#x2F; &lt;Buffer e7 8e 8b e7 ba a2 e5 85 83&gt;\nconst str &#x3D; buffer3.toString();\nconsole.log(str);\n&#x2F;&#x2F; 王红元\n\n如果编码和解码不同：\nconst buffer3 &#x3D; Buffer.from(&quot;王红元&quot;, &#39;utf16le&#39;);\nconsole.log(buffer3);\n\nconst str &#x3D; buffer3.toString(&#39;utf8&#39;);\nconsole.log(str); &#x2F;&#x2F; �s�~CQ\n\nBuffer其他用法2.1. Buffer的其他创建Buffer的创建方式有很多：\nbuffer的创建\n来看一下Buffer.alloc:\n\n我们会发现创建了一个8位长度的Buffer，里面所有的数据默认为00；\n\nconst buffer01 &#x3D; Buffer.alloc(8);\n\nconsole.log(buffer01); &#x2F;&#x2F; &lt;Buffer 00 00 00 00 00 00 00 00&gt;\n\n我们也可以对其进行操作：\nbuffer01[0] &#x3D; &#39;w&#39;.charCodeAt();\nbuffer01[1] &#x3D; 100;\nbuffer01[2] &#x3D; 0x66;\nconsole.log(buffer01);\n\n也可以使用相同的方式来获取：\nconsole.log(buffer01[0]);\nconsole.log(buffer01[0].toString(16));\n\n2.2. Buffer和文件读取文本文件的读取：\nconst fs &#x3D; require(&#39;fs&#39;);\n\nfs.readFile(&#39;.&#x2F;test.txt&#39;, (err, data) &#x3D;&gt; &#123;\n  console.log(data); &#x2F;&#x2F; &lt;Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64&gt;\n  console.log(data.toString()); &#x2F;&#x2F; Hello World\n&#125;)\n\n图片文件的读取：\nfs.readFile(&#39;.&#x2F;zznh.jpg&#39;, (err, data) &#x3D;&gt; &#123;\n  console.log(data); &#x2F;&#x2F; &lt;Buffer ff d8 ff e0 ... 40418 more bytes&gt;\n&#125;);\n\n图片文件的读取和转换：\n\n将读取的某一张图片，转换成一张200x200的图片；\n这里我们可以借助于 sharp 库来完成；\n\nconst sharp &#x3D; require(&#39;sharp&#39;);\nconst fs &#x3D; require(&#39;fs&#39;);\n\nsharp(&#39;.&#x2F;test.png&#39;)\n  .resize(1000, 1000)\n  .toBuffer()\n  .then(data &#x3D;&gt; &#123;\n    fs.writeFileSync(&#39;.&#x2F;test_copy.png&#39;, data);\n  &#125;)\n\n2.3. buffer使用&#x2F;&#x2F;buffer与字符串转换\nBuffer.from(string[, encoding])\nbuf.toString([encoding[, start[, end]]])\n\n&#x2F;&#x2F;复制buffer\nBuffer.from(buf)\n\n&#x2F;&#x2F;ArrayBuffer转换到buffer arrayBuffer类型为TypedArray.buffer属性\nBuffer.from(arrayBuffer[, byteOffset[, length]])\n\n&#x2F;&#x2F;buffer 转 Uint8Array\nvar array &#x3D; new Uint8Array(buffer);\n&#x2F;&#x2F;Uint8Array 转 ArrayBuffer\nvar arraybuffer &#x3D; array.buffer;\n&#x2F;&#x2F;ArrayBuffer 转 Buffer\nvar bufferCopy &#x3D; Buffer.from(arraybuffer);\n&#x2F;&#x2F;ArrayBuffer 转 DataView \nvar view &#x3D; new DataView(arraybuffer)\n&#x2F;&#x2F;DataView 转 ArrrayBuffer\nvar arraybuffer2 &#x3D; view.buffer;\n\n2.4. Buffer 和 TypeArray，ArrayBuffer, Unit8ArrayTypedArray\n概念: TypedArray ES6中新出的一个接口, 不能直接被实例化, Uint8Array 就是实现 TypedArray 接口的一个子类\n子类有:\nInt8Array: 每个元素是8个二进制位(1个字节)的有符号整数\nUint8Array： 每个元素是8个二进制位(1个字节)的无符号整数\nInt16Array： 每个元素是16个二进制位(2个字节)的有符号整数\nUint16Array：每个元素是16个二进制位(2个字节)的无符号整数\nInt32Array： 每个元素是32个二进制位(4个字节)的有符号整数\nUint32Array： 每个元素是32个二进制位(4个字节)的无符号整数\n\n\nArrayBuffer\n概念: TypedArray 的作用是操作二进制数据, 其内部还有一个buffer属性, 这个buffer就是 ArrayBuffer 实例. ArrayBuffer 就存储了要操作的二进制数据,TypedArray 是一个操作二进制数据的接口, 内部的 ArrayBuffer 存储了要操作的二进制数据.\n\nUint8Array\n概念: 数组中的每一个元素都是 8个二进制位(1个字节)的无符号整数.无符号的含义是, 该二进制的首位不表示符号位. 而对于有符号的二进制位, \n\nBuffer\n概念: Node中才有, 继承自 Unit8array, 拥有更多强大的二进制数据操作.\n\nBuffer的内存分配事实上我们创建Buffer时，并不会频繁的向操作系统申请内存，它会默认先申请一个8 * 1024个字节大小的内存，也就是8kb\n\nnode&#x2F;lib&#x2F;buffer.js：135行\n\nBuffer.poolSize &#x3D; 8 * 1024;\nlet poolSize, poolOffset, allocPool;\n\nconst encodingsMap &#x3D; ObjectCreate(null);\nfor (let i &#x3D; 0; i &lt; encodings.length; ++i)\n  encodingsMap[encodings[i]] &#x3D; i;\n\nfunction createPool() &#123;\n  poolSize &#x3D; Buffer.poolSize;\n  allocPool &#x3D; createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset &#x3D; 0;\n&#125;\ncreatePool();\n\n假如我们调用Buffer.from申请Buffer：\n\n这里我们以从字符串创建为例\nnode&#x2F;lib&#x2F;buffer.js：290行\n\nBuffer.from &#x3D; function from(value, encodingOrOffset, length) &#123;\n  if (typeof value &#x3D;&#x3D;&#x3D; &#39;string&#39;)\n    return fromString(value, encodingOrOffset);\n \n &#x2F;&#x2F; 如果是对象，另外一种处理情况\n  &#x2F;&#x2F; ...\n&#125;;\n\n我们查看fromString的调用：\n\nnode&#x2F;lib&#x2F;buffer.js：428行\n\nfunction fromString(string, encoding) &#123;\n  let ops;\n  if (typeof encoding !&#x3D;&#x3D; &#39;string&#39; || encoding.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    if (string.length &#x3D;&#x3D;&#x3D; 0)\n      return new FastBuffer();\n    ops &#x3D; encodingOps.utf8;\n    encoding &#x3D; undefined;\n  &#125; else &#123;\n    ops &#x3D; getEncodingOps(encoding);\n    if (ops &#x3D;&#x3D;&#x3D; undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length &#x3D;&#x3D;&#x3D; 0)\n      return new FastBuffer();\n  &#125;\n  return fromStringFast(string, ops);\n&#125;\n\n接着我们查看fromStringFast：\n\n这里做的事情是判断剩余的长度是否还足够填充这个字符串；\n如果不足够，那么就要通过 createPool 创建新的空间；\n如果够就直接使用，但是之后要进行 poolOffset的偏移变化；\nnode&#x2F;lib&#x2F;buffer.js：428行\n\nfunction fromStringFast(string, ops) &#123;\n  const length &#x3D; ops.byteLength(string);\n\n  if (length &gt;&#x3D; (Buffer.poolSize &gt;&gt;&gt; 1))\n    return createFromString(string, ops.encodingVal);\n\n  if (length &gt; (poolSize - poolOffset))\n    createPool();\n  let b &#x3D; new FastBuffer(allocPool, poolOffset, length);\n  const actual &#x3D; ops.write(b, string, 0, length);\n  if (actual !&#x3D;&#x3D; length) &#123;\n    &#x2F;&#x2F; byteLength() may overestimate. That&#39;s a rare case, though.\n    b &#x3D; new FastBuffer(allocPool, poolOffset, actual);\n  &#125;\n  poolOffset +&#x3D; actual;\n  alignPool();\n  return b;\n&#125;\n\nStream4.1. 认识Stream什么是流呢？\n\n我们的第一反应应该是流水，源源不断的流动；\n程序中的流也是类似的含义，我们可以想象当我们从一个文件中读取数据时，文件的二进制（字节）数据会源源不断的被读取到我们程序中；\n而这个一连串的字节，就是我们程序中的流；\n\n所以，我们可以这样理解流：\n\n是连续字节的一种表现形式和抽象概念；\n流应该是可读的，也是可写的；\n\n在之前学习文件的读写时，我们可以直接通过 readFile或者 writeFile方式读写文件，为什么还需要流呢？\n\n直接读写文件的方式，虽然简单，但是无法控制一些细节的操作；\n比如从什么位置开始读、读到什么位置、一次性读取多少个字节；\n读到某个位置后，暂停读取，某个时刻恢复读取等等；\n或者这个文件非常大，比如一个视频文件，一次性全部读取并不合适；\n\n事实上Node中很多对象是基于流实现的：\n\nhttp模块的Request和Response对象；\nprocess.stdout对象；\n\n官方：另外所有的流都是EventEmitter的实例：\n我们可以看一下Node源码中有这样的操作：\n\nStream和EventEmitter关系\n流（Stream）的分类：\n\nWritable：可以向其写入数据的流（例如 fs.createWriteStream()）。\nReadable：可以从中读取数据的流（例如 fs.createReadStream()）。\nDuplex：同时为Readable和的流Writable（例如 net.Socket）。\nTransform：Duplex可以在写入和读取数据时修改或转换数据的流（例如zlib.createDeflate()）。\n\n这里我们通过fs的操作，讲解一下Writable、Readable，另外两个大家可以自行学习一下。\n4.2. Readable之前我们读取一个文件的信息：\nfs.readFile(&#39;.&#x2F;foo.txt&#39;, (err, data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)\n\n这种方式是一次性将一个文件中所有的内容都读取到程序（内存）中，但是这种读取方式就会出现我们之前提到的很多问题：\n\n文件过大、读取的位置、结束的位置、一次读取的大小；\n\n这个时候，我们可以使用 createReadStream，我们来看几个参数，更多参数可以参考官网：\n\nstart：文件读取开始的位置；\nend：文件读取结束的位置；\nhighWaterMark：一次性读取字节的长度，默认是64kb；\n\nconst read &#x3D; fs.createReadStream(&quot;.&#x2F;foo.txt&quot;, &#123;\n  start: 3,\n  end: 8,\n  highWaterMark: 4\n&#125;);\n\n我们如何获取到数据呢？\n\n可以通过监听data事件，获取读取到的数据；\n\nread.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;);\n\n我们也可以监听其他的事件：\nread.on(&#39;open&#39;, (fd) &#x3D;&gt; &#123;\n  console.log(&quot;文件被打开&quot;);\n&#125;)\n\nread.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件读取结束&quot;);\n&#125;)\n\nread.on(&#39;close&#39;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件被关闭&quot;);\n&#125;)\n\n甚至我们可以在某一个时刻暂停和恢复读取：\nread.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n  console.log(data);\n\n  read.pause();\n\n  setTimeout(() &#x3D;&gt; &#123;\n    read.resume();\n  &#125;, 2000);\n&#125;);\n\n4.3. Writable之前我们写入一个文件的方式是这样的：\nfs.writeFile(&#39;.&#x2F;foo.txt&#39;, &quot;内容&quot;, (err) &#x3D;&gt; &#123;\n  \n&#125;);\n\n这种方式相当于一次性将所有的内容写入到文件中，但是这种方式也有很多问题：\n\n比如我们希望一点点写入内容，精确每次写入的位置等；\n\n这个时候，我们可以使用 createWriteStream，我们来看几个参数，更多参数可以参考官网：\n\nflags：默认是w，如果我们希望是追加写入，可以使用 a或者 a+；\nstart：写入的位置；\n\n我们进行一次简单的写入\nconst writer &#x3D; fs.createWriteStream(&quot;.&#x2F;foo.txt&quot;, &#123;\n  flags: &quot;a+&quot;,\n  start: 8\n&#125;);\n\nwriter.write(&quot;你好啊&quot;, err &#x3D;&gt; &#123;\n  console.log(&quot;写入成功&quot;);\n&#125;);\n\n如果我们希望监听一些事件：\nwriter.on(&quot;open&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件打开&quot;);\n&#125;)\n\nwriter.on(&quot;finish&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件写入结束&quot;);\n&#125;)\n\nwriter.on(&quot;close&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件关闭&quot;);\n&#125;)\n\n我们会发现，我们并不能监听到 close 事件：\n\n这是因为写入流在打开后是不会自动关闭的；\n我们必须手动关闭，来告诉Node已经写入结束了；\n并且会发出一个 finish 事件的；\n\nwriter.close();\n\nwriter.on(&quot;finish&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件写入结束&quot;);\n&#125;)\n\nwriter.on(&quot;close&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件关闭&quot;);\n&#125;)\n\n另外一个非常常用的方法是 end：\n\nend方法相当于做了两步操作：write传入的数据和调用close方法；\n\nwriter.end(&quot;Hello World&quot;);\n\n4.4. pipe方法正常情况下，我们可以将读取到的 输入流，手动的放到 输出流中进行写入：\nconst fs &#x3D; require(&#39;fs&#39;);\nconst &#123; read &#125; &#x3D; require(&#39;fs&#x2F;promises&#39;);\n\nconst reader &#x3D; fs.createReadStream(&#39;.&#x2F;foo.txt&#39;);\nconst writer &#x3D; fs.createWriteStream(&#39;.&#x2F;bar.txt&#39;);\n\nreader.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n  console.log(data);\n  writer.write(data, (err) &#x3D;&gt; &#123;\n    console.log(err);\n  &#125;);\n&#125;);\n\n我们也可以通过pipe来完成这样的操作：\nreader.pipe(writer);\n\nwriter.on(&#39;close&#39;, () &#x3D;&gt; &#123;\n  console.log(&quot;输出流关闭&quot;);\n&#125;)\n","slug":"node/base/Node基础六","date":"2022-10-01T04:26:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"f31c41ff35acbf9aa56d10f7617b9f93","title":"Node基础五","content":"五.npm你不知道的细节1.1. 认识npm我们已经学习了在JavaScript中可以通过模块化的方式将代码划分成一个个小的结构：\n\n在以后的开发中我们就可以通过模块化的方式来封装自己的代码，并且封装成一个工具；\n这个工具我们可以让同事通过导入的方式来使用，甚至你可以分享给世界各地的程序员来使用；\n\n如果我们分享给世界上所有的程序员使用，有哪些方式呢？\n方式一：上传到GitHub上、其他程序员通过GitHub下载我们的代码手动的引用；\n\n缺点是大家必须知道你的代码GitHub的地址，并且从GitHub上手动下载；\n需要在自己的项目中手动的引用，并且管理相关的依赖；\n不需要使用的时候，需要手动来删除相关的依赖；\n当遇到版本升级或者切换时，需要重复上面的操作；\n\n显然，上面的方式是有效的，但是这种传统的方式非常麻烦，并且容易出错；\n方式二：使用一个专业的工具来管理我们的代码\n\n我们通过工具将代码发布到特定的位置；\n其他程序员直接通过工具来安装、升级、删除我们的工具代码；\n\n显然，通过第二种方式我们可以更好的管理自己的工具包，其他人也可以更好的使用我们的工具包。\n包管理工具npm：\n\nNode Package Manager，也就是Node包管理器；\n但是目前已经不仅仅是Node包管理器了，在前端项目中我们也在使用它来管理依赖的包；\n比如express、koa、react、react-dom、axios、babel、webpack等等；\n\nnpm管理的包可以在哪里查看、搜索呢？\n\nhttps://www.npmjs.com/\n这是我们安装相关的npm包的官网；\n\nnpm管理的包存放在哪里呢？\n\n我们发布自己的包其实是发布到registry上面的；\n当我们安装一个包时其实是从registry上面下载的包；\n\n1.2. 项目配置文件事实上，我们每一个项目都会有一个对应的配置文件，无论是前端项目还是后端项目：\n\n这个配置文件会记录着你项目的名称、版本号、项目描述等；\n也会记录着你项目所依赖的其他库的信息和依赖库的版本号；\n\n这个配置文件在Node环境下面（无论是前端还是后端）就是package.json。\n我们以vue cli4脚手架创建的项目为例：\n&#123;\n  &quot;name&quot;: &quot;my-vue&quot;,\n  &quot;version&quot;: &quot;0.1.0&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,\n    &quot;build&quot;: &quot;vue-cli-service build&quot;,\n    &quot;lint&quot;: &quot;vue-cli-service lint&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;core-js&quot;: &quot;^3.6.5&quot;,\n    &quot;vue&quot;: &quot;^2.6.11&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@vue&#x2F;cli-plugin-babel&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue&#x2F;cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue&#x2F;cli-service&quot;: &quot;~4.5.0&quot;,\n    &quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n    &quot;eslint&quot;: &quot;^6.7.2&quot;,\n    &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n    &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot;\n  &#125;,\n  &quot;browserslist&quot;: [\n    &quot;&gt; 1%&quot;,\n    &quot;last 2 versions&quot;,\n    &quot;not dead&quot;\n  ]\n&#125;\n\n事实上Vue ClI4脚手架创建的项目相对进行了简化，我们来看一下CLI2创建的项目：\n&#123;\n  &quot;name&quot;: &quot;vuerouterbasic&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;A Vue.js project&quot;,\n  &quot;author&quot;: &quot;&#39;coderwhy&#39; &lt;&#39;coderwhy@gmail.com&#39;&gt;&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build&#x2F;webpack.dev.conf.js&quot;,\n    &quot;start&quot;: &quot;npm run dev&quot;,\n    &quot;build&quot;: &quot;node build&#x2F;build.js&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;vue&quot;: &quot;^2.5.2&quot;,\n    &quot;vue-router&quot;: &quot;^3.0.1&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,\n    &quot;babel-core&quot;: &quot;^6.22.1&quot;,\n    &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;,\n    &quot;babel-loader&quot;: &quot;^7.1.1&quot;,\n    &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;,\n    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,\n    &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;,\n    &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;,\n    &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;,\n    &quot;chalk&quot;: &quot;^2.0.1&quot;,\n    &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;,\n    &quot;css-loader&quot;: &quot;^0.28.0&quot;,\n    &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;,\n    &quot;file-loader&quot;: &quot;^1.1.4&quot;,\n    &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;,\n    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,\n    &quot;node-notifier&quot;: &quot;^5.1.2&quot;,\n    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;,\n    &quot;ora&quot;: &quot;^1.2.0&quot;,\n    &quot;portfinder&quot;: &quot;^1.0.13&quot;,\n    &quot;postcss-import&quot;: &quot;^11.0.0&quot;,\n    &quot;postcss-loader&quot;: &quot;^2.0.8&quot;,\n    &quot;postcss-url&quot;: &quot;^7.2.1&quot;,\n    &quot;rimraf&quot;: &quot;^2.6.0&quot;,\n    &quot;semver&quot;: &quot;^5.3.0&quot;,\n    &quot;shelljs&quot;: &quot;^0.7.6&quot;,\n    &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;,\n    &quot;url-loader&quot;: &quot;^0.5.8&quot;,\n    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,\n    &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;,\n    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,\n    &quot;webpack&quot;: &quot;^3.6.0&quot;,\n    &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;,\n    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;,\n    &quot;webpack-merge&quot;: &quot;^4.1.0&quot;\n  &#125;,\n  &quot;engines&quot;: &#123;\n    &quot;node&quot;: &quot;&gt;&#x3D; 6.0.0&quot;,\n    &quot;npm&quot;: &quot;&gt;&#x3D; 3.0.0&quot;\n  &#125;,\n  &quot;browserslist&quot;: [\n    &quot;&gt; 1%&quot;,\n    &quot;last 2 versions&quot;,\n    &quot;not ie &lt;&#x3D; 8&quot;\n  ]\n&#125;\n\n我们也可以手动创建一个package.json文件：\nnpm init #创建时填写信息\nnpm init -y # 所有信息使用默认的\n\nnpm init -y生成文件的效果：\n&#123;\n  &quot;name&quot;: &quot;learn-npm&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;main.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n我们会发现属性非常的多，我们这里对一些常见属性进行一些解析。\n必须填写的属性：name、version\n\nname是项目的名称；\nversion是当前项目的版本号；\ndescription是描述信息，很多时候是作为项目的基本描述；\nauthor是作者相关信息（发布时用到）；\nlicense是开源协议（发布时用到）；\n\nprivate属性：\n\nprivate属性记录当前的项目是否是私有的；\n当值为true时，npm是不能发布它的，这是防止私有项目或模块发布出去的方式；\n\nmain属性：\n\n设置程序的入口。\n\n很多人会有疑惑，webpack不是会自动找到程序的入口吗？\n\n\n这个入口和webpack打包的入口并不冲突；\n\n\n它是在你发布一个模块的时候会用到的；\n\n比如我们使用axios模块 const axios = require(&#39;axios&#39;);\n\n实际上是找到对应的main属性查找文件的；\n\n\naxios的入口\nscripts属性\n\nscripts属性用于配置一些脚本命令，以键值对的形式存在；\n\n配置后我们可以通过 npm run 命令的key来执行这个命令；\n\nnpm start和npm run start的区别是什么？\n\n\n它们是等价的；\n\n\n对于常用的 start、 test、stop、restart可以省略掉run直接通过 npm start等方式运行；\n\n\ndependencies属性\n\ndependencies属性是指定无论开发环境还是生成环境都需要依赖的包；\n通常是我们项目实际开发用到的一些库模块；\n与之对应的是devDependencies；\n\ndevDependencies属性\n\n一些包在生成环境是不需要的，比如webpack、babel等；\n这个时候我们会通过 npm install webpack --save-dev，将它安装到devDependencies属性中；\n\n疑问：那么在生成环境如何保证不安装这些包呢？\n\n生成环境不需要安装时，我们需要通过 npm install --production 来安装文件的依赖；\n\n版本管理的问题\n我们会发现安装的依赖版本出现：^2.0.3或~2.0.3，这是什么意思呢？\nnpm的包通常需要遵从semver版本规范：\n\nsemver：https://semver.org/lang/zh-CN/\nnpm semver：https://docs.npmjs.com/misc/semver\n\nsemver版本规范是X.Y.Z：\n\nX主版本号（major）：当你做了不兼容的 API 修改（可能不兼容之前的版本）；\nY次版本号（minor）：当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）；\nZ修订号（patch）：当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug）；\n\n我们这里解释一下 ^和~的区别：\n\n^x.y.z：表示x是保持不变的，y和z永远安装最新的版本；\n~x.y.z：表示x和y保持不变的，z永远安装最新的版本；\n\nengines属性\n\nengines属性用于指定Node和NPM的版本号；\n在安装的过程中，会先检查对应的引擎版本，如果不符合就会报错；\n事实上也可以指定所在的操作系统 &quot;os&quot; : [ &quot;darwin&quot;, &quot;linux&quot; ]，只是很少用到；\n\nbrowserslist属性\n\n用于配置打包后的JavaScript浏览器的兼容情况，参考；\n否则我们需要手动的添加polyfills来让支持某些语法；\n也就是说它是为webpack等打包工具服务的一个属性（这里不是详细讲解webpack等工具的工作原理，所以不再给出详情）；\n\nnpm工具解析2.1. npm install命令安装npm包分两种情况：\n\n全局安装（global install）：npm install yarn -g;\n项目（局部）安装（local install）：npm install\n\n全局安装\n全局安装是直接将某个包安装到全局：\n比如yarn的全局安装：\nnpm install yarn -g\n\n但是很多人对全局安装有一些误会：\n\n通常使用npm全局安装的包都是一些工具包：yarn、webpack等；\n并不是类似于 axios、express、koa等库文件；\n所以全局安装了之后并不能让我们在所有的项目中使用 axios等库；\n\n项目安装\n项目安装会在当前目录下生产一个 node_modules 文件夹，我们之前讲解require查找顺序时有讲解过这个包在什么情况下被查找；\n局部安装分为开发时依赖和生产时依赖：\n# 安装开发和生产依赖\nnpm install axios --save\nnpm install axios -S\nnpm install axios\nnpm i axios\n\n# 开发者\nnpm install axios --save-dev\nnpm install axios -D\nnpm i axios -D\n\n2.2. npm install原理很多同学之情应该已经会了 npm install &lt;package&gt;，但是你是否思考过它的内部原理呢？\n\n执行 npm install它背后帮助我们完成了什么操作？\n我们会发现还有一个成为package-lock.json的文件，它的作用是什么？\n从npm5开始，npm支持缓存策略（来自yarn的压力），缓存有什么作用呢？\n\n这是一幅我画出的根据 npm install 的原理图：\n\nnpm install会检测是有package-lock.json文件：\n\n\n检测lock中包的版本是否和package.json中一致（会按照semver版本规范检测）；\n\n\n一致的情况下，会去优先查找缓存\n\n查找到，会获取缓存中的压缩文件，并且将压缩文件解压到node_modules文件夹中；\n\n不一致，那么会重新构建依赖关系，直接会走顶层的流程；\n\n没有找到，会从registry仓库下载，直接走顶层流程；\n\n分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产生相同依赖的情况；\n\n从registry仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）；\n\n获取到压缩包后会对压缩包进行缓存（从npm5开始有的）；\n\n将压缩包解压到项目的node_modules文件夹中（前面我们讲过，require的查找顺序会在该包下面查找）\n\n没有lock文件\n\n有lock文件\n\n\nnpm install原理图\npackage-lock.json文件：\n&#123;\n  &quot;name&quot;: &quot;learn-npm&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;lockfileVersion&quot;: 1,\n  &quot;requires&quot;: true,\n  &quot;dependencies&quot;: &#123;\n    &quot;axios&quot;: &#123;\n      &quot;version&quot;: &quot;0.20.0&quot;,\n      &quot;resolved&quot;: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;axios&#x2F;-&#x2F;axios-0.20.0.tgz&quot;,\n      &quot;integrity&quot;: &quot;sha512-ANA4rr2BDcmmAQLOKft2fufrtuvlqR+cXNNinUmvfeSNCOF98PZL+7M&#x2F;v1zIdGo7OLjEA9J2gXJL+j4zGsl0bA&#x3D;&#x3D;&quot;,\n      &quot;requires&quot;: &#123;\n        &quot;follow-redirects&quot;: &quot;^1.10.0&quot;\n      &#125;\n    &#125;,\n    &quot;follow-redirects&quot;: &#123;\n      &quot;version&quot;: &quot;1.13.0&quot;,\n      &quot;resolved&quot;: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;follow-redirects&#x2F;-&#x2F;follow-redirects-1.13.0.tgz&quot;,\n      &quot;integrity&quot;: &quot;sha512-aq6gF1BEKje4a9i9+5jimNFIpq4Q1WiwBToeRK5NvZBd&#x2F;TRsmW8BsJfOEGkr76TbOyPVD3OVDN910EcUNtRYEA&#x3D;&#x3D;&quot;\n    &#125;\n  &#125;\n&#125;\n\npackage-lock.json文件解析：\n\nname：项目的名称；\n\nversion：项目的版本；\n\nlockfileVersion：lock文件的版本；\n\nrequires：使用requires来跟着模块的依赖关系；\n\ndependencies：项目的依赖\n\n\nversion表示实际安装的axios的版本；\n\n\nresolved用来记录下载的地址，registry仓库中的位置；\n\nrequires记录当前模块的依赖；\n\nintegrity用来从缓存中获取索引，再通过索引去获取压缩包文件；\n\n当前项目依赖axios，但是axios依赖follow-redireacts；\n\naxios中的属性如下：\n\n\n2.3. 其他npm命令我们这里再介绍几个比较常用的：\n卸载某个依赖包：\nnpm uninstall package\nnpm uninstall package --save-dev\nnpm uninstall package -D\n\n强制重新build\nnpm rebuild\n\n清除缓存\nnpm cache clean\n\nnpm的命令其实是非常多的：\n\nhttps://docs.npmjs.com/cli-documentation/cli\n更多的命令，可以根据需要查阅官方文档\n\n2.4. yarn和cnpm另一个node包管理工具yarn：\n\nyarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具；\nyarn 是为了弥补 npm 的一些缺陷而出现的；\n早期的npm存在很多的缺陷，比如安装依赖速度很慢、版本依赖混乱等等一系列的问题；\n虽然从npm5版本开始，进行了很多的升级和改进，但是依然很多人喜欢使用yarn；\n\n这里给出一张常用命令的对比\nnpm和yarn常用命令对比\n补充：cnpm\n由于一些特殊的原因，某些情况下我们没办法很好的从 https://registry.npmjs.org下载下来一些需要的包。\n查看npm镜像：\nnpm config get registry # npm config get registry\n\n我们可以直接设置npm的镜像：\nnpm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org\n\n但是对于大多数人来说（比如我），并不希望将npm镜像修改了：\n\n第一，不太希望随意修改npm原本从官方下来包的渠道；\n第二，担心某天淘宝的镜像挂了或者不维护了，又要改来改去；\n\n这个时候，我们可以使用cnpm，并且将cnpm设置为淘宝的镜像：\nnpm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org\ncnpm config get registry # https:&#x2F;&#x2F;r.npm.taobao.org&#x2F;\n\n补充：npx\nnpx是npm5.2之后自带的一个命令。\nnpx的作用非常多，但是比较常见的是使用它来调用项目中的某个模块的指令。\n我们以webpack为例：\n\n全局安装的是webpack5.1.3\n项目安装的是webpack3.6.0\n\n如果我在终端执行 webpack --version使用的是哪一个命令呢？\n\n显示结果会是 webpack 5.1.3，事实上使用的是全局的，为什么呢？\n原因非常简单，在当前目录下找不到webpack时，就会去全局找，并且执行命令；\n\n那么如何使用项目（局部）的webpack，常见的是两种方式：\n\n方式一：明确查找到node_module下面的webpack\n方式二：在 scripts定义脚本，来执行webpack；\n\n方式一：在终端中使用如下命令（在项目根目录下）\n.&#x2F;node_modules&#x2F;.bin&#x2F;webpack --version\n\n方式二：修改package.json中的scripts\n&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n  &quot;webpack&quot;: &quot;webpack --version&quot;\n&#125;,\n\n终端中执行：\nnpm run webpack\n\n但是这两种方式都有一点点麻烦，更好的办法是直接使用npx：\nnpx webpack --version\n\nnpx的原理非常简单，它会到当前目录的node_modules&#x2F;.bin目录下查找对应的命令；\n","slug":"node/base/Node基础五","date":"2022-10-01T04:25:11.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"e9d3cfba4c19a66c9a7d2ec6535dbb77","title":"Node基础四","content":"四.常用内置模块1.1. 认识path模块path模块用于对路径和文件进行处理，提供了很多好用的方法。\n并且我们知道在Mac OS、Linux和window上的路径是不一样的\n\nwindow上会使用 \\或者 \\\\ 来作为文件路径的分隔符，当然目前也支持 /；\n在Mac OS、Linux的Unix操作系统上使用 / 来作为文件路径的分隔符；\n\n那么如果我们在window上使用 \\ 来作为分隔符开发了一个应用程序，要部署到Linux上面应该怎么办呢？\n\n显示路径会出现一些问题；\n所以为了屏蔽他们之间的差异，在开发中对于路径的操作我们可以使用 path 模块；\n\n1.2. path常见的API从路径中获取信息\n\ndirname：获取文件的父文件夹；\nbasename：获取文件名；\nextname：获取文件扩展名；\n\nconst path &#x3D; require(&quot;path&quot;);\n\nconst myPath &#x3D; &#39;&#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;课堂&#x2F;PPT&#x2F;01_邂逅Node.pdf&#39;;\n\nconst dirname &#x3D; path.dirname(myPath);\nconst basename &#x3D; path.basename(myPath);\nconst extname &#x3D; path.extname(myPath);\n\nconsole.log(dirname); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;课堂&#x2F;PPT\nconsole.log(basename); &#x2F;&#x2F; 01_邂逅Node.pdf\nconsole.log(extname); &#x2F;&#x2F; .pdf\n\n路径的拼接\n\n如果我们希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符；\n这个时候我们可以使用path.join函数；\n\nconsole.log(path.join(&#39;&#x2F;user&#39;, &#39;why&#39;, &#39;abc.txt&#39;));\n\n将文件和某个文件夹拼接\n\n如果我们希望将某个文件和文件夹拼接，可以使用 path.resolve;\n\n\nresolve函数会判断我们拼接的路径前面是否有 /或../或./；\n\n\n如果有表示是一个绝对路径，会返回对应的拼接路径；\n\n如果没有，那么会和当前执行文件所在的文件夹进行路径的拼接\n\n\npath.resolve(&#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;06_常见的内置模块&#x2F;02_文件路径&#x2F;abc.txt\npath.resolve(&#39;&#x2F;abc.txt&#39;); &#x2F;&#x2F; &#x2F;abc.txt\npath.resolve(&#39;&#x2F;User&#x2F;why&#39;, &#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;User&#x2F;why&#x2F;abc.txt\npath.resolve(&#39;User&#x2F;why&#39;, &#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;06_常见的内置模块&#x2F;02_文件路径&#x2F;User&#x2F;why&#x2F;abc.txt\n\nresolve其实我们在webpack中也会使用：\nconst CracoLessPlugin &#x3D; require(&#39;craco-less&#39;);\nconst path &#x3D; require(&quot;path&quot;);\n\nconst resolve &#x3D; dir &#x3D;&gt; path.resolve(__dirname, dir);\n\nmodule.exports &#x3D; &#123;\n  plugins: [\n    &#123;\n      plugin: CracoLessPlugin,\n      options: &#123;\n        lessLoaderOptions: &#123;\n          lessOptions: &#123;\n            modifyVars: &#123; &#39;@primary-color&#39;: &#39;#1DA57A&#39; &#125;,\n            javascriptEnabled: true,\n          &#125;,\n        &#125;,\n      &#125;,\n    &#125;\n  ],\n  webpack: &#123;\n    alias: &#123;\n      &quot;@&quot;: resolve(&quot;src&quot;),\n      &quot;components&quot;: resolve(&quot;src&#x2F;components&quot;)\n    &#125;\n  &#125;\n&#125;\n\n内置模块fs1.1. 认识fs模块fs是File System的缩写，表示文件系统。\n对于任何一个为服务器端服务的语言或者框架通常都会有自己的文件系统：\n\n因为服务器需要将各种数据、文件等放置到不同的地方；\n比如用户数据可能大多数是放到数据库中的（后面我们也会学习）；\n比如某些配置文件或者用户资源（图片、音视频）都是以文件的形式存在于操作系统上的；\n\nNode也有自己的文件系统操作模块，就是fs：\n\n借助于Node帮我们封装的文件系统，我们可以在任何的操作系统（window、Mac OS、Linux）上面直接去操作文件；\n这也是Node可以开发服务器的一大原因，也是它可以成为前端自动化脚本等热门工具的原因；\n\nNode文件系统的API非常的多：https://nodejs.org/dist/latest-v14.x/docs/api/fs.html\n\n我们不可能，也没必要一个个去学习；\n这个更多的应该是作为一个API查询的手册，等用到的时候查询即可；\n学习阶段我们只需要学习最常用的即可；\n\n但是这些API大多数都提供三种操作方式：\n\n方式一：同步操作文件：代码会被阻塞，不会继续执行；\n方式二：异步回调函数操作文件：代码不会被阻塞，需要传入回调函数，当获取到结果时，回调函数被执行；\n方式三：异步Promise操作文件：代码不会被阻塞，通过 fs.promises 调用方法操作，会返回一个Promise，可以通过then、catch进行处理；\n\n我们这里以获取一个文件的状态为例：\n\n注意：都需要引入 fs 模块；\n\n方式一：同步操作文件\n&#x2F;&#x2F; 1.方式一: 同步读取文件\nconst state &#x3D; fs.statSync(&#39;..&#x2F;foo.txt&#39;);\nconsole.log(state);\n\nconsole.log(&#39;后续代码执行&#39;);\n\n方式二：异步回调函数操作文件\n&#x2F;&#x2F; 2.方式二: 异步读取\nfs.stat(&quot;..&#x2F;foo.txt&quot;, (err, state) &#x3D;&gt; &#123;\n  if (err) &#123;\n    console.log(err);\n    return;\n  &#125;\n  console.log(state);\n&#125;)\nconsole.log(&quot;后续代码执行&quot;);\n\n方式三：异步Promise操作文件\n&#x2F;&#x2F; 3.方式三: Promise方式\nfs.promises.stat(&quot;..&#x2F;foo.txt&quot;).then(state &#x3D;&gt; &#123;\n  console.log(state);\n&#125;).catch(err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\nconsole.log(&quot;后续代码执行&quot;);\n\n后续代码演练中，我将以异步回调的方式演练：相对更通用一些；\n1.2. 文件描述符文件描述符（File descriptors）是什么呢？\n在 POSIX 系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。\n\n每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。\n在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件。\nWindows 系统使用了一个虽然不同但概念上类似的机制来跟踪资源。\n为了简化用户的工作，Node.js 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符。\n\nfs.open() 方法用于分配新的文件描述符。一旦被分配，则文件描述符可用于从文件读取数据、向文件写入数据、或请求关于文件的信息。\n&#x2F;&#x2F; 获取文件描述符\nfs.open(&quot;..&#x2F;foo.txt&quot;, &#39;r&#39;, (err, fd) &#x3D;&gt; &#123;\n  console.log(fd);\n\n  fs.fstat(fd, (err, state) &#x3D;&gt; &#123;\n    console.log(state);\n  &#125;)\n&#125;)\n\n1.3. 文件的读写如果我们希望对文件的内容进行操作，这个时候可以使用文件的读写：\n\nfs.readFile(path[, options], callback)：读取文件的内容；\nfs.writeFile(file, data[, options], callback)：在文件中写入内容；\n\n文件写入：\nfs.writeFile(&#39;..&#x2F;foo.txt&#39;, content, &#123;&#125;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\n\n在上面的代码中，你会发现有一个大括号没有填写任何的内容，这个是写入时填写的option参数：\n\nflag：写入的方式。\nencoding：字符的编码；\n\n我们先来看flag：\n\nflag的值有很多：https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system_flags\n\n\nw 打开文件写入，默认值；\n\n\nw+打开文件进行读写，如果不存在则创建文件；\n\nr+ 打开文件进行读写，如果不存在那么抛出异常；\n\nr打开文件读取，读取时的默认值；\n\na打开要写入的文件，将流放在文件末尾。如果不存在则创建文件；\n\na+打开文件以进行读写，将流放在文件末尾。如果不存在则创建文件\n\n\n我们再来看看编码：\n\n我之前在简书上写过一篇关于字符编码的文章：https://www.jianshu.com/p/899e749be47c\n目前基本用的都是UTF-8编码；\n\n文件读取：\n\n如果不填写encoding，返回的结果是Buffer；\n\nfs.readFile(&#39;..&#x2F;foo.txt&#39;, &#123;encoding: &#39;utf-8&#39;&#125;, (err, data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)\n\n文件读取：\nconst fs &#x3D; require(&#39;fs&#39;);\n\nfs.readFile(&#39;..&#x2F;foo.txt&#39;, &#123;encoding: &#39;utf-8&#39;&#125;, (err, data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)\n\n1.4. 文件夹操作新建一个文件夹\n使用fs.mkdir()或fs.mkdirSync()创建一个新文件夹：\nconst fs &#x3D; require(&#39;fs&#39;);\n\nconst dirname &#x3D; &#39;..&#x2F;why&#39;;\n\nif (!fs.existsSync(dirname)) &#123;\n  fs.mkdir(dirname, (err) &#x3D;&gt; &#123;\n    console.log(err);\n  &#125;)\n&#125;\n\n获取文件夹的内容\n&#x2F;&#x2F; 读取文件夹\nfunction readFolders(folder) &#123;\n  fs.readdir(folder, &#123;withFileTypes: true&#125; ,(err, files) &#x3D;&gt; &#123;\n    files.forEach(file &#x3D;&gt; &#123;\n      if (file.isDirectory()) &#123;\n        const newFolder &#x3D; path.resolve(dirname, file.name);\n        readFolders(newFolder);\n      &#125; else &#123;\n        console.log(file.name);\n      &#125;\n    &#125;)\n  &#125;)\n&#125;\n\nreadFolders(dirname);\n\n文件重命名\nfs.rename(&#39;..&#x2F;why&#39;, &#39;..&#x2F;coder&#39;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\n\n内置模块events3.1. 基本使用Node中的核心API都是基于异步事件驱动的：\n\n在这个体系中，某些对象（发射器（Emitters））发出某一个事件；\n我们可以监听这个事件（监听器 Listeners），并且传入的回调函数，这个回调函数会在监听到事件时调用；\n\n发出事件和监听事件都是通过EventEmitter类来完成的，它们都属于events对象。\n\nemitter.on(eventName, listener)：监听事件，也可以使用addListener；\nemitter.off(eventName, listener)：移除事件监听，也可以使用removeListener；\nemitter.emit(eventName[, ...args])：发出事件，可以携带一些参数；\n\nconst EventEmmiter &#x3D; require(&#39;events&#39;);\n\n&#x2F;&#x2F; 监听事件\nconst bus &#x3D; new EventEmmiter();\n\nfunction clickHanlde(args) &#123;\n  console.log(&quot;监听到click事件&quot;, args);\n&#125;\n\nbus.on(&quot;click&quot;, clickHanlde);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  bus.emit(&quot;click&quot;, &quot;coderwhy&quot;);\n  bus.off(&quot;click&quot;, clickHanlde);\n  bus.emit(&quot;click&quot;, &quot;kobe&quot;);\n&#125;, 2000);\n\n3.2. 常见的属性EventEmitter的实例有一些属性，可以记录一些信息：\n\nemitter.eventNames()：返回当前 EventEmitter对象注册的事件字符串数组；\nemitter.getMaxListeners()：返回当前 EventEmitter对象的最大监听器数量，可以通过setMaxListeners()来修改，默认是10；\nemitter.listenerCount(事件名称)：返回当前 EventEmitter对象某一个事件名称，监听器的个数；\nemitter.listeners(事件名称)：返回当前 EventEmitter对象某个事件监听器上所有的监听器数组；\n\nconsole.log(bus.eventNames());\nconsole.log(bus.getMaxListeners());\nconsole.log(bus.listenerCount(&quot;click&quot;));\nconsole.log(bus.listeners(&quot;click&quot;));\n\n3.3. 方法的补充emitter.once(eventName, listener)：事件监听一次\nconst EventEmitter &#x3D; require(&#39;events&#39;);\n\nconst emitter &#x3D; new EventEmitter();\n\nemitter.once(&#39;click&#39;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;监听到事件&quot;, args);\n&#125;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  emitter.emit(&#39;click&#39;, &#39;coderwhy&#39;);\n  emitter.emit(&#39;click&#39;, &#39;coderwhy&#39;);\n&#125;, 2000);\n\nemitter.prependListener()：将监听事件添加到最前面\nemitter.on(&#39;click&#39;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;a监听到事件&quot;, args);\n&#125;)\n\n&#x2F;&#x2F; b监听事件会被放到前面\nemitter.prependListener(&quot;click&quot;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;b监听到事件&quot;, args);\n&#125;)\n\nemitter.prependOnceListener()：将监听事件添加到最前面，但是只监听一次\nemitter.prependOnceListener(&quot;click&quot;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;c监听到事件&quot;, args);\n&#125;)\n\nemitter.removeAllListeners([eventName])：移除所有的监听器\n&#x2F;&#x2F; 移除emitter上的所有事件监听\nemitter.removeAllListeners();\n&#x2F;&#x2F; 移除emitter上的click事件监听\nemitter.removeAllListeners(&quot;click&quot;);\n","slug":"node/base/Node基础四","date":"2022-10-01T04:24:10.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"4d3281e0b26c044e36154a269947cf99","title":"Node基础三","content":"三 . 掌握前端模块化1.1. JavaScript设计缺陷那么，到底什么是模块化开发呢？\n\n事实上模块化开发最终的目的是将程序划分成一个个小的结构；\n这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；\n这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用；\n也可以通过某种方式，导入另外结构中的变量、函数、对象等；\n\n上面说提到的结构，就是模块；\n按照这种结构划分开发程序的过程，就是模块化开发的过程；\n无论你多么喜欢JavaScript，以及它现在发展的有多好，我们都需要承认在Brendan Eich用了10天写出JavaScript的时候，它都有很多的缺陷：\n\n比如var定义的变量作用域问题；\n比如JavaScript的面向对象并不能像常规面向对象语言一样使用class；\n比如JavaScript没有模块化的问题；\n\nBrendan Eich本人也多次承认过JavaScript设计之初的缺陷，但是随着JavaScript的发展以及标准化，存在的缺陷问题基本都得到了完善。\n\nJavaScript目前已经得到了快速的发展，无论是web、移动端、小程序端、服务器端、桌面应用都被广泛的使用；\n\n在网页开发的早期，Brendan Eich开发JavaScript仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的：\n\n这个时候我们只需要讲JavaScript代码写到标签中即可；\n并没有必要放到多个文件中来编写；\n\n&lt;button id&#x3D;&quot;btn&quot;&gt;按钮&lt;&#x2F;button&gt;\n\n&lt;script&gt;\n  document.getElementById(&quot;btn&quot;).onclick &#x3D; function() &#123;\n    console.log(&quot;按钮被点击了&quot;);\n  &#125;\n&lt;&#x2F;script&gt;\n\n但是随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂了：\n\najax的出现，前后端开发分离，意味着后端返回数据后，我们需要通过JavaScript进行前端页面的渲染；\nSPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现；\n包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤；\n\n所以，模块化已经是JavaScript一个非常迫切的需求：\n\n但是JavaScript本身，直到ES6（2015）才推出了自己的模块化方案；\n在此之前，为了让JavaScript支持模块化，涌现出了很多不同的模块化规范：AMD、CMD、CommonJS等；\n\n在这个章节，我们将详细学习JavaScript的模块化，尤其是CommonJS和ES6的模块化。\n1.2. 没有模块化的问题我们先来简单体会一下没有模块化代码的问题。\n我们知道，对于一个大型的前端项目，通常是多人开发的（即使一个人开发，也会将代码划分到多个文件夹中）：\n\n我们假设有两个人：小明和小丽同时在开发一个项目，并且会将自己的JavaScript代码放在一个单独的js文件中。\n\n小明开发了aaa.js文件，代码如下（当然真实代码会复杂的多）：\nvar flag &#x3D; true;\n\nif (flag) &#123;\n  console.log(&quot;aaa的flag为true&quot;)\n&#125;\n\n小丽开发了bbb.js文件，代码如下：\nvar flag &#x3D; false;\n\nif (!flag) &#123;\n  console.log(&quot;bbb使用了flag为false&quot;);\n&#125;\n\n很明显出现了一个问题：\n\n大家都喜欢使用flag来存储一个boolean类型的值；\n但是一个人赋值了true，一个人赋值了false；\n如果之后都不再使用，那么也没有关系；\n\n但是，小明又开发了ccc.js文件：\nif (flag) &#123;\n  console.log(&quot;使用了aaa的flag&quot;);\n&#125;\n\n问题来了：小明发现ccc中的flag值不对\n\n对于聪明的你，当然一眼就看出来，是小丽将flag赋值为了false；\n但是如果每个文件都有上千甚至更多的代码，而且有上百个文件，你可以一眼看出来flag在哪个地方被修改了吗？\n\n备注：引用路径如下：\n&lt;script src&#x3D;&quot;.&#x2F;aaa.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;.&#x2F;bbb.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;.&#x2F;ccc.js&quot;&gt;&lt;&#x2F;script&gt;\n\n所以，没有模块化对于一个大型项目来说是灾难性的。\n当然，我们有办法可以解决上面的问题：立即函数调用表达式（IIFE）\n\nIIFE (Immediately Invoked Function Expression)\n\naaa.js\nconst moduleA &#x3D; (function () &#123;\n  var flag &#x3D; true;\n\n  if (flag) &#123;\n    console.log(&quot;aaa的flag为true&quot;)\n  &#125;\n\n  return &#123;\n    flag: flag\n  &#125;\n&#125;)();\n\nbbb.js\nconst moduleB &#x3D; (function () &#123;\n  var flag &#x3D; false;\n\n  if (!flag) &#123;\n    console.log(&quot;bbb使用了flag为false&quot;);\n  &#125;\n&#125;)();\n\nccc.js\nconst moduleC &#x3D; (function() &#123;\n  const flag &#x3D; moduleA.flag;\n  if (flag) &#123;\n    console.log(&quot;使用了aaa的flag&quot;);\n  &#125;\n&#125;)();\n\n命名冲突的问题，有没有解决呢？解决了。\n但是，我们其实带来了新的问题：\n\n第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用；\n第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；\n第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况；\n\n所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。\n\n我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码；\n这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性；\n\nJavaScript社区为了解决上面的问题，涌现出一系列好用的规范，接下来我们就学习具有代表性的一些规范。\nCommonJS规范2.1. CommonJS和Node我们需要知道CommonJS是一个规范，最初提出来是在浏览器意外的地方使用，并且当时被命名为ServerJS，后来为了体现它的广泛性，修改为CommonJS，平时我们也会简称为CJS。\n\nNode是CommonJS在服务器端一个具有代表性的实现；\nBrowserify是CommonJS在浏览器中的一种实现；\nwebpack打包工具具备对CommonJS的支持和转换（后面我会讲到）；\n\n所以，Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：\n\n在Node中每一个js文件都是一个单独的模块；\n这个模块中包括CommonJS规范的核心变量：exports、module.exports、require；\n我们可以使用这些变量来方便的进行模块化开发；\n\n前面我们提到过模块化的核心是导出和导入，Node中对其进行了实现：\n\nexports和module.exports可以负责对模块中的内容进行导出；\nrequire函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；\n\n2.2. Node模块化开发我们来看一下两个文件：\nbar.js\nconst name &#x3D; &#39;coderwhy&#39;;\nconst age &#x3D; 18;\n\nfunction sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\nmain.js\nconsole.log(name);\nconsole.log(age);\n\nsayHello(&#39;kobe&#39;);\n\n上面的代码会报错：\n\n在node中每一个文件都是一个独立的模块，有自己的作用域；\n那么，就意味着别的模块main中不能随便访问另外一个模块bar中的内容；\nbar需要导出自己想要暴露的变量、函数、对象等等；\nmain从bar中导入自己想要使用的变量、函数、对象等等；\n\n导出和导入\n2.2.1. exports导出强调：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出\nbar.js中导出内容：\nexports.name &#x3D; name;\nexports.age &#x3D; age;\nexports.sayHello &#x3D; sayHello;\n\nmain.js中导入内容：\nconst bar &#x3D; require(&#39;.&#x2F;bar&#39;);\n\n上面这行代码意味着什么呢？\n\n意味着main中的bar变量等于exports对象；\n\nmain中的bar &#x3D; bar中的exports\n\n所以，我可以编写下面的代码：\nconst bar &#x3D; require(&#39;.&#x2F;bar&#39;);\n\nconst name &#x3D; bar.name;\nconst age &#x3D; bar.age;\nconst sayHello &#x3D; bar.sayHello;\n\nconsole.log(name);\nconsole.log(age);\n\nsayHello(&#39;kobe&#39;);\n\n\n模块之间的引用关系\n为了进一步论证，bar和exports是同一个对象：\n\n所以，bar对象是exports对象的浅拷贝；\n浅拷贝的本质就是一种引用的赋值而已；\n\n定时器修改对象\n2.2.2. module.exports但是Node中我们经常导出东西的时候，又是通过module.exports导出的：\n\nmodule.exports和exports有什么关系或者区别呢？\n\n我们追根溯源，通过维基百科中对CommonJS规范的解析：\n\nCommonJS中是没有module.exports的概念的；\n但是为了实现模块的导出，Node中使用的是Module的类，每一个模块都是Module的一个实例，也就是module；\n所以在Node中真正用于导出的其实根本不是exports，而是module.exports；\n因为module才是导出的真正实现者；\n\n但是，为什么exports也可以导出呢？\n\n这是因为module对象的exports属性是exports对象的一个引用；\n也就是说 module.exports = exports = main中的bar；\n\nimage-20201011163653515\n注意：真正导出的模块内容的核心其实是module.exports，只是为了实现CommonJS的规范，刚好module.exports对exports对象有一个引用而已；\n那么，如果我的代码这样修改了：\nimage-20201011164006266\n你能猜到内存中会有怎么样的表现吗？\n\n结论：和exports对象没有任何关系了，exports你随便玩自己的吧；\nmodule.exports我现在导出一个自己的对象，不带着你玩了；\n新的对象取代了exports对象的导出，那么就意味着require导入的对象是新的对象；\n\nimage-20201011164223607\n2.2.3. require细节我们现在已经知道，require是一个函数，可以帮助我们引入一个文件（模块）中导入的对象。\n那么，require的查找规则是怎么样的呢？\n\nhttps://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together\n\n这里我总结比较常见的查找规则：\n导入格式如下：require(X)\n\n情况一：X是一个核心模块，比如path、http\n\n\n直接返回核心模块，并且停止查找\n\n\n情况二：X是以 ./ 或 ../ 或 /（根目录）开头的\n\n\n查找目录下面的index文件\n\n\n1> 查找X/index.js文件\n\n2> 查找X/index.json文件\n\n3> 查找X/index.node文件\n\n1.如果有后缀名，按照后缀名的格式查找对应的文件\n\n2.如果没有后缀名，会按照如下顺序：\n\n1> 直接查找文件X\n\n2> 查找X.js文件\n\n3> 查找X.json文件\n\n4> 查找X.node文件\n\n第一步：将X当做一个文件在对应的目录下查找；\n\n第二步：没有找到对应的文件，将X作为一个目录\n\n如果没有找到，那么报错：not found\n\n情况三：直接是一个X（没有路径），并且X不是一个核心模块\n\n\n比如 /Users/coderwhy/Desktop/Node/TestCode/04_learn_node/05_javascript-module/02_commonjs/main.js中编写 require(&#39;why&#39;)\n\n\n查找顺序\n\n如果上面的路径中都没有找到，那么报错：not found\n\n\n2.2.4. 模块加载顺序这里我们研究一下模块的加载顺序问题。\n结论一：模块在被第一次引入时，模块中的js代码会被运行一次\naaa.js\nconst name &#x3D; &#39;coderwhy&#39;;\n\nconsole.log(&quot;Hello aaa&quot;);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimeout&quot;);\n&#125;, 1000);\n\nmain.js\nconst aaa &#x3D; require(&#39;.&#x2F;aaa&#39;);\n\naaa.js中的代码在引入时会被运行一次\n结论二：模块被多次引入时，会缓存，最终只加载（运行）一次\nmain.js\nconst aaa &#x3D; require(&#39;.&#x2F;aaa&#39;);\nconst bbb &#x3D; require(&#39;.&#x2F;bbb&#39;);\n\naaa.js\nconst ccc &#x3D; require(&quot;.&#x2F;ccc&quot;);\n\nbbb.js\nconst ccc &#x3D; require(&quot;.&#x2F;ccc&quot;);\n\nccc.js\nconsole.log(&#39;ccc被加载&#39;);\n\nccc中的代码只会运行一次。\n为什么只会加载运行一次呢？\n\n这是因为每个模块对象module都有一个属性：loaded。\n为false表示还没有加载，为true表示已经加载；\n\n结论三：如果有循环引入，那么加载顺序是什么？\n如果出现下面模块的引用关系，那么加载顺序是什么呢？\n\n这个其实是一种数据结构：图结构；\n图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）；\nNode采用的是深度优先算法：main -> aaa -> ccc -> ddd -> eee ->bbb\n\n多个模块的引入关系\n2.3. Node的源码解析Module类\n\nModule类\nModule.prototype.require函数\n\nrequire函数\nModule._load函数\n\n_load函数的实现\nAMD和CMD规范3.1. CommonJS规范缺点CommonJS加载模块是同步的：\n\n同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行；\n这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快；\n\n如果将它应用于浏览器呢？\n\n浏览器加载js文件需要先从服务器将文件下载下来，之后在加载运行；\n那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作；\n\n所以在浏览器中，我们通常不使用CommonJS规范：\n\n当然在webpack中使用CommonJS是另外一回事；\n因为它会将我们的代码转成浏览器可以直接执行的代码；\n\n在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD：\n\n但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换；\nAMD和CMD已经使用非常少了，所以这里我们进行简单的演练；\n\n3.2. AMD规范AMD主要是应用于浏览器的一种模块化规范：\n\nAMD是Asynchronous Module Definition（异步模块定义）的缩写；\n它采用的是异步加载模块；\n事实上AMD的规范还要早于CommonJS，但是CommonJS目前依然在被使用，而AMD使用的较少了；\n\n我们提到过，规范只是定义代码的应该如何去编写，只有有了具体的实现才能被应用：\n\nAMD实现的比较常用的库是require.js和curl.js；\n\n这里我们以require.js为例讲解：\n第一步：下载require.js\n\n下载地址：https://github.com/requirejs/requirejs\n找到其中的require.js文件；\n\n第二步：定义HTML的script标签引入require.js和定义入口文件：\n\ndata-main属性的作用是在加载完src的文件后会加载执行该文件\n\n&lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;require.js&quot; data-main&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n\n第三步：编写如下目录和代码\n├── index.html\n├── index.js\n├── lib\n│   └── require.js\n└── modules\n    ├── bar.js\n    └── foo.js\n\nindex.js\n(function() &#123;\n  require.config(&#123;\n    baseUrl: &#39;&#39;,\n    paths: &#123;\n      foo: &#39;.&#x2F;modules&#x2F;foo&#39;,\n      bar: &#39;.&#x2F;modules&#x2F;bar&#39;\n    &#125;\n  &#125;)\n \n  &#x2F;&#x2F; 开始加载执行foo模块的代码\n  require([&#39;foo&#39;], function(foo) &#123;\n\n  &#125;)\n&#125;)();\n\nmodules/bar.js\n\n如果一个模块不依赖其他，那么直接使用define(function)即可\n\ndefine(function() &#123;\n  const name &#x3D; &quot;coderwhy&quot;;\n  const age &#x3D; 18;\n  const sayHello &#x3D; function(name) &#123;\n    console.log(&quot;Hello &quot; + name);\n  &#125;\n\n  return &#123;\n    name,\n    age, \n    sayHello\n  &#125;\n&#125;)\n\nmodules/foo.js\ndefine([&#39;bar&#39;], function(bar) &#123;\n  console.log(bar.name);\n  console.log(bar.age);\n  bar.sayHello(&#39;kobe&#39;);\n&#125;)\n\n3.3. CMD规范CMD规范也是应用于浏览器的一种模块化规范：\n\nCMD 是Common Module Definition（通用模块定义）的缩写；\n它也采用了异步加载模块，但是它将CommonJS的优点吸收了过来；\n但是目前CMD使用也非常少了；\n\nCMD也有自己比较优秀的实现方案：\n\nSeaJS\n\n我们一起看一下SeaJS如何使用：\n第一步：下载SeaJS\n\n下载地址：https://github.com/seajs/seajs\n找到dist文件夹下的sea.js\n\n第二步：引入sea.js和使用主入口文件\n\nseajs是指定主入口文件的\n\n&lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;sea.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n  seajs.use(&#39;.&#x2F;index.js&#39;);\n&lt;&#x2F;script&gt;\n\n第三步：编写如下目录和代码\n├── index.html\n├── index.js\n├── lib\n│   └── sea.js\n└── modules\n    ├── bar.js\n    └── foo.js\n\nindex.js\ndefine(function(require, exports, module) &#123;\n  const foo &#x3D; require(&#39;.&#x2F;modules&#x2F;foo&#39;);\n&#125;)\n\nbar.js\ndefine(function(require, exports, module) &#123;\n  const name &#x3D; &#39;lilei&#39;;\n  const age &#x3D; 20;\n  const sayHello &#x3D; function(name) &#123;\n    console.log(&quot;你好 &quot; + name);\n  &#125;\n\n  module.exports &#x3D; &#123;\n    name,\n    age,\n    sayHello\n  &#125;\n&#125;)\n\nfoo.js\ndefine(function(require, exports, module) &#123;\n  const bar &#x3D; require(&#39;.&#x2F;bar&#39;);\n\n  console.log(bar.name);\n  console.log(bar.age);\n  bar.sayHello(&quot;韩梅梅&quot;);\n&#125;)\n\nES Module4.1. 认识ES ModuleJavaScript没有模块化一直是它的痛点，所以才会产生我们前面学习的社区规范：CommonJS、AMD、CMD等，所以在ES推出自己的模块化系统时，大家也是兴奋异常。\nES Module和CommonJS的模块化有一些不同之处：\n\n一方面它使用了import和export关键字；\n另一方面它采用编译期静态类型检测，并且动态引用的方式；\n\nES Module模块采用export和import关键字来实现模块化：\n\nexport负责将模块内的内容导出；\nimport负责从其他模块导入内容；\n\n了解：采用ES Module将自动采用严格模式：use strict\n\n如果你不熟悉严格模式可以简单看一下MDN上的解析；\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\n\n4.2. ES Module的使用4.2.1. 代码结构组件这里我在浏览器中演示ES6的模块化开发：\n代码结构如下：\n├── index.html\n├── main.js\n└── modules\n    └── foo.js\n\nindex.html中引入两个js文件作为模块：\n&lt;script src&#x3D;&quot;.&#x2F;modules&#x2F;foo.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;main.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;\n\n如果直接在浏览器中运行代码，会报如下错误：\n\n模块化运行\n这个在MDN上面有给出解释：\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules\n你需要注意本地测试 — 如果你通过本地加载Html 文件 (比如一个 file:// 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。\n你需要通过一个服务器来测试。\n\n我这里使用的VSCode，VSCode中有一个插件：Live Server\n\n通过插件运行，可以将我们的代码运行在一个本地服务中；\n\nimage-20201012153439900\n4.2.2. export关键字export关键字将一个模块中的变量、函数、类等导出；\nfoo.js文件中默认代码如下：\nconst name &#x3D; &#39;coderwhy&#39;;\nconst age &#x3D; 18;\nlet message &#x3D; &quot;my name is why&quot;;\n\nfunction sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\n我们希望将其他中内容全部导出，它可以有如下的方式：\n方式一：在语句声明的前面直接加上export关键字\nexport const name &#x3D; &#39;coderwhy&#39;;\nexport const age &#x3D; 18;\nexport let message &#x3D; &quot;my name is why&quot;;\n\nexport function sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\n方式二：将所有需要导出的标识符，放到export后面的 &#123;&#125;中\n\n注意：这里的 &#123;&#125;里面不是ES6的对象字面量的增强写法，&#123;&#125;也不是表示一个对象的；\n所以：export &#123;name: name&#125;，是错误的写法；\n\nconst name &#x3D; &#39;coderwhy&#39;;\nconst age &#x3D; 18;\nlet message &#x3D; &quot;my name is why&quot;;\n\nfunction sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\nexport &#123;\n  name,\n  age,\n  message,\n  sayHello\n&#125;\n\n方式三：导出时给标识符起一个别名\nexport &#123;\n  name as fName,\n  age as fAge,\n  message as fMessage,\n  sayHello as fSayHello\n&#125;\n\n4.2.3. import关键字import关键字负责从另外一个模块中导入内容\n导入内容的方式也有多种：\n方式一：import &#123;标识符列表&#125; from &#39;模块&#39;；\n\n注意：这里的&#123;&#125;也不是一个对象，里面只是存放导入的标识符列表内容；\n\nimport &#123; name, age, message, sayHello &#125; from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nconsole.log(name)\nconsole.log(message);\nconsole.log(age);\nsayHello(&quot;Kobe&quot;);\n\n方式二：导入时给标识符起别名\nimport &#123; name as wName, age as wAge, message as wMessage, sayHello as wSayHello &#125; from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\n方式三：将模块功能放到一个模块功能对象（a module object）上\nimport * as foo from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nconsole.log(foo.name);\nconsole.log(foo.message);\nconsole.log(foo.age);\nfoo.sayHello(&quot;Kobe&quot;);\n\n4.2.4. export和import结合如果从一个模块中导入的内容，我们希望再直接导出出去，这个时候可以直接使用export来导出。\nbar.js中导出一个sum函数：\nexport const sum &#x3D; function(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nfoo.js中导入，但是只是做一个中转：\nexport &#123; sum &#125; from &#39;.&#x2F;bar.js&#39;;\n\nmain.js直接从foo中导入：\nimport &#123; sum &#125; from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\nconsole.log(sum(20, 30));\n\n甚至在foo.js中导出时，我们可以变化它的名字\nexport &#123; sum as barSum &#125; from &#39;.&#x2F;bar.js&#39;;\n\n为什么要这样做呢？\n\n在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中；\n这样方便指定统一的接口规范，也方便阅读；\n这个时候，我们就可以使用export和import结合使用；\n\n4.2.4. default用法前面我们学习的导出功能都是有名字的导出（named exports）：\n\n在导出export时指定了名字；\n在导入import时需要知道具体的名字；\n\n还有一种导出叫做默认导出（default export）\n\n默认导出export时可以不需要指定名字；\n在导入时不需要使用 &#123;&#125;，并且可以自己来指定名字；\n它也方便我们和现有的CommonJS等规范相互操作；\n\n导出格式如下：\nexport default function sub(num1, num2) &#123;\n  return num1 - num2;\n&#125;\n\n导入格式如下：\nimport sub from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nconsole.log(sub(20, 30));\n\n注意：在一个模块中，只能有一个默认导出（default export）；\n4.2.5. import()通过import加载一个模块，是不可以在其放到逻辑代码中的，比如：\nif (true) &#123;\n  import sub from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n&#125;\n\n为什么会出现这个情况呢？\n\n这是因为ES Module在被JS引擎解析时，就必须知道它的依赖关系；\n由于这个时候js代码没有任何的运行，所以无法在进行类似于if判断中根据代码的执行情况；\n甚至下面的这种写法也是错误的：因为我们必须到运行时能确定path的值；\n\nconst path &#x3D; &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nimport sub from path;\n\n但是某些情况下，我们确确实实希望动态的来加载某一个模块：\n\n如果根据不懂的条件，动态来选择加载模块的路径；\n这个时候我们需要使用 import() 函数来动态加载；\n\naaa.js模块：\nexport function aaa() &#123;\n  console.log(&quot;aaa被打印&quot;);\n&#125;\n\nbbb.js模块：\nexport function bbb() &#123;\n  console.log(&quot;bbb被执行&quot;);\n&#125;\n\nmain.js模块：\nlet flag &#x3D; true;\nif (flag) &#123;\n  import(&#39;.&#x2F;modules&#x2F;aaa.js&#39;).then(aaa &#x3D;&gt; &#123;\n    aaa.aaa();\n  &#125;)\n&#125; else &#123;\n  import(&#39;.&#x2F;modules&#x2F;bbb.js&#39;).then(bbb &#x3D;&gt; &#123;\n    bbb.bbb();\n  &#125;)\n&#125;\n\n4.3. ES Module的原理4.3.1. ES Module和CommonJS的区别CommonJS模块加载js文件的过程是运行时加载的，并且是同步的：\n\n运行时加载意味着是js引擎在执行js代码的过程中加载 模块；\n同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行；\n\nconsole.log(&quot;main代码执行&quot;);\n\nconst flag &#x3D; true;\nif (flag) &#123;\n  &#x2F;&#x2F; 同步加载foo文件，并且执行一次内部的代码\n  const foo &#x3D; require(&#39;.&#x2F;foo&#39;);\n  console.log(&quot;if语句继续执行&quot;);\n&#125;\n\nCommonJS通过module.exports导出的是一个对象：\n\n导出的是一个对象意味着可以将这个对象的引用在其他模块中赋值给其他变量；\n但是最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改；\n\nES Module加载js文件的过程是编译（解析）时加载的，并且是异步的：\n\n编译时（解析）时加载，意味着import不能和运行时相关的内容放在一起使用：\n\n\n比如from后面的路径需要动态获取；\n\n\n比如不能将import放到if等语句的代码块中；\n\n所以我们有时候也称ES Module是静态解析的，而不是动态或者运行时解析的；\n\n异步的意味着：JS引擎在遇到import时会去获取这个js文件，但是这个获取的过程是异步的，并不会阻塞主线程继续执行；\n\n\n也就是说设置了 type=module 的代码，相当于在script标签上也加上了 async 属性；\n\n\n如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行；\n\n\n&lt;script src&#x3D;&quot;main.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;\n&lt;!-- 这个js文件的代码不会被阻塞执行 --&gt;\n&lt;script src&#x3D;&quot;index.js&quot;&gt;&lt;&#x2F;script&gt;\n\nES Module通过export导出的是变量本身的引用：\n\nexport在导出一个变量时，js引擎会解析这个语法，并且创建模块环境记录（module environment record）；\n模块环境记录会和变量进行 绑定（binding），并且这个绑定是实时的；\n而在导入的地方，我们是可以实时的获取到绑定的最新值的；\n\nexport和import绑定的过程\n所以我们下面的代码是成立的：\nbar.js文件中修改\nlet name &#x3D; &#39;coderwhy&#39;;\n\nsetTimeout(() &#x3D;&gt; &#123;\n  name &#x3D; &quot;湖人总冠军&quot;;\n&#125;, 1000);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(name);\n&#125;, 2000);\n\nexport &#123;\n  name\n&#125;\n\nmain.js文件中获取\nimport &#123; name &#125; from &#39;.&#x2F;modules&#x2F;bar.js&#39;;\n\nconsole.log(name);\n\n&#x2F;&#x2F; bar中修改, main中验证\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(name);\n&#125;, 2000);\n\n但是，下面的代码是不成立的：main.js中修改\nimport &#123; name &#125; from &#39;.&#x2F;modules&#x2F;bar.js&#39;;\n\nconsole.log(name);\n\n&#x2F;&#x2F; main中修改, bar中验证\nsetTimeout(() &#x3D;&gt; &#123;\n  name &#x3D; &#39;kobe&#39;;\n&#125;, 1000);\n\n导入的变量不可以被修改\n思考：如果bar.js中导出的是一个对象，那么main.js中是否可以修改对象中的属性呢？\n\n答案是可以的，因为他们指向同一块内存空间；（自己编写代码验证，这里不再给出）\n\n4.3.2. Node中支持 ES Module在Current版本中\n在最新的Current版本（v14.13.1）中，支持es module我们需要进行如下操作：\n\n方式一：在package.json中配置 type: module（后续再学习，我们现在还没有讲到package.json文件的作用）\n方式二：文件以 .mjs 结尾，表示使用的是ES Module；\n\n这里我们暂时选择以 .mjs 结尾的方式来演练：\nbar.mjs\nconst name &#x3D; &#39;coderwhy&#39;;\n\nexport &#123;\n  name\n&#125;\n\nmain.mjs\nimport &#123; name &#125; from &#39;.&#x2F;modules&#x2F;bar.mjs&#39;;\n\nconsole.log(name);\n\n在LTS版本中\n在最新的LST版本（v12.19.0）中，我们也是可以正常运行的，但是会报一个警告：\nlts版本的警告\n4.3.3. ES Module和CommonJS的交互CommonJS加载ES Module\n结论：通常情况下，CommonJS不能加载ES Module\n\n因为CommonJS是同步加载的，但是ES Module必须经过静态分析等，无法在这个时候执行JavaScript代码；\n但是这个并非绝对的，某些平台在实现的时候可以对代码进行针对性的解析，也可能会支持；\nNode当中是不支持的；\n\nES Module加载CommonJS\n结论：多数情况下，ES Module可以加载CommonJS\n\nES Module在加载CommonJS时，会将其module.exports导出的内容作为default导出方式来使用；\n这个依然需要看具体的实现，比如webpack中是支持的、Node最新的Current版本也是支持的；\n但是在最新的LTS版本中就不支持；\n\nfoo.js\nconst address &#x3D; &#39;foo的address&#39;;\n\nmodule.exports &#x3D; &#123;\n  address\n&#125;\n\nmain.js\nimport foo from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\nconsole.log(foo.address);\n","slug":"node/base/Node基础三","date":"2022-10-01T04:23:22.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"a6a1fb5bcb751ccc4e9548f88f960a7a","title":"Node基础二","content":"二.node基础1.1. JavaScript文件执行如果我们编写一个js文件，里面存放JavaScript代码，如何来执行它呢？\n&#x2F;&#x2F; 1.直接打印一段文字\nconsole.log(&quot;我是一段JavaScript代码&quot;);\n\n&#x2F;&#x2F; 2.定义一个函数, 调用这个函数\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nconst result &#x3D; sum(20, 30);\nconsole.log(&quot;计算结果:&quot;, result);\n\n&#x2F;&#x2F; 3.执行定时器代码\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;2s后执行的代码&quot;);\n&#125;, 2000);\n\n目前我们知道有两种方式可以执行：\n\n将代码交给浏览器执行；\n将代码载入到node环境中执行；\n\n演练一：浏览器执行\n如果我们希望把代码交给浏览器执行：\n\n需要通过让浏览器加载、解析html代码，所以我们需要创建一个html文件；\n在html中通过script标签，引入js文件；\n当浏览器遇到script标签时，就会根据src加载、执行JavaScript代码；\n\nindex.html文件：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script src&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n浏览器执行结果\n演练二：Node执行\n如果我们希望把js文件交给node执行：\n\n首先电脑上需要安装Node.js环境，安装过程中会自动配置环境变量；\n可以通过终端命令node js文件的方式来载入和执行对应的js文件；\n\nnode index.js\n\nNode执行结果\n1.2. Node的REPL什么是REPL呢？感觉挺高大上\n\nREPL是Read-Eval-Print Loop的简称，翻译为“读取-求值-输出”循环；\nREPL是一个简单的，交互式的编程环境；\n\n事实上，我们浏览器的console就可以看成一个REPL：\n浏览器控台\nNode也给我们提供了一个REPL环境，我们可以在其中演练简单的代码：\nREPL演练\n2.1. 给node程序传递参数正常情况下执行一个node程序，直接跟上我们对应的文件即可：\nnode index.js\n\n但是，在某些情况下执行node程序的过程中，我们可能希望给node传递一些参数：\nnode index.js env&#x3D;development coderwhy\n\n如果我们这样来使用程序，就意味着我们需要在程序中获取到传递的参数：\n\n获取参数其实是在process的内置对象中的；\n\n如果我们直接打印这个内置对象，它里面包含特别的信息：\n\n其他的一些信息，比如版本、操作系统等大家可以自行查看，后面用到一些其他的我们还会提到；\n\nprocess对象\n现在，我们先找到其中的argv属性：\n\n我们发现它是一个数组，里面包含了我们需要的参数；\n你可能有个疑问，为什么叫argv呢？\n\nargv属性\n在C&#x2F;C++程序中的main函数中，实际上可以获取到两个参数：\n\nargc：argument counter的缩写，传递参数的个数；\n\nargv：argument vector的缩写，传入的具体参数。\n\n\nvector翻译过来是矢量的意思，在程序中表示的是一种数据结构。\n\n\n在C++、Java中都有这种数据结构，是一种数组结构；\n\n在JavaScript中也是一个数组，里面存储一些参数信息；\n\n\n我们可以在代码中，将这些参数信息遍历出来，使用：\n&#x2F;&#x2F; 获取参数\nconsole.log(process.argv);\nprocess.argv.forEach(item &#x3D;&gt; &#123;\n  console.log(item);\n&#125;);\n\n&#x2F;&#x2F; 结果如下：\n&#x2F;&#x2F; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;02_给Node传递参数&#x2F;index.js\n&#x2F;&#x2F; ENV&#x3D;dev\n&#x2F;&#x2F; coderwhy\n\n2.2. node程序输出内容console.log\n最常用的输入内容的方式：console.log\nconsole.log(&quot;hello coderwhy&quot;);\n\nconsole.clear\n清空控制台：console.clear\nconsole.clear\n\nconsole.trace\n打印函数的调用栈：console.trace\nfunction test() &#123;\n  demo();\n&#125;\nfunction demo() &#123;\n  foo();\n&#125;\nfunction foo() &#123;\n  console.trace();\n&#125;\ntest();\n\nconsole.trace结果\n还有一些其他的方法，其他的一些console方法，可以自己在下面学习研究一下。\nimage-20201008163045395\n3.1. 常见的全局对象Node中给我们提供了一些全局对象，方便我们进行一些操作：\n\n这些全局对象，我们并不需要从一开始全部一个个学习；\n某些全局对象并不常用，某些全局对象我们会在后续学习中讲到；\n比如module、exports、require()会在模块化中讲到；\n比如Buffer后续会专门讲到；\n\n全局对象\n3.2. 特殊的全局对象为什么我称之为特殊的全局对象呢？\n\n这些全局对象可以在模块中任意使用，但是在命令行交互中是不可以使用的；\n包括：__dirname、__filename、exports、module、require()\n\n__dirname\n获取当前文件所在的路径：\n\n注意：不包括后面的文件名\n\nconsole.log(__dirname);\n\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;03_常见的全局变量\n\n__filename\n获取当前文件所在的路径和文件名称：\n\n注意：包括后面的文件名称\n\nconsole.log(__filename);\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;03_常见的全局变量&#x2F;global对象.js\n\n3.3. 常见的全局对象process对象\nprocess提供了Node进程中相关的信息：\n\n比如Node的运行环境、参数信息等；\n后面在项目中，我也会讲解，如何将一些环境变量读取到 process 的 env 中；\n\nconsole.log(process);\n\nconsole对象\n提供了简单的调试控制台，在前面讲解输入内容时已经学习过了。\n\n更加详细的查看官网文档：https://nodejs.org/api/console.html\n\n定时器函数\n在Node中使用定时器有好几种方式：\n\nsetTimeout(callback, delay[, ...args])：callback在delay毫秒后执行一次；\n\nsetInterval(callback, delay[, ...args])：callback每delay毫秒重复执行一次；\n\nsetImmediate(callback[, ...args])：callbackI &#x2F; O事件后的回调的“立即”执行；\n\n\n这里先不展开讨论它和setTimeout(callback, 0)之间的区别；\n\n\n因为它涉及到事件循环的阶段问题，我会在后续详细讲解事件循环相关的知识；\n\nprocess.nextTick(callback[, ...args])：添加到下一次tick队列中；\n\n\n具体的讲解，也放到事件循环中说明；\n\n\n\n代码演练：\n\n暂时不用关心执行顺序问题，在后续事件循环中我会讲到；\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimtout&quot;);\n&#125;, 1000);\n\nsetInterval(() &#x3D;&gt; &#123;\n  console.log(&#39;setInterval&#39;);\n&#125;, 1000);\n\nsetImmediate(() &#x3D;&gt; &#123;\n  console.log(&quot;setImmediate&quot;);\n&#125;);\n\nprocess.nextTick(() &#x3D;&gt; &#123;\n  console.log(&quot;process.nextTick&quot;);\n&#125;);\n\n当然，它们有对应的取消定时器的方法：\n\nclearTimeout(timeoutObject);\nclearInterval(intervalObject);\nclearImmediate(immediateObject)\n\nglobal对象\nglobal是一个全局对象，事实上前端我们提到的process、console、setTimeout等都有被放到global中：\nconsole.log(process);\nconsole.log(global.process);\n\n为什么结果是一样的呢？\nNode的源码\nglobal中还有哪些属性呢？\nglobal其他属性的查看\nwindow和global的区别是什么？\n在浏览器中，全局变量都是在window上的，比如有document、setInterval、setTimeout、alert、console等等\n在Node中，我们也有一个global属性，并且看起来它里面有很多其他对象。\n但是在浏览器中执行的JavaScript代码，如果我们在顶级范围内通过var定义的一个属性，默认会被添加到window对象上：\nvar name &#x3D; &#39;coderwhy&#39;;\nconsole.log(window.name); &#x2F;&#x2F; coderwhy\n\n但是在node中，我们通过var定义一个变量，它只是在当前模块中有一个变量，不会放到全局中：\nvar name &#x3D; &#39;coderwhy&#39;;\nconsole.log(global.name); &#x2F;&#x2F; undefined\n","slug":"node/base/Node基础二","date":"2022-10-01T04:06:20.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"16ea75a74e45c427c7de22a19d8e1e05","title":"Node基础一","content":"一.JavaScript运行原理1.1. Atwood定律官方对Node.js的定义：\n\nNode.js是一个基于V8 JavaScript引擎的JavaScript运行时环境。\n\n什么是JavaScript运行环境？\n\n为什么JavaScript需要特别的运行环境呢？\n\n什么又是JavaScript引擎？\n\n什么是V8？\n\n\n我们先来把这些概念搞清楚，再去看Node到底是什么？\nStack Overflow的创立者之一的 Jeff Atwood 在2007年提出了著名的 Atwood定律：\n\nAny application that can be written in JavaScript, will eventually be written in JavaScript.\n任何可以使用JavaScript来实现的应用都最终都会使用JavaScript实现\n\n但是在发明之初，JavaScript的目的是应用于在浏览器执行简单的脚本任务，对浏览器以及其中的DOM进行各种操作，所以JavaScript的应用场景非常受限。\n\nAtwood定律更像是一种美好的远景，在当时看来还没有实现的可能性。\n但是随着Node的出现，Atwood定律已经越来越多的被证实是正确的。\n\n但是为了可以理解Node.js到底是如何帮助我们做到这一点的，我们必须了解JavaScript是如何被运行的。\n1.2. 浏览器内核我们经常会说：不同的浏览器有不同的内核组成\n\nGecko：早期被Netscape和Mozilla Firefox浏览器浏览器使用；\nTrident：微软开发，被IE4~IE11浏览器使用，但是Edge浏览器已经转向Blink；\nWebkit：苹果基于KHTML开发、开源的，用于Safari，Google Chrome之前也在使用；\nBlink：是Webkit的一个分支，Google开发，目前应用于Google Chrome、Edge、Opera等；\n\n事实上，我们经常说的浏览器内核指的是浏览器的排版引擎：\n\n排版引擎（layout engine），也称为浏览器引擎（browser engine）、页面渲染引擎（rendering engine）或样版引擎。\n\nWebKit main flow\n但是在这个执行过程中，HTML解析的时候遇到了JavaScript标签，应该怎么办呢？\n\n会停止解析HTML，而去加载和执行JavaScript代码；\n\n当然，为什么不直接异步去加载执行JavaScript代码，而要在这里停止掉呢？\n\n这是因为JavaScript代码可以操作我们的DOM；\n所以浏览器希望将HTML解析的DOM和JavaScript操作之后的DOM放到一起来生成最终的DOM树，而不是频繁的去生成新的DOM树；\n\n那么，JavaScript代码由谁来执行呢？\n\nJavaScript引擎\n\n1.3. JavaScript引擎为什么需要JavaScript引擎呢？\n\n事实上我们编写的JavaScript无论你交给浏览器或者Node执行，最后都是需要被CPU执行的；\n但是CPU只认识自己的指令集，实际上是机器语言，才能被CPU所执行；\n所以我们需要JavaScript引擎帮助我们将JavaScript代码翻译成CPU指令来执行；\n\n比较常见的JavaScript引擎有哪些呢？\n\nSpiderMonkey：第一款JavaScript引擎，由Brendan Eich开发（也就是JavaScript作者）；\nChakra：微软开发，用于IT浏览器；\nJavaScriptCore：WebKit中的JavaScript引擎，Apple公司开发；\nV8：Google开发的强大JavaScript引擎，也帮助Chrome从众多浏览器中脱颖而出；\n\n这里我们先以WebKit为例，WebKit事实上由两部分组成的：\n\nWebCore：负责HTML解析、布局、渲染等等相关的工作；\nJavaScriptCore：解析、执行JavaScript代码；\n\nwebkit内核\n看到这里，学过小程序的同学有没有感觉非常的熟悉呢？\n\n在小程序中编写的JavaScript代码就是被JSCore执行的；\n\n\n另外一个强大的JavaScript引擎就是V8引擎。\n1.4. V8引擎我们来看一下官方对V8引擎的定义：\n\nV8是用C ++编写的Google开源高性能JavaScript和WebAssembly引擎，它用于Chrome和Node.js等。\n它实现ECMAScript和WebAssembly，并在Windows 7或更高版本，macOS 10.12+和使用x64，IA-32，ARM或MIPS处理器的Linux系统上运行。\nV8可以独立运行，也可以嵌入到任何C ++应用程序中。\n\nV8引擎本身的源码非常复杂，大概有超过100w行C++代码，但是我们可以简单了解一下它执行JavaScript代码的原理：\n\nParse模块会将JavaScript代码转换成AST（抽象语法树），这是因为解释器并不直接认识JavaScript代码；\n\n\n如果函数没有被调用，那么是不会被转换成AST的；\n\n\nParse的V8官方文档：https://v8.dev/blog/scanner\n\nIgnition是一个解释器，会将AST转换成ByteCode（字节码）\n\n\n同时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）；\n\n\n如果函数只调用一次，Ignition会执行解释执行ByteCode；\n\nIgnition的V8官方文档：https://v8.dev/blog/ignition-interpreter\n\nTurboFan是一个编译器，可以将字节码编译为CPU可以直接执行的机器码；\n\n\n如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能；\n\n\n但是，机器码实际上也会被还原为ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如sum函数原来执行的是number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码；\n\nTurboFan的V8官方文档：https://v8.dev/blog/turbofan-jit\n\n\nimage-20200924165143332\n上面是JavaScript代码的执行过程，事实上V8的内存回收也是其强大的另外一个原因，这里暂时先不展开讨论：\n\nOrinoco模块，负责垃圾回收，将程序中不需要的内存回收；\nOrinoco的V8官方文档：https://v8.dev/blog/trash-talk\n\n2.1. Node.js是什么？回顾：官方对Node.js的定义：\n\nNode.js是一个基于V8 JavaScript引擎的JavaScript运行时环境。\n\nimage-20200924193328076\n也就是说Node.js基于V8引擎来执行JavaScript的代码，但是不仅仅只有V8引擎：\n\n前面我们知道Node.js可以嵌入到任何C ++应用程序中，无论是Chrome还是Node.js，事实上都是嵌入了V8引擎来执行JavaScript代码；\n但是在Chrome浏览器中，还需要解析、渲染HTML、CSS等相关渲染引擎，另外还需要提供支持浏览器操作的API、浏览器自己的事件循环等；\n另外，在Node.js中我们也需要进行一些额外的操作，比如文件系统读&#x2F;写、网络IO、加密、压缩解压文件等操作；\n\n所以，我们可以简单理解规划出Node.js和浏览器的差异：\nChrome浏览器和Node架构区别\n这里也有一份单独的Node.js的架构图：\n\n我们编写的JavaScript代码会经过V8引擎，再通过Node.js的Bindings，将任务放到Libuv的事件循环中；\nlibuv（Unicorn Velociraptor—独角伶盗龙）是使用C语言编写的库；\nlibuv提供了事件循环、文件系统读写、网络IO、线程池等等内容；\n具体内部代码的执行流程，我会在后续专门讲解事件和异步IO的原理中详细讲解；\n\nWhat is Node.js? Where, when and how to use it with examples\n2.2. Node.js可以做什么？了解了Node.js的架构，那么使用它我们可以做什么呢？\n\n前面我们提到，Node.js的出现，真正让Atwood定律变成了现实，Node.js的应用场景也越来越多。\n\n我们可以使用基于Node.js的Electron开发出类似于VSCode这种强大的桌面应用程序。另外前端自动化、模块化打包工具gulp、webpack也是基于Node.js开发和使用的。\nNode.js的快速发展也让企业对Node.js技术越来越重视，在前端招聘中通常会对Node.js有一定的要求，特别对于高级前端开发工程师，Node.js更是必不可少的技能：\n前端工程师岗位需求\n目前前端开发的库都是以node包的形式进行管理；\n\nnpm、yarn工具成为前端开发使用最多的工具；\n越来越多的公司使用Node.js作为web服务器开发；\n大量项目需要借助Node.js完成前后端渲染的同构应用；\n资深前端工程师需要为项目编写脚本工具（前端工程师编写脚本通常会使用JavaScript，而不是Python或者shell）；\n很多企业在使用Electron来开发桌面应用程序；\n\n总结一下，目前Node.js到底有哪些应用场景呢？\n\n前后端页面渲染\n\n\n支持项目同构开发\n\n\n对于需要进行首屏优化、SEO的页面进行后端渲染\n\n开发命令行工具\n\n\nwebpack、gulp等都是基于Node\n\n\n开发自己独立的命令行工具（类似于shell、Python做的事情，对于前端更加友好）\n\n桌面应用的开发\n\n\n类似于VSCode这种强大的桌面应用\n\n\n甚至开发桌面端类似于wayward大型游戏\n\n进行服务器开发\n\n\n拥有类似express、koa等强大的web框架\n\n\n开发Web Socket等服务器\n\n\n所以，作为前端开发工程师，Node.js已经是我们必须掌握的核心技术。\n2.3. Node.js的安装2.3.1. Node.js下载安装Node.js是在2009年诞生的，目前最新的版本是分别是12.18.4以及14.12.0：\n\nLTS版本：相对稳定一些，推荐线上环境使用该版本；\nCurrent版本：最新的Node版本，包含很多新特性；\n\nnode的版本\n这些我们选择什么版本呢？\n\n如果你是学习使用，可以选择current版本；\n如果你是公司开发，建议选择LTS版本；\n\nNode的安装方式有很多：\n\n可以借助于一些操作系统上的软件管理工具，比如Mac上的homebrew，Linux上的yum、dnf等；\n也可以直接下载对应的安装包下载安装；\n\n我们选择下载安装，下载自己操作系统的安装包直接安装就可以了：\n\nwindow选择.msi安装包，Mac选择.pkg安装包，Linux会在后续部署中讲解；\n安装过程中会配置环境变量；\n并且安装node过程中会安装npm（Node Package Manager）工具；\n\n我当前电脑上的版本：\n\nnode版本是12.16.1；\nnpm版本是6.14.8；\n\n我的node版本\n你应该已经发现，我这里使用的版本并不是Node的最新版本，无论是LTS或者Current：\n\n正好借助这里，和大家讲一下node的版本升级；\n\n2.3.2. Node.js版本管理在实际开发学习中，我们只需要使用一个Node版本来开发或者学习即可。\n但是，如果你希望通过可以快速更新或切换多个版本时，可以借助于一些工具：\n\nnvm：Node Version Manager；\nn：Interactively Manage Your Node.js Versions（交互式管理你的Node.js版本）\n\n这里我演示管理工具：n\n\nn是TJ方便node的版本管理，专门开发的；\n官方介绍是：n -  Interactively Manage Your Node.js Versions（交互式管理你的Node.js版本）\n\n安装n：直接使用npm安装即可\n# 安装工具n\nnpm install -g n\n# 查看安装的版本\nn --version\n\n安装最新的lts版本：\n\n前面添加的sudo是权限问题；\n可以两个版本都安装，之后我们可以通过n快速在两个版本间切换；\n\n# 安装最新的lts版本\nn lts\n\n# 安装最新的版本\nn latest\n\n安装lts版本\n查看所有的版本，并且选择要使用的版本：\n\n可以上下选择想使用的版本\n\n# 查看所有的版本\nn\n\n查看和选择所有的版本\n查看当前Node的版本：\n查看当前的版本\n问题：这两个工具都不支持window\n\nn：n is not supported natively on Windows.\nnvm：nvm does not support Windows\n\nWindow的同学怎么办？\n\n1.并不是每个人都需要安装多个版本，在课堂上我会以最新的Current版本讲解几乎所有内容；\n2.接下来我会在Mac上面演练n工具的使用，windows上可以使用nvm-window来完成；\n\n","slug":"node/base/Node基础一","date":"2022-09-30T15:33:43.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"18dd7f629894be8963e8c1c6b1ef8456","title":"Nginx常用操作及配置","content":"Nginx常用操作及配置常用操作#强制停止Nginx\nkill -9 nginx \nstart nginx\nnginx -s quit\nnginx -s reload\n\n常见配置# 进程数量\nworker_processes 1;\n\nevents &#123;\n  # 最大连接数量\n  worker_connections 1024;\n&#125;\n\nhttp &#123;\n  include mime.types;\n  default_type application&#x2F;octet-stream;\n  sendfile on;\n  keepalive_timeout 65;\n\n  # 演示如何强制http跳转https\n  server &#123;\n    listen 80;\n    server_name test.com;\n\n    # http强制跳转到https\n    rewrite ^(.*)$ https:&#x2F;&#x2F;$server_name$1 permanent;\n  &#125;\n\n  # 演示如何配置微信支付的校验文件\n  server &#123;\n    listen 80;\n    server_name localhost;\n\n    # 默认根路径\n    location &#x2F; &#123;\n      root index.html;\n    &#125;\n    # 微信支付校验文件，可以直接配置访问名称\n    location ^~&#x2F;MP_verify_2g3uEjrB5B2LIbNl.txt &#123;\n      alias &#x2F;home&#x2F;MP_verify_2g3uEjrB5B2LIbNl.txt;\n    &#125;\n    # 微信支付校验文件，也可以通过正则配置\n    location ~^&#x2F;MP_verify_[a-zA-Z0-9]*\\.(txt)$ &#123;\n      root &#x2F;home&#x2F;;\n      rewrite ^&#x2F;home&#x2F;(.txt)$ &#x2F;home&#x2F;$1 last;\n    &#125;\n  &#125;\n\n  # 演示root和alias两种配置静态资源的区别\n  server &#123;\n    listen 80;\n    server_name localhost;\n\n    # 用root方式，location中的路径会拼加到root的地址后面\n    # 请求路径为：http:&#x2F;&#x2F;localhost:8080&#x2F;files&#x2F;index.jpg    实际访问为：&#x2F;home&#x2F;files&#x2F;index.jpg\n    location ~^&#x2F;files&#x2F; &#123;\n      root &#x2F;home&#x2F;;\n      index index.html index.htm;\n    &#125;\n    # 用alias方式，location中的路径不会拼加到alias的地址后面\n    # 这请求路径为：http:&#x2F;&#x2F;localhost:8080&#x2F;files&#x2F;index.jpg    实际访问为：&#x2F;home&#x2F;index.jpg\n    location ~^&#x2F;files&#x2F; &#123;\n      alias &#x2F;home&#x2F;;\n      index index.html index.htm;\n    &#125;\n  &#125;\n\n  # 演示请求后台接口代理配置\n  server &#123;\n    listen 8080;\n    server_name localhost;\n\n    #################### 第一种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;api&#x2F;getUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际指向为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;api&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n\n    #################### 第二种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;getUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n\n    #################### 第三种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;usergetUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n\n    #################### 第四种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;getUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n  &#125;\n\n  # 演示前端项目部署加访问前缀的nginx配置\n  server &#123;\n    listen 8090;\n    server_name localhost;\n\n    # 部署路径：&#x2F;home&#x2F;web&#x2F;my_demo\n    # 访问路径为：http:&#x2F;&#x2F;localhost:8090&#x2F;\n    location &#x2F; &#123;\n      try_files $uri $uri&#x2F; &#x2F;index.html;\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header Host $http_host;\n      root &#x2F;home&#x2F;web&#x2F;my_demo&#x2F;;\n      index index.html index.htm;\n    &#125;\n\n    # 部署路径：&#x2F;home&#x2F;web&#x2F;my_demo\n    # 访问路径为：http:&#x2F;&#x2F;localhost:8090&#x2F;my_demo&#x2F;\n    # 如果location路径最后没有配置斜杠，则浏览器输入访问地址后，路径最后会自动拼一个斜杠\n    location ^~&#x2F;my_demo&#x2F; &#123;\n      try_files $uri $uri&#x2F; &#x2F;my_demo&#x2F;index.html;\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header Host $http_host;\n      root &#x2F;home&#x2F;web&#x2F;;\n      index index.html index.htm;\n    &#125;\n  &#125;\n&#125;\n\n","slug":"nginx/Nginx常用操作及配置","date":"2022-09-30T15:24:15.000Z","categories_index":"Nginx","tags_index":"Nginx","author_index":"ChrisWood"}]