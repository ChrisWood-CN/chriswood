[{"id":"ab71b7b05749a5527c735a9fb6d5af98","title":"Java高并发专题-JUC线程池","content":"线程池Executor框架接口\nExecutors.newCachedThreadPool() 创建缓存线程池public class ThreadPoolExample1 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;\nExecutors.newFixedThreadPool(3) 创建定长线程池public class ThreadPoolExample2 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(3);\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;\nExecutors.newSingleThreadExecutor() 创建单线程线程池public class ThreadPoolExample3 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor();\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            final int index &#x3D; i;\n            executorService.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    log.info(&quot;task:&#123;&#125;&quot;, index);\n                &#125;\n            &#125;);\n        &#125;\n        executorService.shutdown();\n    &#125;\n&#125;\nExecutors.newScheduledThreadPool(1) 创建定长线程池，支持定时，周期性的任务执行public class ThreadPoolExample4 &#123;\n\n    public static void main(String[] args) &#123;\n\n        ScheduledExecutorService executorService &#x3D; Executors.newScheduledThreadPool(1);\n\n        executorService.scheduleAtFixedRate(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                log.warn(&quot;schedule run&quot;);\n            &#125;\n        &#125;, 1, 3, TimeUnit.SECONDS);\n        \n&#x2F;&#x2F;        executorService.shutdown();\n\n        Timer timer &#x3D; new Timer();\n        timer.schedule(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                log.warn(&quot;timer run&quot;);\n            &#125;\n        &#125;, new Date(), 5 * 1000);\n    &#125;\n&#125;\n前面三种线程池都是直接创建ThreadPoolExecutor类的对象。ScheduledThreadPool 因为要实现定时功能，创建的是 ScheduledThreadPoolExecutor 类的对象。但 ScheduledThreadPoolExecutor 也是继承自ThreadPoolExecutor 。下面这个构造方法是参数最全的一个创建线程池的源码。&#x2F;**\n * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial\n * parameters.\n *\n * @param corePoolSize 线程池中维持的线程数量。\n *                     当线程数量不超过这个数时，即使线程处于空闲状态也不会被销毁，会一直等待任务到来。\n *                     但是如果设置 allowCoreThreadTimeOut 为 true，corePoolSize 就不再有效了。\n * @param maximumPoolSize 线程池中线程的最大数量。\n * @param keepAliveTime 当线程数量超过了 corePoolSize 时，多余的线程销毁前等待的时间。\n * @param unit keepAliveTime 的时间单位\n * @param workQueue 用来管理待执行任务的队列。\n * @param threadFactory 创建线程的工厂。\n * @param handler RejectedExecutionHandler 接口的实现对象。用于处理任务被拒绝执行的情况。\n *                被拒绝的原因可能是所有线程正在执行任务而任务队列容量又满了\n *&#x2F;\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) &#123;\n    ...\n&#125;\n\n","slug":"java/concurrent/Java高并发专题-JUC线程池","date":"2022-10-08T08:55:43.000Z","categories_index":"Java高并发专题","tags_index":"Java高并发专题","author_index":"ChrisWood"},{"id":"38ca70cafbfd87b7f0418630bd7d0ad1","title":"springboot配置文件","content":"springboot配置文件在springboot 项目中一般默认的配置文件是application.properties,但是实际项目中我们一般会使用application.yml文件\nyml文件读取顺序存放目录SpringBoot配置文件默认可以放到以下目录中，可以自动读取到：\n\n项目根目录中config目录下\n项目根目录下\n项目resources目录中config目录下\n项目的resources目录下\n\n读取顺序在不同的目录中存在多个配置文件，它的读取顺序是：1、config&#x2F;application.properties（项目根目录中config目录下）2、config&#x2F;application.yml3、application.properties（项目根目录下）4、application.yml5、resources&#x2F;config&#x2F;application.properties（项目resources目录中config目录下）6、resources&#x2F;config&#x2F;application.yml7、resources&#x2F;application.properties（项目的resources目录下）8、resources&#x2F;application.yml\n\n\n\n\n\n\n\n\n\n注意：1、如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。2、如果同一个配置属性，在多个配置文件都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。3、创建SpringBoot项目时，一般的配置文件放置在“项目的resources目录下\nyml文件读取方式yml文件规则\nyml文件的好处，天然的树状结构，一目了然，实质上跟properties是差不多\n不支持tab缩进\n可以使用 “-小写字母” 或 “_小写字母”来 代替 “大写字母”,如 userName 与 user-name ,user_name 含义是一样的,key: value 格式书写key,后面跟着冒号,再后面跟着一个空格,然后是值\n\n几种数据格式的表示方式1.普通的值（数字，字符串，布尔）key: value ,如:\nage: 18\nname: zhangsan\n\n\n\n\n\n\n\n\n\n注意：字符串默认不用加上单引号或者双引号；“”：双引号不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi‘’：单引号会转义特殊字符，特殊字符最终只是一个普通的字符串数据name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi\n2.对象、Map（属性和值）（键值对）person:\n    age: 18\n    name: mysgk\nmap:  \n  name: 刘德华  \n  age: 10\n3.数组（List、Set）hands:\n    - left\n    - right\nlist: 列表1,列表2,列表3\nset: [集合1,集合2,集合3]\n读取配置的方式1.@Value直接在对应的变量上添加@Value注解即可，此时配置的key可以不与变量名相同\nserver:\n  port: 8081\n@Value(&quot;$&#123;server.port&#125;&quot;)\npublic String serverPort;\n2.@ConfigurationProperties新增一个Student类，同时添加@ConfigurationProperties注解\nstudent:  \n  name: 刘德华  \n  age: 40\n@Data\n@ConfigurationProperties(prefix &#x3D; &quot;student&quot;)\npublic class Student &#123;    \n    String name;    \n    int age;\n&#125;\n3.@Environment用的很少，了解即可\ntest:\n    msg: aaa\n@Autowired\nprivate Environment env\n\npublic static void main() &#123;\n    System.out.println(env.getProperty(&quot;test.msg&quot;));\n&#125;\n","slug":"springboot/springboot配置文件","date":"2022-10-08T07:55:43.000Z","categories_index":"springboot","tags_index":"springboot","author_index":"ChrisWood"},{"id":"e92c64341ee2ef385eda6a1d1f832be9","title":"Mysql基础","content":"Mysql常见数据库\nMYSQL：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费。\nOracle：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。\nDB2 ：IBM公司的数据库产品,收费的。常应用在银行系统中.\nSQLServer：MicroSoft 公司收费的中型的数据库。C#、.net等语言常使用。\nSyBase：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。\nSQLite：嵌入式的小型数据库，应用在手机端。\n常用数据库：MYSQL，Oracle\nSQL语句SQL分类：\n数据定义语言：简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列等。关键字：create，alter，drop等\n数据操作语言：简称DML(Data Manipulation Language)，用来对数据库中表的记录进行更新。关键字：insert，delete，update等\n数据控制语言：简称DCL(Data Control Language)，用来定义数据库的访问权限和安全级别，及创建用户\n数据查询语言：简称DQL(Data Query Language)，用来查询数据库中表的记录。关键字：select，from，where等\nint（integer） 整数类型\nbigint （long） 整数类型\ndouble 小数类型\ndecimal（m,d） 指定整数位与小数位长度的小数类型\ndate 日期类型，格式为yyyy-MM-dd，包含年月日，不包含时分秒\ndatetime 日期类型，格式为 YYYY-MM-DD HH:MM:SS，包含年月日时分秒\ntimestamp 日期类型，时间戳\nvarchar（M） 文本类型， M为0~65535之间的整数\njson 8.0以上版本支持json数据类型\n\nDDL操作语言(3%)数据库操作：database\n#创建数据库\ncreate database 数据库名;\ncreate database 数据库名 character set 字符集;\n#查看所有数据库\nshow databases;\n#查看某个数据库的定义的信息\nshow create database 数据库名;\n#删除数据库\ndrop database 数据库名;\n#查看正在使用的数据库\nselect database();\n#切换数据库\nuse 数据库名;\n\n表操作：table\n#创建表\ncreate table 表名(\n字段名 类型(长度) [约束],##[ ]代表可以省略\n字段名 类型(长度) [约束],\n&#x2F;*约束 对某列数据进行限制\n主键约束--限制某列数据既不能为空也不能重复\n唯一约束--限制某列数据不能重复\n非空约束--限制某列数据不能为空\n*&#x2F;\n...\n字段名 类型(长度) [约束]\n);\nCREATE TABLE category (\ncid INT primary key, #分类ID\ncname VARCHAR(100) #分类名称\n);\n#查看数据库中的所有表\nshow tables;\n#查看表结构\ndesc 表名;\n#删除表\ndrop table 表名;\n#修改表结构格式\n&#x2F;*添加列*&#x2F;  alter table 表名 add 列名 类型(长度) [约束];\n&#x2F;*修改列的类型长度及约束*&#x2F;  alter table 表名 modify 列名 类型(长度) 约束;\n&#x2F;*修改列名*&#x2F; alter table 表名 change 旧列名 新列名 类型(长度) 约束;\n&#x2F;*删除列*&#x2F; alter table 表名 drop 列名;#列中数据一起删除\n&#x2F;*修改表名*&#x2F;rename table 表名 to 新表名;\n&#x2F;*修改表的字符集*&#x2F;alter table 表名 character set 字符集(了解);\n\nDML操作语言(7%)#插入表记录：insert\n-- 向表中插入某些字段\ninsert into 表 (字段1,字段2,字段3..) values (值1,值2,值3..);\n-- 向表中插入所有字段,字段的顺序为创建表时的顺序 \ninsert into 表 values (值1,值2,值3..);#数值类型外其他的字段类型的值必须使用引号(建议单引号)\ninsert into 表 values (值1,值2,值3..),(值1,值2,值3..); #批量插入\ninsert into 表 values [[值1,值2,值3..],[值1,值2,值3..]]; #批量插入\n-- 涉及自增的可以这样用,自增数值会自动覆盖null\ninsert into 表 values (null,值2,值3...);\n#更新表记录：update\nupdate 表名 set 字段名&#x3D;值,字段名&#x3D;值,...;\nupdate 表名 set 字段名&#x3D;值,字段名&#x3D;值,... where 条件;\n#删除符合条件记录：delete  from 表名 [where 条件] 逐行删除,不重置主键自增,再添加数据继续用之前的主键\n#删除表中所有记录: truncate table 表名  把表也删除,重新创建新表,会重置主键自增,重新开始\ndelete from 表名 [where 条件];\n\n扩展\nshow variables like &#39;character%&#39;; #查看所有mysql的编码\nset names gbk;#临时方案 当前窗口有效\n#安装目录下修改my.ini文件，重启服务所有地方生效。\n\nSQL约束主键约束\n#设置主键约束\nfirstname int PRIMARY KEY -- 1.创建表时，在字段描述处，声明指定字段为主键\nCONSTRAINT pk_personID PRIMARY KEY (firstname,lastname)\n-- 2.创建表时，在constraint约束区域，声明指定字段为主键  格式： [constraint 名称] primary key (字段列表)\n-- 关键字constraint可以省略，如果需要为主键命名，constraint不能省略，主键名称一般没用\n-- 字段列表需要使用小括号括住，如果有多字段需要使用逗号分隔。声明两个以上字段为主键，我们称为联合主键\nALTER TABLE persons ADD PRIMARY KEY (firstname,lastname)-- 3.创建表之后，通过修改表结构，声明指定字段为主键\n\n#删除主键约束\nALTER TABLE persons DROP PRIMARY KEY;#扩展 小bug 删除主键约束之后会保留非空约束\n\n自动增长列\n&#x2F;* auto_increment（自动增长列）关键字，自动增长列类型必须是整形，自动增长列必须为键(一般是主键)。*&#x2F;\np_id int PRIMARY KEY AUTO_INCREMENT,\n#扩展：默认AUTO_INCREMENT 的开始值是 1，如果希望修改起始值，请使用下列 SQL 语法\nALTER TABLE persons AUTO_INCREMENT&#x3D;100\n#删除方式：\n#delete 一条一条删除，不清空auto_increment记录数。\n#truncate 直接将表删除，重新建表，auto_increment将置为零，从新开始。\n\n非空约束\n# NOT NULL 约束强制列不接受 NULL 值\nid_p int NOT NULL,\nlastname varchar(255) NOT NULL\n\n唯一约束\n&#x2F;*UNIQUE约束唯一标识数据库表中的每条记录.UNIQUE和PRIMARY KEY约束均为列或列集合提供了唯一性的保\n证.PRIMARY KEY拥有自动定义的UNIQUE约束.!!每个表可以有多个UNIQU约束，但是每个表只能有一个PRIMARY KEY约束。*&#x2F;\nid_p int UNIQUE, -- 1.创建表时，在字段描述处声明唯一\nCONSTRAINT 名称 UNIQUE (id_p)-- 2.创建表时，在约束区域声明唯一\nALTER TABLE persons ADD [CONSTRAINT 名称] UNIQUE (id_p)-- 3.创建表后，修改表结构，声明字段唯一\n#如果值为null,则失去了unique约束的意义\n#删除唯一约束\nALTER TABLE persons DROP INDEX 字段名&#x2F;唯一约束名;\n\n默认约束\n#方式一,创建表,列数据类型后面 default &#39;默认值&#39;\ncity varchar(20) default &#39;北京&#39;\n#方式二,修改表结构\nalter table persons modify city varchar(20) default &#39;北京&#39;\n#删除默认约束\nalter table persons modify city varchar(20)\n\n数据库密码重置(扩展)\n停止mysql服务器运行输入services.msc 停止mysql服务\n\n在cmd下,输入mysqld –console –skip-grant-tables 启动服务器,出现一下页面,不要关闭该窗口\n\n新打开cmd,输入mysql -uroot 不需要密码\nuse mysql;\nupdate user set password&#x3D;password(&#39;abc&#39;) WHERE user&#x3D;&#39;root&#39;;#新密码为abc\n\n关闭两个cmd窗口\n\n\nSQL语句(DQL)简单查询语句\n&#x2F;* 格式一 查询指定的列 select 列名,列名 from 表名;\n*&#x2F;\nSELECT pid,pname FROM product;\n&#x2F;* 格式二 查询所有列的数据 \n select 列出所有列名 from 表名;\n select * from 表名 &#x2F;&#x2F;工作中很少用,查询数据多,效率慢\n*&#x2F;\nSELECT * FROM product;\n&#x2F;* 格式三 过滤重复的数据 \nselect distinct 字段1,字段二.. from 表名;\ndistinct关键字之后只有一个字段,就会过滤掉这个字段中重复的数据\ndistinct关键字之后又多个字段,多个字段同时满足才会过滤掉\n*&#x2F;\n-- 查询商品价格 过滤掉重复的价格\nSELECT DISTINCT price FROM product;\n-- 查询商品名称和价格 过滤掉名称和价格同时重复的数据\nSELECT DISTINCT pname,price FROM product;\n&#x2F;* 格式四 别名查询 \n1.给表起一个别名:多表查询时使用\n\tselect *|字段 from 表名 [as] 别名;\n2.给表中的字段起别名\n\tselect 字段1 [as] 别名,...字段n [as] 别名 from 表名;\n注意:别名只是对查询结果临时起一个名字,不会改变表中原有的名字;别名中如有特殊符号或者空格,必须用引号包裹起来\n*&#x2F;\nSELECT * FROM product AS p;\nSELECT pname AS 商品名称,price AS 商品价格 FROM product;\nSELECT pname  商品名称,price  &#39;商品 价格&#39; FROM product;\n&#x2F;*\n查询语句中可以直接进行数据计算\n*&#x2F;\nSELECT (1&#x3D;1+1);-- 2\n-- 查询商品名称和商品价格,把价格在查询时+10000\nSELECT pname  商品名称,price+10000  商品价格 FROM product;\n\n条件查询\n&#x2F;*\n比较运算符 &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;(!&#x3D;);between...and...显示在某一区间的值含头含尾;in(set)显示在in列表中的值;like&#39;_a%&#39;模糊查询,_代表一个字符%代表零个或多个任意字符;is null判断是否为空\n逻辑运算符 and or not\n*&#x2F;\n\n排序查询\n&#x2F;*通过order by语句，可以将查询出的结果进行排序。暂时放置在select语句的最后。\nSELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;\n#ASC 升序 (默认)\n#DESC 降序\n*&#x2F;\nSELECT * FROM product ORDER BY price DESC,category_id DESC;\n\n聚合查询\n&#x2F;*\n之前的查询都是横向查询，都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。\n五个聚合函数\ncount：统计指定列不为NULL的记录行数；\nsum：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；\nmax：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；\nmin：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；\navg：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；\n*&#x2F;\nSELECT count(*) FROM product\n\n分组查询\nSELECT 被份组的字段1,(求和,平均值,个数,最大,最小) FROM 表名 [where 条件 ]GROUP BY 被分组字段 HAVING 分组条件;\n#分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条件。\n&#x2F;*\nhaving与where的区别:\nhaving是在分组后对数据进行过滤\nwhere是在分组前对数据进行过滤\nhaving后面可以使用分组函数(统计函数)\nwhere后面不可以使用分组函数\n*&#x2F;\n\n分页查询\n在工作中不是把所有满足条件的数据全部查询出来,效率低下,对数据进行分页查询,\n&#x2F;*\n分页查询语句 关键字 limit\n格式: \n只要n条数据 select *|字段 from 表名 limit n;\nselect *|字段 from 表名 limit m n; m表示每页开始的行的索引(变化的) n表示每页的数量(不变的)\n注意:数据库行的索引从0开始,列的索引从1开始\n*&#x2F;\n\n多表操作一对多关系建表原则:从表使用主表的主键作为外键\n&#x2F;*\n外键约束的作用:保证数据的准确和完整\n主表中有的数据,从表可以有也可以没有\n主表中没有的数据,从表也不能有\n删除主表的数据,必须保证从表没有使用\n*&#x2F;\n#声明外键约束\nalter table 从表 add [constraint][外键名称] foreign key (从表外键字段名) references 主表 (主表的主键);\n#删除外键约束\nalter table 从表 drop foreign key 外键名称\n\n多对多关系需要创建一张中间表(商品主键–订单主键),中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键\n一对多操作多对多操作多表关系实战#实战1：省和市 \n&#x2F;*\n省和市实例\n*&#x2F;\nCREATE DATABASE day03;\nUSE day03;\n-- 创建主表\nCREATE TABLE province(\n  pid INT PRIMARY KEY AUTO_INCREMENT,\n  pname VARCHAR(20),\n  description VARCHAR(50)\n);\nINSERT INTO province(pname,description) VALUES (&#39;河北&#39;,&#39;雾霾&#39;),(&#39;内蒙古&#39;,&#39;草原&#39;),(&#39;广东&#39;,&#39;经济特区&#39;);\n-- 创建从表\nCREATE TABLE city(\n  cid INT PRIMARY KEY AUTO_INCREMENT,\n  cname VARCHAR(20),\n  description VARCHAR(50),\n-- 所属省份 外键\n  province_pid INT\n);\nALTER TABLE city ADD FOREIGN KEY (province_pid) REFERENCES province(pid);\nSHOW TABLES;\nINSERT INTO city VALUES (NULL,&#39;石家庄&#39;,&#39;雾霾之最&#39;,1),(NULL,&#39;承德&#39;,&#39;避暑山庄&#39;,1);\nINSERT INTO city VALUES (NULL,&#39;包头&#39;,&#39;草原钢城&#39;,2),(NULL,&#39;赤峰&#39;,&#39;红山文化&#39;,2);\nINSERT INTO city VALUES (NULL,&#39;深圳&#39;,&#39;经济特区&#39;,3),(NULL,&#39;东莞&#39;,&#39;服务行业&#39;,3);\n-- 城市表添加主表省份不存在的数据\nINSERT INTO city VALUES (NULL,&#39;澳门&#39;,&#39;博彩娱乐&#39;,4);-- 报错\n\n自关联的一对多关系(了解)本表的外键使用本表的主键,工作中很少用\n\n\n\n地区主键\n地区名称\n地区描述\n所属省份\n\n\n\n1\n河北\n雾霾\nnull\n\n\n2\n内蒙古\n草原\nnull\n\n\n3\n石家庄\n雾霾之最\n1\n\n\n4\n承德\n避暑山庄\n1\n\n\n5\n包头\n草原钢城\n2\n\n\n6\n赤峰\n红山文化\n2\n\n\n#实战2\n&#x2F;*\n用户和角色\n*&#x2F;\n创建用户表\n创建角色表\n创建中间表 添加外键(直接在创建表时声明或者alter table 从表名 add foreign key (从表字段名) references 主表(主表字段名))\n\n多表查询#交叉连接查询(很少用,有错误数据,笛卡尔积)\nselect * from 表A,表B\n#内连接查询,在交叉连接查询的基础上,使用外键约束作为查询条件\n&#x2F;*隐式内连接 ,不使用关键字 [inner] join on*&#x2F;\nselect * from 表A,表B where 表A.主键&#x3D;表B.外键;\n&#x2F;*显式内连接 ,使用关键字 [inner] join on    on的后面可继续写where条件*&#x2F;\nselect * from 表A  [inner] join 表B on 表A.主键&#x3D;表B.外键;\n#外连接,在交叉查询的基础上,使用外键约束作为查询条件\n&#x2F;*左外连接 ,使用关键字 left [outer] join on*&#x2F;\nselect * from 表A  left [outer] join 表B on 表A.主键&#x3D;表B.外键;\n-- 左外连接查询以左边表为主,左边有的数据右边没有就使用null代替,左边没有的数据,右边也不能出现\n&#x2F;*右外连接 ,使用关键字 right [outer] join on*&#x2F;\nselect * from 表A  right [outer] join 表B on 表A.主键&#x3D;表B.外键;\n-- 右外连接和左外连接相反\n\n#子查询 sql语句的嵌套\n&#x2F;*一条sql语句的查询结果,作为另一条sql语句的查询条件*&#x2F;\nselect * from 表B where 字段&#x3D;(select 字段 from 表A [where条件])\n&#x2F;*一条sql语句的查询结果,作为另一条sql语句的另一张表(隐式内连接查询,先过滤数据)*&#x2F;\nselect * from (select * from 表A [where条件]),表B where 表A.主键&#x3D;表B.外键\n\n事务操作事务指的是逻辑上的一组操作,组成这组操作的各个单元要么全都成功,要么全都失败事务作用：保证在一个事务中多次SQL操作要么全都成功,要么全都失败\nmysql事务操作 start transaction开启事务 commit提交事务 rollback回滚事务\n事务总结事务特性ACID\n原子性(Atomicity)指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生\n一致性(Consistency)事务前后数据的完整性必须保持一致\n隔离性(Isolation)事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。\n持久性(Durability)持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。\n\n并发访问问题\n脏读：一个事务读到了另一个事务未提交的数据\n不可重复读：一个事务读到了另一个事务已经提交(update)的数据。引发另一个事务，在事务中的多次查询结果不一致\n虚读 &#x2F;幻读：一个事务读到了另一个事务已经提交(insert)的数据。导致另一个事务，在事务中多次查询的结果不一致\n\n隔离级别(解决问题)数据库规范规定了4种隔离级别，分别用于描述两个事务并发的所有情况\n1.read uncommitted 读未提交，一个事务读到另一个事务没有提交的数据,可能存在脏读、不可重复读、虚读\n2.read committed 读已提交，一个事务读到另一个事务已经提交的数据，可能存在不可重复读、虚读\n3.repeatable read 可重复读，在一个事务中读到的数据始终保持一致，无论另一个事务是否提交，可能存在虚读\nserializable 串行化，同时只能执行一个事务，相当于事务中的单线程，三个问题都没有了\n安全性： serializable[8]&gt;repeatable read[4]&gt;read committed[2 ]&gt;read uncommitted[1]\n性能对比刚好和安全性相反\n常见数据库的默认隔离级别：MySql: repeatable read   Oracle: read committed\nmysql统计技巧-- 统计前六个月的数据\nSELECT month_table.monthValue as month, temp.countValue as count FROM\n(SELECT\n\tdate_format( @lastDay :&#x3D; last_day( date_add( @lastDay, INTERVAL 1 MONTH ) ), &#39;%Y-%m&#39; ) monthValue \nFROM\n\t( SELECT @lastDay :&#x3D; date_add( curdate( ), INTERVAL - 6 MONTH ) FROM mysql.help_topic LIMIT 6 ) a) month_table\nLEFT JOIN\n(select DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;) as monthValue, count(*) as countValue from sys_user u GROUP BY DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;)) temp ON temp.monthValue &#x3D; month_table.monthValue\nORDER BY month_table.monthValue\n-- 原理 1 制作前六个月的月份表\nSELECT\n\tdate_format( @lastDay :&#x3D; last_day( date_add( @lastDay, INTERVAL 1 MONTH ) ), &#39;%Y-%m&#39; ) monthValue \nFROM\n\t( SELECT @lastDay :&#x3D; date_add( curdate( ), INTERVAL - 6 MONTH ) FROM mysql.help_topic LIMIT 6 ) a\n-- 原理 2 制作目标表的按月分组的统计数据\nselect DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;) as monthValue, count(*) as countValue from sys_user u GROUP BY DATE_FORMAT(u.create_time,&#39;%Y-%m&#39;)\n-- 使用外链接合并两张临时表，并查询出需要的字段\n\n-- 统计近30天的数据\n-- 1 生成30天的表\nSELECT\n\t\t@s :&#x3D; @s + 1 AS indexs,\n\t\tDATE_FORMAT( DATE( DATE_SUB( CURRENT_DATE, INTERVAL @s DAY ) ), &#39;%Y-%m-%d&#39; ) AS dates \n\tFROM\n\t\tmysql.help_topic,\n\t\t( SELECT @s :&#x3D; -1 ) temp  #不想包含当天，@s:&#x3D;0\n\tWHERE\n\t\t@s &lt; 30 \n\tORDER BY\n\t\tdates\n-- 制作目标表按天的统计数据\n-- 使用外链接合并两张临时表，并查询出需要的字段\n\nMySQL日期格式化MySQL日期格式化DATE_FORMAT()取值范围。\n值     含义\n%S、%s 秒        两位数字形式的秒（ 00,01, ..., 59）\n%I、%i 分       两位数字形式的分（ 00,01, ..., 59）\n%H    小时     24小时制，两位数形式小时（00,01, ...,23）\n%h    12小时制，两位数形式小时（00,01, ...,12）\n%k    24小时制，数形式小时（0,1, ...,23）\n%l    12小时制，数形式小时（0,1, ...,12）\n%T    24小时制，时间形式（HH:mm:ss）\n%r    12小时制，时间形式（hh:mm:ss AM 或 PM）\n%p    AM上午或PM下午 \n%W    周      一周中每一天的名称（Sunday,Monday, ...,Saturday）\n%a    一周中每一天名称的缩写（Sun,Mon, ...,Sat） \n%w     以数字形式标识周（0&#x3D;Sunday,1&#x3D;Monday, ...,6&#x3D;Saturday） \n%U    数字表示周数，星期天为周中第一天\n%u    数字表示周数，星期一为周中第一天\n%d     天     两位数字表示月中天数（01,02, ...,31）\n%e      数字表示月中天数（1,2, ...,31）\n%D    英文后缀表示月中天数（1st,2nd,3rd ...） \n%j    以三位数字表示年中天数（001,002, ...,366） \n%M     月  英文月名（January,February, ...,December） \n%b     英文缩写月名（Jan,Feb, ...,Dec） \n%m     两位数字表示月份（01,02, ...,12）\n%c     数字表示月份（1,2, ...,12） \n%Y    年     四位数字表示的年份（2015,2016...）\n%y      两位数字表示的年份（15,16...）\n%文字   文字输出       直接输出文字内容\n\n","slug":"mysql/base/Mysql基础","date":"2022-10-01T04:55:09.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"ChrisWood"},{"id":"c5c39a45409b6c5284d037b63eb17322","title":"Node基础十二","content":"十二.数据库MySQL认识数据库1.1. 为什么要使用数据库任何的软件系统都需要存放大量的数据，这些数据通常是非常复杂和庞大的：\n\n比如用户信息包括姓名、年龄、性别、地址、身份证号、出生日期等等；\n比如商品信息包括商品的名称、描述、价格（原价）、分类标签、商品图片等等；\n比如歌曲信息包括歌曲的名称、歌手、专辑、歌曲时长、歌词信息、封面图片等等；\n\n那么这些信息不能直接存储到文件中吗？可以，但是文件系统有很多的缺点：\n\n很难以合适的方式组织数据（多张表之前的关系合理组织）；\n并且对数据进行增删改查中的复杂操作（虽然一些简单确实可以），并且保证单操作的原子性；\n很难进行数据共享，比如一个数据库需要为多个程序服务，如何进行很好的数据共享；\n需要考虑如何进行数据的高效备份、迁移、恢复；\n等等…\n\n数据库通俗来讲就是一个存储数据的仓库，数据库本质上就是一个软件、一个程序。\n1.2. 常见的数据库有哪些？通常我们将数据划分成两类：\n\n关系型数据库：MySQL、Oracle、DB2、SQL Server、Postgre SQL等；\n\n\n关系型数据库通常我们会创建很多个二维数据表；\n\n\n数据表之间相互关联起来，形成一对一、一对多、多对对等关系；\n\n之后可以利用SQL语句在多张表中查询我们所需的数据；\n\n支持事物，对数据的访问更加的安全；\n\n非关系型数据库：MongoDB、Redis、Memcached、HBse等；\n\n\n非关系型数据库的英文其实是Not only SQL，也简称为NoSQL；\n\n\n相当而已非关系型数据库比较简单一些，存储数据也会更加自由（甚至我们可以直接将一个复杂的json对象直接塞入到数据库中）；\n\nNoSQL是基于Key-Value的对应关系，并且查询的过程中不需要经过SQL解析，所以性能更高；\n\nNoSQL通常不支持事物，需要在自己的程序中来保证一些原子性的操作；\n\n\n如何在开发中选择他们呢？具体的选择会根据不同的项目进行综合的分析，我这里给一点点建议：\n\n目前在公司进行后端开发（Node、Java、Go等），还是以关系型数据库为主；\n比较常用的用到非关系型数据库的，在爬取大量的数据进行存储时，会比较常见；\n\n我们的课程是开发自己的后端项目，所以我们以关系型数据库MySQL作为主要内容。\nMySQL的介绍：\n\nMySQL原本是一个开源的数据库，原开发者为瑞典的MySQL AB公司；\n在2008年被Sun公司收购；在2009年，Sun被Oracle收购；\n所以目前MySQL归属于Oracle；\n\nMySQL是一个关系型数据库，其实本质上就是一款软件、一个程序：\n\n这个程序中管理着多个数据库；\n每个数据库中可以有多张表；\n每个表中可以有多条数据；\n\n关系型数据库\n1.3. MySQL的下载和安装第一步：下载MySQL软件\n下载地址：https://dev.mysql.com/downloads/mysql/\n\n根据自己的操作系统下载即可；\n\n推荐大家直接下载安装版本，在安装过程中会配置一些环境变量；\n\n\nWindows推荐下载MSI的版本；\n\n\nMac推荐下载DMG的版本；\n\n这里我安装的是MySQL最新的版本：8.0.22（不再使用旧的MySQL5.x的版本）\n\n\nWindows：\n\n下载下面的，不需要联网安装；\n\nWindows下载的版本\nMac：\nMac下载的版本\n第二步：安装的过程\n安装的过程，基本没有太复杂的操作。\n有一个需要着重说明的是MySQL8，可以采用一种更新的、安全性更高的密码和加密方式：\n\n最新的加密方式有可能会被一些比较老的软件驱动不支持；\n所以要根据情况来选择，但是我这里选择最新的加密方式了；\n\nWindows的安装过程：\nServer Only\n执行\n安装一个依赖\n下一步\n配置端口号\n选择密码加密方式\n填写一个复杂的密码\n配置服务的名称\n应用所有配置\n完成即可\n第三步：启动mysql\n在Windows启动MySQL：\nimage-20201109171443817\n在Mac中启动MySQL是在系统偏好设置中：\nMac启动MySQL\n1.4. mysql的连接和操作打开终端，查看MySQL的安装：\n\n这里会显示找不到命令；\n\nmysql --version\n\n在Windows上配置环境变量：\nWindows上配置环境变量\n在Mac上配置环境变量：\n手动执行下面的终端命令，将MySQL配置到环境变量中：\n# 添加环境变量\nexport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin\n# 再次执行mysql版本\nmysql --version\n\n1.4.1. 终端连接数据库我们如果想要操作数据，需要先和数据建立一个连接，最直接的方式就是通过终端来连接；\n有两种方式来连接：\n\n两种方式的区别在于输入密码是直接输入，还是另起一行以密文的形式输入；\n\n# 方式一：\nmysql -uroot -pCoderwhy888.\n# 方式二：\nmysql -uroot -p\nEnter password: your password\n\n输入成功后，会进入到mysql的REPL（交互式的编程环境）：\nMySQL的REPL\n我们可以直接在REPL中对数据库进行操作。\n1.4.2. 终端操作数据库我们说过，一个数据库软件中，可以包含很多个数据库：\n\ninfomation_schema：信息数据库，其中包括MySQL在维护的其他数据库、表、列、访问权限等信息；\nperformance_schema：性能数据库，记录着MySQL Server数据库引擎在运行过程中的一些资源消耗相关的信息；\nmysql：用于存储数据库管理者的用户信息、权限信息以及一些日志信息等；\nsys：相当于是一个简易版的performance_schema，将数据汇总成更容易理解的形式；\n\n注意：这里我只是在终端简单演练数据库，并没有详细讲解每一个命令，也没有完全按照SQL格式规范；\n\n这些在后面会详细讲解的；\n\n查看所有的数据库：\nshow databases;\n\nimage-20201108165132702\n在终端直接创建一个属于自己的新的数据库coderhub（一般情况下一个新的项目会对应一个新的数据库）。\ncreate database coderhub;\n\n创建一个数据库\n使用我们创建的数据库coderhub：\nuse coderhub;\n\n在数据库中创建自己的表：\ncreate table user(\n\tname varchar(20),\n\tage int,\n\theight double\n);\n\n创建用户表\n在user表中插入自己的数据：\ninsert into user (name, age, height) values (&#39;why&#39;, 18, 1.88);\ninsert into user (name, age, height) values (&#39;kobe&#39;, 40, 1.98);\n\n插入两条数据\n查看user表中所有的数据：\nselect * from user;\n\n查询表中的数据\n1.5. GUI工具操作数据库我们会发现在终端操作数据库有很多不方便的地方：\n\n语句写出来没有高亮，并且不会有任何的提示；\n复杂的语句分成多行，格式看起来并不美观，很冗余出现错误；\n终端中查看所有的数据库或者表非常的不直观和不方便；\n等等…\n\n所以在开发中，我们可以借助于一些GUI工具来帮助我们连接上数据库，之后直接在GUI工具中操作就会非常方便。\n常见的MySQL的GUI工具有很多，这里推荐几款：\n\nNavicat：个人最喜欢的一款工作，但是是收费的（有免费的试用时间，或者各显神通）；\nSQLYog：一款免费的SQL工具；\nTablePlus：常用功能都可以使用，但是会多一些限制（比如只能开两个标签页）；\n\n这里我选择使用Navicat。\n连接数据库\n查看所有的数据库、表、表中的数据：\nNavicat界面\n编写SQL语句，并且执行；\nNavicat编写SQL\nSQL语句2.1. 认识SQL语句我们希望操作数据库（特别是在程序中），就需要有和数据库沟通的语言，这个语言就是SQL：\n\nSQL是Structured Query Language，称之为结构化查询语言，简称SQL；\n使用SQL编写出来的语句，就称之为SQL语句；\nSQL语句可以用于对数据库进行操作；\n\n事实上，常见的关系型数据库SQL语句都是比较相似的，所以你学会了MySQL中的SQL语句，之后去操作比如Oracle或者其他关系型数据库，也是非常方便的。\nSQL语句的常用规范：\n\n通常关键字是大写的，比如CREATE、TABLE、SHOW等等；\n一条语句结束后，需要以 ; 结尾；\n如果遇到关键字作为表明或者字段名称，可以使用&#96;&#96;包裹;\n\n常见的SQL语句我们可以分成四类：\n\nDDL（Data Definition Language）：数据定义语言；\n\n\n可以通过DDL语句对数据库或者表进行：创建、删除、修改等操作；\n\n\nDML（Data Manipulation Language）：数据操作语言；\n\n\n可以通过DML语句对表进行：添加、删除、修改等操作；\n\n\nDQL（Data Query Language）：数据查询语言；\n\n\n可以通过DQL从数据库中查询记录；（重点）\n\n\nDCL（Data Control Language）：数据控制语言；\n\n\n对数据库、表格的权限进行相关访问控制操作；\n\n\n\n接下来我们对他们进行一个个的学习和掌握。\n2.2. DDL语句2.2.1. 数据库的操作查看当前的数据库：\n# 查看所有的数据SHOW DATABASES;# 使用某一个数据USE coderhub;# 查看当前正在使用的数据库SELECT DATABASE();\n\n创建新的数据：\n# 创建数据库语句CREATE DATABASE bilibili;CREATE DATABASE IF NOT EXISTS bilibili;CREATE DATABASE IF NOT EXISTS bilibili DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci;\n\n创建数据库时，可以设置字符串和字符排序（我们可以直接使用默认的）：\n\n字符集：utf8mb4在我们需要插入emoji表情时要用到；\n排序规则：ai表示不区分重音；ci表示不区分大小写；\n\nimage-20201108210407214\n删除数据库：\n# 删除数据库DROP DATABASE bilibili;DROP DATABASE IF EXIT bilibili;\n\n修改数据库：\n# 修改数据库的字符集和排序规则ALTER DATABASE bilibili CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_unicode_ci;\n\n2.2.2. 数据表的操作查看数据表\n# 查看所有的数据表SHOW TABLES;# 查看某一个表结构DESC user;\n\n创建数据表\nCREATE TABLE IF NOT EXISTS &#96;users&#96;(\tname VARCHAR(20),\tage INT,\theight DOUBLE);\n\n2.3. 创建表细节2.3.1. SQL数据类型我们知道不同的数据会划分为不同的数据类型，在数据库中也是一样：\n\nMySQL支持的数据类型有：数字类型，日期和时间类型，字符串（字符和字节）类型，空间类型和 JSON数据类型。\n\n数字类型\nMySQL的数字类型有很多：\n\n整数数字类型：INTEGER，INT，SMALLINT，TINYINT，MEDIUMINT，BIGINT；\n\n整数类型\n\n精确数字类型：DECIMAL，NUMERIC（DECIMAL是NUMERIC的实现形式）；\n\nsalary DECIMAL(5,2)\n\n\n浮点数字类型：FLOAT，DOUBLE\n\n\nFLOAT是4个字节，DOUBLE是8个字节；\n\n\n\n日期类型\nMySQL的日期类型也很多：\n\nYEAR以*YYYY*格式显示值\n\n\n范围 1901到2155，和 0000。\n\n\nDATE类型用于具有日期部分但没有时间部分的值：\n\n\nDATE以格式*YYYY-MM-DD*显示值 ；\n\n\n支持的范围是 &#39;1000-01-01&#39; 到 &#39;9999-12-31&#39;；\n\nDATETIME类型用于包含日期和时间部分的值：\n\n\nDATETIME以格式’YYYY-MM-DD hh:mm:ss‘显示值；\n\n\n支持的范围是1000-01-01 00:00:00到9999-12-31 23:59:59;\n\nTIMESTAMP数据类型被用于同时包含日期和时间部分的值：\n\n\nTIMESTAMP以格式’YYYY-MM-DD hh:mm:ss‘显示值；\n\n\n但是它的范围是UTC的时间范围：&#39;1970-01-01 00:00:01&#39;到&#39;2038-01-19 03:14:07&#39;;\n\n另外：DATETIME或TIMESTAMP 值可以包括在高达微秒（6位）精度的后小数秒一部分\n\n\n比如DATETIME表示的范围可以是&#39;1000-01-01 00:00:00.000000&#39;到&#39;9999-12-31 23:59:59.999999&#39;;\n\n\n\n字符串类型\nMySQL的字符串类型表示方式如下：\n\nCHAR类型在创建表时为固定长度，长度可以是0到255之间的任何值；\n\n\n在被查询时，会删除后面的空格；\n\n\nVARCHAR类型的值是可变长度的字符串，长度可以指定为0到65535之间的值；\n\n\n在被查询时，不会删除后面的空格；\n\n\nBINARY和VARBINARY 类型用于存储二进制字符串，存储的是字节字符串；\n\n\nhttps://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html\n\n\nBLOB用于存储大的二进制类型；\n\nTEXT用于存储大的字符串类型；\n\n\n2.3.2. 表的约束主键：PRIMARY KEY\n一张表中，我们为了区分每一条记录的唯一性，必须有一个字段是永远不会重复，并且不会为空的，这个字段我们通常会将它设置为主键：\n\n主键是表中唯一的索引；\n并且必须是NOT NULL的，如果没有设置 NOT NULL，那么MySQL也会隐式的设置为NOT NULL；\n主键也可以是多列索引，PRIMARY KEY(key_part, …)，我们一般称之为联合主键；\n建议：开发中主键字段应该是和业务无关的，尽量不要使用业务字段来作为主键；\n\n唯一：UNIQUE\n某些字段在开发中我们希望是唯一的，不会重复的，比如手机号码、身份证号码等，这个字段我们可以使用UNIQUE来约束：\n\n使用UNIQUE约束的字段在表中必须是不同的；\n对于所有引擎，UNIQUE 索引允许NULL包含的列具有多个值NULL。\n\n不能为空：NOT NULL\n某些字段我们要求用户必须插入值，不可以为空，这个时候我们可以使用 NOT NULL 来约束；\n默认值：DEFAULT\n某些字段我们希望在没有设置值时给予一个默认值，这个时候我们可以使用 DEFAULT来完成；\n自动递增：AUTO_INCREMENT\n某些字段我们希望不设置值时可以进行递增，比如用户的id，这个时候可以使用AUTO_INCREMENT来完成；\n外键约束也是最常用的一种约束手段，我们再讲到多表关系时，再进行讲解；\n# 创建表CREATE TABLE IF NOT EXISTS &#96;users&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\tage INT DEFAULT 0,\ttelPhone VARCHAR(20) DEFAULT &#39;&#39; UNIQUE NOT NULL,\tcreateTime TIMESTAMP DEFAULT CURRENT_TIMESTAMP);\n\n删除数据表\n# 删除表DROP TABLE &#96;moment&#96;;DROP TABLE IF EXISTS &#96;moment&#96;;\n\n修改数据表\n# 1.修改表名ALTER TABLE &#96;moments&#96; RENAME TO &#96;moment&#96;;# 2.添加一个新的列ALTER TABLE &#96;moment&#96; ADD &#96;publishTime&#96; DATETIME;ALTER TABLE &#96;moment&#96; ADD &#96;updateTime&#96; DATETIME;# 3.删除一列数据ALTER TABLE &#96;moment&#96; DROP &#96;updateTime&#96;;# 4.修改列的名称ALTER TABLE &#96;moment&#96; CHANGE &#96;publishTime&#96; &#96;publishDate&#96; DATE;# 5.修改列的数据类型ALTER TABLE &#96;moment&#96; MODIFY &#96;id&#96; INT;\n\n2.3. DML语句新建一张商品表：\nCREATE TABLE IF NOT EXISTS &#96;products&#96;(\t&#96;id&#96; INT PRIMARY KEY AUTO_INCREMENT,\t&#96;title&#96; VARCHAR(20),\t&#96;description&#96; VARCHAR(200),\t&#96;price&#96; DOUBLE,\t&#96;publishTime&#96; DATETIME);\n\n2.3.1. 插入数据INSERT INTO &#96;products&#96; (&#96;title&#96;, &#96;description&#96;, &#96;price&#96;, &#96;publishTime&#96;) \t\t\t\t\t\t\t\tVALUES (&#39;iPhone&#39;, &#39;iPhone12只要998&#39;, 998.88, &#39;2020-10-10&#39;); INSERT INTO &#96;products&#96; (&#96;title&#96;, &#96;description&#96;, &#96;price&#96;, &#96;publishTime&#96;) \t\t\t\t\t\t\t\tVALUES (&#39;huawei&#39;, &#39;iPhoneP40只要888&#39;, 888.88, &#39;2020-11-11&#39;);\n\n2.3.2. 删除数据# 删除数据# 会删除表中所有的数据DELETE FROM &#96;products&#96;;# 会删除符合条件的数据DELETE FROM &#96;products&#96; WHERE &#96;title&#96; &#x3D; &#39;iPhone&#39;;\n\n2.3.3. 修改数据# 修改数据# 会修改表中所有的数据UPDATE &#96;products&#96;  SET &#96;title&#96; &#x3D; &#39;iPhone12&#39;, &#96;price&#96; &#x3D; 1299.88;# 会修改符合条件的数据UPDATE &#96;products&#96;  SET &#96;title&#96; &#x3D; &#39;iPhone12&#39;, &#96;price&#96; &#x3D; 1299.88 WHERE &#96;title&#96; &#x3D; &#39;iPhone&#39;;\n\n如果我们希望修改完数据后，直接可以显示最新的更新时间：\nALTER TABLE &#96;products&#96; ADD &#96;updateTime&#96; TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;\n\n2.4. DQL语句SELECT用于从一个或者多个表中检索选中的行（Record）。\nSELECT select_expr [, select_expr]...\t[FROM table_references]\t[WHERE where_condition]\t[ORDER expr [ASC | DESC]]\t[LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]\t[GROUP BY expr]\t[HAVING where_condition]\n\n我们先准备一张表：\nCREATE TABLE IF NOT EXISTS &#96;products&#96; (\tid INT PRIMARY KEY AUTO_INCREMENT,\tbrand VARCHAR(20),\ttitle VARCHAR(100) NOT NULL,\tprice DOUBLE NOT NULL,\tscore DECIMAL(2,1),\tvoteCnt INT,\turl VARCHAR(100),\tpid INT);\n\n我们在其中插入一些数据：\nconst mysql &#x3D; require(&#39;mysql2&#39;); const connection &#x3D; mysql.createConnection(&#123;  host: &#39;localhost&#39;,  port: 3306,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;,  database: &#39;coderhub&#39;&#125;);const statement &#x3D; &#96;INSERT INTO products SET ?;&#96;const phoneJson &#x3D; require(&#39;.&#x2F;phone.json&#39;);for (let phone of phoneJson) &#123;  connection.query(statement, phone);&#125;\n\nimage-20201111103013994\n2.4.1. 基本查询查询所有的数据并且显示所有的字段：\nSELECT * FROM &#96;products&#96;;\n\n查询title、brand、price：\nSELECT title, brand, price FROM &#96;products&#96;;\n\n我们也可以给字段起别名：\n\n别名一般在多张表或者给客户端返回对应的key时会使用到；\n\nSELECT title as t, brand as b, price as p FROM &#96;products&#96;;\n\n2.4.2. 条件查询在开发中，我们希望根据条件来筛选我们的数据，这个时候我们要使用条件查询：\n\n条件查询会使用 WEHRE查询子句；\n\nWHERE的比较运算符\n# 查询价格小于1000的手机SELECT * FROM &#96;products&#96; WHERE price &lt; 1000;# 查询价格大于等于2000的手机SELECT * FROM &#96;products&#96; WHERE price &gt;&#x3D; 2000;# 价格等于3399的手机SELECT * FROM &#96;products&#96; WHERE price &#x3D; 3399;# 价格不等于3399的手机SELECT * FROM &#96;products&#96; WHERE price &#x3D; 3399;# 查询华为品牌的手机SELECT * FROM &#96;products&#96; WHERE &#96;brand&#96; &#x3D; &#39;华为&#39;;\n\nWHERE的逻辑运算符\n# 查询品牌是华为，并且小于2000元的手机SELECT * FROM &#96;products&#96; WHERE &#96;brand&#96; &#x3D; &#39;华为&#39; and &#96;price&#96; &lt; 2000;SELECT * FROM &#96;products&#96; WHERE &#96;brand&#96; &#x3D; &#39;华为&#39; &amp;&amp; &#96;price&#96; &lt; 2000;# 查询1000到2000的手机（不包含1000和2000）SELECT * FROM &#96;products&#96; WHERE price &gt; 1000 and price &lt; 2000;# OR: 符合一个条件即可# 查询所有的华为手机或者价格小于1000的手机SELECT * FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39; or price &lt; 1000;# 查询1000到2000的手机（包含1000和2000）SELECT * FROM &#96;products&#96; WHERE price BETWEEN 1000 and 2000;# 查看多个结果中的一个SELECT * FROM &#96;products&#96; WHERE brand in (&#39;华为&#39;, &#39;小米&#39;);\n\nWHERE的模糊查询\n模糊查询使用LIKE关键字，结合两个特殊的符号：\n\n%表示匹配任意个的任意字符；\n_表示匹配一个的任意字符；\n\n# 查询所有以v开头的titleSELECT * FROM &#96;products&#96; WHERE title LIKE &#39;v%&#39;;# 查询带M的titleSELECT * FROM &#96;products&#96; WHERE title LIKE &#39;%M%&#39;;# 查询带M的title必须是第三个字符SELECT * FROM &#96;products&#96; WHERE title LIKE &#39;__M%&#39;;\n\n2.4.3. 查询排序当我们查询到结果的时候，我们希望讲结果按照某种方式进行排序，这个时候使用的是ORDER BY；\nORDER BY有两个常用的值：\n\nASC：升序排列；\nDESC：降序排列；\n\nSELECT * FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39; or price &lt; 1000 ORDER BY price ASC;\n\n2.4.4. 分页偏移当数据库中的数据非常多时，一次性查询到所有的结果进行显示是不太现实的：\n\n在真实开发中，我们都会要求用户传入offset、limit或者page等字段；\n它们的目的是让我们可以在数据库中进行分页查询；\n它的用法有[LIMIT[offset,] row_countrow_count OFFSET offset]\n\nSELECT * FROM &#96;products&#96; LIMIT 30 OFFSET 0;SELECT * FROM &#96;products&#96; LIMIT 30 OFFSET 30;SELECT * FROM &#96;products&#96; LIMIT 30 OFFSET 60;# 另外一种写法：offset, row_countSELECT * FROM &#96;products&#96; LIMIT 90, 30;\n\n2.4.5. 聚合函数聚合函数表示对值集合进行操作的组（集合）函数。\n聚合查询\n我们这里学习最常用的一些聚合函数：\n# 华为手机价格的平均值SELECT AVG(price) FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39;;# 计算所有手机的平均分SELECT AVG(score) FROM &#96;products&#96;;# 手机中最低和最高分数SELECT MAX(score) FROM &#96;products&#96;;SELECT MIN(score) FROM &#96;products&#96;;# 计算总投票人数SELECT SUM(voteCnt) FROM &#96;products&#96;;# 计算所有条目的数量SELECT COUNT(*) FROM &#96;products&#96;;# 华为手机的个数SELECT COUNT(*) FROM &#96;products&#96; WHERE brand &#x3D; &#39;华为&#39;;\n\n事实上聚合函数相当于默认将所有的数据分成了一组：\n\n我们前面使用avg还是max等，都是将所有的结果看成一组来计算的；\n那么如果我们希望划分多个组：比如华为、苹果、小米等手机分别的平均价格，应该怎么来做呢？\n这个时候我们可以使用 GROUP BY；\n\nGROUP BY通常和聚合函数一起使用：\n\n表示我们先对数据进行分组，再对每一组数据，进行聚合函数的计算；\n\n我们现在来提一个需求：\n\n根据品牌进行分组；\n计算各个品牌中商品的个数、平均价格、最高价格、最低价格、平均评分；\n\nSELECT brand, \t\t\tCOUNT(*) as count, \t\t\tROUND(AVG(price),2) as avgPrice,\t\t\tMAX(price) as maxPrice,\t\t\tMIN(price) as minPrice,\t\t\tAVG(score) as avgScoreFROM &#96;products&#96; GROUP BY brand;\n\n如果我们还希望筛选出平均价格在4000以下，并且平均分在7以上的品牌：\nSELECT brand, \t\t\tCOUNT(*) as count, \t\t\tROUND(AVG(price),2) as avgPrice,\t\t\tMAX(price) as maxPrice,\t\t\tMIN(price) as minPrice,\t\t\tAVG(score) as avgScoreFROM &#96;products&#96; GROUP BY brand HAVING avgPrice &lt; 4000 and avgScore &gt; 7;\n\n2.5. 外键约束2.5.1. 创建多张表假如我们的上面的商品表中，对应的品牌还需要包含其他的信息：\n\n比如品牌的官网，品牌的世界排名，品牌的市值等等；\n\n如果我们直接在商品中去体现品牌相关的信息，会存在一些问题：\n\n一方面，products表中应该表示的都是商品相关的数据，应该有另外一张表来表示brand的数据；\n另一方面，多个商品使用的品牌是一致时，会存在大量的冗余数据；\n\n所以，我们可以将所有的批评数据，单独放到一张表中，创建一张品牌的表：\nCREATE TABLE IF NOT EXISTS &#96;brand&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\twebsite VARCHAR(100),\tworldRank INT);\n\n插入模拟的数据：\n\n这里我是刻意有一些商品数据的品牌是没有添加的；\n并且也可以添加了一些不存在的手机品牌；\n\nINSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;华为&#39;, &#39;www.huawei.com&#39;, 1);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;小米&#39;, &#39;www.mi.com&#39;, 10);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;苹果&#39;, &#39;www.apple.com&#39;, 5);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;oppo&#39;, &#39;www.oppo.com&#39;, 15);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;京东&#39;, &#39;www.jd.com&#39;, 3);INSERT INTO &#96;brand&#96; (name, website, worldRank) VALUES (&#39;Google&#39;, &#39;www.google.com&#39;, 8);\n\n2.5.2. 创建外键我们先给products添加一个brand_id字段：\n将两张表联系起来，我们可以将products中的brand_id关联到brand中的id：\n\n如果是创建表添加外键约束：\nFOREIGN KEY (brand_id) REFERENCES brand(id)\n\n如果是表已经创建好，额外添加外键：\nALTER TABLE &#96;products&#96; ADD FOREIGN KEY (brand_id) REFERENCES brand(id);\n\n现在我们可以将products中的brand_id关联到brand中的id的值：\nUPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 1 WHERE &#96;brand&#96; &#x3D; &#39;华为&#39;;UPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 4 WHERE &#96;brand&#96; &#x3D; &#39;OPPO&#39;;UPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 3 WHERE &#96;brand&#96; &#x3D; &#39;苹果&#39;;UPDATE &#96;products&#96; SET &#96;brand_id&#96; &#x3D; 2 WHERE &#96;brand&#96; &#x3D; &#39;小米&#39;;\n\n2.5.3. 删除和更新我们来思考一个问题：\n\n如果products中引用的外键被更新了或者删除了，这个时候会出现什么情况呢？\n\n我们来进行一个更新操作：比如将华为的id更新为100\nUPDATE &#96;brand&#96; SET id &#x3D; 100 WHERE id &#x3D; 1;\n\n这个时候执行代码是报错的：\n不可以更新和删除，因为有一个外键引用\n如果我希望可以更新呢？我们可以给更新时设置几个值：\n\nRESTRICT（默认属性）：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话会报错的，不允许更新或删除；\n\nNO ACTION：和RESTRICT是一致的，是在SQL标准中定义的；\n\nCASCADE：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话：\n\n\n更新：那么会更新对应的记录；\n\n\n删除：那么关联的记录会被一起删除掉；\n\nSET NULL：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话，将对应的值设置为NULL；\n\n\n如果修改外键的更新时的动作呢？\n第一步：查看表结构：\n# 执行命令SHOW CREATE TABLE &#96;products&#96;;# 结果如下：CREATE TABLE &#96;products&#96; (  &#96;id&#96; int NOT NULL AUTO_INCREMENT,  &#96;brand&#96; varchar(20) DEFAULT NULL,  &#96;title&#96; varchar(100) NOT NULL,  &#96;price&#96; double NOT NULL,  &#96;score&#96; decimal(2,1) DEFAULT NULL,  &#96;voteCnt&#96; int DEFAULT NULL,  &#96;url&#96; varchar(100) DEFAULT NULL,  &#96;pid&#96; int DEFAULT NULL,  &#96;brand_id&#96; int DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;),  KEY &#96;brand_id&#96; (&#96;brand_id&#96;),  CONSTRAINT &#96;products_ibfk_1&#96; FOREIGN KEY (&#96;brand_id&#96;) REFERENCES &#96;brand&#96; (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;109 DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci\n\n这个时候，我们可以知道外键的名称是products_ibfk_1。\n第二步：删除之前的外键\nALTER TABLE &#96;products&#96; DROP FOREIGN KEY products_ibfk_1;\n\n第三步：添加新的外键，并且设置新的action\nALTER TABLE &#96;products&#96; ADD FOREIGN KEY (brand_id) REFERENCES brand(id) ON UPDATE CASCADE ON DELETE CASCADE;\n\n2.6. 多表查询2.6.1. 多表查询如果我们希望查询到产品的同时，显示对应的品牌相关的信息，因为数据是存放在两张表中，所以这个时候就需要进行多表查询。\n如果我们直接通过查询语句希望在多张表中查询到数据，这个时候是什么效果呢？\nSELECT * FROM &#96;products&#96;, &#96;brand&#96;;\n\n查询结果\n我们会发现一共有648条数据，这个数据量是如何得到的呢？\n\n第一张表的108条 * 第二张表的6条数据；\n也就是说第一张表中每一个条数据，都会和第二张表中的每一条数据结合一次；\n这个结果我们称之为 笛卡尔乘积，也称之为直积，表示为 X*Y；\n\n但是事实上很多的数据是没有意义的，比如华为和苹果、小米的品牌结合起来的数据就是没有意义的，我们可不可以进行筛选呢？\n\n使用where来进行筛选；\n这个表示查询到笛卡尔乘积后的结果中，符合products.brand_id = brand.id条件的数据过滤出来；\n\nSELECT * FROM &#96;products&#96;, &#96;brand&#96; WHERE &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n事实上我们想要的效果并不是这样的，而且表中的某些特定的数据，这个时候我们可以使用 SQL JOIN 操作：\n\n左连接\n右连接\n内连接\n全连接\n\nSQL JOIN\n2.6.2. 左连接如果我们希望获取到的是左边所有的数据（以左表为主）：\n\n这个时候就表示无论左边的表是否有对应的brand_id的值对应右边表的id，左边的数据都会被查询出来；\n这个也是开发中使用最多的情况，它的完整写法是LEFT [OUTER] JOIN，但是OUTER可以省略的；\n\n\nSELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n如果我们查询的是左连接部分中，和右表无关的数据：\n\n也非常简单，只需要加上一个条件即可：B表中的数据为空\n\n\nSELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE brand.id IS NULL;\n\n2.6.3. 右连接如果我们希望获取到的是右边所有的数据（以由表为主）：\n\n\n这个时候就表示无论左边的表中的brand_id是否有和右边表中的id对应，右边的数据都会被查询出来；\n右连接在开发中没有左连接常用，它的完整写法是RIGHT [OUTER] JOIN，但是OUTER可以省略的；\n\nSELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n如果我们查询的是右连接部分中，和左表无关的数据：\n\n也非常简单，只需要加上一个条件即可：A表中的数据为空；\n\n\nSELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE products.id IS NULL;\n\n2.6.4. 内连接事实上内连接是表示左边的表和右边的表都有对应的数据关联：\nSELECT * FROM &#96;products&#96; INNER JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n我们会发现它和之前的下面写法是一样的效果：\nSELECT * FROM &#96;products&#96;, &#96;brand&#96; WHERE &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id;\n\n但是他们代表的含义并不相同：\n\nSQL语句一：内连接，代表的是在两张表连接时就会约束数据之间的关系，来决定之后查询的结果；\nSQL语句二：where条件，代表的是先计算出笛卡尔乘积，在笛卡尔乘积的数据基础之上进行where条件的筛选；\n\n内连接在开发中偶尔也会常见使用，看自己的场景。\n内连接有其他的写法：CROSS JOIN或者 JOIN都可以；\n2.6.5. 全连接SQL规范中全连接是使用FULL JOIN，但是MySQL中并没有对它的支持，我们需要使用 UNION 来实现：\n\n(SELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id)UNION(SELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id);\n\n如果我们希望查询的是下面的结果：\n\n(SELECT * FROM &#96;products&#96; LEFT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE &#96;brand&#96;.id IS NULL)UNION(SELECT * FROM &#96;products&#96; RIGHT JOIN &#96;brand&#96; ON &#96;products&#96;.brand_id &#x3D; &#96;brand&#96;.id WHERE &#96;products&#96;.id IS NULL);\n\n2.7. 多对多关系2.7.1. 准备多张表在开发中我们还会遇到多对多的关系：\n\n比如学生可以选择多门课程，一个课程可以被多个学生选择；\n这种情况我们应该在开发中如何处理呢？\n\n这个时候我们通常是会建三张表来建立它们之间的关系的：\n# 创建学生表CREATE TABLE IF NOT EXISTS &#96;students&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\tage INT);# 创建课程表CREATE TABLE IF NOT EXISTS &#96;courses&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tname VARCHAR(20) NOT NULL,\tprice DOUBLE NOT NULL);\n\n我们在两张表中插入一些数据：\nINSERT INTO &#96;students&#96; (name, age) VALUES(&#39;why&#39;, 18);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;tom&#39;, 22);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;lilei&#39;, 25);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;lucy&#39;, 16);INSERT INTO &#96;students&#96; (name, age) VALUES(&#39;lily&#39;, 20);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;英语&#39;, 100);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;语文&#39;, 666);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;数学&#39;, 888);INSERT INTO &#96;courses&#96; (name, price) VALUES (&#39;历史&#39;, 80);\n\n2.7.2. 创建关系表我们需要一个关系表来记录两张表中的数据关系：\n# 创建关系表CREATE TABLE IF NOT EXISTS &#96;students_select_courses&#96;(\tid INT PRIMARY KEY AUTO_INCREMENT,\tstudent_id INT NOT NULL,\tcourse_id INT NOT NULL,\tFOREIGN KEY (student_id) REFERENCES students(id) ON UPDATE CASCADE,\tFOREIGN KEY (course_id) REFERENCES courses(id) ON UPDATE CASCADE);\n\n我们插入一些数据：\n# why 选修了 英文和数学INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (1, 1);INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (1, 3);# lilei选修了 语文和数学和历史INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (3, 2);INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (3, 3);INSERT INTO &#96;students_select_courses&#96; (student_id, course_id) VALUES (3, 4);\n\n2.7.3. 多表数据查询查询多条数据：\n# 查询所有的学生选择的所有课程SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id; # 查询所有的选手选课情况SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu LEFT JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id LEFT JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id;\n\n查询单个学生的课程：\n# why同学选择了哪些课程SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id \tWHERE stu.id &#x3D; 1; # lily同学选择了哪些课程SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stu LEFT JOIN &#96;students_select_courses&#96; ssc \tON stu.id &#x3D; ssc.student_id LEFT JOIN &#96;courses&#96; cs \tON ssc.course_id &#x3D; cs.id \tWHERE stu.id &#x3D; 5;\n\n查询哪些学生没有选择和哪些课程没有被选择：\n# 哪些学生是没有选课的SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stuLEFT JOIN &#96;students_select_courses&#96; ssc\tON stu.id &#x3D; ssc.student_idLEFT JOIN &#96;courses&#96; cs\tON ssc.course_id &#x3D; cs.id\tWHERE cs.id IS NULL;# 查询哪些课程没有被学生选择SELECT \tstu.id studentId, stu.name studentName, cs.id courseId, cs.name courseName, cs.price coursePrice FROM &#96;students&#96; stuRIGHT JOIN &#96;students_select_courses&#96; ssc\tON stu.id &#x3D; ssc.student_idRIGHT JOIN &#96;courses&#96; cs\tON ssc.course_id &#x3D; cs.id\tWHERE stu.id IS NULL;\n\nNode操作MySQL3.1.对象和数组3.1.1. 一对多 - 对象前面我们学习的查询语句，查询到的结果通常是一张表，比如查询手机+品牌信息：\nSELECT * FROM products LEFT JOIN brand ON products.brand_id &#x3D; brand.id;\n\n查询结果\n但是在真实开发中，实际上红色圈起来的部分应该放入到一个对象中，那么我们可以使用下面的查询方式：\n\n这个时候我们要用 JSON_OBJECT;\n\nSELECT products.id as id, products.title as title, products.price as price, products.score as score, \t\t\t\tJSON_OBJECT(&#39;id&#39;, brand.id, &#39;name&#39;, brand.name, &#39;rank&#39;, brand.phoneRank, &#39;website&#39;, brand.website) as brandFROM products LEFT JOIN brand ON products.brand_id &#x3D; brand.id;\n\n查询结果\n3.1.2. 多对多 - 数组在多对多关系中，我们希望查询到的是一个数组：\n\n比如一个学生的多门课程信息，应该是放到一个数组中的；\n数组中存放的是课程信息的一个个对象；\n这个时候我们要 JSON_ARRAYAGG和JSON_OBJECT结合来使用；\n\nSELECT stu.id, stu.name, stu.age, \t\t   JSON_ARRAYAGG(JSON_OBJECT(&#39;id&#39;, cs.id, &#39;name&#39;, cs.name)) as courses FROM students stuLEFT JOIN students_select_courses ssc ON stu.id &#x3D; ssc.student_idLEFT JOIN courses cs ON ssc.course_id &#x3D; cs.idGROUP BY stu.id;\n\n查询结果\n3.2. mysql2的使用3.2.1. 认识mysql2前面我们所有的操作都是在GUI工具中，通过执行SQL语句来获取结果的，那真实开发中肯定是通过代码来完成所有的操作的。\n那么如何可以在Node的代码中执行SQL语句来，这里我们可以借助于两个库：\n\nmysql：最早的Node连接MySQL的数据库驱动；\nmysql2：在mysql的基础之上，进行了很多的优化、改进；\n\n目前相对来说，我更偏向于使用mysql2，mysql2兼容mysql的API，并且提供了一些附加功能\n\n更快&#x2F;更好的性能；\n\nPrepared Statement（预编译语句）：\n\n\n提高性能：将创建的语句模块发送给MySQL，然后MySQL编译（解析、优化、转换）语句模块，并且存储它但是不执行，之后我们在真正执行时会给?提供实际的参数才会执行；就算多次执行，也只会编译一次，所以性能是更高的；\n\n\n防止SQL注入：之后传入的值不会像模块引擎那样就编译，那么一些SQL注入的内容不会被执行；or 1 = 1不会被执行；\n\n支持Promise，所以我们可以使用async和await语法\n\n等等….\n\n\n所以后续的学习中我会选择mysql2在node中操作数据。\n安装\nnpm install mysql2\n\n3.2.2. mysql2基本使用mysql2的使用过程如下：\n\n第一步：创建连接（通过createConnection），并且获取连接对象；\n第二步：执行SQL语句即可（通过query）；\n\nconst mysql &#x3D; require(&#39;mysql2&#39;);&#x2F;&#x2F; 创建连接const connection &#x3D; mysql.createConnection(&#123;  host: &#39;localhost&#39;,  database: &#39;coderhub&#39;,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;&#125;);&#x2F;&#x2F; 执行SQL语句connection.query(&#39;SELECT title, price FROM products WHERE price &gt; 9000;&#39;, (err, results, fields) &#x3D;&gt; &#123;  console.log(err);  console.log(&#39;----------&#39;);  console.log(results);  console.log(&#39;----------&#39;);  console.log(fields);&#125;)\n\n通常我们的连接建立之后是不会轻易断开的，因为我们需要这个连接持续帮助我们查询客户端过来的请求。\n但是如果我们确实希望断开连接，可以使用 end 方法：\nconnection.end();\n\n3.2.3. 预编译语句Prepared Statement（预编译语句）：\n\n提高性能：将创建的语句模块发送给MySQL，然后MySQL编译（解析、优化、转换）语句模块，并且存储它但是不执行，之后我们在真正执行时会给?提供实际的参数才会执行；就算多次执行，也只会编译一次，所以性能是更高的；\n防止SQL注入：之后传入的值不会像模块引擎那样就编译，那么一些SQL注入的内容不会被执行；or 1 = 1不会被执行；\n\nconst statement &#x3D; &#39;SELECT * FROM products WHERE price &gt; ? and brand &#x3D; ?;&#39;;connection.execute(statement, [1000, &#39;华为&#39;], (err, results) &#x3D;&gt; &#123;  console.log(results);&#125;);\n\n强调：如果再次执行该语句，它将会从LRU（Least Recently Used） Cache中获取获取，省略了编译statement的时间来提高性能。\n3.2.4. 连接池前面我们是创建了一个连接（connection），但是如果我们有多个请求的话，该连接很有可能正在被占用，那么我们是否需要每次一个请求都去创建一个新的连接呢？\n\n事实上，mysql2给我们提供了连接池（connection pools）；\n连接池可以在需要的时候自动创建连接，并且创建的连接不会被销毁，会放到连接池中，后续可以继续使用；\n我们可以在创建连接池的时候设置LIMIT，也就是最大创建个数；\n\nconst mysql &#x3D; require(&#39;mysql2&#39;);const pool &#x3D; mysql.createPool(&#123;  host: &#39;localhost&#39;,  database: &#39;coderhub&#39;,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;,  connectionLimit: 10&#125;);const statement &#x3D; &#39;SELECT * FROM products WHERE price &gt; ? and brand &#x3D; ?;&#39;;pool.execute(statement, [1000, &#39;华为&#39;], (err, results) &#x3D;&gt; &#123;  console.log(results);&#125;);\n\n为什么Node执行JavaScript时单线程的，还需要连接池呢？\n\n这是因为Node中操作数据库，本质上是通过Libuv进行了的数据库操作；\n而在libuv中是可以有多个线程的，多个线程也是可以同时去建立连接来操作数据库的；\n\n3.2.5. promises目前在JavaScript开发中我们更习惯Promise和await、async的方式，mysql2同样是支持的：\nconst mysql &#x3D; require(&#39;mysql2&#39;);const pool &#x3D; mysql.createPool(&#123;  host: &#39;localhost&#39;,  database: &#39;coderhub&#39;,  user: &#39;root&#39;,  password: &#39;Coderwhy888.&#39;,  connectionLimit: 5&#125;);const statement &#x3D; &#39;SELECT * FROM products WHERE price &gt; ? and brand &#x3D; ?;&#39;;pool.promise().execute(statement, [1000, &#39;华为&#39;]).then(([results]) &#x3D;&gt; &#123;  console.log(results);&#125;);\n\n3.3. ORM的sequelize3.3.1. 认识ORM对象关系映射（英语：Object Relational Mapping，简称ORM，或O&#x2F;RM，或O&#x2F;R mapping），是一种程序设计的方案：\n\n从效果上来讲，它提供了一个可在编程语言中，使用 虚拟对象数据库 的效果；\n比如在Java开发中经常使用的ORM包括：Hibernate、MyBatis；\n\nNode当中的ORM我们通常使用的是 sequelize;\n\nSequelize是用于Postgres，MySQL，MariaDB，SQLite和Microsoft SQL Server的基于Node.js 的 ORM；\n它支持非常多的功能；\n\n如果我们希望将Sequelize和MySQL一起使用，那么我们需要先安装两个东西：\n\nmysql2：sequelize在操作mysql时使用的是mysql2；\nsequelize：使用它来让对象映射到表中；\n\nnpm install sequelize mysql2\n\n3.3.2. Sequelize的使用Sequelize的连接数据库：\n\n第一步：创建一个Sequelize的对象，并且制定数据库、用户名、密码、数据库类型、主机地址等；\n第二步：测试连接是否成功；\n\nconst &#123;Sequelize, DataTypes, Model, Op&#125; &#x3D; require(&#39;sequelize&#39;);const sequelize &#x3D; new Sequelize(&#39;coderhub&#39;, &#39;root&#39;, &#39;Coderwhy888.&#39;, &#123;  host: &#39;localhost&#39;,  dialect: &#39;mysql&#39;&#125;);sequelize.authenticate().then(() &#x3D;&gt; &#123;  console.log(&quot;sequelize连接成功~&quot;);&#125;).catch(err &#x3D;&gt; &#123;  console.log(&quot;sequlize连接失败~&quot;, err);&#125;);\n\nSequelize映射关系表：\nclass Student extends Model &#123;&#125;Student.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  name: &#123;    type: DataTypes.STRING,    allowNull: false  &#125;,  age: DataTypes.INTEGER&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false&#125;)\n\n测试增删改查的操作：\nasync function queryStudent() &#123;  &#x2F;&#x2F; 1.查询所有的学生  const result1 &#x3D; await Student.findAll(&#123;&#125;);  console.log(result1);  &#x2F;&#x2F; 2.查询年龄大于等于20岁的学生  const result2 &#x3D; await Student.findAll(&#123;    where: &#123;      age: &#123;        [Op.gte]: 20      &#125;    &#125;  &#125;);  console.log(result2);  &#x2F;&#x2F; 3.创建用户  const result3 &#x3D; await Student.create(&#123;    name: &#39;hmm&#39;,    age: 22  &#125;);  console.log(result3);  &#x2F;&#x2F; 4.更新用户  const result4 &#x3D; await Student.update(&#123;    age: 25  &#125;, &#123;    where: &#123;      id: 6    &#125;  &#125;);  console.log(result4);&#125;queryStudent();\n\n3.3.3. 多对多关系第一步：连接数据库\nconst &#123; Sequelize, DataTypes, Model, Op &#125; &#x3D; require(&#39;sequelize&#39;);const sequelize &#x3D; new Sequelize(&#39;coderhub&#39;, &#39;root&#39;, &#39;Coderwhy888.&#39;, &#123;  host: &#39;localhost&#39;,  dialect: &#39;mysql&#39;&#125;);\n\n第二步：创建映射关系\nclass Student extends Model &#123;&#125;Student.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  name: &#123;    type: DataTypes.STRING,    allowNull: false  &#125;,  age: DataTypes.INTEGER&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false&#125;)class Course extends Model &#123;&#125;Course.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  name: &#123;    type: DataTypes.STRING(20),    allowNull: false  &#125;,  price: &#123;    type: DataTypes.DOUBLE,    allowNull: false  &#125;&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false&#125;);class StudentCourse extends Model &#123;&#125;;StudentCourse.init(&#123;  id: &#123;    type: DataTypes.INTEGER,    primaryKey: true,    autoIncrement: true  &#125;,  studentId: &#123;    type: DataTypes.INTEGER,    references: &#123;      model: Student,      key: &#39;id&#39;    &#125;,    field: &#39;student_id&#39;,  &#125;,  courseId: &#123;    type: DataTypes.INTEGER,    references: &#123;      model: Course,      key: &#39;id&#39;    &#125;,    field: &#39;course_id&#39;,  &#125;&#125;, &#123;  sequelize,  createdAt: false,  updatedAt: false,  tableName: &#39;students_select_courses&#39;&#125;);\n\n第三步：建立多对多的联系\nStudent.belongsToMany(Course, &#123;  through: StudentCourse,   foreignKey: &#39;student_id&#39;,   otherKey: &#39;course_id&#39;,&#125;);Course.belongsToMany(Student, &#123;  through: StudentCourse,   foreignKey: &#39;course_id&#39;,   otherKey: &#39;student_id&#39;&#125;);\n\n第四步：执行多对多查询操作：\nasync function queryStudent() &#123;  &#x2F;&#x2F; 查询结果  const result &#x3D; await Student.findAll(&#123;    include: &#123;      model: Course    &#125;\n\nhttp协议1.超文本传输协议\n规定了如何从网站服务器传输超文本到本地浏览器,基于客户端服务器架构工作,是客户端和服务器端请求和应答标准\n\n2.报文   过程中传递的数据块\n请求报文:1.请求方式 req.method获取请求方式   GET POST\n\t\t2.请求地址 req.url获取请求地址\n\t\t3.请求报文 req.headers[&#39;键名&#39;]获取请求报文\n\t\t\n请求组成:请求行 方式 资源 协议版本\n\t\t请求头 键值对\n\t\t请求体 post有请求参数 get请求参数不在请求体中,在url地址后面\n\t\t\n\n响应报文:1.http状态码   200成功 404没找到 500服务器端错误 400客户端请求语法错\n\t\t2.内容类型 text&#x2F;html text&#x2F;css application&#x2F;javascript image&#x2F;jpeg application&#x2F;json\n\t\t3. 内容长度 内容..\n\t\tres.writeHead(状态码,&#123;&#39;content-type&#39;:&#39;text&#x2F;plain&#39;&#125;) 内容类型默认纯文本\n\t\tres.end(&#39;...&#39;)响应内容\n\t\t\n响应组成:响应行 http协议 状态码 其他状态码(成功2xx 重定向 3xx 客户端4xx 服务器端错误5xx)\n\t\t响应头 键值对\n\t\t响应体 post有请求参数 get请求参数不在请求体中,在url地址后面\n\nhttp请求与响应处理8种请求方式 OPTIONS HEAD  GET POST PUT DELETE TRACE \n\n请求参数GET\n使用url模块,用于处理url地址   \nurl.parse(req.url) 返回一个对象\nurl.parse(req.url,true)把查询参数解析成对象\nurl.parse(req.url,true).query得到这个对象  通过这个对象.键名得到参数值\n\n解构赋值 &#123; query, pathname&#125; &#x3D; url.parse(req.url,true) 得到参数对象和请求地址\n\nwindow释放端口1.cmd\n2.netstat -ano | findstr 9090 查询端口9090使用情况\n3.tasklist | findstr +进程ID  查询端口被进程占用的程序\n4.taskkill &#x2F;f &#x2F;t &#x2F;im  +进程ID或程序  杀死进程\n\nNPMnpm常用命令# 临时\n$ npm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install 插件名\n# 配置\n$ npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org\n\n# 查看 npm 的版本 \n$ npm -v  \n# 查看各个命令的简单用法\n$ npm -l \n# 查看 npm 命令列表\n$ npm help\n# 查看 npm 的配置\n$ npm config list -l\n# 查看插件的版本\nnpm view 插件名 versions\n# 创建模块\nnpm init\n#当前项目安装的所有模块\n$npm list\n#列出全局安装的模块 带上[--depth 0] 不深入到包的支点 更简洁\n$ npm list -g --depth 0\n\n# 读取package.json里面的配置单安装  \n$ npm install \n&#x2F;&#x2F;可简写成 npm i\n\n# 默认安装指定模块的最新(@latest)版本\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt; \n&#x2F;&#x2F;eg:npm install gulp\n\n# 安装指定模块的指定版本\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt;@&lt;version&gt;\n&#x2F;&#x2F;eg: npm install gulp@3.9.1\n\n# 安装指定指定版本范围内的模块\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt;@&lt;version range&gt;\n&#x2F;&#x2F;eg: npm install vue@&quot;&gt;&#x3D;1.0.28 &lt; 2.0.0&quot;\n\n# 安装指定模块的指定标签 默认值为(@latest)\n$ npm install [&lt;@scope&gt;&#x2F;]&lt;name&gt;@&lt;tag&gt;\n&#x2F;&#x2F;eg:npm install sax@0.1.1\n\n# 通过Github代码库地址安装\n$ npm install &lt;tarball url&gt;\n&#x2F;&#x2F;eg:npm install git:&#x2F;&#x2F;github.com&#x2F;package&#x2F;path.git\n\n#卸载当前项目或全局模块 \n$ npm uninstall &lt;name&gt; [-g] \n\n#升级当前项目或全局的指定模块\n$ npm update &lt;name&gt; [-g]\n\n# 引用依赖 有些包是全局安装了，在项目里面只需要引用即可。\n$ npm link [&lt;@scope&gt;&#x2F;]&lt;pkg&gt;[@&lt;version&gt;]\n&#x2F;&#x2F;eg: 引用   npm link gulp gulp-ssh gulp-ftp\n&#x2F;&#x2F;eg: 解除引用 npm unlink gulp\n\n# 未注册 申请注册一个用户 直接在https:&#x2F;&#x2F;www.npmjs.com&#x2F;注册一样\n$ npm adduser\n&#x2F;&#x2F;执行后 填写几个问题 Username、Password、Email\n\n#已注册\n$ npm login \n\n#发布\n$ npm publish\n\nNPM私库搭建npm+git1.新建私有git仓库\n2.clone仓库\n3.npm init\n4.按npm规范开发完。push到仓库即可\n\nverdaccio(https://www.jianshu.com/p/0c905e4a8b70)\n云服务器安装node环境,nginx\n\n\n\n\n\n\n\n\n1 云服务器安装verdaccio(轻量级开源私有npm代理注册表)npm i verdaccio -g\n\n\n\n\n\n\n\n\n\n2 启动服务：verdaccio\n\n\n\n\n\n\n\n\n\n3 配置config.yaml\n1、vim &#x2F;home&#x2F;yg&#x2F;.config&#x2F;verdaccio&#x2F;config.yaml 进入编辑配置文件\n\n# This is the default config file. It allows all users to do anything,\n# so don&#39;t use it on production systems.\n#\n# Look here for more config file examples:\n# https:&#x2F;&#x2F;github.com&#x2F;verdaccio&#x2F;verdaccio&#x2F;tree&#x2F;master&#x2F;conf\n#\n\n# path to a directory with all packages\n# 所有包缓存的目录\nstorage: .&#x2F;storage\n# path to a directory with plugins to include\n# 插件目录\nplugins: .&#x2F;plugins\n\n# 开启web服务，能够通过web访问\nweb:\n  # WebUI is enabled as default, if you want disable it, just uncomment this line\n  #enable: false\n  title: Verdaccio\n\n# 验证信息\nauth:\n  htpasswd:\n    # 用户信息存储目录\n    file: .&#x2F;htpasswd\n    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.\n    # You can set this to -1 to disable registration.\n    #max_users: 1000\n\n# a list of other known repositories we can talk to\n# 公有仓库配置\nuplinks:\n  npmjs:\n    url: https:&#x2F;&#x2F;registry.npmjs.org&#x2F;\n\npackages:\n  &#39;@*&#x2F;*&#39;:\n    # scoped packages\n    access: $all\n    publish: $authenticated\n    # 代理，表示没有的仓库去这个npmjs里边去找\n    # npmjs 又指向 https:&#x2F;&#x2F;registry.npmjs.org&#x2F; ,就是上面的 uplinks 配置\n    proxy: npmjs\n\n  &#39;**&#39;:\n    # allow all users (including non-authenticated users) to read and\n    # publish all packages\n    #\n    # you can specify usernames&#x2F;groupnames (depending on your auth plugin)\n    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;\n    # 三种身份所有人，匿名用户，认证（登录用户）\n    # 是否可访问所需的权限\n    access: $all\n\n    # allow all known users to publish packages\n    # (anyone can register by default, remember?)\n    # 发布package的权限\n    publish: $authenticated\n\n    # if package is not available locally, proxy requests to &#39;npmjs&#39; registry\n    # 如果package不存在，就向代理的上游服务器发起请求\n    proxy: npmjs\n\n# To use &#96;npm audit&#96; uncomment the following section\nmiddlewares:\n  audit:\n    enabled: true\n\n# 监听端口，重点，不配置这个只能本机可以访问\nlisten: 0.0.0.0:4873\n\n# log settings\nlogs:\n  - &#123;type: stdout, format: pretty, level: http&#125;\n  #- &#123;type: file, path: verdaccio.log, level: info&#125;\n\n\n\n\n\n\n\n\n\n\n4.启动  pm2 start verdaccio   这是后就可以通过http://xxx（ip地址）去访问了\n\n\n\n\n\n\n\n\n\n5.如何使用\n#当前npm 服务指向本地 \nnpm set registry http:&#x2F;&#x2F;localhost:4873\n# 注册用户 在本地注册一个用户然后指向我们的地址然后我们就可以发布包了\nnpm adduser --registry http:&#x2F;&#x2F;xxx:4873\nUsername: xxx\nPassword: xxx\nPassword:  xxx\nEmail: (this IS public) xxx\nLogged in as yg-ui on http:&#x2F;&#x2F;xxx&#x2F; （你的ip地址）这时候我们就注册一个用户，我们可以用这个用户名和密码去登录去上图窗口去登录\n\n\n与私服连接\n\nnpm set registry http:&#x2F;&#x2F;xxx：4873 (失败试试：npm config set registry http:&#x2F;&#x2F;xxx:4873 ，然后查看是否配置成功npm config edit）\n把下载镜像源的地址切换到从我们的服务器上下载。这里的npmrc文件里面内地址也就会易主\n\n\n安装nrm\n\nnrm是 npm registry 管理工具, 能够查看和切换当前使用的registry。不安装也可以，安装会更高效。\n1、安装 npm install -g nrm\n2、添加私服地址到nrm管理工具\n\n3、这里的 yg-ui是我们给自己的私服地址起的别名，为了切换和使用方便。\n   nrm add yg-ui http:&#x2F;&#x2F;xxx:4873 成功后如下\n     add registry my50 success\n4、将npm包的下载地址改到my50的私服。\n   nrm use yg-ui 成功后如下\n     verb config Skipping project config: &#x2F;home&#x2F;yg&#x2F;.npmrc.\n     Registry has been set to: http:&#x2F;&#x2F;xxx:4873&#x2F;\n5、使用nrm ls可查到我们可以使用的所有镜像源地址，* 后面是当前使用的，如果我们不想从私服上下载包，就可以用上一步骤的nrm use命令，use其它的地址，将下载地址改到别的服务器。\n   \n   输入 nrm ls 成功后如下\n   npm ---- https:&#x2F;&#x2F;registry.npmjs.org&#x2F;\n   cnpm --- http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;\n   taobao - https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;\n   nj ----- https:&#x2F;&#x2F;registry.nodejitsu.com&#x2F;\n   rednpm - http:&#x2F;&#x2F;registry.mirror.cqupt.edu.cn&#x2F;\n   npmMirror  https:&#x2F;&#x2F;skimdb.npmjs.com&#x2F;registry&#x2F;\n   edunpm - http:&#x2F;&#x2F;registry.enpmjs.org&#x2F; \n   * yg-ui --- http:&#x2F;&#x2F;xxx:4873&#x2F;\n\n   其实nrm只是个npm registry 管理工具，有了它可以让我们切换和查看registry 地址更方便快捷，即便没有它，我们直接用npm的set命令也可以切换地址，用type命令也可以查看地址，只不过用nrm更便捷，用不用随你了，觉得方便就用。\n\n\n发布包\n\n1、新建一个npmtest 目录，里边放一个文件\n2、进入目录 npm init 生成package.json\n3、npm publish           # 第二次发包已经切换到我们私服地址的情况下\n   npm publish --registry http:&#x2F;&#x2F;xxx:4873   #未切换到我们的私服时，直接加后缀可以发布到私服上。\n  第二次发包我们需要npm login 输入用户密码以及邮箱即可（这里需要注意的是\n\n\n下载包\n\n1、新建.npmrc文件\n   registry&#x3D;http:&#x2F;&#x2F;xxx:4873&#x2F;#&#x2F;detail&#x2F;ui-test\n   &#x2F;&#x2F;xxx&#x2F;:_authToken&#x3D;&quot;EF+Q227aTInBu2cvmkDyiozkm&#x2F;Z&#x2F;nOz9m1mWK&#x2F;PlgoA&#x3D;&quot;\n   &#x2F;&#x2F;localhost:4873&#x2F;:_authToken&#x3D;&quot;OTmT9IjKXStdvRwV8RRf6g&#x3D;&#x3D;&quot;\n   package-lock&#x3D;false\n   npm config edit  可以查看到_authToken\n2、npm install npmtest --save\n\n   这个命令是默认下载当前定位文件夹下package.json文件中需要的所有包，包括其间接依赖的包。第一次下载\n\n   之后的包都会缓存在我们的私服上，然后后期下载的时候从私服下载，就不会再从npmjs上下载包，但是它下\n\n   载每个包的时候都会再走一遍npmjs去检查包的版本，即便不下载资源，但这无疑也浪费了时间。经验证发\n\n   现，我们的package-lock.json文件在此刻起了大作用，因为package-lock.json文件本来就是更新node库后自\n\n   动生成的文件，里面包含了node库中所有包的下载地址当前版本以及包之间的依赖关系，既然package-\n\n   lock.json稳定了版本，所以当我们项目中包含了这个文件时，我们下包时就会根据package-lock.json的稳定版\n\n   本来，就不会再去npmjs上去检查了，这样会极大的提升下载包的速度。所以项目中一定要有稳定的\n\n   package.json和package-lock.json文件，并及时更新这两个文件。\n   package.json里边配置\n   &quot;publishConfig&quot;: &#123;\n     &quot;registry&quot;: &quot;http:&#x2F;&#x2F;xxx&#x2F;repository&#x2F;npmself&#x2F;&quot;\n   &#125;,\n\n\n删除包\n\n$ cd &#x2F;home&#x2F;yg&#x2F;.config&#x2F;verdaccio\n$ ls \nconfig.yaml  htpasswd  storage\n$ cd storage\n$ ls\n$ rm -rf  ui-test\n\n","slug":"node/base/Node基础十二","date":"2022-10-01T04:32:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"52153482f8bb5490978c774dade2918c","title":"Node基础十一","content":"十一.koa开发web服务器Koa初体验1.1. 认识Koa前面我们已经学习了express，另外一个非常流行的Node Web服务器框架就是Koa。\nKoa官方的介绍：\n\nkoa：next generation web framework for node.js；\nkoa：node.js的下一代web框架；\n\n事实上，koa是express同一个团队开发的一个新的Web框架：\n\n目前团队的核心开发者TJ的主要精力也在维护Koa，express已经交给团队维护了；\nKoa旨在为Web应用程序和API提供更小、更丰富和更强大的能力；\n相对于express具有更强的异步处理能力（后续我们再对比）；\nKoa的核心代码只有1600+行，是一个更加轻量级的框架，我们可以根据需要安装和使用中间件；\n\n1.2. koa初体验因为学习过了express，它们的基本开发模式是比较相似的。\n我们来体验一下koa的Web服务器：\nconst Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(&quot;middleware 01&quot;);\n  next();\n&#125;)\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(&quot;middleware 02&quot;);\n  ctx.response.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动成功~&quot;);\n&#125;);\n\nkoa注册的中间件提供了两个参数：\n\nctx：上下文（Context）对象；\n\n\nkoa并没有像express一样，将req和res分开，而是将它们作为ctx的属性；\n\n\nctx代表依次请求的上下文对象；\n\nctx.request：获取请求对象；\n\nctx.response：获取响应对象；\n\nnext：本质上是一个dispatch，类似于之前的next；\n\n\n后续我们学习Koa的源码，来看一下它是一个怎么样的函数；\n\n\n\nkoa通过创建的app对象，注册中间件只能通过use方法：\n\nKoa并没有提供methods的方式来注册中间件；\n也没有提供path中间件来匹配路径；\n\n但是真实开发中我们如何将路径和method分离呢？\n\n方式一：根据request自己来判断；\n方式二：使用第三方路由中间件；\n\n方式一：根据request自己判断\napp.use((ctx, next) &#x3D;&gt; &#123;\n  if (ctx.request.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;users&#39;) &#123;\n    if (ctx.request.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      ctx.response.body &#x3D; &quot;Create User Success~&quot;;\n    &#125; else &#123;\n      ctx.response.body &#x3D; &quot;Users List~&quot;;\n    &#125;\n  &#125; else &#123;\n    ctx.response.body &#x3D; &quot;Other Request Response&quot;;\n  &#125;\n&#125;)\n\n整个代码的逻辑是非常复杂和混乱的，真实开发中我们会使用路由。\n1.3. 路由的使用koa官方并没有给我们提供路由的库，我们可以选择第三方库：koa-router\n1.3.1. 安装koa-router因为是第三方的库，所以我们需要单独下项目中安装：\nnpm install koa-router\n\n1.3.2. koa-router基本使用我们可以先封装一个 user.router.js 的文件：\nconst Router &#x3D; require(&#39;koa-router&#39;);\n\nconst userRouter &#x3D; new Router();\n\nuserRouter.get(&#39;&#x2F;users&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;user list~&quot;;\n&#125;);\n\nuserRouter.post(&#39;&#x2F;users&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;create user info~&quot;;\n&#125;);\n\nmodule.exports &#x3D; userRouter;\n\n在app中将router.routes()注册为中间件：\napp.use(userRouter.routes());\napp.use(userRouter.allowedMethods());\n\n注意：allowedMethods用于判断某一个method是否支持：\n\n如果我们请求 get，那么是正常的请求，因为我们有实现get；\n如果我们请求 put、delete、patch，那么就自动报错：Method Not Allowed，状态码：405；\n如果我们请求 link、copy、lock，那么就自动报错：Not Implemented，状态码：501；\n\n1.3.3. router的前缀通常一个路由对象是对一组相似路径的封装，那么路径的前缀都是一直的，所以我们可以直接在创建Router时，添加前缀：\nconst userRouter &#x3D; new Router(&#123;prefix: &#39;&#x2F;users&#39;&#125;);\n\nuserRouter.get(&#39;&#x2F;&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;user list~&quot;;\n&#125;);\n\nuserRouter.post(&#39;&#x2F;&#39;, (ctx, next) &#x3D;&gt; &#123;\n  ctx.response.body &#x3D; &quot;create user info~&quot;;\n&#125;);\n\nmodule.exports &#x3D; userRouter;\n\n1.4. 请求解析客户端传递到服务器参数的方法常见的是5种：\n\n方式一：通过get请求中的URL的params；\n方式二：通过get请求中的URL的query；\n方式三：通过post请求中的body的json格式；\n方式四：通过post请求中的body的x-www-form-urlencoded格式；\n方式五：通过post请求中的form-data格式；\n\n1.4.1. 方式一：params请求地址：http://localhost:8000/users/123\n获取params：\nconst userRouter &#x3D; new Router(&#123;prefix: &quot;&#x2F;users&quot;&#125;)\n\nuserRouter.get(&quot;&#x2F;:id&quot;, (ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.params.id);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.2. 方式二：query请求地址：http://localhost:8000/login?username=why&amp;password=123\n获取query：\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.query);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.3. 方式三：json请求地址：http://localhost:8000/login\nbody是json格式：\n&#123;\n    &quot;username&quot;: &quot;coderwhy&quot;,\n    &quot;password&quot;: &quot;123&quot;\n&#125;\n\n获取json数据：\n\n安装依赖：npm install koa-bodyparser;\n使用 koa-bodyparser的中间件；\n\napp.use(bodyParser());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.4. 方式四：x-www-form-urlencoded请求地址：http://localhost:8000/login\nbody是x-www-form-urlencoded格式：\nx-www-form-urlencoded\n获取json数据：(和json是一致的)\n\n安装依赖：npm install koa-bodyparser;\n使用 koa-bodyparser的中间件；\n\napp.use(bodyParser());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.request.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;)\n\n1.4.5. 方式五：form-data请求地址：http://localhost:8000/login\nbody是form-data格式：\nform-data\n解析body中的数据，我们需要使用multer\n\n安装依赖：npm install koa-multer;\n使用 multer中间件；\n\nconst upload &#x3D; multer(&#123;\n&#125;);\n\napp.use(upload.any());\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.req.body);\n  ctx.body &#x3D; &quot;Hello World&quot;;\n&#125;);\n\n我们知道multer还可以实现文件的上传：\nconst storage &#x3D; multer.diskStorage(&#123;\n  destination: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, &quot;.&#x2F;uploads&#x2F;&quot;)\n  &#125;,\n  filename: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, Date.now() + path.extname(file.originalname))\n  &#125;\n&#125;)\n\nconst upload &#x3D; multer(&#123;\n  storage\n&#125;);\n\nconst fileRouter &#x3D; new Router();\n\nfileRouter.post(&quot;&#x2F;upload&quot;, upload.single(&#39;avatar&#39;), (ctx, next) &#x3D;&gt; &#123;\n  console.log(ctx.req.file);\n&#125;)\n\napp.use(fileRouter.routes());\n\n1.5. 响应方式输出结果：body\n将响应主体设置为以下之一：\n\nstring ：字符串数据\nBuffer ：Buffer数据\nStream ：流数据\nObject|| Array：对象或者数组\nnull ：不输出任何内容\n\n如果response.status尚未设置，Koa会自动将状态设置为200或204。\n比较常见的输出方式：\nctx.response.body &#x3D; &quot;Hello World&quot;;\nctx.body &#x3D; &#123;\n  name: &quot;why&quot;,\n  age: 18,\n  height: 1.88\n&#125;;\nctx.body &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];\n\n疑惑：ctx.response.body和ctx.body之间的区别：\n\n事实上，我们访问ctx.body时，本质上是访问ctx.response.body；\n我们可以看到源码中，我们访问 proto（这里就是ctx），其实是访问proto中的response的属性；\n\nimage-20201104155927483\n请求状态：status\n请求状态我们可以直接给ctx设置，或者给ctx.response设置也是一样的效果：\nctx.status &#x3D; 201;\nctx.response.status &#x3D; 204;\n\n1.6. 错误处理const Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use((ctx, next) &#x3D;&gt; &#123;\n  ctx.app.emit(&#39;error&#39;, new Error(&quot;哈哈哈&quot;), ctx);\n&#125;)\n\napp.on(&#39;error&#39;, (err, ctx) &#x3D;&gt; &#123;\n  console.log(err.message);\n  ctx.response.body &#x3D; &quot;哈哈哈&quot;;\n&#125;)\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;错误处理服务启动成功~&quot;);\n&#125;)\n\n1.7. 静态服务器koa并没有内置部署相关的功能，所以我们需要使用第三方库：\nnpm install koa-static\n\n部署的过程类似于express：\nconst Koa &#x3D; require(&#39;koa&#39;);\nconst static &#x3D; require(&#39;koa-static&#39;);\n\nconst app &#x3D; new Koa();\n\napp.use(static(&#39;.&#x2F;build&#39;));\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;静态服务器启动成功~&quot;);\n&#125;);\n\n1.8. 源码解析视频里面有讲解，这里不再截图\n二. 和express对比在学习了两个框架之后，我们应该已经可以发现koa和express的区别：\n从架构设计上来说：\n\nexpress是完整和强大的，其中帮助我们内置了非常多好用的功能；\n\nkoa是简洁和自由的，它只包含最新的功能，并不会对我们使用其他中间件进行任何的限制。\n\n\n甚至是在app中连最基本的get、post都没有给我们提供；\n\n\n我们需要通过自己或者路由来判断请求方式或者其他功能；\n\n\n因为express和koa框架他们的核心其实都是中间件：\n\n但是他们的中间件事实上，它们的中间件的执行机制是不同的，特别是针对某个中间件中包含异步操作时；\n所以，接下来，我们再来研究一下express和koa中间件的执行顺序问题；\n\n我通过一个需求来演示所有的过程：\n\n假如有三个中间件会在一次请求中匹配到，并且按照顺序执行；\n\n我希望最终实现的方案是：\n\n\n注意：是middleware1中；\n\n\n在middleware1中，在req.message中添加一个字符串 aaa；\n\n在middleware2中，在req.message中添加一个 字符串bbb；\n\n在middleware3中，在req.message中添加一个 字符串ccc；\n\n当所有内容添加结束后，在middleware1中，通过res返回最终的结果；\n\n\n2.1. 同步执行顺序假如我们获取的所有数据，是可以同步获取的；\n我们先通过express实现这个过程：\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\n\nconst middleware1 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;ccc&#39;;\n&#125;\n\napp.use(middleware1, middleware2, middleware3);\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;启动成功~&quot;);\n&#125;)\n\n最终的结果是：aaabbbccc，没问题；\n我们再通过koa实现这个过程：\nconst Koa &#x3D; require(&#39;koa&#39;);\n\nconst app &#x3D; new Koa();\n\nconst middleware1 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  next();\n  console.log(&quot;aaaa&quot;);\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  console.log(&quot;bbbb&quot;);\n  next();\n&#125;\n\nconst middleware3 &#x3D; (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;ccc&#39;;\n&#125;\n\napp.use(middleware1);\napp.use(middleware2);\napp.use(middleware3);\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;启动成功~&quot;);\n&#125;)\n\n最终的结果也是：aaabbbccc，也没问题；\n2.2. 异步执行顺序但是，如果我们最后的ccc中的结果，是需要异步操作才能获取到的，是否会产生问题呢？\n2.2.1. express中遇到异步操作express有异步操作（没有在next前，加async、await）：\nconst middleware1 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  req.message &#x3D; req.message + result.data.lrc.lyric;\n  console.log(req.message);\n&#125;\n\n最终的结果aaabbb，是不正确。\nexpress有异步操作（有在next前，加async、await）：\nconst middleware1 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; &quot;aaa&quot;;\n  await next();\n  res.end(req.message);\n&#125;\n\nconst middleware2 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  req.message &#x3D; req.message + &#39;bbb&#39;;\n  await next();\n&#125;\n\nconst middleware3 &#x3D; async (req, res, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  req.message &#x3D; req.message + result.data.lrc.lyric;\n  console.log(req.message);\n&#125;\n\n最终的结果也是aaabbb，也是不正确。\n为什么呢？\n\n原因是本质上的next()和异步没有任何关系；\n它本身就是一个同步函数的调用，所以它不会等到你异步有结果之后，再继续执行后续的操作；\n\nimage-20201106175205300\n2.2.2. koa中遇到异步操作koa有异步操作（没有在next前，加async、await）：\nconst middleware1 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  next();\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  next();\n&#125;\n\nconst middleware3 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  ctx.message &#x3D; ctx.message + result.data.lrc.lyric;\n&#125;\n\n最终的结果也是aaabbb，也是不正确。\n\n这是因为虽然next函数是一个返回promise的异步操作，但是在前面不加await的情况，是不同等待结果的返回，就会继续向后执行了；\n\nkoa有异步操作（有在next前，加async、await）：\nconst middleware1 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; &quot;aaa&quot;;\n  await next();\n  ctx.body &#x3D; ctx.message;\n&#125;\n\nconst middleware2 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  ctx.message &#x3D; ctx.message + &#39;bbb&#39;;\n  await next();\n&#125;\n\nconst middleware3 &#x3D; async (ctx, next) &#x3D;&gt; &#123;\n  const result &#x3D; await axios.get(&#39;http:&#x2F;&#x2F;123.207.32.32:9001&#x2F;lyric?id&#x3D;167876&#39;);\n  ctx.message &#x3D; ctx.message + result.data.lrc.lyric;\n&#125;\n\n最终的结果是aaabbb+歌词信息，是正确。\n\n这是因为，当我们在koa中的next前面加await时，它会等到后续有一个确定结果时，在执行后续的代码；\n\n","slug":"node/base/Node基础十一","date":"2022-10-01T04:31:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"c2943d2fce9c96d8a973d43b491afc6a","title":"Node基础十","content":"十.express开发web服务器Express初体验1.1. 认识Web框架前面我们已经学习了使用http内置模块来搭建Web服务器，为什么还要使用框架？\n\n原生http在进行很多处理时，会较为复杂；\n有URL判断、Method判断、参数处理、逻辑代码处理等，都需要我们自己来处理和封装；\n并且所有的内容都放在一起，会非常的混乱；\n\n目前在Node中比较流行的Web服务器框架是express、koa；\n\n我们先来学习express，后面再学习koa，并且对他们进行对比；\n\nexpress早于koa出现，并且在Node社区中迅速流行起来：\n\n我们可以基于express快速、方便的开发自己的Web服务器；\n并且可以通过一些实用工具和中间件来扩展自己功能；\n\nexpress中文网连接: https://www.expressjs.com.cn/\n1.2. express的安装express的使用过程有两种方式：\n\n方式一：通过express提供的脚手架，直接创建一个应用的骨架；\n方式二：从零搭建自己的express应用结构；\n\n方式一：安装express-generator\nnpm install -g express-generator\n\n创建项目：\nexpress express-demo\n\n项目目录如下：\n├── app.js\n├── bin\n│   └── www\n├── package-lock.json\n├── package.json\n├── public\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes\n│   ├── index.js\n│   └── users.js\n└── views\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n\n我们可以安装依赖，将程序跑起来：\nnpm install\nnode bin&#x2F;www\n\n方式二：从零学习搭建\n刚才创建的项目express项目，很多内容可能我们并不认识，所以刚开始我们最好从零来学习。\n初始化一个新的项目\nnpm init -y\n\nexpress的安装：\n\n目前最新的 release 版本是4.17.1，我们使用该版本；\n\nnpm install express\n\n1.3. express初体验我们来创建自己的第一个express程序：\nconst express &#x3D; require(&#39;express&#39;);\n\n&#x2F;&#x2F; 创建服务器\nconst app &#x3D; express();\n\n&#x2F;&#x2F; &#x2F;home的get请求处理\napp.get(&quot;&#x2F;home&quot;, (req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Home&quot;);\n&#125;);\n\n&#x2F;&#x2F; &#x2F;login的post请求处理\napp.post(&quot;&#x2F;login&quot;, (req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Login&quot;);\n&#125;);\n\n&#x2F;&#x2F; 开启监听\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动成功~&quot;);\n&#125;)\n\n我们会发现，之后的开发过程中，可以方便的将请求进行分离：\n\n无论是不同的URL，还是get、post等请求方式；\n这样的方式非常方便我们已经进行维护、扩展；\n\n当然，这只是初体验，接下来我们来探索更多的用法；\n1.4. 请求和响应请求的路径中如果有一些参数，可以这样表达：\n\n/users/:userId；\n在request对象中要获取可以通过 req.params.userId;\n\n返回数据，我们可以方便的使用json：\n\nres.json(数据)方式；\n可以支持其他的方式，可以自行查看文档；\nhttps://www.expressjs.com.cn/guide/routing.html\n\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\napp.get(&#39;&#x2F;users&#x2F;:userId&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.params.userId);\n  res.json(&#123;username: &quot;coderwhy&quot;, level: 99&#125;);\n&#125;);\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;静态服务器启动成功~&quot;);\n&#125;)\n\n二. Express中间件2.1. 认识中间件Express是一个路由和中间件的Web框架，它本身的功能非常少：\n\nExpress应用程序本质上是一系列中间件函数的调用；\n\n中间件是什么呢？\n\n中间件的本质就是一个回调函数；\n\n这个回调函数接受三个参数：\n\n\n请求对象（request对象）；\n\n\n响应对象（response对象）；\n\nnext函数（在express中定义的用于执行下一个中间件的函数）；\n\n\n中间件中可以执行哪些任务呢？\n\n执行任何代码；\n更改请求（request）和响应（response）对象；\n结束请求-响应周期（返回数据）；\n调用栈中的下一个中间件；\n\n如果当前中间件功能没有结束请求-响应周期，则必须调用next()将控制权传递给下一个中间件功能，否则，请求将被挂起。\n中间件函数调用的元素：\nimage-20201101205333843\n2.2. 应用中间件那么，如何将一个中间件应用到我们的应用程序中呢？\n\nexpress主要提供了两种方式：app/router.use和app/router.methods；\n可以是 app，也可以是router，router我们后续再学习:\nmethods指的是常用的请求方式，比如：app.get或app.post等；\n\n我们先来学习use的用法，因为methods的方式本质是use的特殊情况；\n案例一：最普通的中间件\n之所以称之为最普通的中间件，是因为无论是什么path、methods都会应用该中间件；\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware 01&quot;);\n  next();\n&#125;)\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware 02&quot;);\n  res.end(&quot;Hello Common Middleware~&quot;);\n&#125;)\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;中间件服务器启动成功~&quot;);\n&#125;)\n\n中间件的执行顺序：\n\n在匹配上的情况下，中间件按照注册的顺序执行；\n\n案例二：path匹配中间件\n如果我们希望匹配一个明确的路径，也可以使用use方法：\n&#x2F;&#x2F; 案例二: 路径匹配中间件\napp.use(&#39;&#x2F;home&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;home middleware 01&quot;);\n  next();\n&#125;);\n\napp.use(&#39;&#x2F;home&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;home middleware 02&quot;);\n  next();\n  res.end(&quot;Hello Home middleware&quot;);\n&#125;);\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware&quot;);\n&#125;);\n\n案例三：path和method匹配中间件\n&#x2F;&#x2F; 案例三: method匹配中间件\napp.get(&#39;&#x2F;home&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;home get middleware&quot;);\n  next();\n&#125;)\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;login post middleware&quot;);\n  next();\n&#125;);\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  console.log(&quot;common middleware&quot;);\n&#125;);\n\n案例四：注册多个中间件\n&#x2F;&#x2F; 案例四: 注册多个中间件\nconst homeMiddleware1 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  console.log(&#39;home middleware 01&#39;);\n  next();\n&#125;\n\nconst homeMiddleware2 &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  console.log(&#39;home middleware 02&#39;);\n  next();\n&#125;\n\nconst homeHandle &#x3D; (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Home~&quot;);\n&#125;\n\napp.get(&#39;&#x2F;home&#39;, homeMiddleware1, homeMiddleware2, homeHandle);\n\n2.3. 应用其他中间件并非所有的中间件都需要我们从零去编写：\n\nexpress有内置一些帮助我们完成对request解析的中间件；\nregistry仓库中也有很多可以辅助我们开发的中间件；\n\n2.3.1. request解析中间件在客户端发送post请求时，会将数据放到body中：\n\n客户端可以通过json的方式传递；\n也可以通过form表单的方式传递；\n\n我们这里先使用json传递给服务器body：\njson传递body\n不进行解析时的操作：\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  req.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n    console.log(data.toString());\n  &#125;)\n  req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n    res.end(&quot;登录成功~&quot;);\n  &#125;);\n&#125;);\n\n我们也可以自己编写中间件来解析JSON：\napp.use((req, res, next) &#x3D;&gt; &#123;\n  if (req.headers[&#39;content-type&#39;] &#x3D;&#x3D;&#x3D; &#39;application&#x2F;json&#39;) &#123;\n    req.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n      const userInfo &#x3D; JSON.parse(data.toString());\n      req.body &#x3D; userInfo;\n    &#125;)\n    req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n      next();\n    &#125;)\n  &#125; else &#123;\n    next();\n  &#125;\n&#125;)\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n  res.end(&quot;登录成功~&quot;);\n&#125;);\n\n但是，事实上我们可以使用express内置的中间件或者使用body-parser来完成：\napp.use(express.json());\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n  res.end(&quot;登录成功~&quot;);\n&#125;);\n\n如果我们解析的是 application/x-www-form-urlencoded：\nform传递body\n我们可以使用express自带的 urlencoded函数来作为中间件：\n\n传入的extended用于表示使用哪一种解析方式：\n\n\ntrue：使用qs第三方模块；\n\n\nfalse：使用querystring内置模块；\n\n备注：它们之间的区别这里不展开讲解；\n\n\napp.use(express.json());\napp.use(express.urlencoded(&#123;extended: true&#125;));\n\napp.post(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n  res.end(&quot;登录成功~&quot;);\n&#125;);\n\n2.3.2. 日志记录中间件如果我们希望将请求日志记录下来，那么可以使用express官网开发的第三方库：morgan\n安装morgan：\nnpm install morgan\n\n直接作为中间件使用即可：\nconst loggerWriter &#x3D; fs.createWriteStream(&#39;.&#x2F;log&#x2F;access.log&#39;, &#123;\n  flags: &#39;a+&#39;\n&#125;)\napp.use(morgan(&#39;combined&#39;, &#123;stream: loggerWriter&#125;));\n\n2.3.3. 上传文件中间件图片上传我们可以使用express官方开发的第三方库：multer\nnpm install multer\n\n上传文件，并且默认文件名：\nconst upload &#x3D; multer(&#123;\n  dest: &quot;uploads&#x2F;&quot;\n&#125;)\n\napp.post(&#39;&#x2F;upload&#39;, upload.single(&#39;file&#39;), (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.file.buffer);\n  res.end(&quot;文件上传成功~&quot;);\n&#125;)\n\n添加文件名后缀：\nconst storage &#x3D; multer.diskStorage(&#123;\n  destination: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, &quot;uploads&#x2F;&quot;)\n  &#125;,\n  filename: (req, file, cb) &#x3D;&gt; &#123;\n    cb(null, Date.now() + path.extname(file.originalname));\n  &#125;\n&#125;)\n\nconst upload &#x3D; multer(&#123;\n  storage\n&#125;)\n\napp.post(&#39;&#x2F;upload&#39;, upload.single(&#39;file&#39;), (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.file.buffer);\n  res.end(&quot;文件上传成功~&quot;);\n&#125;)\n\n我们也可以上传多张图片：\napp.use(&#39;&#x2F;upload&#39;, upload.array(&#39;files&#39;), (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.files);\n&#125;);\n\n如果我们希望借助于multer帮助我们解析一些form-data中的普通数据，那么我们可以使用any：\n\n请求如下：\n\nimage-20201104165039444\napp.use(upload.any());\n\napp.use(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.body);\n&#125;);\n\n2.4. 请求和响应客户端传递到服务器参数的方法常见的是5种：\n\n方式一：通过get请求中的URL的params；\n方式二：通过get请求中的URL的query；\n方式三：通过post请求中的body的json格式（中间件中已经使用过）；\n方式四：通过post请求中的body的x-www-form-urlencoded格式（中间件使用过）；\n方式五：通过post请求中的form-data格式（中间件中使用过）；\n\n2.4.1. 请求解析方式一：params\n请求地址：http://localhost:8000/login/abc/why\n获取参数：\napp.use(&#39;&#x2F;login&#x2F;:id&#x2F;:name&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.params);\n  res.json(&quot;请求成功~&quot;);\n&#125;)\n\n方式二：query\n请求地址：http://localhost:8000/login?username=why&amp;password=123\n获取参数：\napp.use(&#39;&#x2F;login&#39;, (req, res, next) &#x3D;&gt; &#123;\n  console.log(req.query);\n\n  res.json(&quot;请求成功~&quot;);\n&#125;)\n\n2.4.2. 响应方式end方法\n类似于http中的response.end方法，用法是一致的\nres.end(&quot;Hello World&quot;);\n\njson方法\njson方法中可以传入很多的类型：object、array、string、boolean、number、null等，它们会被转换成json格式返回；\nres.json(&#123;name: &quot;why&quot;, age: 18&#125;);\n\nstatus方法\n用于设置状态码：\nres.status(204);\n\n三. 其他支持补充3.1. 路由的使用如果我们将所有的代码逻辑都写在app中，那么app会变得越来越复杂：\n\n一方面完整的Web服务器包含非常多的处理逻辑；\n\n另一方面有些处理逻辑其实是一个整体，我们应该将它们放在一起：比如对users相关的处理\n\n\n获取用户列表；\n\n\n获取某一个用户信息；\n\n创建一个新的用户；\n\n删除一个用户；\n\n更新一个用户；\n\n\n我们可以使用 express.Router来创建一个路由处理程序：\n\n一个Router实例拥有完整的中间件和路由系统；\n因此，它也被称为 迷你应用程序（mini-app）；\n\n&#x2F;&#x2F; 用户相关的处理\nconst userRouter &#x3D; express.Router();\n\nuserRouter.get(&#39;&#x2F;&#39;, (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;用户列表&quot;);\n&#125;);\n\nuserRouter.post(&#39;&#x2F;&#39;, (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;创建用户&quot;);\n&#125;);\n\nuserRouter.delete(&#39;&#x2F;&#39;, (req, res, next) &#x3D;&gt; &#123;\n  res.end(&quot;删除用户&quot;);\n&#125;);\n\napp.use(&#39;&#x2F;users&#39;, userRouter);\n\n当然，我们可以配置更多的路由，并且将所有的逻辑放到一个单独的文件中。\n3.2. 静态资源服务器部署静态资源我们可以选择很多方式：\n\nNode也可以作为静态资源服务器，并且express给我们提供了方便部署静态资源的方法；\n\nconst express &#x3D; require(&#39;express&#39;);\n\nconst app &#x3D; express();\n\napp.use(express.static(&#39;.&#x2F;build&#39;));\n\napp.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;静态服务器启动成功~&quot;);\n&#125;)\n\n3.3. 错误处理方式app.use((req, res, next) &#x3D;&gt; &#123;\n  next(new Error(&quot;USER DOES NOT EXISTS&quot;));\n&#125;);\n\napp.use((err, req, res, next) &#x3D;&gt; &#123;\n  const message &#x3D; err.message;\n\n  switch (message) &#123;\n    case &quot;USER DOES NOT EXISTS&quot;:\n      res.status(400).json(&#123;message&#125;)\n  &#125;\n\n  res.status(500)\n&#125;)\n\n3.4. 源码分析3.4.1. 创建app的过程express函数的本质其实是createApplication：\nimage-20201102161803339\n当我们调用app.listen的时候，本质上是调用proto中的listen\n\n因为上面有进行 mixin 的操作；\n\nimage-20201102161939032\n3.4.2. 注册中间件比如我们通过use来注册一个中间件，源码中发生了什么？\n\n我们会发现无论是app.use还是app.methods都会注册一个主路由；\n我们会发现app本质上会将所有的函数，交给这个主路由去处理的；\n\nimage-20201102162627758\n我们来看一下router.use中又做了什么事情？\n\n本质上一个函数会创建一个layer，并且会被放入到stack中；\n\nimage-20201102162749391\n3.4.3. 请求的处理过程如果有一个请求过来，那么从哪里开始呢？\n\napp函数被调用开始的；\n\nimage-20201102162943190\napp.handle本质上会去调用router.handle：\nimage-20201102163035566\nrouter.handle中做的什么事情呢？\nimage-20201102163153121\nimage-20201102163314862\n","slug":"node/base/Node基础十","date":"2022-10-01T04:30:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"b171402bc406b8e8ddf1dcd5f712137e","title":"Node基础九","content":"九.http开发web服务器\n\n\n\n\n\n\n\n\n什么是Web服务器？\n当应用程序（客户端）需要某一个资源时，可以向一个台服务器，通过Http请求获取到这个资源；提供服务器的这个服务器，就是一个Web服务器；\nWeb服务器\n目前有很多开源的Web服务器：Nginx、Apache（静态）、Apache Tomcat（静态、动态）、Node.js\n一. Http模板基本使用1.1. 如何创建服务1.1.1. Web服务器初体验创建一个Web服务器的初体验：\nconst http &#x3D; require(&#39;http&#39;);\n\nconst HTTP_PORT &#x3D; 8000;\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello World&quot;);\n&#125;);\n\nserver.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&#96;🚀服务器在$&#123;HTTP_PORT&#125;启动~&#96;)\n&#125;)\n\n1.1.2. 创建服务器创建服务器对象，我们是通过 createServer 来完成的\n\nhttp.createServer会返回服务器的对象；\n底层其实使用直接 new Server 对象。\n\nfunction createServer(opts, requestListener) &#123;\n  return new Server(opts, requestListener);\n&#125;\n\n那么，当然，我们也可以自己来创建这个对象：\nconst server2 &#x3D; new http.Server((req, res) &#x3D;&gt; &#123;\n  res.end(&quot;Hello Server2&quot;);\n&#125;);\n\nserver2.listen(9000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动成功~&quot;);\n&#125;)\n\n上面我们已经看到，创建Server时会传入一个回调函数，这个回调函数在被调用时会传入两个参数：\n\nreq：request请求对象，包含请求相关的信息；\nres：response响应对象，包含我们要发送给客户端的信息；\n\n1.1.3. 监听端口和主机Server通过listen方法来开启服务器，并且在某一个主机和端口上监听网络请求：\n\n也就是当我们通过 ip:port的方式发送到我们监听的Web服务器上时；\n我们就可以对其进行相关的处理；\n\nlisten函数有三个参数：\n\n端口port: 可以不传, 系统会默认分配端, 后续项目中我们会写入到环境变量中；\n\n主机host: 通常可以传入localhost、ip地址127.0.0.1、或者ip地址0.0.0.0，默认是0.0.0.0；\n\n\n监听IPV4上所有的地址，再根据端口找到不同的应用程序；\n\n\n比如我们监听 0.0.0.0时，在同一个网段下的主机中，通过ip地址是可以访问的；\n\n正常的数据库包经常 应用层 - 传输层 - 网络层 - 数据链路层 - 物理层 ；\n\n而回环地址，是在网络层直接就被获取到了，是不会经常数据链路层和物理层的；\n\n比如我们监听 127.0.0.1时，在同一个网段下的主机中，通过ip地址是不能访问的；\n\nlocalhost：本质上是一个域名，通常情况下会被解析成127.0.0.1；\n\n127.0.0.1：回环地址（Loop Back Address），表达的意思其实是我们主机自己发出去的包，直接被自己接收；\n\n0.0.0.0：\n\n回调函数：服务器启动成功时的回调函数；\n\n\nserver.listen(() &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动~🚀&quot;);\n&#125;)\n\n1.2. request请求对象在向服务器发送请求时，我们会携带很多信息，比如：\n\n本次请求的URL，服务器需要根据不同的URL进行不同的处理；\n本次请求的请求方式，比如GET、POST请求传入的参数和处理的方式是不同的；\n本次请求的headers中也会携带一些信息，比如客户端信息、接受数据的格式、支持的编码格式等；\n等等…\n\n这些信息，Node会帮助我们封装到一个request的对象中，我们可以直接来处理这个request对象：\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; request对象\n  console.log(req.url);\n  console.log(req.method);\n  console.log(req.headers);\n\n  res.end(&quot;Hello World&quot;);\n&#125;);\n\n1.2.1. URL的处理客户端在发送请求时，会请求不同的数据，那么会传入不同的请求地址：\n\n比如 http://localhost:8000/login；\n比如 http://localhost:8000/products;\n\n服务器端需要根据不同的请求地址，作出不同的响应：\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  const url &#x3D; req.url;\n  console.log(url);\n\n  if (url &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n    res.end(&quot;welcome Back~&quot;);\n  &#125; else if (url &#x3D;&#x3D;&#x3D; &#39;&#x2F;products&#39;) &#123;\n    res.end(&quot;products&quot;);\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);\n\n那么如果用户发送的地址中还携带一些额外的参数呢？\n\nhttp://localhost:8000/login?name=why&amp;password=123;\n这个时候，url的值是 /login?name=why&amp;password=123；\n\n我们如何对它进行解析呢？\n\n使用内置模块url；\n\nconst url &#x3D; require(&#39;url&#39;);\n\n&#x2F;&#x2F; 解析请求\nconst parseInfo &#x3D; url.parse(req.url);\nconsole.log(parseInfo);\n\n解析结果：\nUrl &#123;\n  protocol: null,\n  slashes: null,\n  auth: null,\n  host: null,\n  port: null,\n  hostname: null,\n  hash: null,\n  search: &#39;?name&#x3D;why&amp;password&#x3D;123&#39;,\n  query: &#39;name&#x3D;why&amp;password&#x3D;123&#39;,\n  pathname: &#39;&#x2F;login&#39;,\n  path: &#39;&#x2F;login?name&#x3D;why&amp;password&#x3D;123&#39;,\n  href: &#39;&#x2F;login?name&#x3D;why&amp;password&#x3D;123&#39;\n&#125;\n\n我们会发现 pathname就是我们想要的结果。\n但是 query 信息如何可以获取呢？\n\n方式一：截取字符串；\n方式二：使用querystring内置模块；\n\nconst &#123; pathname, query &#125; &#x3D; url.parse(req.url);\nconst queryObj &#x3D; qs.parse(query);\nconsole.log(queryObj.name);\nconsole.log(queryObj.password);\n\n1.2.2. Method的处理在Restful规范（设计风格）中，我们对于数据的增删改查应该通过不同的请求方式：\n\nGET：查询数据；\nPOST：新建数据；\nPATCH：更新数据；\nDELETE：删除数据；\n\n所以，我们可以通过判断不同的请求方式进行不同的处理。\n比如创建一个用户：\n\n请求接口为 /users；\n请求方式为 POST请求；\n携带数据 username和password；\n\n创建用户请求\n在我们程序中如何进行判断以及获取对应的数据呢？\n\n这里我们需要判断接口是 /users，并且请求方式是POST方法去获取传入的数据；\n获取这种body携带的数据，我们需要通过监听req的 data事件来获取；\n\nif (req.url.indexOf(&#39;&#x2F;users&#39;) !&#x3D;&#x3D; -1) &#123;\n  if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n  \n    &#x2F;&#x2F; 可以设置编码，也可以在下方通过 data.toString() 获取字符串格式\n    req.setEncoding(&#39;utf-8&#39;);\n\n    req.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n      const &#123;username, password&#125; &#x3D; JSON.parse(data);\n      console.log(username, password);\n    &#125;);\n\n    res.end(&quot;create user success&quot;);\n  &#125; else &#123;\n    res.end(&quot;users list&quot;);\n  &#125;\n&#125; else &#123;\n  res.end(&quot;error message&quot;);\n&#125;\n\n将JSON字符串格式转成对象类型，通过JSON.parse方法即可。\n1.2.3. header属性在request对象的header中也包含很多有用的信息：\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  console.log(req.headers);\n\n  res.end(&quot;Hello Header&quot;);\n&#125;);\n\n浏览器会默认传递过来一些信息：\n&#123;\n  &#39;content-type&#39;: &#39;application&#x2F;json&#39;,\n  &#39;user-agent&#39;: &#39;PostmanRuntime&#x2F;7.26.5&#39;,\n  accept: &#39;*&#x2F;*&#39;,\n  &#39;postman-token&#39;: &#39;afe4b8fe-67e3-49cc-bd6f-f61c95c4367b&#39;,\n  host: &#39;localhost:8000&#39;,\n  &#39;accept-encoding&#39;: &#39;gzip, deflate, br&#39;,\n  connection: &#39;keep-alive&#39;,\n  &#39;content-length&#39;: &#39;48&#39;\n&#125;\n\ncontent-type是这次请求携带的数据的类型：\n\napplication/json表示是一个json类型；\ntext/plain表示是文本类型；\napplication/xml表示是xml类型；\nmultipart/form-data表示是上传文件；\n\ncontent-length：\n\n文件的大小和长度\n\nkeep-alive：\n\nhttp是基于TCP协议的，但是通常在进行一次请求和响应结束后会立刻中断；\n\n在http1.0中，如果想要继续保持连接：\n\n\n浏览器需要在请求头中添加 connection: keep-alive；\n\n\n服务器需要在响应头中添加 connection:keey-alive；\n\n当客户端再次放请求时，就会使用同一个连接，直接一方中断连接；\n\n在http1.1中，所有连接默认是 connection: keep-alive的；\n\n\n不同的Web服务器会有不同的保持 keep-alive的时间；\n\n\nNode中默认是5s中；\n\n\naccept-encoding：\n\n告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip编码，对应 .gz文件；\n\naccept：\n\n告知服务器，客户端可接受文件的格式类型；\n\nuser-agent：\n\n客户端相关的信息；\n\n1.3. 响应对象response1.3.1. 返回响应结果如果我们希望给客户端响应的结果数据，可以通过两种方式：\n\nWrite方法：这种方式是直接写出数据，但是并没有关闭流；\nend方法：这种方式是写出最后的数据，并且写出后会关闭流；\n\nconst http &#x3D; require(&#39;http&#39;);\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n\n  &#x2F;&#x2F; 响应数据的方式有两个:\n  res.write(&quot;Hello World&quot;);\n  res.write(&quot;Hello Response&quot;);\n  res.end(&quot;message end&quot;);\n&#125;);\n\nserver.listen(8000, () &#x3D;&gt; &#123;\n  console.log(&quot;服务器启动🚀~&quot;)\n&#125;);\n\n如果我们没有调用 end和close，客户端将会一直等待结果，所以客户端在发送网络请求时，都会设置超时时间。\n1.3.2. 返回状态码Http状态码（Http Status Code）是用来表示Http响应状态的数字代码：\n\nHttp状态码非常多，可以根据不同的情况，给客户端返回不同的状态码；\n常见的状态码是下面这些（后续项目中，也会用到其中的状态码）；\n\n状态码\n设置状态码常见的有两种方式：\nres.statusCode &#x3D; 400;\nres.writeHead(200);\n\n1.3.3. 响应头文件返回头部信息，主要有两种方式：\n\nres.setHeader：一次写入一个头部信息；\nres.writeHead：同时写入header和status；\n\nres.setHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;utf8&quot;);\n\nres.writeHead(200, &#123;\n  &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;utf8&quot;\n&#125;)\n\nHeader设置 Content-Type有什么作用呢？\n\n默认客户端接收到的是字符串，客户端会按照自己默认的方式进行处理；\n\n比如，我们返回的是一段HTML，但是没有指定格式：\nres.end(&#39;&lt;h2&gt;Hello World&lt;&#x2F;h2&gt;&#39;)\n\nimage-20201030154312050\n但是，如果我们指定了格式：\nres.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html;charset&#x3D;utf8&quot;);\nres.end(&#39;&lt;h2&gt;Hello World&lt;&#x2F;h2&gt;&#39;)\n\nimage-20201030154404172\n如果我们希望返回一段JSON数据，应该怎么做呢？\nres.writeHead(200, &#123;\n  &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;utf8&quot;\n&#125;)\n\nconst data &#x3D; &#123;\n  name: &quot;王红元&quot;,\n  age: 18,\n  height: 1.88\n&#125;;\n\nres.end(JSON.stringify(data));\n\n二. Web其他补充2.1. 文件上传的使用如果是一个很大的文件需要上传到服务器端，服务器端进行保存应该如何操作呢？\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;upload&#39;) &#123;\n    if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      const fileWriter &#x3D; fs.createWriteStream(&#39;.&#x2F;foo.png&#39;);\n      req.pipe(fileWriter);\n\n      const fileSize &#x3D; req.headers[&#39;content-length&#39;];\n      let curSize &#x3D; 0;\n      console.log(fileSize);\n\n      req.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n        curSize +&#x3D; data.length;\n        console.log(curSize);\n        res.write(&#96;文件上传进度: $&#123;curSize&#x2F;fileSize * 100&#125;%\\n&#96;);\n      &#125;);\n\n      req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n        res.end(&quot;文件上传完成~&quot;);\n      &#125;)\n    &#125;\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);\n\n这个时候我们发现文件上传成功了，但是文件却打不开：\n\n这是因为我们写入的数据，里面包含一些特殊的信息；\n这些信息打开的软件并不能很好的解析；\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n  if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;upload&#39;) &#123;\n    if (req.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;) &#123;\n      &#x2F;&#x2F; 图片文件必须设置为二进制的\n      req.setEncoding(&#39;binary&#39;);\n\n      &#x2F;&#x2F; 获取content-type中的boundary的值\n      var boundary &#x3D; req.headers[&#39;content-type&#39;].split(&#39;; &#39;)[1].replace(&#39;boundary&#x3D;&#39;,&#39;&#39;);\n      \n      &#x2F;&#x2F; 记录当前数据的信息\n      const fileSize &#x3D; req.headers[&#39;content-length&#39;];\n      let curSize &#x3D; 0;\n      let body &#x3D; &#39;&#39;;\n\n      &#x2F;&#x2F; 监听当前的数据\n      req.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n        curSize +&#x3D; data.length;\n        res.write(&#96;文件上传进度: $&#123;curSize&#x2F;fileSize * 100&#125;%\\n&#96;);\n        body +&#x3D; data;\n      &#125;);\n\n      &#x2F;&#x2F; 数据结构\n      req.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 切割数据\n        const payload &#x3D; qs.parse(body, &quot;\\r\\n&quot;, &quot;:&quot;);\n        &#x2F;&#x2F; 获取最后的类型(image&#x2F;png)\n        const fileType &#x3D; payload[&quot;Content-Type&quot;].substring(1);\n        &#x2F;&#x2F; 获取要截取的长度\n        const fileTypePosition &#x3D; body.indexOf(fileType) + fileType.length;\n        let binaryData &#x3D; body.substring(fileTypePosition);\n        binaryData &#x3D; binaryData.replace(&#x2F;^\\s\\s*&#x2F;, &#39;&#39;);\n\n        &#x2F;&#x2F; binaryData &#x3D; binaryData.replaceAll(&#39;\\r\\n&#39;, &#39;&#39;);\n        const finalData &#x3D; binaryData.substring(0, binaryData.indexOf(&#39;--&#39;+boundary+&#39;--&#39;));\n\n        fs.writeFile(&#39;.&#x2F;boo.png&#39;, finalData, &#39;binary&#39;, (err) &#x3D;&gt; &#123;\n          console.log(err);\n          res.end(&quot;文件上传完成~&quot;);\n        &#125;)\n      &#125;)\n    &#125;\n  &#125; else &#123;\n    res.end(&quot;error message&quot;);\n  &#125;\n&#125;);\n\n2.2. http发送网络请求axios库可以在浏览器中使用，也可以在Node中使用：\n\n在浏览器中，axios使用的是封装xhr；\n在Node中，使用的是http内置模块；\n\n所以http模块是可以在Node中直接发送网络请求的。\n发送get请求：\nhttp.get(&quot;http:&#x2F;&#x2F;localhost:8000&quot;, (res) &#x3D;&gt; &#123;\n  res.on(&#39;data&#39;, data &#x3D;&gt; &#123;\n    console.log(data.toString());\n    console.log(JSON.parse(data.toString()));\n  &#125;)\n&#125;);\n\n发送post请求：\nconst req &#x3D; http.request(&#123;\n  method: &#39;POST&#39;,\n  hostname: &quot;localhost&quot;,\n  port: 8000\n&#125;, (res) &#x3D;&gt; &#123;\n  res.on(&#39;data&#39;, data &#x3D;&gt; &#123;\n    console.log(data.toString());\n    console.log(JSON.parse(data.toString()));\n  &#125;)\n&#125;)\n\nreq.on(&#39;error&#39;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\n\nreq.end();\n","slug":"node/base/Node基础九","date":"2022-10-01T04:29:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"adefcce4d4f2d80811a82b2ac8c91417","title":"Node基础八","content":"八. 深入事件循环事件循环是什么？事实上我把事件循环理解成我们编写的JavaScript和浏览器或者Node之间的一个桥梁。\n浏览器的事件循环是一个我们编写的JavaScript代码和浏览器API调用(setTimeout&#x2F;AJAX&#x2F;监听事件等)的一个桥梁, 桥梁之间他们通过回调函数进行沟通。\nNode的事件循环是一个我们编写的JavaScript代码和系统调用（file system、network等）之间的一个桥梁, 桥梁之间他们通过回调函数进行沟通的.\n浏览器的事件循环1.1. 进程和线程线程和进程是操作系统中的两个概念：\n\n进程（process）：计算机已经运行的程序；\n线程（thread）：操作系统能够运行运算调度的最小单位；\n\n听起来很抽象，我们直观一点解释：\n\n进程：我们可以认为，启动一个应用程序，就会默认启动一个进程（也可能是多个进程）；\n线程：每一个进程中，都会启动一个线程用来执行程序中的代码，这个线程被称之为主线程；\n所以我们也可以说进程是线程的容器；\n\n再用一个形象的例子解释：\n\n操作系统类似于一个工厂；\n工厂中里有很多车间，这个车间就是进程；\n每个车间可能有一个以上的工人在工厂，这个工人就是线程；\n\n操作系统、线程、进程\n操作系统是如何做到同时让多个进程（边听歌、边写代码、边查阅资料）同时工作呢？\n\n这是因为CPU的运算速度非常快，它可以快速的在多个进程之间迅速的切换；\n当我们的进程中的线程获取获取到时间片时，就可以快速执行我们编写的代码；\n对于用于来说是感受不到这种快速的切换的；\n\n你可以在Mac的活动监视器或者Windows的资源管理器中查看到很多进程：\n活动监视器\n1.2. 浏览器和JavaScript我们经常会说JavaScript是单线程的，但是JavaScript的线程应该有自己的容器进程：浏览器或者Node。\n浏览器是一个进程吗，它里面只有一个线程吗？\n\n目前多数的浏览器其实都是多进程的，当我们打开一个tab页面时就会开启一个新的进程，这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出；\n每个进程中又有很多的线程，其中包括执行JavaScript代码的线程；\n\n但是JavaScript的代码执行是在一个单独的线程中执行的：\n\n这就意味着JavaScript的代码，在同一个时刻只能做一件事；\n如果这件事是非常耗时的，就意味着当前的线程就会被阻塞；\n\n分析下面代码的执行过程：\n\n定义变量name；\n执行log函数，函数会被放入到调用栈中执行；\n调用bar()函数，被压入到调用栈中，但是执行未结束；\nbar因为调用了sum，sum函数被压入到调用栈中，获取到结果后出栈；\nbar获取到结果后出栈，获取到结果result；\n将log函数压入到调用栈，log被执行，并且出栈；\n\nconst name &#x3D; &quot;coderwhy&quot;;\n\n&#x2F;&#x2F; 1.将该函数放入到调用栈中被执行\nconsole.log(name);\n\n&#x2F;&#x2F; 2. 调用栈\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nfunction bar() &#123;\n  return sum(20, 30);\n&#125;\n\nconsole.log(bar());\n\n1.3. 浏览器的事件循环如果在执行JavaScript代码的过程中，有异步操作呢？\n\n中间我们插入了一个setTimeout的函数调用；\n这个函数被放到入调用栈中，执行会立即结束，并不会阻塞后续代码的执行；\n\nconst name &#x3D; &quot;coderwhy&quot;;\n\n&#x2F;&#x2F; 1.将该函数放入到调用栈中被执行\nconsole.log(name);\n\n&#x2F;&#x2F; 2.调用栈\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nfunction bar() &#123;\n  return sum(20, 30);\n&#125;\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;settimeout&quot;);\n&#125;, 1000);\n\nconst result &#x3D; bar();\n\nconsole.log(result);\n\n那么，传入的一个函数（比如我们称之为timer函数），会在什么时候被执行呢？\n\n事实上，setTimeout是调用了web api，在合适的时机，会将timer函数加入到一个事件队列中；\n事件队列中的函数，会被放入到调用栈中，在调用栈中被执行；\n\n浏览器的事件循环\n1.4. 宏任务和微任务但是事件循环中并非只维护着一个队列，事实上是有两个队列：\n\n宏任务队列（macrotask queue）：ajax、setTimeout、setInterval、DOM监听、UI Rendering等\n微任务队列（microtask queue）：Promise的then回调、 Mutation Observer API、queueMicrotask()等\n\n那么事件循环对于两个队列的优先级是怎么样的呢？\n\n1.main script中的代码优先执行（编写的顶层script代码）；\n\n2.在执行任何一个宏任务之前（不是队列，是一个宏任务），都会先查看微任务队列中是否有任务需要执行\n\n\n也就是宏任务执行之前，必须保证微任务队列是空的；\n\n\n如果不为空，那么就优先执行微任务队列中的任务（回调）；\n\n\n我们来看一个面试题：执行结果如何？\nsetTimeout(function () &#123;\n  console.log(&quot;set1&quot;);\n\n  new Promise(function (resolve) &#123;\n    resolve();\n  &#125;).then(function () &#123;\n    new Promise(function (resolve) &#123;\n      resolve();\n    &#125;).then(function () &#123;\n      console.log(&quot;then4&quot;);\n    &#125;);\n    console.log(&quot;then2&quot;);\n  &#125;);\n&#125;);\n\nnew Promise(function (resolve) &#123;\n  console.log(&quot;pr1&quot;);\n  resolve();\n&#125;).then(function () &#123;\n  console.log(&quot;then1&quot;);\n&#125;);\n\nsetTimeout(function () &#123;\n  console.log(&quot;set2&quot;);\n&#125;);\n\nconsole.log(2);\n\nqueueMicrotask(() &#x3D;&gt; &#123;\n  console.log(&quot;queueMicrotask1&quot;)\n&#125;);\n\nnew Promise(function (resolve) &#123;\n  resolve();\n&#125;).then(function () &#123;\n  console.log(&quot;then3&quot;);\n&#125;);\n\n执行结果：\npr1\n2\nthen1\nqueueMicrotask1\nthen3\nset1\nthen2\nthen4\nset2\n\nasync、await是Promise的一个语法糖：\n\n我们可以将await关键字后面执行的代码，看做是包裹在(resolve, reject) =&gt; &#123;函数执行&#125;中的代码；\nawait的下一条语句，可以看做是then(res =&gt; &#123;函数执行&#125;)中的代码；\n\n今日头条的面试题：\nasync function async1 () &#123;\n  console.log(&#39;async1 start&#39;)\n  await async2();\n  console.log(&#39;async1 end&#39;)\n&#125;\n \nasync function async2 () &#123;\n  console.log(&#39;async2&#39;)\n&#125;\n\nconsole.log(&#39;script start&#39;)\n \nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout&#39;)\n&#125;, 0)\n \nasync1();\n \nnew Promise (function (resolve) &#123;\n  console.log(&#39;promise1&#39;)\n  resolve();\n&#125;).then (function () &#123;\n  console.log(&#39;promise2&#39;)\n&#125;)\n\nconsole.log(&#39;script end&#39;)\n\n执行结果如下：\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n\nNode的事件循环2.1. Node的事件循环浏览器中的EventLoop是根据HTML5定义的规范来实现的，不同的浏览器可能会有不同的实现，而Node中是由libuv实现的。\n我们来看在很早就给大家展示的Node架构图：\n\n我们会发现libuv中主要维护了一个EventLoop和worker threads（线程池）；\nEventLoop负责调用系统的一些其他操作：文件的IO、Network、child-processes等\n\nNode的架构图\nlibuv到底是什么呢？\n\nlibuv is a multi-platform support library with a focus on asynchronous I&#x2F;O. It was primarily developed for use by Node.js, but it’s also used by Luvit, Julia, pyuv, and others.\nlibuv是一个多平台的专注于异步IO的库，它最初是为Node开发的，但是现在也被使用到Luvit、Julia、pyuv等其他地方；\n\nlibuv到底帮助我们做了什么事情呢？\n\n我们以文件操作为例，来讲解一下它内部的结构；\n\n2.2. 阻塞IO和非阻塞IO如果我们希望在程序中对一个文件进行操作，那么我们就需要打开这个文件：通过文件描述符。\n\n我们思考：JavaScript可以直接对一个文件进行操作吗？\n看起来是可以的，但是事实上我们任何程序中的文件操作都是需要进行系统调用（操作系统封装了文件系统）；\n事实上对文件的操作，是一个操作系统的IO操作（输入、输出）；\n\n操作系统为我们提供了阻塞式调用和非阻塞式调用：\n\n阻塞式调用： 调用结果返回之前，当前线程处于阻塞态（阻塞态CPU是不会分配时间片的），调用线程只有在得到调用结果之后才会继续执行。\n非阻塞式调用： 调用执行之后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。\n\n所以我们开发中的很多耗时操作，都可以基于这样的 非阻塞式调用：\n\n比如网络请求本身使用了Socket通信，而Socket本身提供了select模型，可以进行非阻塞方式的工作；\n比如文件读写的IO操作，我们可以使用操作系统提供的基于事件的回调机制；\n\n但是非阻塞IO也会存在一定的问题：我们并没有获取到需要读取（我们以读取为例）的结果\n\n那么就意味着为了可以知道是否读取到了完整的数据，我们需要频繁的去确定读取到的数据是否是完整的；\n这个过程我们称之为轮训操作；\n\n那么这个轮训的工作由谁来完成呢？\n\n如果我们的主线程频繁的去进行轮训的工作，那么必然会大大降低性能；\n并且开发中我们可能不只是一个文件的读写，可能是多个文件；\n而且可能是多个功能：网络的IO、数据库的IO、子进程调用；\n\nlibuv提供了一个线程池（Thread Pool）：\n\n线程池会负责所有相关的操作，并且会通过轮训等方式等待结果；\n当获取到结果时，就可以将对应的回调放到事件循环（某一个事件队列）中；\n事件循环就可以负责接管后续的回调工作，告知JavaScript应用程序执行对应的回调函数；\n\nEvent loop in node.js\n阻塞和非阻塞，同步和异步有什么区别？\n\n阻塞和非阻塞是对于被调用者来说的；\n\n\n在我们这里就是系统调用，操作系统为我们提供了阻塞调用和非阻塞调用；\n\n\n同步和异步是对于调用者来说的；\n\n\n在我们这里就是自己的程序；\n\n\n如果我们在发起调用之后，不会进行其他任何的操作，只是等待结果，这个过程就称之为同步调用；\n\n如果我们再发起调用之后，并不会等待结果，继续完成其他的工作，等到有回调时再去执行，这个过程就是异步调用；\n\n\n2.3. Node事件循环的阶段我们最前面就强调过，事件循环像是一个桥梁，是连接着应用程序的JavaScript和系统调用之间的通道：\n\n无论是我们的文件IO、数据库、网络IO、定时器、子进程，在完成对应的操作后，都会将对应的结果和回调函数放到事件循环（任务队列）中；\n事件循环会不断的从任务队列中取出对应的事件（回调函数）来执行；\n\n但是一次完整的事件循环Tick分成很多个阶段：\n\n定时器（Timers）：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。\n待定回调（Pending Callback）：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到ECONNREFUSED。\nidle, prepare：仅系统内部使用。\n轮询（Poll）：检索新的 I&#x2F;O 事件；执行与 I&#x2F;O 相关的回调；\n检测：setImmediate() 回调函数在这里执行。\n关闭的回调函数：一些关闭的回调函数，如：socket.on(&#39;close&#39;, ...)。\n\n一次tick的事件循环阶段\n我们会发现从一次事件循环的Tick来说，Node的事件循环更复杂，它也分为微任务和宏任务：\n\n宏任务（macrotask）：setTimeout、setInterval、IO事件、setImmediate、close事件；\n微任务（microtask）：Promise的then回调、process.nextTick、queueMicrotask；\n\n但是，Node中的事件循环不只是 微任务队列和 宏任务队列：\n\n微任务队列：\n\n\nnext tick queue：process.nextTick；\n\n\nother queue：Promise的then回调、queueMicrotask；\n\n宏任务队列：\n\n\ntimer queue：setTimeout、setInterval；\n\n\npoll queue：IO事件；\n\ncheck queue：setImmediate；\n\nclose queue：close事件；\n\n\n所以，在每一次事件循环的tick中，会按照如下顺序来执行代码：\n\nnext tick microtask queue；\nother microtask queue；\ntimer queue；\npoll queue；\ncheck queue；\nclose queue；\n\n2.4. Node代码执行面试面试题一：\nasync function async1() &#123;\n  console.log(&#39;async1 start&#39;)\n  await async2()\n  console.log(&#39;async1 end&#39;)\n&#125;\n\nasync function async2() &#123;\n  console.log(&#39;async2&#39;)\n&#125;\n\nconsole.log(&#39;script start&#39;)\n\nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout0&#39;)\n&#125;, 0)\n\nsetTimeout(function () &#123;\n  console.log(&#39;setTimeout2&#39;)\n&#125;, 300)\n\nsetImmediate(() &#x3D;&gt; console.log(&#39;setImmediate&#39;));\n\nprocess.nextTick(() &#x3D;&gt; console.log(&#39;nextTick1&#39;));\n\nasync1();\n\nprocess.nextTick(() &#x3D;&gt; console.log(&#39;nextTick2&#39;));\n\nnew Promise(function (resolve) &#123;\n  console.log(&#39;promise1&#39;)\n  resolve();\n  console.log(&#39;promise2&#39;)\n&#125;).then(function () &#123;\n  console.log(&#39;promise3&#39;)\n&#125;)\n\nconsole.log(&#39;script end&#39;)\n\n执行结果如下：\nscript start\nasync1 start\nasync2\npromise1\npromise2\nscript end\nnextTick\nasync1 end\npromise3\n\nsetTimeout0\nsetImmediate\nsetTimeout2\n\n面试题二：\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimeout&quot;);\n&#125;, 0);\n\nsetImmediate(() &#x3D;&gt; &#123;\n  console.log(&quot;setImmediate&quot;);\n&#125;);\n\n执行结果：\n情况一：\nsetTimeout\nsetImmediate\n\n情况二：\nsetImmediate\nsetTimeout\n\n为什么会出现不同的情况呢？\n\n在Node源码的deps&#x2F;uv&#x2F;src&#x2F;timer.c中141行，有一个 uv__next_timeout的函数；\n这个函数决定了，poll阶段要不要阻塞在这里；\n阻塞在这里的目的是当有异步IO被处理时，尽可能快的让代码被执行；\n\nint uv__next_timeout(const uv_loop_t* loop) &#123;\n  const struct heap_node* heap_node;\n  const uv_timer_t* handle;\n  uint64_t diff;\n\n  &#x2F;&#x2F; 计算距离当前时间节点最小的计时器\n  heap_node &#x3D; heap_min(timer_heap(loop));\n  &#x2F;&#x2F; 如果为空, 那么返回-1,表示为阻塞状态\n  if (heap_node &#x3D;&#x3D; NULL)\n    return -1; &#x2F;* block indefinitely *&#x2F;\n\n  &#x2F;&#x2F; 如果计时器的时间小于当前loop的开始时间, 那么返回0\n  &#x2F;&#x2F; 继续执行后续阶段, 并且开启下一次tick\n  handle &#x3D; container_of(heap_node, uv_timer_t, heap_node);\n  if (handle-&gt;timeout &lt;&#x3D; loop-&gt;time)\n    return 0;\n\n  &#x2F;&#x2F; 如果不大于loop的开始时间, 那么会返回时间差\n  diff &#x3D; handle-&gt;timeout - loop-&gt;time;\n  if (diff &gt; INT_MAX)\n    diff &#x3D; INT_MAX;\n\n  return (int) diff;\n&#125;\n\n和上面有什么关系呢？\n\n情况一：如果事件循环开启的时间(ms)是小于 setTimeout函数的执行时间的；\n\n\n也就意味着先开启了event-loop，但是这个时候执行到timer阶段，并没有定时器的回调被放到入 timer queue中；\n\n\n所以没有被执行，后续开启定时器和检测到有setImmediate时，就会跳过poll阶段，向后继续执行；\n\n这个时候是先检测 setImmediate，第二次的tick中执行了timer中的 setTimeout；\n\n情况二：如果事件循环开启的时间(ms)是大于 setTimeout函数的执行时间的；\n\n\n这就意味着在第一次 tick中，已经准备好了timer queue；\n\n\n所以会直接按照顺序执行即可；\n\n\n","slug":"node/base/Node基础八","date":"2022-10-01T04:28:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"9cc987ed6425e4445f09c1cfe9b13abf","title":"Node基础七","content":"七.脚手架开发目前前端工程化开发过程中，我们会使用各种各样的脚手架，vue-cli、create-react-app，当然也包括webpack、gulp、rollup、vite等工具。\n这些工具是怎么开发出来的呢？当我们执行一个命令时，它们做了什么事情？是怎么样完成的一系列操作？\n这里我开发了一个coderwhy的脚手架：一个帮助你快速搭建和开发前端项目的CLI。\n文档内容分成两部分：\n第一部分：coderwhy使用说明；\n第二部分：coderwhy脚手架开发过程；\n如何安装？\nnpm install coderwhy -g\n\n使用说明一. 创建项目目前支持Vue，后期会支持React，Angular考虑中~\nvue项目模块已经帮你配置：\n\n常用的目录结构（你可以在此基础上修改）\nvue.config.js（其中配置了别名，你可以自行修改和配置更多）\naxios（网络请求axios的安装以及二次封装）\nvue-router（router的安装和配置，另外有路由的动态加载，后面详细说明）\nvuex（vuex的安装和配置，另外有动态加载子模块，后面详细说明）\n\n创建项目\ncoderwhy create your_project_name\n\n自动拉取项目模板、安装项目依赖、打开浏览器 http://localhost:8080/、自动启动项目\n二. 项目开发项目开发目前提供三个功能：\n\n创建Vue组件\n创建Vue页面，并配置路由\n创建Vuex子模块\n\n2.1. 创建Vue组件：coderwhy addcpn YourComponentName # 例如coderwhy add NavBar，默认会存放到src&#x2F;components文件夹中\ncoderwhy addcpn YourComponentName -d src&#x2F;pages&#x2F;home # 也可以指定存放的具体文件夹\n\n2.2. 创建Vue页面，并配置路由coderwhy addpage YourPageName # 例如coderwhy addpage Home，默认会放到src&#x2F;pages&#x2F;home&#x2F;Home.vue中，并且会创建src&#x2F;page&#x2F;home&#x2F;router.js\ncoderwhy addpage YourPageName -d src&#x2F;views # 也可以指定文件夹，但需要手动集成路由\n\n为什么会创建router.js文件：\n\nrouter.js文件是路由的其中一个配置；\n创建该文件中 src/router/index.js中会自动加载到路由的 routes配置中，不需要手动配置了（如果是自己配置的文件夹需要手动配置）\n\nsrc/router/index.js中已经完成如下操作：\n&#x2F;&#x2F; 动态加载pages中所有的路由文件\nconst files &#x3D; require.context(&#39;@&#x2F;pages&#39;, true, &#x2F;router\\.js$&#x2F;);\nconst routes &#x3D; files.keys().map(key &#x3D;&gt; &#123;\n  const page &#x3D; require(&#39;@&#x2F;pages&#39; + key.replace(&#39;.&#39;, &#39;&#39;));\n  return page.default;\n&#125;)\n\n2.3. 创建Vuex子模块coderwhy addstore YourVuexChildModuleName # 例如coderwhy addstore home，默认会放到src&#x2F;store&#x2F;modules&#x2F;home&#x2F;index.js和types.js\ncoderwhy addstore YourVuexChildModuleName -d src&#x2F;vuex&#x2F;modules # 也可以指定文件夹\n\n创建完成后，不需要手动配置，已经动态将所有子模块集成进去：\n&#x2F;&#x2F; 动态加载modules\nconst modules &#x3D; &#123;&#125;\nconst files &#x3D; require.context(&#39;.&#x2F;&#39;, true, &#x2F;index\\.js$&#x2F;);\nfiles.keys().filter(key &#x3D;&gt; &#123;\n  if (key &#x3D;&#x3D;&#x3D; &#39;.&#x2F;index.js&#39;) return false;\n  return true\n&#125;).map(key &#x3D;&gt; &#123;  \n  &#x2F;&#x2F; 获取名字\n  const modulePath &#x3D; key.replace(&#39;.&#x2F;modules&#x2F;&#39;, &#39;&#39;);\n  const moduleName &#x3D; modulePath.replace(&#39;&#x2F;index.js&#39;, &#39;&#39;);\n  const module &#x3D; require(&#96;$&#123;key&#125;&#96;);\n\n  modules[&#96;$&#123;moduleName&#125;&#96;] &#x3D; module.default;\n&#125;)\n\n脚手架开发过程一. 创建文件创建index.js\nconsole.log(&quot;Hello Coderwhy&quot;)\n\n创建package.json\n&#123;\n  &quot;name&quot;: &quot;coderwhy&quot;,\n  &quot;version&quot;: &quot;1.1.0&quot;,\n  &quot;description&quot;: &quot;CLI front-end development tools&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;bin&quot;: &#123;\n    &quot;coderwhy&quot;: &quot;index.js&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [\n    &quot;vue&quot;,\n    &quot;react&quot;,\n    &quot;CLI&quot;,\n    &quot;component&quot;\n  ],\n  &quot;author&quot;: &quot;coderwhy&quot;,\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;,\n  &quot;repository&quot;: &#123;\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;chalk&quot;: &quot;^4.1.0&quot;,\n    &quot;commander&quot;: &quot;^6.1.0&quot;,\n    &quot;download-git-repo&quot;: &quot;^3.0.2&quot;,\n    &quot;ejs&quot;: &quot;^3.1.5&quot;,\n    &quot;open&quot;: &quot;^7.3.0&quot;\n  &#125;\n&#125;\n\n最终的目录结构：\n├── LICENSE\n├── index.js\n├── lib\n│   ├── config\n│   │   └── repo_config.js\n│   ├── core\n│   │   ├── actions.js\n│   │   ├── create.js\n│   │   └── help.js\n│   ├── template\n│   │   ├── component.vue.ejs\n│   │   ├── vue-router.js.ejs\n│   │   ├── vue-store.js.ejs\n│   │   └── vue-types.js.ejs\n│   └── utils\n│       ├── file.js\n│       ├── log.js\n│       └── terminal.js\n├── package-lock.json\n├── package.json\n└── readme.md\n\n二. 创建coderwhy的命令自动在你的环境变量中查找node\n注意：必须放在第一行\n#!&#x2F;usr&#x2F;bin&#x2F;env node\n\n修改package.json\n&quot;bin&quot;: &#123;\n  &quot;coderwhy&quot;: &quot;index.js&quot;\n&#125;\n\n执行npm link\n三. commander用法3.1. 定义版本号#!&#x2F;usr&#x2F;bin&#x2F;env node\nconst cmd &#x3D; require(&#39;commander&#39;);\n&#x2F;&#x2F; 定义显示模块的版本号\ncmd.version(require(&#39;.&#x2F;package.json&#39;).version);\n&#x2F;&#x2F; 解析终端指令\ncmd.parse(process.argv);\n\n3.2. 给help增加其他选项添加单个选项\nprogram.option(&#39;-s --src &lt;src&gt;&#39;, &#39;a source folder&#39;);\nprogram.option(&#39;-d --dest &lt;dest&gt;&#39;, &#39;a destination folder&#39;);\nprogram.option(&#39;-f --framework &lt;framework&gt;&#39;, &#39;your framework name&#39;);\n\n监听help指令\nprogram.on(&#39;--help&#39;, function() &#123;\n  console.log(&quot;&quot;);\n  console.log(&quot;usage&quot;);\n  console.log(&quot;   coderwhy -v&quot;);\n  console.log(&quot;   coderwhy -version&quot;);\n&#125;)\n\n四. 创建项目指令&#x2F;&#x2F; 创建命令\nprogram\n  .command(&#39;create &lt;project&gt; [otherArgs...]&#39;)\n  .description(&#39;clone a repository into a newly created directory&#39;)\n  .action((project, otherArgs) &#x3D;&gt; &#123;\n    console.log(project);\n    console.log(otherArgs);\n   &#x2F;&#x2F; 调用封装的函数\n   createProject(project, otherArgs)\n  &#125;)\n\n在actions中封装创建过程：\nconst downloadRepo &#x3D; promisify(require(&#39;download-git-repo&#39;));\n\nconst createProject &#x3D; async (project, otherArg) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 1.提示信息\n  console.log(&#39;coderwhy helps you create your project, please wait a moment~&#39;);\n\n  &#x2F;&#x2F; 2.clone项目从仓库\n  await downloadRepo(repoConfig.vueGitRepo, project, &#123; clone: true &#125;);\n\n  &#x2F;&#x2F; 3.执行终端命令npm install\n  &#x2F;&#x2F; terminal.exec(&#39;npm install&#39;, &#123;cwd: &#96;.&#x2F;$&#123;project&#125;&#96;&#125;);\n  const npm &#x3D; process.platform &#x3D;&#x3D;&#x3D; &#39;win32&#39; ? &#39;npm.cmd&#39; : &#39;npm&#39;;\n  await terminal.spawn(npm, [&#39;install&#39;], &#123; cwd: &#96;.&#x2F;$&#123;project&#125;&#96; &#125;);\n\n  &#x2F;&#x2F; 4.打开浏览器\n  open(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;&#39;);\n\n  &#x2F;&#x2F; 5.运行项目\n  await terminal.spawn(npm, [&#39;run&#39;, &#39;serve&#39;], &#123; cwd: &#96;.&#x2F;$&#123;project&#125;&#96; &#125;);\n&#125;\n\n配置的Git地址如下：\n\n后续会开发一个设置自己地址的指令\n\nconst vueGitRepo &#x3D; &quot;direct:https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;hy-vue-temp.git&quot;;\n\nmodule.exports &#x3D; &#123;\n  vueGitRepo\n&#125;\n\n封装执行终端命令的过程：\nconst &#123; spawn, exec &#125; &#x3D; require(&#39;child_process&#39;);\n\nconst spawnCommand &#x3D; (...args) &#x3D;&gt; &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    const childProcess &#x3D; spawn(...args);\n    childProcess.stdout.pipe(process.stdout);\n    childProcess.stderr.pipe(process.stderr);\n    childProcess.on(&#39;close&#39;, () &#x3D;&gt; &#123;\n      resolve();\n    &#125;);\n  &#125;)\n&#125;\n\nprocess和child_process使用process在Node.js中每个应用程序都是一个进程类的实例对象。使用process对象代表应用程序,这是一个全局对象，可以通过它来获取Node.jsy应用程序以及运行该程序的用户、环境等各种信息的属性、方法和事件\n进程中几个重要的属性\nstdin 标准输入可读流\nstdout 标准输入可写流\nstderr 标准错误输出流\nargv 终端输入参数数组\nenv 操作系统环境信息\npid 应用程序进程id\n\n进程方法\nprocess.memoryUsage() 查看内存使用信息\nprocess.nextTick() 当前eventloop执行完毕执行回调函数\nprocess.chdir() chdir方法用于修改Node.js应用程序中使用的当前工作目录\nprocess.cwd() 进程当前工作目录\nprocess.kill() 杀死进程\nprocess.uncaughtException() 当应用程序抛出一个未被捕获的异常时触发进程对象的uncaughtException事件\n\nchild_process在Node.js中，提供了一个child_process模块,通过它可以开启多个子进程，在多个子进程之间可以共享内存空间，可以通过子进程的互相通信来实现信息的交换,child_process模块给予node任意创建子进程的能力，node官方文档对于child_proces模块给出了四种方法，映射到操作系统其实都是创建子进程。但对于开发者而已，这几种方法的api有点不同\nchild_process.exec(command[, options][, callback]) 启动子进程来执行shell命令,可以通过回调参数来获取脚本shell执行结果\nchild_process.execfile(file[, args][, options][, callback]) 与exec类型不同的是，它执行的不是shell命令而是一个可执行文件\nchild_process.spawn(command[, args][, options])仅仅执行一个shell命令，不需要获取执行结果\\\nchild_process.fork(modulePath[, args][, options]) 可以用node执行的.js文件，也不需要获取执行结果。fork出来的子进程一定是node进程\n\n&#x2F;&#x2F;exec用法:\n&#x2F;&#x2F;执行shell脚本, 使用管道符也是可以的\n&#x2F;&#x2F;exec也是可以执行文件的，只不过不能传参数\n&#x2F;&#x2F;适合开销比较小的任务\nconst cp &#x3D; require(&#39;child_process&#39;)\ncp.exec(&#39;ls -al|grep node_modules&#39;, &#123; \n  timeout: 0, &#x2F;&#x2F; 超时时间\n  cwd: process.cwd(), &#x2F;&#x2F; 可以改变当前的执行路径\n  &#125;, function (err, stdout, stderr) &#123;\n  &#x2F;&#x2F; 执行结果\n&#125;)\n\n&#x2F;&#x2F;execFile用法:\n&#x2F;&#x2F;可以执行文件，也可以执行语句，可传参\n&#x2F;&#x2F;适合开销比较小的任务\n&#x2F;&#x2F; 执行文件,参数\ncp.execFile(&#39;ls&#39;, [&#39;-al&#39;], function (err, stdout, std,err) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 执行结果\n&#125;)\n&#x2F;&#x2F; 让execFile执行ls -al|grep node_modules这种语句\n&#x2F;&#x2F;test.shell:\n  ls -al|grep node_modules\n  echo $1 &#x2F;&#x2F; 打印参数\n  echo $2\n&#x2F;&#x2F;index.js:\ncp.execFile(path.resolve(__dirname, &#39;test.shell&#39;), [&#39;-al&#39;, &#39;bl&#39;], \nfunction(err,   stdout, stderr) &#123;\n&#125;)\n\n&#x2F;&#x2F;fork用法\n&#x2F;&#x2F;用node执行, 耗时操作且用node实现，如下载文件\n\n&#x2F;&#x2F; cp.fork(模块路径)\n&#x2F;&#x2F; 和require一样把文件执行起来\nconst child &#x3D; cp.fork(path.resolve(__dirname, &#39;child_process_demo&#39;))\nconsole.log(process.pid)\n&#x2F;&#x2F; 主进程向子进程通信\nchild.send(&#39;hello child_process&#39;, () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; child.disconnent() &#x2F;&#x2F; 如果不断开，两边会出现等待的情况\n&#125;)\n&#x2F;&#x2F; 子进程向主进程通信\nchild.on(&#39;message&#39;, msg &#x3D;&gt; &#123;\n  \n&#125;)\n\n&#x2F;&#x2F; child_process_demo.js:\nconsole.log(&#39;aaa&#39;, process.pid)\nprocess.on(&#39;message&#39;, msg &#x3D;&gt; &#123;\n  console.log(msg)\n  &#x2F;&#x2F; 很容易出现死循环\n&#125;)\nprocess.send(&#39;send msg to parent&#39;)\n&#x2F;&#x2F; 进程不一样,完全独立，本质也是调用spawn\n\n\n&#x2F;&#x2F;spawn 用法\n&#x2F;&#x2F;spawn: 流式的，没有回调，适合耗时任务(比如：npm install), 需要不断打印日志(不断给用户输出日志\ncp.spawn(file, args, options) &#x2F;&#x2F; 不支持回调, exec,execFile底层都是spwan\nconst childProcess &#x3D; cp.spawn(path.resolve(__dirname, &#39;test.shell&#39;), [&#39;-al&#39;, &#39;-bl&#39;], &#123;\n  cwd: path.resolve(&#39;..&#39;),\n&#125;) &#x2F;&#x2F; 返回的是子进程\nconsole.log(childProcess.pid, childProcess.pid)\n&#x2F;&#x2F; 监听成功\nchildProcess.stdout.on(&#39;data&#39;, function(chunk) &#123;\n  console.log(chunk.toString())\n&#125;)\n&#x2F;&#x2F; 监听失败\nchildProcess.stderr.on(&#39;data&#39;, function(chunk) &#123;\n  console.log(chunk.toString())\n&#125;)\n\nconst code &#x3D; &#96;require(&#39;$&#123;rootFile&#125;&#39;).call(null, $&#123;JSON.stringify(args)&#125;)&#96;\n &#x2F;&#x2F; cp.spawn(&#39;cmd&#39;, [&#39;&#x2F;c&#39;, &#39;node&#39;, &#39;-e&#39;, code]) &#x2F;&#x2F; win下是这种结构\n const childProcess &#x3D; spawn(&#39;node&#39;, [&#39;-e&#39;, code], &#123;\n   cwd: process.cwd(), &#x2F;&#x2F; 当前执行未知的cwd\n   stdio: &#39;inherit&#39;, &#x2F;&#x2F; 默认是pipe,pipe必须通过on来接收信息，inherit不需要，实时反馈\n &#125;)\n childProcess.on(&#39;error&#39;, e &#x3D;&gt; &#123;\n   log.error(e.message)\n   process.exit(1)\n &#125;)\nchildProcess.on(&#39;exit&#39;, e &#x3D;&gt; &#123;\n  log.verbose(&#39;命令执行成功&#39;, e)\n  process.exit(e)\n&#125;)\n\n\n\n五. 添加组件指令5.1. 封装ejs模板组件模块如下：\n&lt;%_ if(data) &#123; _%&gt;\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;&lt;%&#x3D; data.lowerName %&gt;&quot;&gt;\n    &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n  export default &#123;\n    name: &quot;&lt;%&#x3D; data.name %&gt;&quot;,\n    components: &#123;\n\n    &#125;,\n    mixins: [],\n    props: &#123;\n\n    &#125;,\n    data: function() &#123;\n      return &#123;\n        message: &quot;Hello &lt;%&#x3D; data.name %&gt;&quot;\n      &#125;\n    &#125;,\n    created: function() &#123;\n\n    &#125;,\n    mounted: function() &#123;\n\n    &#125;,\n    computed: &#123;\n\n    &#125;,\n    methods: &#123;\n\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n  .&lt;%&#x3D; data.lowerName %&gt; &#123;\n    \n  &#125;\n&lt;&#x2F;style&gt;\n\n&lt;%_ &#125; _%&gt;\n\n路由模板：\n\n组件模板，直接使用上面的即可\nrouter.js模板\n\n&lt;%_ if (data) &#123; _%&gt;\n&#x2F;&#x2F; 普通加载路由\n&#x2F;&#x2F; import &lt;%&#x3D; data.name %&gt; from &#39;.&#x2F;&lt;%&#x3D; data.name %&gt;.vue&#39;\n&#x2F;&#x2F; 懒加载路由\nconst &lt;%&#x3D; data.name %&gt; &#x3D; () &#x3D;&gt; import(&#39;.&#x2F;&lt;%&#x3D; data.name %&gt;.vue&#39;)\nexport default &#123;\n  path: &#39;&#x2F;&lt;%&#x3D; data.lowerName %&gt;&#39;,\n  name: &#39;&lt;%&#x3D; data.name %&gt;&#39;,\n  component: &lt;%&#x3D; data.name %&gt;,\n  children: [\n  ]\n&#125;\n&lt;%_ &#125; _%&gt;\n\nvuex模块的模板\n\nindex.js模板\ntypes.js模板\n\nindex.js模块\nimport * as types from &#39;.&#x2F;types.js&#39;\nexport default &#123;\n  namespaced: true,\n  state: &#123;\n  &#125;,\n  mutations: &#123;\n  &#125;,\n  actions: &#123;\n  &#125;,\n  getters: &#123;\n  &#125;\n&#125;\n\ntypes.js模块\nexport &#123;\n  \n&#125;\n\n5.2. 封装ejs解析封装ejs的编译过程：\nconst ejsCompile &#x3D; (templatePath, data&#x3D;&#123;&#125;, options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    ejs.renderFile(templatePath, &#123;data&#125;, options, (err, str) &#x3D;&gt; &#123;\n      if (err) &#123;\n        reject(err);\n        return;\n      &#125;\n      resolve(str);\n    &#125;)\n  &#125;)\n&#125;\n\n封装创建文件夹的过程：\nconst mkdirSync &#x3D; (dirname) &#x3D;&gt; &#123;\n  if (fs.existsSync(dirname)) &#123;\n    return true\n  &#125; else &#123;\n    &#x2F;&#x2F; 不存在,判断父亲文件夹是否存在？\n    if (mkdirSync(path.dirname(dirname))) &#123;\n      &#x2F;&#x2F; 存在父亲文件，就直接新建该文件\n      fs.mkdirSync(dirname)\n      return true\n    &#125;\n  &#125;\n&#125;\n\n封装写入文件的过程：\nconst writeFile &#x3D; (path, content) &#x3D;&gt; &#123;\n  if (fs.existsSync(path)) &#123;\n    log.error(&quot;the file already exists~&quot;)\n    return;\n  &#125;\n  return fs.promises.writeFile(path, content);\n&#125;\n\n封装ejs到文件的转化过程：\nconst handleEjsToFile &#x3D; async (name, dest, template, filename) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 1.获取模块引擎的路径\n  const templatePath &#x3D; path.resolve(__dirname, template);\n  const result &#x3D; await ejsCompile(templatePath, &#123;name, lowerName: name.toLowerCase()&#125;);\n\n  &#x2F;&#x2F; 2.写入文件中\n  &#x2F;&#x2F; 判断文件不存在,那么就创建文件\n  mkdirSync(dest);\n  const targetPath &#x3D; path.resolve(dest, filename);\n  writeFile(targetPath, result);\n&#125;\n\n5.3. 创建添加指令添加指令\nprogram\n  .command(&#39;addcpn &lt;name&gt;&#39;)\n  .description(&#39;add vue component, 例如: coderwhy addcpn NavBar [-d src&#x2F;components]&#39;)\n  .action(name &#x3D;&gt; addComponent(name, program.dest || &#39;src&#x2F;components&#39;))\n\nprogram\n  .command(&#39;addpage &lt;name&gt;&#39;)\n  .description(&#39;add vue page, 例如: coderwhy addpage Home [-d dest]&#39;)\n  .action(name &#x3D;&gt; &#123;\n  addPage(name, program.dest || &#96;src&#x2F;pages&#x2F;$&#123;name.toLowerCase()&#125;&#96;)\n&#125;)\n\nprogram\n  .command(&#39;addstore &lt;name&gt;&#39;)\n  .description(&#39;add vue store, 例如: coderwhy addstore favor [-d dest]&#39;)\n  .action(name &#x3D;&gt; &#123;\n  addStore(name, program.dest || &#96;src&#x2F;store&#x2F;modules&#x2F;$&#123;name.toLowerCase()&#125;&#96;)\n&#125;)\n\n封装对应的action\nconst addComponent &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;component.vue.ejs&#39;, &#96;$&#123;name&#125;.vue&#96;);\n&#125;\n\nconst addPage &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  addComponent(name, dest);\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-router.js.ejs&#39;, &#39;router.js&#39;)\n&#125;\n\nconst addStore &#x3D; async (name, dest) &#x3D;&gt; &#123;\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-store.js.ejs&#39;, &#39;index.js&#39;)\n  handleEjsToFile(name, dest, &#39;..&#x2F;template&#x2F;vue-types.js.ejs&#39;, &#39;types.js&#39;)\n&#125;\n\n六. 发布工具注册npm账号：\n\nhttps://www.npmjs.com/\n选择sign up\n\nsign up注册\n在命令行登录：\nnpm login\n# 输入账号、密码、邮箱\n\n修改好package.json文件：\n&quot;keywords&quot;: [\n  &quot;vue&quot;,\n  &quot;react&quot;,\n  &quot;CLI&quot;,\n  &quot;component&quot;\n],\n&quot;author&quot;: &quot;coderwhy&quot;,\n&quot;license&quot;: &quot;MIT&quot;,\n&quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;,\n&quot;repository&quot;: &#123;\n  &quot;type&quot;: &quot;git&quot;,\n  &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;coderwhy&#x2F;coderwhy&quot;\n&#125;,\n\n发布到npm registry中\nnpm publish\n\n更新registry\n# 1.修改版本号(最好符合semver规范)\n# 2.重新发布\n\n删除发布的包：\nnpm unpublish\n\n过期发布的包：\nnpm deprecate\n","slug":"node/base/Node基础七","date":"2022-10-01T04:27:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"2625758c12baaaa025e1a25440bca02f","title":"Node基础六","content":"六.Buffer的使用1.1. 数据的二进制计算机中所有的内容：文字、数字、图片、音频、视频最终都会使用二进制来表示。\nJavaScript可以直接去处理非常直观的数据：比如字符串，我们通常展示给用户的也是这些内容。\n不对啊，JavaScript不是也可以处理图片吗？\n\n事实上在网页端，图片我们一直是交给浏览器来处理的；\nJavaScript或者HTML，只是负责告诉浏览器一个图片的地址；\n浏览器负责获取这个图片，并且最终将这个图片渲染出来；\n\n但是对于服务器来说是不一样的：\n\n服务器要处理的本地文件类型相对较多;\n比如某一个保存文本的文件并不是使用 utf-8进行编码的，而是用 GBK，那么我们必须读取到他们的二进制数据，再通过GKB转换成对应的文字；\n比如我们需要读取的是一张图片数据（二进制），再通过某些手段对图片数据进行二次的处理（裁剪、格式转换、旋转、添加滤镜），Node中有一个Sharp的库，就是读取图片或者传入图片的Buffer对其再进行处理；\n比如在Node中通过TCP建立长连接，TCP传输的是字节流，我们需要将数据转成字节再进行传入，并且需要知道传输字节的大小（客服端需要根据大小来判断读取多少内容）；\n\n我们会发现，对于前端开发来说，通常很少会和二进制打交道，但是对于服务器端为了做很多的功能，我们必须直接去操作其二进制的数据；\n所以Node为了可以方便开发者完成更多功能，提供给了我们一个类Buffer，并且它是全局的。\n1.2. Buffer和二进制我们前面说过，Buffer中存储的是二进制数据，那么到底是如何存储呢？\n\n我们可以将Buffer看成是一个存储二进制的数组；\n这个数组中的每一项，可以保存8位二进制：00000000\n\n为什么是8位呢？\n\n在计算机中，很少的情况我们会直接操作一位二进制，因为一位二进制存储的数据是非常有限的；\n所以通常会将8位合在一起作为一个单元，这个单元称之为一个字节（byte）；\n也就是说 1byte = 8bit，1kb=1024byte，1M=1024kb;\n比如很多编程语言中的int类型是4个字节，long类型是8个字节；\n比如TCP传输的是字节流，在写入和读取时都需要说明字节的个数；\n比如RGB的值分别都是255，所以本质上在计算机中都是用一个字节存储的；\n\n也就是说，Buffer相当于是一个字节的数组，数组中的每一项对于一个字节的大小：\n如果我们希望将一个字符串放入到Buffer中，是怎么样的过程呢？\nconst buffer01 &#x3D; new Buffer(&quot;why&quot;);\n\nconsole.log(buffer01);\n\n字符串存储buffer的过程\n当然目前已经不希望我们这样来做了：\nVSCode的警告\n那么我们可以通过另外一个创建方法：\nconst buffer2 &#x3D; Buffer.from(&quot;why&quot;);\nconsole.log(buffer2);\n\n如果是中文呢？\nconst buffer3 &#x3D; Buffer.from(&quot;王红元&quot;);\nconsole.log(buffer3);\n&#x2F;&#x2F; &lt;Buffer e7 8e 8b e7 ba a2 e5 85 83&gt;\nconst str &#x3D; buffer3.toString();\nconsole.log(str);\n&#x2F;&#x2F; 王红元\n\n如果编码和解码不同：\nconst buffer3 &#x3D; Buffer.from(&quot;王红元&quot;, &#39;utf16le&#39;);\nconsole.log(buffer3);\n\nconst str &#x3D; buffer3.toString(&#39;utf8&#39;);\nconsole.log(str); &#x2F;&#x2F; �s�~CQ\n\nBuffer其他用法2.1. Buffer的其他创建Buffer的创建方式有很多：\nbuffer的创建\n来看一下Buffer.alloc:\n\n我们会发现创建了一个8位长度的Buffer，里面所有的数据默认为00；\n\nconst buffer01 &#x3D; Buffer.alloc(8);\n\nconsole.log(buffer01); &#x2F;&#x2F; &lt;Buffer 00 00 00 00 00 00 00 00&gt;\n\n我们也可以对其进行操作：\nbuffer01[0] &#x3D; &#39;w&#39;.charCodeAt();\nbuffer01[1] &#x3D; 100;\nbuffer01[2] &#x3D; 0x66;\nconsole.log(buffer01);\n\n也可以使用相同的方式来获取：\nconsole.log(buffer01[0]);\nconsole.log(buffer01[0].toString(16));\n\n2.2. Buffer和文件读取文本文件的读取：\nconst fs &#x3D; require(&#39;fs&#39;);\n\nfs.readFile(&#39;.&#x2F;test.txt&#39;, (err, data) &#x3D;&gt; &#123;\n  console.log(data); &#x2F;&#x2F; &lt;Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64&gt;\n  console.log(data.toString()); &#x2F;&#x2F; Hello World\n&#125;)\n\n图片文件的读取：\nfs.readFile(&#39;.&#x2F;zznh.jpg&#39;, (err, data) &#x3D;&gt; &#123;\n  console.log(data); &#x2F;&#x2F; &lt;Buffer ff d8 ff e0 ... 40418 more bytes&gt;\n&#125;);\n\n图片文件的读取和转换：\n\n将读取的某一张图片，转换成一张200x200的图片；\n这里我们可以借助于 sharp 库来完成；\n\nconst sharp &#x3D; require(&#39;sharp&#39;);\nconst fs &#x3D; require(&#39;fs&#39;);\n\nsharp(&#39;.&#x2F;test.png&#39;)\n  .resize(1000, 1000)\n  .toBuffer()\n  .then(data &#x3D;&gt; &#123;\n    fs.writeFileSync(&#39;.&#x2F;test_copy.png&#39;, data);\n  &#125;)\n\n2.3. buffer使用&#x2F;&#x2F;buffer与字符串转换\nBuffer.from(string[, encoding])\nbuf.toString([encoding[, start[, end]]])\n\n&#x2F;&#x2F;复制buffer\nBuffer.from(buf)\n\n&#x2F;&#x2F;ArrayBuffer转换到buffer arrayBuffer类型为TypedArray.buffer属性\nBuffer.from(arrayBuffer[, byteOffset[, length]])\n\n&#x2F;&#x2F;buffer 转 Uint8Array\nvar array &#x3D; new Uint8Array(buffer);\n&#x2F;&#x2F;Uint8Array 转 ArrayBuffer\nvar arraybuffer &#x3D; array.buffer;\n&#x2F;&#x2F;ArrayBuffer 转 Buffer\nvar bufferCopy &#x3D; Buffer.from(arraybuffer);\n&#x2F;&#x2F;ArrayBuffer 转 DataView \nvar view &#x3D; new DataView(arraybuffer)\n&#x2F;&#x2F;DataView 转 ArrrayBuffer\nvar arraybuffer2 &#x3D; view.buffer;\n\n2.4. Buffer 和 TypeArray，ArrayBuffer, Unit8ArrayTypedArray\n概念: TypedArray ES6中新出的一个接口, 不能直接被实例化, Uint8Array 就是实现 TypedArray 接口的一个子类\n子类有:\nInt8Array: 每个元素是8个二进制位(1个字节)的有符号整数\nUint8Array： 每个元素是8个二进制位(1个字节)的无符号整数\nInt16Array： 每个元素是16个二进制位(2个字节)的有符号整数\nUint16Array：每个元素是16个二进制位(2个字节)的无符号整数\nInt32Array： 每个元素是32个二进制位(4个字节)的有符号整数\nUint32Array： 每个元素是32个二进制位(4个字节)的无符号整数\n\n\nArrayBuffer\n概念: TypedArray 的作用是操作二进制数据, 其内部还有一个buffer属性, 这个buffer就是 ArrayBuffer 实例. ArrayBuffer 就存储了要操作的二进制数据,TypedArray 是一个操作二进制数据的接口, 内部的 ArrayBuffer 存储了要操作的二进制数据.\n\nUint8Array\n概念: 数组中的每一个元素都是 8个二进制位(1个字节)的无符号整数.无符号的含义是, 该二进制的首位不表示符号位. 而对于有符号的二进制位, \n\nBuffer\n概念: Node中才有, 继承自 Unit8array, 拥有更多强大的二进制数据操作.\n\nBuffer的内存分配事实上我们创建Buffer时，并不会频繁的向操作系统申请内存，它会默认先申请一个8 * 1024个字节大小的内存，也就是8kb\n\nnode&#x2F;lib&#x2F;buffer.js：135行\n\nBuffer.poolSize &#x3D; 8 * 1024;\nlet poolSize, poolOffset, allocPool;\n\nconst encodingsMap &#x3D; ObjectCreate(null);\nfor (let i &#x3D; 0; i &lt; encodings.length; ++i)\n  encodingsMap[encodings[i]] &#x3D; i;\n\nfunction createPool() &#123;\n  poolSize &#x3D; Buffer.poolSize;\n  allocPool &#x3D; createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset &#x3D; 0;\n&#125;\ncreatePool();\n\n假如我们调用Buffer.from申请Buffer：\n\n这里我们以从字符串创建为例\nnode&#x2F;lib&#x2F;buffer.js：290行\n\nBuffer.from &#x3D; function from(value, encodingOrOffset, length) &#123;\n  if (typeof value &#x3D;&#x3D;&#x3D; &#39;string&#39;)\n    return fromString(value, encodingOrOffset);\n \n &#x2F;&#x2F; 如果是对象，另外一种处理情况\n  &#x2F;&#x2F; ...\n&#125;;\n\n我们查看fromString的调用：\n\nnode&#x2F;lib&#x2F;buffer.js：428行\n\nfunction fromString(string, encoding) &#123;\n  let ops;\n  if (typeof encoding !&#x3D;&#x3D; &#39;string&#39; || encoding.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    if (string.length &#x3D;&#x3D;&#x3D; 0)\n      return new FastBuffer();\n    ops &#x3D; encodingOps.utf8;\n    encoding &#x3D; undefined;\n  &#125; else &#123;\n    ops &#x3D; getEncodingOps(encoding);\n    if (ops &#x3D;&#x3D;&#x3D; undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length &#x3D;&#x3D;&#x3D; 0)\n      return new FastBuffer();\n  &#125;\n  return fromStringFast(string, ops);\n&#125;\n\n接着我们查看fromStringFast：\n\n这里做的事情是判断剩余的长度是否还足够填充这个字符串；\n如果不足够，那么就要通过 createPool 创建新的空间；\n如果够就直接使用，但是之后要进行 poolOffset的偏移变化；\nnode&#x2F;lib&#x2F;buffer.js：428行\n\nfunction fromStringFast(string, ops) &#123;\n  const length &#x3D; ops.byteLength(string);\n\n  if (length &gt;&#x3D; (Buffer.poolSize &gt;&gt;&gt; 1))\n    return createFromString(string, ops.encodingVal);\n\n  if (length &gt; (poolSize - poolOffset))\n    createPool();\n  let b &#x3D; new FastBuffer(allocPool, poolOffset, length);\n  const actual &#x3D; ops.write(b, string, 0, length);\n  if (actual !&#x3D;&#x3D; length) &#123;\n    &#x2F;&#x2F; byteLength() may overestimate. That&#39;s a rare case, though.\n    b &#x3D; new FastBuffer(allocPool, poolOffset, actual);\n  &#125;\n  poolOffset +&#x3D; actual;\n  alignPool();\n  return b;\n&#125;\n\nStream4.1. 认识Stream什么是流呢？\n\n我们的第一反应应该是流水，源源不断的流动；\n程序中的流也是类似的含义，我们可以想象当我们从一个文件中读取数据时，文件的二进制（字节）数据会源源不断的被读取到我们程序中；\n而这个一连串的字节，就是我们程序中的流；\n\n所以，我们可以这样理解流：\n\n是连续字节的一种表现形式和抽象概念；\n流应该是可读的，也是可写的；\n\n在之前学习文件的读写时，我们可以直接通过 readFile或者 writeFile方式读写文件，为什么还需要流呢？\n\n直接读写文件的方式，虽然简单，但是无法控制一些细节的操作；\n比如从什么位置开始读、读到什么位置、一次性读取多少个字节；\n读到某个位置后，暂停读取，某个时刻恢复读取等等；\n或者这个文件非常大，比如一个视频文件，一次性全部读取并不合适；\n\n事实上Node中很多对象是基于流实现的：\n\nhttp模块的Request和Response对象；\nprocess.stdout对象；\n\n官方：另外所有的流都是EventEmitter的实例：\n我们可以看一下Node源码中有这样的操作：\n\nStream和EventEmitter关系\n流（Stream）的分类：\n\nWritable：可以向其写入数据的流（例如 fs.createWriteStream()）。\nReadable：可以从中读取数据的流（例如 fs.createReadStream()）。\nDuplex：同时为Readable和的流Writable（例如 net.Socket）。\nTransform：Duplex可以在写入和读取数据时修改或转换数据的流（例如zlib.createDeflate()）。\n\n这里我们通过fs的操作，讲解一下Writable、Readable，另外两个大家可以自行学习一下。\n4.2. Readable之前我们读取一个文件的信息：\nfs.readFile(&#39;.&#x2F;foo.txt&#39;, (err, data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)\n\n这种方式是一次性将一个文件中所有的内容都读取到程序（内存）中，但是这种读取方式就会出现我们之前提到的很多问题：\n\n文件过大、读取的位置、结束的位置、一次读取的大小；\n\n这个时候，我们可以使用 createReadStream，我们来看几个参数，更多参数可以参考官网：\n\nstart：文件读取开始的位置；\nend：文件读取结束的位置；\nhighWaterMark：一次性读取字节的长度，默认是64kb；\n\nconst read &#x3D; fs.createReadStream(&quot;.&#x2F;foo.txt&quot;, &#123;\n  start: 3,\n  end: 8,\n  highWaterMark: 4\n&#125;);\n\n我们如何获取到数据呢？\n\n可以通过监听data事件，获取读取到的数据；\n\nread.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;);\n\n我们也可以监听其他的事件：\nread.on(&#39;open&#39;, (fd) &#x3D;&gt; &#123;\n  console.log(&quot;文件被打开&quot;);\n&#125;)\n\nread.on(&#39;end&#39;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件读取结束&quot;);\n&#125;)\n\nread.on(&#39;close&#39;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件被关闭&quot;);\n&#125;)\n\n甚至我们可以在某一个时刻暂停和恢复读取：\nread.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n  console.log(data);\n\n  read.pause();\n\n  setTimeout(() &#x3D;&gt; &#123;\n    read.resume();\n  &#125;, 2000);\n&#125;);\n\n4.3. Writable之前我们写入一个文件的方式是这样的：\nfs.writeFile(&#39;.&#x2F;foo.txt&#39;, &quot;内容&quot;, (err) &#x3D;&gt; &#123;\n  \n&#125;);\n\n这种方式相当于一次性将所有的内容写入到文件中，但是这种方式也有很多问题：\n\n比如我们希望一点点写入内容，精确每次写入的位置等；\n\n这个时候，我们可以使用 createWriteStream，我们来看几个参数，更多参数可以参考官网：\n\nflags：默认是w，如果我们希望是追加写入，可以使用 a或者 a+；\nstart：写入的位置；\n\n我们进行一次简单的写入\nconst writer &#x3D; fs.createWriteStream(&quot;.&#x2F;foo.txt&quot;, &#123;\n  flags: &quot;a+&quot;,\n  start: 8\n&#125;);\n\nwriter.write(&quot;你好啊&quot;, err &#x3D;&gt; &#123;\n  console.log(&quot;写入成功&quot;);\n&#125;);\n\n如果我们希望监听一些事件：\nwriter.on(&quot;open&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件打开&quot;);\n&#125;)\n\nwriter.on(&quot;finish&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件写入结束&quot;);\n&#125;)\n\nwriter.on(&quot;close&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件关闭&quot;);\n&#125;)\n\n我们会发现，我们并不能监听到 close 事件：\n\n这是因为写入流在打开后是不会自动关闭的；\n我们必须手动关闭，来告诉Node已经写入结束了；\n并且会发出一个 finish 事件的；\n\nwriter.close();\n\nwriter.on(&quot;finish&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件写入结束&quot;);\n&#125;)\n\nwriter.on(&quot;close&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;文件关闭&quot;);\n&#125;)\n\n另外一个非常常用的方法是 end：\n\nend方法相当于做了两步操作：write传入的数据和调用close方法；\n\nwriter.end(&quot;Hello World&quot;);\n\n4.4. pipe方法正常情况下，我们可以将读取到的 输入流，手动的放到 输出流中进行写入：\nconst fs &#x3D; require(&#39;fs&#39;);\nconst &#123; read &#125; &#x3D; require(&#39;fs&#x2F;promises&#39;);\n\nconst reader &#x3D; fs.createReadStream(&#39;.&#x2F;foo.txt&#39;);\nconst writer &#x3D; fs.createWriteStream(&#39;.&#x2F;bar.txt&#39;);\n\nreader.on(&quot;data&quot;, (data) &#x3D;&gt; &#123;\n  console.log(data);\n  writer.write(data, (err) &#x3D;&gt; &#123;\n    console.log(err);\n  &#125;);\n&#125;);\n\n我们也可以通过pipe来完成这样的操作：\nreader.pipe(writer);\n\nwriter.on(&#39;close&#39;, () &#x3D;&gt; &#123;\n  console.log(&quot;输出流关闭&quot;);\n&#125;)\n","slug":"node/base/Node基础六","date":"2022-10-01T04:26:50.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"f31c41ff35acbf9aa56d10f7617b9f93","title":"Node基础五","content":"五.npm你不知道的细节1.1. 认识npm我们已经学习了在JavaScript中可以通过模块化的方式将代码划分成一个个小的结构：\n\n在以后的开发中我们就可以通过模块化的方式来封装自己的代码，并且封装成一个工具；\n这个工具我们可以让同事通过导入的方式来使用，甚至你可以分享给世界各地的程序员来使用；\n\n如果我们分享给世界上所有的程序员使用，有哪些方式呢？\n方式一：上传到GitHub上、其他程序员通过GitHub下载我们的代码手动的引用；\n\n缺点是大家必须知道你的代码GitHub的地址，并且从GitHub上手动下载；\n需要在自己的项目中手动的引用，并且管理相关的依赖；\n不需要使用的时候，需要手动来删除相关的依赖；\n当遇到版本升级或者切换时，需要重复上面的操作；\n\n显然，上面的方式是有效的，但是这种传统的方式非常麻烦，并且容易出错；\n方式二：使用一个专业的工具来管理我们的代码\n\n我们通过工具将代码发布到特定的位置；\n其他程序员直接通过工具来安装、升级、删除我们的工具代码；\n\n显然，通过第二种方式我们可以更好的管理自己的工具包，其他人也可以更好的使用我们的工具包。\n包管理工具npm：\n\nNode Package Manager，也就是Node包管理器；\n但是目前已经不仅仅是Node包管理器了，在前端项目中我们也在使用它来管理依赖的包；\n比如express、koa、react、react-dom、axios、babel、webpack等等；\n\nnpm管理的包可以在哪里查看、搜索呢？\n\nhttps://www.npmjs.com/\n这是我们安装相关的npm包的官网；\n\nnpm管理的包存放在哪里呢？\n\n我们发布自己的包其实是发布到registry上面的；\n当我们安装一个包时其实是从registry上面下载的包；\n\n1.2. 项目配置文件事实上，我们每一个项目都会有一个对应的配置文件，无论是前端项目还是后端项目：\n\n这个配置文件会记录着你项目的名称、版本号、项目描述等；\n也会记录着你项目所依赖的其他库的信息和依赖库的版本号；\n\n这个配置文件在Node环境下面（无论是前端还是后端）就是package.json。\n我们以vue cli4脚手架创建的项目为例：\n&#123;\n  &quot;name&quot;: &quot;my-vue&quot;,\n  &quot;version&quot;: &quot;0.1.0&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,\n    &quot;build&quot;: &quot;vue-cli-service build&quot;,\n    &quot;lint&quot;: &quot;vue-cli-service lint&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;core-js&quot;: &quot;^3.6.5&quot;,\n    &quot;vue&quot;: &quot;^2.6.11&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@vue&#x2F;cli-plugin-babel&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue&#x2F;cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue&#x2F;cli-service&quot;: &quot;~4.5.0&quot;,\n    &quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n    &quot;eslint&quot;: &quot;^6.7.2&quot;,\n    &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n    &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot;\n  &#125;,\n  &quot;browserslist&quot;: [\n    &quot;&gt; 1%&quot;,\n    &quot;last 2 versions&quot;,\n    &quot;not dead&quot;\n  ]\n&#125;\n\n事实上Vue ClI4脚手架创建的项目相对进行了简化，我们来看一下CLI2创建的项目：\n&#123;\n  &quot;name&quot;: &quot;vuerouterbasic&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;A Vue.js project&quot;,\n  &quot;author&quot;: &quot;&#39;coderwhy&#39; &lt;&#39;coderwhy@gmail.com&#39;&gt;&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build&#x2F;webpack.dev.conf.js&quot;,\n    &quot;start&quot;: &quot;npm run dev&quot;,\n    &quot;build&quot;: &quot;node build&#x2F;build.js&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;vue&quot;: &quot;^2.5.2&quot;,\n    &quot;vue-router&quot;: &quot;^3.0.1&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,\n    &quot;babel-core&quot;: &quot;^6.22.1&quot;,\n    &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;,\n    &quot;babel-loader&quot;: &quot;^7.1.1&quot;,\n    &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;,\n    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,\n    &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;,\n    &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;,\n    &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;,\n    &quot;chalk&quot;: &quot;^2.0.1&quot;,\n    &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;,\n    &quot;css-loader&quot;: &quot;^0.28.0&quot;,\n    &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;,\n    &quot;file-loader&quot;: &quot;^1.1.4&quot;,\n    &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;,\n    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,\n    &quot;node-notifier&quot;: &quot;^5.1.2&quot;,\n    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;,\n    &quot;ora&quot;: &quot;^1.2.0&quot;,\n    &quot;portfinder&quot;: &quot;^1.0.13&quot;,\n    &quot;postcss-import&quot;: &quot;^11.0.0&quot;,\n    &quot;postcss-loader&quot;: &quot;^2.0.8&quot;,\n    &quot;postcss-url&quot;: &quot;^7.2.1&quot;,\n    &quot;rimraf&quot;: &quot;^2.6.0&quot;,\n    &quot;semver&quot;: &quot;^5.3.0&quot;,\n    &quot;shelljs&quot;: &quot;^0.7.6&quot;,\n    &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;,\n    &quot;url-loader&quot;: &quot;^0.5.8&quot;,\n    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,\n    &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;,\n    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,\n    &quot;webpack&quot;: &quot;^3.6.0&quot;,\n    &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;,\n    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;,\n    &quot;webpack-merge&quot;: &quot;^4.1.0&quot;\n  &#125;,\n  &quot;engines&quot;: &#123;\n    &quot;node&quot;: &quot;&gt;&#x3D; 6.0.0&quot;,\n    &quot;npm&quot;: &quot;&gt;&#x3D; 3.0.0&quot;\n  &#125;,\n  &quot;browserslist&quot;: [\n    &quot;&gt; 1%&quot;,\n    &quot;last 2 versions&quot;,\n    &quot;not ie &lt;&#x3D; 8&quot;\n  ]\n&#125;\n\n我们也可以手动创建一个package.json文件：\nnpm init #创建时填写信息\nnpm init -y # 所有信息使用默认的\n\nnpm init -y生成文件的效果：\n&#123;\n  &quot;name&quot;: &quot;learn-npm&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;main.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n我们会发现属性非常的多，我们这里对一些常见属性进行一些解析。\n必须填写的属性：name、version\n\nname是项目的名称；\nversion是当前项目的版本号；\ndescription是描述信息，很多时候是作为项目的基本描述；\nauthor是作者相关信息（发布时用到）；\nlicense是开源协议（发布时用到）；\n\nprivate属性：\n\nprivate属性记录当前的项目是否是私有的；\n当值为true时，npm是不能发布它的，这是防止私有项目或模块发布出去的方式；\n\nmain属性：\n\n设置程序的入口。\n\n很多人会有疑惑，webpack不是会自动找到程序的入口吗？\n\n\n这个入口和webpack打包的入口并不冲突；\n\n\n它是在你发布一个模块的时候会用到的；\n\n比如我们使用axios模块 const axios = require(&#39;axios&#39;);\n\n实际上是找到对应的main属性查找文件的；\n\n\naxios的入口\nscripts属性\n\nscripts属性用于配置一些脚本命令，以键值对的形式存在；\n\n配置后我们可以通过 npm run 命令的key来执行这个命令；\n\nnpm start和npm run start的区别是什么？\n\n\n它们是等价的；\n\n\n对于常用的 start、 test、stop、restart可以省略掉run直接通过 npm start等方式运行；\n\n\ndependencies属性\n\ndependencies属性是指定无论开发环境还是生成环境都需要依赖的包；\n通常是我们项目实际开发用到的一些库模块；\n与之对应的是devDependencies；\n\ndevDependencies属性\n\n一些包在生成环境是不需要的，比如webpack、babel等；\n这个时候我们会通过 npm install webpack --save-dev，将它安装到devDependencies属性中；\n\n疑问：那么在生成环境如何保证不安装这些包呢？\n\n生成环境不需要安装时，我们需要通过 npm install --production 来安装文件的依赖；\n\n版本管理的问题\n我们会发现安装的依赖版本出现：^2.0.3或~2.0.3，这是什么意思呢？\nnpm的包通常需要遵从semver版本规范：\n\nsemver：https://semver.org/lang/zh-CN/\nnpm semver：https://docs.npmjs.com/misc/semver\n\nsemver版本规范是X.Y.Z：\n\nX主版本号（major）：当你做了不兼容的 API 修改（可能不兼容之前的版本）；\nY次版本号（minor）：当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）；\nZ修订号（patch）：当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug）；\n\n我们这里解释一下 ^和~的区别：\n\n^x.y.z：表示x是保持不变的，y和z永远安装最新的版本；\n~x.y.z：表示x和y保持不变的，z永远安装最新的版本；\n\nengines属性\n\nengines属性用于指定Node和NPM的版本号；\n在安装的过程中，会先检查对应的引擎版本，如果不符合就会报错；\n事实上也可以指定所在的操作系统 &quot;os&quot; : [ &quot;darwin&quot;, &quot;linux&quot; ]，只是很少用到；\n\nbrowserslist属性\n\n用于配置打包后的JavaScript浏览器的兼容情况，参考；\n否则我们需要手动的添加polyfills来让支持某些语法；\n也就是说它是为webpack等打包工具服务的一个属性（这里不是详细讲解webpack等工具的工作原理，所以不再给出详情）；\n\nnpm工具解析2.1. npm install命令安装npm包分两种情况：\n\n全局安装（global install）：npm install yarn -g;\n项目（局部）安装（local install）：npm install\n\n全局安装\n全局安装是直接将某个包安装到全局：\n比如yarn的全局安装：\nnpm install yarn -g\n\n但是很多人对全局安装有一些误会：\n\n通常使用npm全局安装的包都是一些工具包：yarn、webpack等；\n并不是类似于 axios、express、koa等库文件；\n所以全局安装了之后并不能让我们在所有的项目中使用 axios等库；\n\n项目安装\n项目安装会在当前目录下生产一个 node_modules 文件夹，我们之前讲解require查找顺序时有讲解过这个包在什么情况下被查找；\n局部安装分为开发时依赖和生产时依赖：\n# 安装开发和生产依赖\nnpm install axios --save\nnpm install axios -S\nnpm install axios\nnpm i axios\n\n# 开发者\nnpm install axios --save-dev\nnpm install axios -D\nnpm i axios -D\n\n2.2. npm install原理很多同学之情应该已经会了 npm install &lt;package&gt;，但是你是否思考过它的内部原理呢？\n\n执行 npm install它背后帮助我们完成了什么操作？\n我们会发现还有一个成为package-lock.json的文件，它的作用是什么？\n从npm5开始，npm支持缓存策略（来自yarn的压力），缓存有什么作用呢？\n\n这是一幅我画出的根据 npm install 的原理图：\n\nnpm install会检测是有package-lock.json文件：\n\n\n检测lock中包的版本是否和package.json中一致（会按照semver版本规范检测）；\n\n\n一致的情况下，会去优先查找缓存\n\n查找到，会获取缓存中的压缩文件，并且将压缩文件解压到node_modules文件夹中；\n\n不一致，那么会重新构建依赖关系，直接会走顶层的流程；\n\n没有找到，会从registry仓库下载，直接走顶层流程；\n\n分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产生相同依赖的情况；\n\n从registry仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）；\n\n获取到压缩包后会对压缩包进行缓存（从npm5开始有的）；\n\n将压缩包解压到项目的node_modules文件夹中（前面我们讲过，require的查找顺序会在该包下面查找）\n\n没有lock文件\n\n有lock文件\n\n\nnpm install原理图\npackage-lock.json文件：\n&#123;\n  &quot;name&quot;: &quot;learn-npm&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;lockfileVersion&quot;: 1,\n  &quot;requires&quot;: true,\n  &quot;dependencies&quot;: &#123;\n    &quot;axios&quot;: &#123;\n      &quot;version&quot;: &quot;0.20.0&quot;,\n      &quot;resolved&quot;: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;axios&#x2F;-&#x2F;axios-0.20.0.tgz&quot;,\n      &quot;integrity&quot;: &quot;sha512-ANA4rr2BDcmmAQLOKft2fufrtuvlqR+cXNNinUmvfeSNCOF98PZL+7M&#x2F;v1zIdGo7OLjEA9J2gXJL+j4zGsl0bA&#x3D;&#x3D;&quot;,\n      &quot;requires&quot;: &#123;\n        &quot;follow-redirects&quot;: &quot;^1.10.0&quot;\n      &#125;\n    &#125;,\n    &quot;follow-redirects&quot;: &#123;\n      &quot;version&quot;: &quot;1.13.0&quot;,\n      &quot;resolved&quot;: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;follow-redirects&#x2F;-&#x2F;follow-redirects-1.13.0.tgz&quot;,\n      &quot;integrity&quot;: &quot;sha512-aq6gF1BEKje4a9i9+5jimNFIpq4Q1WiwBToeRK5NvZBd&#x2F;TRsmW8BsJfOEGkr76TbOyPVD3OVDN910EcUNtRYEA&#x3D;&#x3D;&quot;\n    &#125;\n  &#125;\n&#125;\n\npackage-lock.json文件解析：\n\nname：项目的名称；\n\nversion：项目的版本；\n\nlockfileVersion：lock文件的版本；\n\nrequires：使用requires来跟着模块的依赖关系；\n\ndependencies：项目的依赖\n\n\nversion表示实际安装的axios的版本；\n\n\nresolved用来记录下载的地址，registry仓库中的位置；\n\nrequires记录当前模块的依赖；\n\nintegrity用来从缓存中获取索引，再通过索引去获取压缩包文件；\n\n当前项目依赖axios，但是axios依赖follow-redireacts；\n\naxios中的属性如下：\n\n\n2.3. 其他npm命令我们这里再介绍几个比较常用的：\n卸载某个依赖包：\nnpm uninstall package\nnpm uninstall package --save-dev\nnpm uninstall package -D\n\n强制重新build\nnpm rebuild\n\n清除缓存\nnpm cache clean\n\nnpm的命令其实是非常多的：\n\nhttps://docs.npmjs.com/cli-documentation/cli\n更多的命令，可以根据需要查阅官方文档\n\n2.4. yarn和cnpm另一个node包管理工具yarn：\n\nyarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具；\nyarn 是为了弥补 npm 的一些缺陷而出现的；\n早期的npm存在很多的缺陷，比如安装依赖速度很慢、版本依赖混乱等等一系列的问题；\n虽然从npm5版本开始，进行了很多的升级和改进，但是依然很多人喜欢使用yarn；\n\n这里给出一张常用命令的对比\nnpm和yarn常用命令对比\n补充：cnpm\n由于一些特殊的原因，某些情况下我们没办法很好的从 https://registry.npmjs.org下载下来一些需要的包。\n查看npm镜像：\nnpm config get registry # npm config get registry\n\n我们可以直接设置npm的镜像：\nnpm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org\n\n但是对于大多数人来说（比如我），并不希望将npm镜像修改了：\n\n第一，不太希望随意修改npm原本从官方下来包的渠道；\n第二，担心某天淘宝的镜像挂了或者不维护了，又要改来改去；\n\n这个时候，我们可以使用cnpm，并且将cnpm设置为淘宝的镜像：\nnpm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org\ncnpm config get registry # https:&#x2F;&#x2F;r.npm.taobao.org&#x2F;\n\n补充：npx\nnpx是npm5.2之后自带的一个命令。\nnpx的作用非常多，但是比较常见的是使用它来调用项目中的某个模块的指令。\n我们以webpack为例：\n\n全局安装的是webpack5.1.3\n项目安装的是webpack3.6.0\n\n如果我在终端执行 webpack --version使用的是哪一个命令呢？\n\n显示结果会是 webpack 5.1.3，事实上使用的是全局的，为什么呢？\n原因非常简单，在当前目录下找不到webpack时，就会去全局找，并且执行命令；\n\n那么如何使用项目（局部）的webpack，常见的是两种方式：\n\n方式一：明确查找到node_module下面的webpack\n方式二：在 scripts定义脚本，来执行webpack；\n\n方式一：在终端中使用如下命令（在项目根目录下）\n.&#x2F;node_modules&#x2F;.bin&#x2F;webpack --version\n\n方式二：修改package.json中的scripts\n&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n  &quot;webpack&quot;: &quot;webpack --version&quot;\n&#125;,\n\n终端中执行：\nnpm run webpack\n\n但是这两种方式都有一点点麻烦，更好的办法是直接使用npx：\nnpx webpack --version\n\nnpx的原理非常简单，它会到当前目录的node_modules&#x2F;.bin目录下查找对应的命令；\n","slug":"node/base/Node基础五","date":"2022-10-01T04:25:11.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"e9d3cfba4c19a66c9a7d2ec6535dbb77","title":"Node基础四","content":"四.常用内置模块1.1. 认识path模块path模块用于对路径和文件进行处理，提供了很多好用的方法。\n并且我们知道在Mac OS、Linux和window上的路径是不一样的\n\nwindow上会使用 \\或者 \\\\ 来作为文件路径的分隔符，当然目前也支持 /；\n在Mac OS、Linux的Unix操作系统上使用 / 来作为文件路径的分隔符；\n\n那么如果我们在window上使用 \\ 来作为分隔符开发了一个应用程序，要部署到Linux上面应该怎么办呢？\n\n显示路径会出现一些问题；\n所以为了屏蔽他们之间的差异，在开发中对于路径的操作我们可以使用 path 模块；\n\n1.2. path常见的API从路径中获取信息\n\ndirname：获取文件的父文件夹；\nbasename：获取文件名；\nextname：获取文件扩展名；\n\nconst path &#x3D; require(&quot;path&quot;);\n\nconst myPath &#x3D; &#39;&#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;课堂&#x2F;PPT&#x2F;01_邂逅Node.pdf&#39;;\n\nconst dirname &#x3D; path.dirname(myPath);\nconst basename &#x3D; path.basename(myPath);\nconst extname &#x3D; path.extname(myPath);\n\nconsole.log(dirname); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;课堂&#x2F;PPT\nconsole.log(basename); &#x2F;&#x2F; 01_邂逅Node.pdf\nconsole.log(extname); &#x2F;&#x2F; .pdf\n\n路径的拼接\n\n如果我们希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符；\n这个时候我们可以使用path.join函数；\n\nconsole.log(path.join(&#39;&#x2F;user&#39;, &#39;why&#39;, &#39;abc.txt&#39;));\n\n将文件和某个文件夹拼接\n\n如果我们希望将某个文件和文件夹拼接，可以使用 path.resolve;\n\n\nresolve函数会判断我们拼接的路径前面是否有 /或../或./；\n\n\n如果有表示是一个绝对路径，会返回对应的拼接路径；\n\n如果没有，那么会和当前执行文件所在的文件夹进行路径的拼接\n\n\npath.resolve(&#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;06_常见的内置模块&#x2F;02_文件路径&#x2F;abc.txt\npath.resolve(&#39;&#x2F;abc.txt&#39;); &#x2F;&#x2F; &#x2F;abc.txt\npath.resolve(&#39;&#x2F;User&#x2F;why&#39;, &#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;User&#x2F;why&#x2F;abc.txt\npath.resolve(&#39;User&#x2F;why&#39;, &#39;abc.txt&#39;); &#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;06_常见的内置模块&#x2F;02_文件路径&#x2F;User&#x2F;why&#x2F;abc.txt\n\nresolve其实我们在webpack中也会使用：\nconst CracoLessPlugin &#x3D; require(&#39;craco-less&#39;);\nconst path &#x3D; require(&quot;path&quot;);\n\nconst resolve &#x3D; dir &#x3D;&gt; path.resolve(__dirname, dir);\n\nmodule.exports &#x3D; &#123;\n  plugins: [\n    &#123;\n      plugin: CracoLessPlugin,\n      options: &#123;\n        lessLoaderOptions: &#123;\n          lessOptions: &#123;\n            modifyVars: &#123; &#39;@primary-color&#39;: &#39;#1DA57A&#39; &#125;,\n            javascriptEnabled: true,\n          &#125;,\n        &#125;,\n      &#125;,\n    &#125;\n  ],\n  webpack: &#123;\n    alias: &#123;\n      &quot;@&quot;: resolve(&quot;src&quot;),\n      &quot;components&quot;: resolve(&quot;src&#x2F;components&quot;)\n    &#125;\n  &#125;\n&#125;\n\n内置模块fs1.1. 认识fs模块fs是File System的缩写，表示文件系统。\n对于任何一个为服务器端服务的语言或者框架通常都会有自己的文件系统：\n\n因为服务器需要将各种数据、文件等放置到不同的地方；\n比如用户数据可能大多数是放到数据库中的（后面我们也会学习）；\n比如某些配置文件或者用户资源（图片、音视频）都是以文件的形式存在于操作系统上的；\n\nNode也有自己的文件系统操作模块，就是fs：\n\n借助于Node帮我们封装的文件系统，我们可以在任何的操作系统（window、Mac OS、Linux）上面直接去操作文件；\n这也是Node可以开发服务器的一大原因，也是它可以成为前端自动化脚本等热门工具的原因；\n\nNode文件系统的API非常的多：https://nodejs.org/dist/latest-v14.x/docs/api/fs.html\n\n我们不可能，也没必要一个个去学习；\n这个更多的应该是作为一个API查询的手册，等用到的时候查询即可；\n学习阶段我们只需要学习最常用的即可；\n\n但是这些API大多数都提供三种操作方式：\n\n方式一：同步操作文件：代码会被阻塞，不会继续执行；\n方式二：异步回调函数操作文件：代码不会被阻塞，需要传入回调函数，当获取到结果时，回调函数被执行；\n方式三：异步Promise操作文件：代码不会被阻塞，通过 fs.promises 调用方法操作，会返回一个Promise，可以通过then、catch进行处理；\n\n我们这里以获取一个文件的状态为例：\n\n注意：都需要引入 fs 模块；\n\n方式一：同步操作文件\n&#x2F;&#x2F; 1.方式一: 同步读取文件\nconst state &#x3D; fs.statSync(&#39;..&#x2F;foo.txt&#39;);\nconsole.log(state);\n\nconsole.log(&#39;后续代码执行&#39;);\n\n方式二：异步回调函数操作文件\n&#x2F;&#x2F; 2.方式二: 异步读取\nfs.stat(&quot;..&#x2F;foo.txt&quot;, (err, state) &#x3D;&gt; &#123;\n  if (err) &#123;\n    console.log(err);\n    return;\n  &#125;\n  console.log(state);\n&#125;)\nconsole.log(&quot;后续代码执行&quot;);\n\n方式三：异步Promise操作文件\n&#x2F;&#x2F; 3.方式三: Promise方式\nfs.promises.stat(&quot;..&#x2F;foo.txt&quot;).then(state &#x3D;&gt; &#123;\n  console.log(state);\n&#125;).catch(err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\nconsole.log(&quot;后续代码执行&quot;);\n\n后续代码演练中，我将以异步回调的方式演练：相对更通用一些；\n1.2. 文件描述符文件描述符（File descriptors）是什么呢？\n在 POSIX 系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。\n\n每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。\n在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件。\nWindows 系统使用了一个虽然不同但概念上类似的机制来跟踪资源。\n为了简化用户的工作，Node.js 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符。\n\nfs.open() 方法用于分配新的文件描述符。一旦被分配，则文件描述符可用于从文件读取数据、向文件写入数据、或请求关于文件的信息。\n&#x2F;&#x2F; 获取文件描述符\nfs.open(&quot;..&#x2F;foo.txt&quot;, &#39;r&#39;, (err, fd) &#x3D;&gt; &#123;\n  console.log(fd);\n\n  fs.fstat(fd, (err, state) &#x3D;&gt; &#123;\n    console.log(state);\n  &#125;)\n&#125;)\n\n1.3. 文件的读写如果我们希望对文件的内容进行操作，这个时候可以使用文件的读写：\n\nfs.readFile(path[, options], callback)：读取文件的内容；\nfs.writeFile(file, data[, options], callback)：在文件中写入内容；\n\n文件写入：\nfs.writeFile(&#39;..&#x2F;foo.txt&#39;, content, &#123;&#125;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\n\n在上面的代码中，你会发现有一个大括号没有填写任何的内容，这个是写入时填写的option参数：\n\nflag：写入的方式。\nencoding：字符的编码；\n\n我们先来看flag：\n\nflag的值有很多：https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system_flags\n\n\nw 打开文件写入，默认值；\n\n\nw+打开文件进行读写，如果不存在则创建文件；\n\nr+ 打开文件进行读写，如果不存在那么抛出异常；\n\nr打开文件读取，读取时的默认值；\n\na打开要写入的文件，将流放在文件末尾。如果不存在则创建文件；\n\na+打开文件以进行读写，将流放在文件末尾。如果不存在则创建文件\n\n\n我们再来看看编码：\n\n我之前在简书上写过一篇关于字符编码的文章：https://www.jianshu.com/p/899e749be47c\n目前基本用的都是UTF-8编码；\n\n文件读取：\n\n如果不填写encoding，返回的结果是Buffer；\n\nfs.readFile(&#39;..&#x2F;foo.txt&#39;, &#123;encoding: &#39;utf-8&#39;&#125;, (err, data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)\n\n文件读取：\nconst fs &#x3D; require(&#39;fs&#39;);\n\nfs.readFile(&#39;..&#x2F;foo.txt&#39;, &#123;encoding: &#39;utf-8&#39;&#125;, (err, data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)\n\n1.4. 文件夹操作新建一个文件夹\n使用fs.mkdir()或fs.mkdirSync()创建一个新文件夹：\nconst fs &#x3D; require(&#39;fs&#39;);\n\nconst dirname &#x3D; &#39;..&#x2F;why&#39;;\n\nif (!fs.existsSync(dirname)) &#123;\n  fs.mkdir(dirname, (err) &#x3D;&gt; &#123;\n    console.log(err);\n  &#125;)\n&#125;\n\n获取文件夹的内容\n&#x2F;&#x2F; 读取文件夹\nfunction readFolders(folder) &#123;\n  fs.readdir(folder, &#123;withFileTypes: true&#125; ,(err, files) &#x3D;&gt; &#123;\n    files.forEach(file &#x3D;&gt; &#123;\n      if (file.isDirectory()) &#123;\n        const newFolder &#x3D; path.resolve(dirname, file.name);\n        readFolders(newFolder);\n      &#125; else &#123;\n        console.log(file.name);\n      &#125;\n    &#125;)\n  &#125;)\n&#125;\n\nreadFolders(dirname);\n\n文件重命名\nfs.rename(&#39;..&#x2F;why&#39;, &#39;..&#x2F;coder&#39;, err &#x3D;&gt; &#123;\n  console.log(err);\n&#125;)\n\n内置模块events3.1. 基本使用Node中的核心API都是基于异步事件驱动的：\n\n在这个体系中，某些对象（发射器（Emitters））发出某一个事件；\n我们可以监听这个事件（监听器 Listeners），并且传入的回调函数，这个回调函数会在监听到事件时调用；\n\n发出事件和监听事件都是通过EventEmitter类来完成的，它们都属于events对象。\n\nemitter.on(eventName, listener)：监听事件，也可以使用addListener；\nemitter.off(eventName, listener)：移除事件监听，也可以使用removeListener；\nemitter.emit(eventName[, ...args])：发出事件，可以携带一些参数；\n\nconst EventEmmiter &#x3D; require(&#39;events&#39;);\n\n&#x2F;&#x2F; 监听事件\nconst bus &#x3D; new EventEmmiter();\n\nfunction clickHanlde(args) &#123;\n  console.log(&quot;监听到click事件&quot;, args);\n&#125;\n\nbus.on(&quot;click&quot;, clickHanlde);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  bus.emit(&quot;click&quot;, &quot;coderwhy&quot;);\n  bus.off(&quot;click&quot;, clickHanlde);\n  bus.emit(&quot;click&quot;, &quot;kobe&quot;);\n&#125;, 2000);\n\n3.2. 常见的属性EventEmitter的实例有一些属性，可以记录一些信息：\n\nemitter.eventNames()：返回当前 EventEmitter对象注册的事件字符串数组；\nemitter.getMaxListeners()：返回当前 EventEmitter对象的最大监听器数量，可以通过setMaxListeners()来修改，默认是10；\nemitter.listenerCount(事件名称)：返回当前 EventEmitter对象某一个事件名称，监听器的个数；\nemitter.listeners(事件名称)：返回当前 EventEmitter对象某个事件监听器上所有的监听器数组；\n\nconsole.log(bus.eventNames());\nconsole.log(bus.getMaxListeners());\nconsole.log(bus.listenerCount(&quot;click&quot;));\nconsole.log(bus.listeners(&quot;click&quot;));\n\n3.3. 方法的补充emitter.once(eventName, listener)：事件监听一次\nconst EventEmitter &#x3D; require(&#39;events&#39;);\n\nconst emitter &#x3D; new EventEmitter();\n\nemitter.once(&#39;click&#39;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;监听到事件&quot;, args);\n&#125;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  emitter.emit(&#39;click&#39;, &#39;coderwhy&#39;);\n  emitter.emit(&#39;click&#39;, &#39;coderwhy&#39;);\n&#125;, 2000);\n\nemitter.prependListener()：将监听事件添加到最前面\nemitter.on(&#39;click&#39;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;a监听到事件&quot;, args);\n&#125;)\n\n&#x2F;&#x2F; b监听事件会被放到前面\nemitter.prependListener(&quot;click&quot;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;b监听到事件&quot;, args);\n&#125;)\n\nemitter.prependOnceListener()：将监听事件添加到最前面，但是只监听一次\nemitter.prependOnceListener(&quot;click&quot;, (args) &#x3D;&gt; &#123;\n  console.log(&quot;c监听到事件&quot;, args);\n&#125;)\n\nemitter.removeAllListeners([eventName])：移除所有的监听器\n&#x2F;&#x2F; 移除emitter上的所有事件监听\nemitter.removeAllListeners();\n&#x2F;&#x2F; 移除emitter上的click事件监听\nemitter.removeAllListeners(&quot;click&quot;);\n","slug":"node/base/Node基础四","date":"2022-10-01T04:24:10.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"4d3281e0b26c044e36154a269947cf99","title":"Node基础三","content":"三 . 掌握前端模块化1.1. JavaScript设计缺陷那么，到底什么是模块化开发呢？\n\n事实上模块化开发最终的目的是将程序划分成一个个小的结构；\n这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；\n这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用；\n也可以通过某种方式，导入另外结构中的变量、函数、对象等；\n\n上面说提到的结构，就是模块；\n按照这种结构划分开发程序的过程，就是模块化开发的过程；\n无论你多么喜欢JavaScript，以及它现在发展的有多好，我们都需要承认在Brendan Eich用了10天写出JavaScript的时候，它都有很多的缺陷：\n\n比如var定义的变量作用域问题；\n比如JavaScript的面向对象并不能像常规面向对象语言一样使用class；\n比如JavaScript没有模块化的问题；\n\nBrendan Eich本人也多次承认过JavaScript设计之初的缺陷，但是随着JavaScript的发展以及标准化，存在的缺陷问题基本都得到了完善。\n\nJavaScript目前已经得到了快速的发展，无论是web、移动端、小程序端、服务器端、桌面应用都被广泛的使用；\n\n在网页开发的早期，Brendan Eich开发JavaScript仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的：\n\n这个时候我们只需要讲JavaScript代码写到标签中即可；\n并没有必要放到多个文件中来编写；\n\n&lt;button id&#x3D;&quot;btn&quot;&gt;按钮&lt;&#x2F;button&gt;\n\n&lt;script&gt;\n  document.getElementById(&quot;btn&quot;).onclick &#x3D; function() &#123;\n    console.log(&quot;按钮被点击了&quot;);\n  &#125;\n&lt;&#x2F;script&gt;\n\n但是随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂了：\n\najax的出现，前后端开发分离，意味着后端返回数据后，我们需要通过JavaScript进行前端页面的渲染；\nSPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现；\n包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤；\n\n所以，模块化已经是JavaScript一个非常迫切的需求：\n\n但是JavaScript本身，直到ES6（2015）才推出了自己的模块化方案；\n在此之前，为了让JavaScript支持模块化，涌现出了很多不同的模块化规范：AMD、CMD、CommonJS等；\n\n在这个章节，我们将详细学习JavaScript的模块化，尤其是CommonJS和ES6的模块化。\n1.2. 没有模块化的问题我们先来简单体会一下没有模块化代码的问题。\n我们知道，对于一个大型的前端项目，通常是多人开发的（即使一个人开发，也会将代码划分到多个文件夹中）：\n\n我们假设有两个人：小明和小丽同时在开发一个项目，并且会将自己的JavaScript代码放在一个单独的js文件中。\n\n小明开发了aaa.js文件，代码如下（当然真实代码会复杂的多）：\nvar flag &#x3D; true;\n\nif (flag) &#123;\n  console.log(&quot;aaa的flag为true&quot;)\n&#125;\n\n小丽开发了bbb.js文件，代码如下：\nvar flag &#x3D; false;\n\nif (!flag) &#123;\n  console.log(&quot;bbb使用了flag为false&quot;);\n&#125;\n\n很明显出现了一个问题：\n\n大家都喜欢使用flag来存储一个boolean类型的值；\n但是一个人赋值了true，一个人赋值了false；\n如果之后都不再使用，那么也没有关系；\n\n但是，小明又开发了ccc.js文件：\nif (flag) &#123;\n  console.log(&quot;使用了aaa的flag&quot;);\n&#125;\n\n问题来了：小明发现ccc中的flag值不对\n\n对于聪明的你，当然一眼就看出来，是小丽将flag赋值为了false；\n但是如果每个文件都有上千甚至更多的代码，而且有上百个文件，你可以一眼看出来flag在哪个地方被修改了吗？\n\n备注：引用路径如下：\n&lt;script src&#x3D;&quot;.&#x2F;aaa.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;.&#x2F;bbb.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;.&#x2F;ccc.js&quot;&gt;&lt;&#x2F;script&gt;\n\n所以，没有模块化对于一个大型项目来说是灾难性的。\n当然，我们有办法可以解决上面的问题：立即函数调用表达式（IIFE）\n\nIIFE (Immediately Invoked Function Expression)\n\naaa.js\nconst moduleA &#x3D; (function () &#123;\n  var flag &#x3D; true;\n\n  if (flag) &#123;\n    console.log(&quot;aaa的flag为true&quot;)\n  &#125;\n\n  return &#123;\n    flag: flag\n  &#125;\n&#125;)();\n\nbbb.js\nconst moduleB &#x3D; (function () &#123;\n  var flag &#x3D; false;\n\n  if (!flag) &#123;\n    console.log(&quot;bbb使用了flag为false&quot;);\n  &#125;\n&#125;)();\n\nccc.js\nconst moduleC &#x3D; (function() &#123;\n  const flag &#x3D; moduleA.flag;\n  if (flag) &#123;\n    console.log(&quot;使用了aaa的flag&quot;);\n  &#125;\n&#125;)();\n\n命名冲突的问题，有没有解决呢？解决了。\n但是，我们其实带来了新的问题：\n\n第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用；\n第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；\n第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况；\n\n所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。\n\n我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码；\n这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性；\n\nJavaScript社区为了解决上面的问题，涌现出一系列好用的规范，接下来我们就学习具有代表性的一些规范。\nCommonJS规范2.1. CommonJS和Node我们需要知道CommonJS是一个规范，最初提出来是在浏览器意外的地方使用，并且当时被命名为ServerJS，后来为了体现它的广泛性，修改为CommonJS，平时我们也会简称为CJS。\n\nNode是CommonJS在服务器端一个具有代表性的实现；\nBrowserify是CommonJS在浏览器中的一种实现；\nwebpack打包工具具备对CommonJS的支持和转换（后面我会讲到）；\n\n所以，Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：\n\n在Node中每一个js文件都是一个单独的模块；\n这个模块中包括CommonJS规范的核心变量：exports、module.exports、require；\n我们可以使用这些变量来方便的进行模块化开发；\n\n前面我们提到过模块化的核心是导出和导入，Node中对其进行了实现：\n\nexports和module.exports可以负责对模块中的内容进行导出；\nrequire函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；\n\n2.2. Node模块化开发我们来看一下两个文件：\nbar.js\nconst name &#x3D; &#39;coderwhy&#39;;\nconst age &#x3D; 18;\n\nfunction sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\nmain.js\nconsole.log(name);\nconsole.log(age);\n\nsayHello(&#39;kobe&#39;);\n\n上面的代码会报错：\n\n在node中每一个文件都是一个独立的模块，有自己的作用域；\n那么，就意味着别的模块main中不能随便访问另外一个模块bar中的内容；\nbar需要导出自己想要暴露的变量、函数、对象等等；\nmain从bar中导入自己想要使用的变量、函数、对象等等；\n\n导出和导入\n2.2.1. exports导出强调：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出\nbar.js中导出内容：\nexports.name &#x3D; name;\nexports.age &#x3D; age;\nexports.sayHello &#x3D; sayHello;\n\nmain.js中导入内容：\nconst bar &#x3D; require(&#39;.&#x2F;bar&#39;);\n\n上面这行代码意味着什么呢？\n\n意味着main中的bar变量等于exports对象；\n\nmain中的bar &#x3D; bar中的exports\n\n所以，我可以编写下面的代码：\nconst bar &#x3D; require(&#39;.&#x2F;bar&#39;);\n\nconst name &#x3D; bar.name;\nconst age &#x3D; bar.age;\nconst sayHello &#x3D; bar.sayHello;\n\nconsole.log(name);\nconsole.log(age);\n\nsayHello(&#39;kobe&#39;);\n\n\n模块之间的引用关系\n为了进一步论证，bar和exports是同一个对象：\n\n所以，bar对象是exports对象的浅拷贝；\n浅拷贝的本质就是一种引用的赋值而已；\n\n定时器修改对象\n2.2.2. module.exports但是Node中我们经常导出东西的时候，又是通过module.exports导出的：\n\nmodule.exports和exports有什么关系或者区别呢？\n\n我们追根溯源，通过维基百科中对CommonJS规范的解析：\n\nCommonJS中是没有module.exports的概念的；\n但是为了实现模块的导出，Node中使用的是Module的类，每一个模块都是Module的一个实例，也就是module；\n所以在Node中真正用于导出的其实根本不是exports，而是module.exports；\n因为module才是导出的真正实现者；\n\n但是，为什么exports也可以导出呢？\n\n这是因为module对象的exports属性是exports对象的一个引用；\n也就是说 module.exports = exports = main中的bar；\n\nimage-20201011163653515\n注意：真正导出的模块内容的核心其实是module.exports，只是为了实现CommonJS的规范，刚好module.exports对exports对象有一个引用而已；\n那么，如果我的代码这样修改了：\nimage-20201011164006266\n你能猜到内存中会有怎么样的表现吗？\n\n结论：和exports对象没有任何关系了，exports你随便玩自己的吧；\nmodule.exports我现在导出一个自己的对象，不带着你玩了；\n新的对象取代了exports对象的导出，那么就意味着require导入的对象是新的对象；\n\nimage-20201011164223607\n2.2.3. require细节我们现在已经知道，require是一个函数，可以帮助我们引入一个文件（模块）中导入的对象。\n那么，require的查找规则是怎么样的呢？\n\nhttps://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together\n\n这里我总结比较常见的查找规则：\n导入格式如下：require(X)\n\n情况一：X是一个核心模块，比如path、http\n\n\n直接返回核心模块，并且停止查找\n\n\n情况二：X是以 ./ 或 ../ 或 /（根目录）开头的\n\n\n查找目录下面的index文件\n\n\n1> 查找X/index.js文件\n\n2> 查找X/index.json文件\n\n3> 查找X/index.node文件\n\n1.如果有后缀名，按照后缀名的格式查找对应的文件\n\n2.如果没有后缀名，会按照如下顺序：\n\n1> 直接查找文件X\n\n2> 查找X.js文件\n\n3> 查找X.json文件\n\n4> 查找X.node文件\n\n第一步：将X当做一个文件在对应的目录下查找；\n\n第二步：没有找到对应的文件，将X作为一个目录\n\n如果没有找到，那么报错：not found\n\n情况三：直接是一个X（没有路径），并且X不是一个核心模块\n\n\n比如 /Users/coderwhy/Desktop/Node/TestCode/04_learn_node/05_javascript-module/02_commonjs/main.js中编写 require(&#39;why&#39;)\n\n\n查找顺序\n\n如果上面的路径中都没有找到，那么报错：not found\n\n\n2.2.4. 模块加载顺序这里我们研究一下模块的加载顺序问题。\n结论一：模块在被第一次引入时，模块中的js代码会被运行一次\naaa.js\nconst name &#x3D; &#39;coderwhy&#39;;\n\nconsole.log(&quot;Hello aaa&quot;);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimeout&quot;);\n&#125;, 1000);\n\nmain.js\nconst aaa &#x3D; require(&#39;.&#x2F;aaa&#39;);\n\naaa.js中的代码在引入时会被运行一次\n结论二：模块被多次引入时，会缓存，最终只加载（运行）一次\nmain.js\nconst aaa &#x3D; require(&#39;.&#x2F;aaa&#39;);\nconst bbb &#x3D; require(&#39;.&#x2F;bbb&#39;);\n\naaa.js\nconst ccc &#x3D; require(&quot;.&#x2F;ccc&quot;);\n\nbbb.js\nconst ccc &#x3D; require(&quot;.&#x2F;ccc&quot;);\n\nccc.js\nconsole.log(&#39;ccc被加载&#39;);\n\nccc中的代码只会运行一次。\n为什么只会加载运行一次呢？\n\n这是因为每个模块对象module都有一个属性：loaded。\n为false表示还没有加载，为true表示已经加载；\n\n结论三：如果有循环引入，那么加载顺序是什么？\n如果出现下面模块的引用关系，那么加载顺序是什么呢？\n\n这个其实是一种数据结构：图结构；\n图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）；\nNode采用的是深度优先算法：main -> aaa -> ccc -> ddd -> eee ->bbb\n\n多个模块的引入关系\n2.3. Node的源码解析Module类\n\nModule类\nModule.prototype.require函数\n\nrequire函数\nModule._load函数\n\n_load函数的实现\nAMD和CMD规范3.1. CommonJS规范缺点CommonJS加载模块是同步的：\n\n同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行；\n这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快；\n\n如果将它应用于浏览器呢？\n\n浏览器加载js文件需要先从服务器将文件下载下来，之后在加载运行；\n那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作；\n\n所以在浏览器中，我们通常不使用CommonJS规范：\n\n当然在webpack中使用CommonJS是另外一回事；\n因为它会将我们的代码转成浏览器可以直接执行的代码；\n\n在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD：\n\n但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换；\nAMD和CMD已经使用非常少了，所以这里我们进行简单的演练；\n\n3.2. AMD规范AMD主要是应用于浏览器的一种模块化规范：\n\nAMD是Asynchronous Module Definition（异步模块定义）的缩写；\n它采用的是异步加载模块；\n事实上AMD的规范还要早于CommonJS，但是CommonJS目前依然在被使用，而AMD使用的较少了；\n\n我们提到过，规范只是定义代码的应该如何去编写，只有有了具体的实现才能被应用：\n\nAMD实现的比较常用的库是require.js和curl.js；\n\n这里我们以require.js为例讲解：\n第一步：下载require.js\n\n下载地址：https://github.com/requirejs/requirejs\n找到其中的require.js文件；\n\n第二步：定义HTML的script标签引入require.js和定义入口文件：\n\ndata-main属性的作用是在加载完src的文件后会加载执行该文件\n\n&lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;require.js&quot; data-main&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n\n第三步：编写如下目录和代码\n├── index.html\n├── index.js\n├── lib\n│   └── require.js\n└── modules\n    ├── bar.js\n    └── foo.js\n\nindex.js\n(function() &#123;\n  require.config(&#123;\n    baseUrl: &#39;&#39;,\n    paths: &#123;\n      foo: &#39;.&#x2F;modules&#x2F;foo&#39;,\n      bar: &#39;.&#x2F;modules&#x2F;bar&#39;\n    &#125;\n  &#125;)\n \n  &#x2F;&#x2F; 开始加载执行foo模块的代码\n  require([&#39;foo&#39;], function(foo) &#123;\n\n  &#125;)\n&#125;)();\n\nmodules/bar.js\n\n如果一个模块不依赖其他，那么直接使用define(function)即可\n\ndefine(function() &#123;\n  const name &#x3D; &quot;coderwhy&quot;;\n  const age &#x3D; 18;\n  const sayHello &#x3D; function(name) &#123;\n    console.log(&quot;Hello &quot; + name);\n  &#125;\n\n  return &#123;\n    name,\n    age, \n    sayHello\n  &#125;\n&#125;)\n\nmodules/foo.js\ndefine([&#39;bar&#39;], function(bar) &#123;\n  console.log(bar.name);\n  console.log(bar.age);\n  bar.sayHello(&#39;kobe&#39;);\n&#125;)\n\n3.3. CMD规范CMD规范也是应用于浏览器的一种模块化规范：\n\nCMD 是Common Module Definition（通用模块定义）的缩写；\n它也采用了异步加载模块，但是它将CommonJS的优点吸收了过来；\n但是目前CMD使用也非常少了；\n\nCMD也有自己比较优秀的实现方案：\n\nSeaJS\n\n我们一起看一下SeaJS如何使用：\n第一步：下载SeaJS\n\n下载地址：https://github.com/seajs/seajs\n找到dist文件夹下的sea.js\n\n第二步：引入sea.js和使用主入口文件\n\nseajs是指定主入口文件的\n\n&lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;sea.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n  seajs.use(&#39;.&#x2F;index.js&#39;);\n&lt;&#x2F;script&gt;\n\n第三步：编写如下目录和代码\n├── index.html\n├── index.js\n├── lib\n│   └── sea.js\n└── modules\n    ├── bar.js\n    └── foo.js\n\nindex.js\ndefine(function(require, exports, module) &#123;\n  const foo &#x3D; require(&#39;.&#x2F;modules&#x2F;foo&#39;);\n&#125;)\n\nbar.js\ndefine(function(require, exports, module) &#123;\n  const name &#x3D; &#39;lilei&#39;;\n  const age &#x3D; 20;\n  const sayHello &#x3D; function(name) &#123;\n    console.log(&quot;你好 &quot; + name);\n  &#125;\n\n  module.exports &#x3D; &#123;\n    name,\n    age,\n    sayHello\n  &#125;\n&#125;)\n\nfoo.js\ndefine(function(require, exports, module) &#123;\n  const bar &#x3D; require(&#39;.&#x2F;bar&#39;);\n\n  console.log(bar.name);\n  console.log(bar.age);\n  bar.sayHello(&quot;韩梅梅&quot;);\n&#125;)\n\nES Module4.1. 认识ES ModuleJavaScript没有模块化一直是它的痛点，所以才会产生我们前面学习的社区规范：CommonJS、AMD、CMD等，所以在ES推出自己的模块化系统时，大家也是兴奋异常。\nES Module和CommonJS的模块化有一些不同之处：\n\n一方面它使用了import和export关键字；\n另一方面它采用编译期静态类型检测，并且动态引用的方式；\n\nES Module模块采用export和import关键字来实现模块化：\n\nexport负责将模块内的内容导出；\nimport负责从其他模块导入内容；\n\n了解：采用ES Module将自动采用严格模式：use strict\n\n如果你不熟悉严格模式可以简单看一下MDN上的解析；\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\n\n4.2. ES Module的使用4.2.1. 代码结构组件这里我在浏览器中演示ES6的模块化开发：\n代码结构如下：\n├── index.html\n├── main.js\n└── modules\n    └── foo.js\n\nindex.html中引入两个js文件作为模块：\n&lt;script src&#x3D;&quot;.&#x2F;modules&#x2F;foo.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;main.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;\n\n如果直接在浏览器中运行代码，会报如下错误：\n\n模块化运行\n这个在MDN上面有给出解释：\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules\n你需要注意本地测试 — 如果你通过本地加载Html 文件 (比如一个 file:// 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。\n你需要通过一个服务器来测试。\n\n我这里使用的VSCode，VSCode中有一个插件：Live Server\n\n通过插件运行，可以将我们的代码运行在一个本地服务中；\n\nimage-20201012153439900\n4.2.2. export关键字export关键字将一个模块中的变量、函数、类等导出；\nfoo.js文件中默认代码如下：\nconst name &#x3D; &#39;coderwhy&#39;;\nconst age &#x3D; 18;\nlet message &#x3D; &quot;my name is why&quot;;\n\nfunction sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\n我们希望将其他中内容全部导出，它可以有如下的方式：\n方式一：在语句声明的前面直接加上export关键字\nexport const name &#x3D; &#39;coderwhy&#39;;\nexport const age &#x3D; 18;\nexport let message &#x3D; &quot;my name is why&quot;;\n\nexport function sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\n方式二：将所有需要导出的标识符，放到export后面的 &#123;&#125;中\n\n注意：这里的 &#123;&#125;里面不是ES6的对象字面量的增强写法，&#123;&#125;也不是表示一个对象的；\n所以：export &#123;name: name&#125;，是错误的写法；\n\nconst name &#x3D; &#39;coderwhy&#39;;\nconst age &#x3D; 18;\nlet message &#x3D; &quot;my name is why&quot;;\n\nfunction sayHello(name) &#123;\n  console.log(&quot;Hello &quot; + name);\n&#125;\n\nexport &#123;\n  name,\n  age,\n  message,\n  sayHello\n&#125;\n\n方式三：导出时给标识符起一个别名\nexport &#123;\n  name as fName,\n  age as fAge,\n  message as fMessage,\n  sayHello as fSayHello\n&#125;\n\n4.2.3. import关键字import关键字负责从另外一个模块中导入内容\n导入内容的方式也有多种：\n方式一：import &#123;标识符列表&#125; from &#39;模块&#39;；\n\n注意：这里的&#123;&#125;也不是一个对象，里面只是存放导入的标识符列表内容；\n\nimport &#123; name, age, message, sayHello &#125; from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nconsole.log(name)\nconsole.log(message);\nconsole.log(age);\nsayHello(&quot;Kobe&quot;);\n\n方式二：导入时给标识符起别名\nimport &#123; name as wName, age as wAge, message as wMessage, sayHello as wSayHello &#125; from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\n方式三：将模块功能放到一个模块功能对象（a module object）上\nimport * as foo from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nconsole.log(foo.name);\nconsole.log(foo.message);\nconsole.log(foo.age);\nfoo.sayHello(&quot;Kobe&quot;);\n\n4.2.4. export和import结合如果从一个模块中导入的内容，我们希望再直接导出出去，这个时候可以直接使用export来导出。\nbar.js中导出一个sum函数：\nexport const sum &#x3D; function(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nfoo.js中导入，但是只是做一个中转：\nexport &#123; sum &#125; from &#39;.&#x2F;bar.js&#39;;\n\nmain.js直接从foo中导入：\nimport &#123; sum &#125; from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\nconsole.log(sum(20, 30));\n\n甚至在foo.js中导出时，我们可以变化它的名字\nexport &#123; sum as barSum &#125; from &#39;.&#x2F;bar.js&#39;;\n\n为什么要这样做呢？\n\n在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中；\n这样方便指定统一的接口规范，也方便阅读；\n这个时候，我们就可以使用export和import结合使用；\n\n4.2.4. default用法前面我们学习的导出功能都是有名字的导出（named exports）：\n\n在导出export时指定了名字；\n在导入import时需要知道具体的名字；\n\n还有一种导出叫做默认导出（default export）\n\n默认导出export时可以不需要指定名字；\n在导入时不需要使用 &#123;&#125;，并且可以自己来指定名字；\n它也方便我们和现有的CommonJS等规范相互操作；\n\n导出格式如下：\nexport default function sub(num1, num2) &#123;\n  return num1 - num2;\n&#125;\n\n导入格式如下：\nimport sub from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nconsole.log(sub(20, 30));\n\n注意：在一个模块中，只能有一个默认导出（default export）；\n4.2.5. import()通过import加载一个模块，是不可以在其放到逻辑代码中的，比如：\nif (true) &#123;\n  import sub from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n&#125;\n\n为什么会出现这个情况呢？\n\n这是因为ES Module在被JS引擎解析时，就必须知道它的依赖关系；\n由于这个时候js代码没有任何的运行，所以无法在进行类似于if判断中根据代码的执行情况；\n甚至下面的这种写法也是错误的：因为我们必须到运行时能确定path的值；\n\nconst path &#x3D; &#39;.&#x2F;modules&#x2F;foo.js&#39;;\n\nimport sub from path;\n\n但是某些情况下，我们确确实实希望动态的来加载某一个模块：\n\n如果根据不懂的条件，动态来选择加载模块的路径；\n这个时候我们需要使用 import() 函数来动态加载；\n\naaa.js模块：\nexport function aaa() &#123;\n  console.log(&quot;aaa被打印&quot;);\n&#125;\n\nbbb.js模块：\nexport function bbb() &#123;\n  console.log(&quot;bbb被执行&quot;);\n&#125;\n\nmain.js模块：\nlet flag &#x3D; true;\nif (flag) &#123;\n  import(&#39;.&#x2F;modules&#x2F;aaa.js&#39;).then(aaa &#x3D;&gt; &#123;\n    aaa.aaa();\n  &#125;)\n&#125; else &#123;\n  import(&#39;.&#x2F;modules&#x2F;bbb.js&#39;).then(bbb &#x3D;&gt; &#123;\n    bbb.bbb();\n  &#125;)\n&#125;\n\n4.3. ES Module的原理4.3.1. ES Module和CommonJS的区别CommonJS模块加载js文件的过程是运行时加载的，并且是同步的：\n\n运行时加载意味着是js引擎在执行js代码的过程中加载 模块；\n同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行；\n\nconsole.log(&quot;main代码执行&quot;);\n\nconst flag &#x3D; true;\nif (flag) &#123;\n  &#x2F;&#x2F; 同步加载foo文件，并且执行一次内部的代码\n  const foo &#x3D; require(&#39;.&#x2F;foo&#39;);\n  console.log(&quot;if语句继续执行&quot;);\n&#125;\n\nCommonJS通过module.exports导出的是一个对象：\n\n导出的是一个对象意味着可以将这个对象的引用在其他模块中赋值给其他变量；\n但是最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改；\n\nES Module加载js文件的过程是编译（解析）时加载的，并且是异步的：\n\n编译时（解析）时加载，意味着import不能和运行时相关的内容放在一起使用：\n\n\n比如from后面的路径需要动态获取；\n\n\n比如不能将import放到if等语句的代码块中；\n\n所以我们有时候也称ES Module是静态解析的，而不是动态或者运行时解析的；\n\n异步的意味着：JS引擎在遇到import时会去获取这个js文件，但是这个获取的过程是异步的，并不会阻塞主线程继续执行；\n\n\n也就是说设置了 type=module 的代码，相当于在script标签上也加上了 async 属性；\n\n\n如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行；\n\n\n&lt;script src&#x3D;&quot;main.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;\n&lt;!-- 这个js文件的代码不会被阻塞执行 --&gt;\n&lt;script src&#x3D;&quot;index.js&quot;&gt;&lt;&#x2F;script&gt;\n\nES Module通过export导出的是变量本身的引用：\n\nexport在导出一个变量时，js引擎会解析这个语法，并且创建模块环境记录（module environment record）；\n模块环境记录会和变量进行 绑定（binding），并且这个绑定是实时的；\n而在导入的地方，我们是可以实时的获取到绑定的最新值的；\n\nexport和import绑定的过程\n所以我们下面的代码是成立的：\nbar.js文件中修改\nlet name &#x3D; &#39;coderwhy&#39;;\n\nsetTimeout(() &#x3D;&gt; &#123;\n  name &#x3D; &quot;湖人总冠军&quot;;\n&#125;, 1000);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(name);\n&#125;, 2000);\n\nexport &#123;\n  name\n&#125;\n\nmain.js文件中获取\nimport &#123; name &#125; from &#39;.&#x2F;modules&#x2F;bar.js&#39;;\n\nconsole.log(name);\n\n&#x2F;&#x2F; bar中修改, main中验证\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(name);\n&#125;, 2000);\n\n但是，下面的代码是不成立的：main.js中修改\nimport &#123; name &#125; from &#39;.&#x2F;modules&#x2F;bar.js&#39;;\n\nconsole.log(name);\n\n&#x2F;&#x2F; main中修改, bar中验证\nsetTimeout(() &#x3D;&gt; &#123;\n  name &#x3D; &#39;kobe&#39;;\n&#125;, 1000);\n\n导入的变量不可以被修改\n思考：如果bar.js中导出的是一个对象，那么main.js中是否可以修改对象中的属性呢？\n\n答案是可以的，因为他们指向同一块内存空间；（自己编写代码验证，这里不再给出）\n\n4.3.2. Node中支持 ES Module在Current版本中\n在最新的Current版本（v14.13.1）中，支持es module我们需要进行如下操作：\n\n方式一：在package.json中配置 type: module（后续再学习，我们现在还没有讲到package.json文件的作用）\n方式二：文件以 .mjs 结尾，表示使用的是ES Module；\n\n这里我们暂时选择以 .mjs 结尾的方式来演练：\nbar.mjs\nconst name &#x3D; &#39;coderwhy&#39;;\n\nexport &#123;\n  name\n&#125;\n\nmain.mjs\nimport &#123; name &#125; from &#39;.&#x2F;modules&#x2F;bar.mjs&#39;;\n\nconsole.log(name);\n\n在LTS版本中\n在最新的LST版本（v12.19.0）中，我们也是可以正常运行的，但是会报一个警告：\nlts版本的警告\n4.3.3. ES Module和CommonJS的交互CommonJS加载ES Module\n结论：通常情况下，CommonJS不能加载ES Module\n\n因为CommonJS是同步加载的，但是ES Module必须经过静态分析等，无法在这个时候执行JavaScript代码；\n但是这个并非绝对的，某些平台在实现的时候可以对代码进行针对性的解析，也可能会支持；\nNode当中是不支持的；\n\nES Module加载CommonJS\n结论：多数情况下，ES Module可以加载CommonJS\n\nES Module在加载CommonJS时，会将其module.exports导出的内容作为default导出方式来使用；\n这个依然需要看具体的实现，比如webpack中是支持的、Node最新的Current版本也是支持的；\n但是在最新的LTS版本中就不支持；\n\nfoo.js\nconst address &#x3D; &#39;foo的address&#39;;\n\nmodule.exports &#x3D; &#123;\n  address\n&#125;\n\nmain.js\nimport foo from &#39;.&#x2F;modules&#x2F;foo.js&#39;;\nconsole.log(foo.address);\n","slug":"node/base/Node基础三","date":"2022-10-01T04:23:22.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"a6a1fb5bcb751ccc4e9548f88f960a7a","title":"Node基础二","content":"二.node基础1.1. JavaScript文件执行如果我们编写一个js文件，里面存放JavaScript代码，如何来执行它呢？\n&#x2F;&#x2F; 1.直接打印一段文字\nconsole.log(&quot;我是一段JavaScript代码&quot;);\n\n&#x2F;&#x2F; 2.定义一个函数, 调用这个函数\nfunction sum(num1, num2) &#123;\n  return num1 + num2;\n&#125;\n\nconst result &#x3D; sum(20, 30);\nconsole.log(&quot;计算结果:&quot;, result);\n\n&#x2F;&#x2F; 3.执行定时器代码\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;2s后执行的代码&quot;);\n&#125;, 2000);\n\n目前我们知道有两种方式可以执行：\n\n将代码交给浏览器执行；\n将代码载入到node环境中执行；\n\n演练一：浏览器执行\n如果我们希望把代码交给浏览器执行：\n\n需要通过让浏览器加载、解析html代码，所以我们需要创建一个html文件；\n在html中通过script标签，引入js文件；\n当浏览器遇到script标签时，就会根据src加载、执行JavaScript代码；\n\nindex.html文件：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script src&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n浏览器执行结果\n演练二：Node执行\n如果我们希望把js文件交给node执行：\n\n首先电脑上需要安装Node.js环境，安装过程中会自动配置环境变量；\n可以通过终端命令node js文件的方式来载入和执行对应的js文件；\n\nnode index.js\n\nNode执行结果\n1.2. Node的REPL什么是REPL呢？感觉挺高大上\n\nREPL是Read-Eval-Print Loop的简称，翻译为“读取-求值-输出”循环；\nREPL是一个简单的，交互式的编程环境；\n\n事实上，我们浏览器的console就可以看成一个REPL：\n浏览器控台\nNode也给我们提供了一个REPL环境，我们可以在其中演练简单的代码：\nREPL演练\n2.1. 给node程序传递参数正常情况下执行一个node程序，直接跟上我们对应的文件即可：\nnode index.js\n\n但是，在某些情况下执行node程序的过程中，我们可能希望给node传递一些参数：\nnode index.js env&#x3D;development coderwhy\n\n如果我们这样来使用程序，就意味着我们需要在程序中获取到传递的参数：\n\n获取参数其实是在process的内置对象中的；\n\n如果我们直接打印这个内置对象，它里面包含特别的信息：\n\n其他的一些信息，比如版本、操作系统等大家可以自行查看，后面用到一些其他的我们还会提到；\n\nprocess对象\n现在，我们先找到其中的argv属性：\n\n我们发现它是一个数组，里面包含了我们需要的参数；\n你可能有个疑问，为什么叫argv呢？\n\nargv属性\n在C&#x2F;C++程序中的main函数中，实际上可以获取到两个参数：\n\nargc：argument counter的缩写，传递参数的个数；\n\nargv：argument vector的缩写，传入的具体参数。\n\n\nvector翻译过来是矢量的意思，在程序中表示的是一种数据结构。\n\n\n在C++、Java中都有这种数据结构，是一种数组结构；\n\n在JavaScript中也是一个数组，里面存储一些参数信息；\n\n\n我们可以在代码中，将这些参数信息遍历出来，使用：\n&#x2F;&#x2F; 获取参数\nconsole.log(process.argv);\nprocess.argv.forEach(item &#x3D;&gt; &#123;\n  console.log(item);\n&#125;);\n\n&#x2F;&#x2F; 结果如下：\n&#x2F;&#x2F; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;02_给Node传递参数&#x2F;index.js\n&#x2F;&#x2F; ENV&#x3D;dev\n&#x2F;&#x2F; coderwhy\n\n2.2. node程序输出内容console.log\n最常用的输入内容的方式：console.log\nconsole.log(&quot;hello coderwhy&quot;);\n\nconsole.clear\n清空控制台：console.clear\nconsole.clear\n\nconsole.trace\n打印函数的调用栈：console.trace\nfunction test() &#123;\n  demo();\n&#125;\nfunction demo() &#123;\n  foo();\n&#125;\nfunction foo() &#123;\n  console.trace();\n&#125;\ntest();\n\nconsole.trace结果\n还有一些其他的方法，其他的一些console方法，可以自己在下面学习研究一下。\nimage-20201008163045395\n3.1. 常见的全局对象Node中给我们提供了一些全局对象，方便我们进行一些操作：\n\n这些全局对象，我们并不需要从一开始全部一个个学习；\n某些全局对象并不常用，某些全局对象我们会在后续学习中讲到；\n比如module、exports、require()会在模块化中讲到；\n比如Buffer后续会专门讲到；\n\n全局对象\n3.2. 特殊的全局对象为什么我称之为特殊的全局对象呢？\n\n这些全局对象可以在模块中任意使用，但是在命令行交互中是不可以使用的；\n包括：__dirname、__filename、exports、module、require()\n\n__dirname\n获取当前文件所在的路径：\n\n注意：不包括后面的文件名\n\nconsole.log(__dirname);\n\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;03_常见的全局变量\n\n__filename\n获取当前文件所在的路径和文件名称：\n\n注意：包括后面的文件名称\n\nconsole.log(__filename);\n&#x2F;&#x2F; &#x2F;Users&#x2F;coderwhy&#x2F;Desktop&#x2F;Node&#x2F;TestCode&#x2F;04_learn_node&#x2F;03_常见的全局变量&#x2F;global对象.js\n\n3.3. 常见的全局对象process对象\nprocess提供了Node进程中相关的信息：\n\n比如Node的运行环境、参数信息等；\n后面在项目中，我也会讲解，如何将一些环境变量读取到 process 的 env 中；\n\nconsole.log(process);\n\nconsole对象\n提供了简单的调试控制台，在前面讲解输入内容时已经学习过了。\n\n更加详细的查看官网文档：https://nodejs.org/api/console.html\n\n定时器函数\n在Node中使用定时器有好几种方式：\n\nsetTimeout(callback, delay[, ...args])：callback在delay毫秒后执行一次；\n\nsetInterval(callback, delay[, ...args])：callback每delay毫秒重复执行一次；\n\nsetImmediate(callback[, ...args])：callbackI &#x2F; O事件后的回调的“立即”执行；\n\n\n这里先不展开讨论它和setTimeout(callback, 0)之间的区别；\n\n\n因为它涉及到事件循环的阶段问题，我会在后续详细讲解事件循环相关的知识；\n\nprocess.nextTick(callback[, ...args])：添加到下一次tick队列中；\n\n\n具体的讲解，也放到事件循环中说明；\n\n\n\n代码演练：\n\n暂时不用关心执行顺序问题，在后续事件循环中我会讲到；\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimtout&quot;);\n&#125;, 1000);\n\nsetInterval(() &#x3D;&gt; &#123;\n  console.log(&#39;setInterval&#39;);\n&#125;, 1000);\n\nsetImmediate(() &#x3D;&gt; &#123;\n  console.log(&quot;setImmediate&quot;);\n&#125;);\n\nprocess.nextTick(() &#x3D;&gt; &#123;\n  console.log(&quot;process.nextTick&quot;);\n&#125;);\n\n当然，它们有对应的取消定时器的方法：\n\nclearTimeout(timeoutObject);\nclearInterval(intervalObject);\nclearImmediate(immediateObject)\n\nglobal对象\nglobal是一个全局对象，事实上前端我们提到的process、console、setTimeout等都有被放到global中：\nconsole.log(process);\nconsole.log(global.process);\n\n为什么结果是一样的呢？\nNode的源码\nglobal中还有哪些属性呢？\nglobal其他属性的查看\nwindow和global的区别是什么？\n在浏览器中，全局变量都是在window上的，比如有document、setInterval、setTimeout、alert、console等等\n在Node中，我们也有一个global属性，并且看起来它里面有很多其他对象。\n但是在浏览器中执行的JavaScript代码，如果我们在顶级范围内通过var定义的一个属性，默认会被添加到window对象上：\nvar name &#x3D; &#39;coderwhy&#39;;\nconsole.log(window.name); &#x2F;&#x2F; coderwhy\n\n但是在node中，我们通过var定义一个变量，它只是在当前模块中有一个变量，不会放到全局中：\nvar name &#x3D; &#39;coderwhy&#39;;\nconsole.log(global.name); &#x2F;&#x2F; undefined\n","slug":"node/base/Node基础二","date":"2022-10-01T04:06:20.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"16ea75a74e45c427c7de22a19d8e1e05","title":"Node基础一","content":"一.JavaScript运行原理1.1. Atwood定律官方对Node.js的定义：\n\nNode.js是一个基于V8 JavaScript引擎的JavaScript运行时环境。\n\n什么是JavaScript运行环境？\n\n为什么JavaScript需要特别的运行环境呢？\n\n什么又是JavaScript引擎？\n\n什么是V8？\n\n\n我们先来把这些概念搞清楚，再去看Node到底是什么？\nStack Overflow的创立者之一的 Jeff Atwood 在2007年提出了著名的 Atwood定律：\n\nAny application that can be written in JavaScript, will eventually be written in JavaScript.\n任何可以使用JavaScript来实现的应用都最终都会使用JavaScript实现\n\n但是在发明之初，JavaScript的目的是应用于在浏览器执行简单的脚本任务，对浏览器以及其中的DOM进行各种操作，所以JavaScript的应用场景非常受限。\n\nAtwood定律更像是一种美好的远景，在当时看来还没有实现的可能性。\n但是随着Node的出现，Atwood定律已经越来越多的被证实是正确的。\n\n但是为了可以理解Node.js到底是如何帮助我们做到这一点的，我们必须了解JavaScript是如何被运行的。\n1.2. 浏览器内核我们经常会说：不同的浏览器有不同的内核组成\n\nGecko：早期被Netscape和Mozilla Firefox浏览器浏览器使用；\nTrident：微软开发，被IE4~IE11浏览器使用，但是Edge浏览器已经转向Blink；\nWebkit：苹果基于KHTML开发、开源的，用于Safari，Google Chrome之前也在使用；\nBlink：是Webkit的一个分支，Google开发，目前应用于Google Chrome、Edge、Opera等；\n\n事实上，我们经常说的浏览器内核指的是浏览器的排版引擎：\n\n排版引擎（layout engine），也称为浏览器引擎（browser engine）、页面渲染引擎（rendering engine）或样版引擎。\n\nWebKit main flow\n但是在这个执行过程中，HTML解析的时候遇到了JavaScript标签，应该怎么办呢？\n\n会停止解析HTML，而去加载和执行JavaScript代码；\n\n当然，为什么不直接异步去加载执行JavaScript代码，而要在这里停止掉呢？\n\n这是因为JavaScript代码可以操作我们的DOM；\n所以浏览器希望将HTML解析的DOM和JavaScript操作之后的DOM放到一起来生成最终的DOM树，而不是频繁的去生成新的DOM树；\n\n那么，JavaScript代码由谁来执行呢？\n\nJavaScript引擎\n\n1.3. JavaScript引擎为什么需要JavaScript引擎呢？\n\n事实上我们编写的JavaScript无论你交给浏览器或者Node执行，最后都是需要被CPU执行的；\n但是CPU只认识自己的指令集，实际上是机器语言，才能被CPU所执行；\n所以我们需要JavaScript引擎帮助我们将JavaScript代码翻译成CPU指令来执行；\n\n比较常见的JavaScript引擎有哪些呢？\n\nSpiderMonkey：第一款JavaScript引擎，由Brendan Eich开发（也就是JavaScript作者）；\nChakra：微软开发，用于IT浏览器；\nJavaScriptCore：WebKit中的JavaScript引擎，Apple公司开发；\nV8：Google开发的强大JavaScript引擎，也帮助Chrome从众多浏览器中脱颖而出；\n\n这里我们先以WebKit为例，WebKit事实上由两部分组成的：\n\nWebCore：负责HTML解析、布局、渲染等等相关的工作；\nJavaScriptCore：解析、执行JavaScript代码；\n\nwebkit内核\n看到这里，学过小程序的同学有没有感觉非常的熟悉呢？\n\n在小程序中编写的JavaScript代码就是被JSCore执行的；\n\n\n另外一个强大的JavaScript引擎就是V8引擎。\n1.4. V8引擎我们来看一下官方对V8引擎的定义：\n\nV8是用C ++编写的Google开源高性能JavaScript和WebAssembly引擎，它用于Chrome和Node.js等。\n它实现ECMAScript和WebAssembly，并在Windows 7或更高版本，macOS 10.12+和使用x64，IA-32，ARM或MIPS处理器的Linux系统上运行。\nV8可以独立运行，也可以嵌入到任何C ++应用程序中。\n\nV8引擎本身的源码非常复杂，大概有超过100w行C++代码，但是我们可以简单了解一下它执行JavaScript代码的原理：\n\nParse模块会将JavaScript代码转换成AST（抽象语法树），这是因为解释器并不直接认识JavaScript代码；\n\n\n如果函数没有被调用，那么是不会被转换成AST的；\n\n\nParse的V8官方文档：https://v8.dev/blog/scanner\n\nIgnition是一个解释器，会将AST转换成ByteCode（字节码）\n\n\n同时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）；\n\n\n如果函数只调用一次，Ignition会执行解释执行ByteCode；\n\nIgnition的V8官方文档：https://v8.dev/blog/ignition-interpreter\n\nTurboFan是一个编译器，可以将字节码编译为CPU可以直接执行的机器码；\n\n\n如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能；\n\n\n但是，机器码实际上也会被还原为ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如sum函数原来执行的是number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码；\n\nTurboFan的V8官方文档：https://v8.dev/blog/turbofan-jit\n\n\nimage-20200924165143332\n上面是JavaScript代码的执行过程，事实上V8的内存回收也是其强大的另外一个原因，这里暂时先不展开讨论：\n\nOrinoco模块，负责垃圾回收，将程序中不需要的内存回收；\nOrinoco的V8官方文档：https://v8.dev/blog/trash-talk\n\n2.1. Node.js是什么？回顾：官方对Node.js的定义：\n\nNode.js是一个基于V8 JavaScript引擎的JavaScript运行时环境。\n\nimage-20200924193328076\n也就是说Node.js基于V8引擎来执行JavaScript的代码，但是不仅仅只有V8引擎：\n\n前面我们知道Node.js可以嵌入到任何C ++应用程序中，无论是Chrome还是Node.js，事实上都是嵌入了V8引擎来执行JavaScript代码；\n但是在Chrome浏览器中，还需要解析、渲染HTML、CSS等相关渲染引擎，另外还需要提供支持浏览器操作的API、浏览器自己的事件循环等；\n另外，在Node.js中我们也需要进行一些额外的操作，比如文件系统读&#x2F;写、网络IO、加密、压缩解压文件等操作；\n\n所以，我们可以简单理解规划出Node.js和浏览器的差异：\nChrome浏览器和Node架构区别\n这里也有一份单独的Node.js的架构图：\n\n我们编写的JavaScript代码会经过V8引擎，再通过Node.js的Bindings，将任务放到Libuv的事件循环中；\nlibuv（Unicorn Velociraptor—独角伶盗龙）是使用C语言编写的库；\nlibuv提供了事件循环、文件系统读写、网络IO、线程池等等内容；\n具体内部代码的执行流程，我会在后续专门讲解事件和异步IO的原理中详细讲解；\n\nWhat is Node.js? Where, when and how to use it with examples\n2.2. Node.js可以做什么？了解了Node.js的架构，那么使用它我们可以做什么呢？\n\n前面我们提到，Node.js的出现，真正让Atwood定律变成了现实，Node.js的应用场景也越来越多。\n\n我们可以使用基于Node.js的Electron开发出类似于VSCode这种强大的桌面应用程序。另外前端自动化、模块化打包工具gulp、webpack也是基于Node.js开发和使用的。\nNode.js的快速发展也让企业对Node.js技术越来越重视，在前端招聘中通常会对Node.js有一定的要求，特别对于高级前端开发工程师，Node.js更是必不可少的技能：\n前端工程师岗位需求\n目前前端开发的库都是以node包的形式进行管理；\n\nnpm、yarn工具成为前端开发使用最多的工具；\n越来越多的公司使用Node.js作为web服务器开发；\n大量项目需要借助Node.js完成前后端渲染的同构应用；\n资深前端工程师需要为项目编写脚本工具（前端工程师编写脚本通常会使用JavaScript，而不是Python或者shell）；\n很多企业在使用Electron来开发桌面应用程序；\n\n总结一下，目前Node.js到底有哪些应用场景呢？\n\n前后端页面渲染\n\n\n支持项目同构开发\n\n\n对于需要进行首屏优化、SEO的页面进行后端渲染\n\n开发命令行工具\n\n\nwebpack、gulp等都是基于Node\n\n\n开发自己独立的命令行工具（类似于shell、Python做的事情，对于前端更加友好）\n\n桌面应用的开发\n\n\n类似于VSCode这种强大的桌面应用\n\n\n甚至开发桌面端类似于wayward大型游戏\n\n进行服务器开发\n\n\n拥有类似express、koa等强大的web框架\n\n\n开发Web Socket等服务器\n\n\n所以，作为前端开发工程师，Node.js已经是我们必须掌握的核心技术。\n2.3. Node.js的安装2.3.1. Node.js下载安装Node.js是在2009年诞生的，目前最新的版本是分别是12.18.4以及14.12.0：\n\nLTS版本：相对稳定一些，推荐线上环境使用该版本；\nCurrent版本：最新的Node版本，包含很多新特性；\n\nnode的版本\n这些我们选择什么版本呢？\n\n如果你是学习使用，可以选择current版本；\n如果你是公司开发，建议选择LTS版本；\n\nNode的安装方式有很多：\n\n可以借助于一些操作系统上的软件管理工具，比如Mac上的homebrew，Linux上的yum、dnf等；\n也可以直接下载对应的安装包下载安装；\n\n我们选择下载安装，下载自己操作系统的安装包直接安装就可以了：\n\nwindow选择.msi安装包，Mac选择.pkg安装包，Linux会在后续部署中讲解；\n安装过程中会配置环境变量；\n并且安装node过程中会安装npm（Node Package Manager）工具；\n\n我当前电脑上的版本：\n\nnode版本是12.16.1；\nnpm版本是6.14.8；\n\n我的node版本\n你应该已经发现，我这里使用的版本并不是Node的最新版本，无论是LTS或者Current：\n\n正好借助这里，和大家讲一下node的版本升级；\n\n2.3.2. Node.js版本管理在实际开发学习中，我们只需要使用一个Node版本来开发或者学习即可。\n但是，如果你希望通过可以快速更新或切换多个版本时，可以借助于一些工具：\n\nnvm：Node Version Manager；\nn：Interactively Manage Your Node.js Versions（交互式管理你的Node.js版本）\n\n这里我演示管理工具：n\n\nn是TJ方便node的版本管理，专门开发的；\n官方介绍是：n -  Interactively Manage Your Node.js Versions（交互式管理你的Node.js版本）\n\n安装n：直接使用npm安装即可\n# 安装工具n\nnpm install -g n\n# 查看安装的版本\nn --version\n\n安装最新的lts版本：\n\n前面添加的sudo是权限问题；\n可以两个版本都安装，之后我们可以通过n快速在两个版本间切换；\n\n# 安装最新的lts版本\nn lts\n\n# 安装最新的版本\nn latest\n\n安装lts版本\n查看所有的版本，并且选择要使用的版本：\n\n可以上下选择想使用的版本\n\n# 查看所有的版本\nn\n\n查看和选择所有的版本\n查看当前Node的版本：\n查看当前的版本\n问题：这两个工具都不支持window\n\nn：n is not supported natively on Windows.\nnvm：nvm does not support Windows\n\nWindow的同学怎么办？\n\n1.并不是每个人都需要安装多个版本，在课堂上我会以最新的Current版本讲解几乎所有内容；\n2.接下来我会在Mac上面演练n工具的使用，windows上可以使用nvm-window来完成；\n\n","slug":"node/base/Node基础一","date":"2022-09-30T15:33:43.000Z","categories_index":"Node","tags_index":"Node Node基础系列","author_index":"ChrisWood"},{"id":"18dd7f629894be8963e8c1c6b1ef8456","title":"Nginx常用操作及配置","content":"Nginx常用操作及配置常用操作#强制停止Nginx\nkill -9 nginx \nstart nginx\nnginx -s quit\nnginx -s reload\n\n常见配置# 进程数量\nworker_processes 1;\n\nevents &#123;\n  # 最大连接数量\n  worker_connections 1024;\n&#125;\n\nhttp &#123;\n  include mime.types;\n  default_type application&#x2F;octet-stream;\n  sendfile on;\n  keepalive_timeout 65;\n\n  # 演示如何强制http跳转https\n  server &#123;\n    listen 80;\n    server_name test.com;\n\n    # http强制跳转到https\n    rewrite ^(.*)$ https:&#x2F;&#x2F;$server_name$1 permanent;\n  &#125;\n\n  # 演示如何配置微信支付的校验文件\n  server &#123;\n    listen 80;\n    server_name localhost;\n\n    # 默认根路径\n    location &#x2F; &#123;\n      root index.html;\n    &#125;\n    # 微信支付校验文件，可以直接配置访问名称\n    location ^~&#x2F;MP_verify_2g3uEjrB5B2LIbNl.txt &#123;\n      alias &#x2F;home&#x2F;MP_verify_2g3uEjrB5B2LIbNl.txt;\n    &#125;\n    # 微信支付校验文件，也可以通过正则配置\n    location ~^&#x2F;MP_verify_[a-zA-Z0-9]*\\.(txt)$ &#123;\n      root &#x2F;home&#x2F;;\n      rewrite ^&#x2F;home&#x2F;(.txt)$ &#x2F;home&#x2F;$1 last;\n    &#125;\n  &#125;\n\n  # 演示root和alias两种配置静态资源的区别\n  server &#123;\n    listen 80;\n    server_name localhost;\n\n    # 用root方式，location中的路径会拼加到root的地址后面\n    # 请求路径为：http:&#x2F;&#x2F;localhost:8080&#x2F;files&#x2F;index.jpg    实际访问为：&#x2F;home&#x2F;files&#x2F;index.jpg\n    location ~^&#x2F;files&#x2F; &#123;\n      root &#x2F;home&#x2F;;\n      index index.html index.htm;\n    &#125;\n    # 用alias方式，location中的路径不会拼加到alias的地址后面\n    # 这请求路径为：http:&#x2F;&#x2F;localhost:8080&#x2F;files&#x2F;index.jpg    实际访问为：&#x2F;home&#x2F;index.jpg\n    location ~^&#x2F;files&#x2F; &#123;\n      alias &#x2F;home&#x2F;;\n      index index.html index.htm;\n    &#125;\n  &#125;\n\n  # 演示请求后台接口代理配置\n  server &#123;\n    listen 8080;\n    server_name localhost;\n\n    #################### 第一种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;api&#x2F;getUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际指向为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;api&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n\n    #################### 第二种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;getUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n\n    #################### 第三种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;usergetUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n\n    #################### 第四种场景 ####################\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;getUser\n    location ^~&#x2F;api&#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n    # 请求路径为：http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;getUser   实际代理为：http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;&#x2F;getUser\n    location ^~&#x2F;api &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;user&#x2F;;\n      proxy_set_header Host $http_host; #后台可以获取到完整的ip+端口号\n      proxy_set_header X-Real-IP $remote_addr; #后台可以获取到用户访问的真实ip地址\n    &#125;\n  &#125;\n\n  # 演示前端项目部署加访问前缀的nginx配置\n  server &#123;\n    listen 8090;\n    server_name localhost;\n\n    # 部署路径：&#x2F;home&#x2F;web&#x2F;my_demo\n    # 访问路径为：http:&#x2F;&#x2F;localhost:8090&#x2F;\n    location &#x2F; &#123;\n      try_files $uri $uri&#x2F; &#x2F;index.html;\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header Host $http_host;\n      root &#x2F;home&#x2F;web&#x2F;my_demo&#x2F;;\n      index index.html index.htm;\n    &#125;\n\n    # 部署路径：&#x2F;home&#x2F;web&#x2F;my_demo\n    # 访问路径为：http:&#x2F;&#x2F;localhost:8090&#x2F;my_demo&#x2F;\n    # 如果location路径最后没有配置斜杠，则浏览器输入访问地址后，路径最后会自动拼一个斜杠\n    location ^~&#x2F;my_demo&#x2F; &#123;\n      try_files $uri $uri&#x2F; &#x2F;my_demo&#x2F;index.html;\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header Host $http_host;\n      root &#x2F;home&#x2F;web&#x2F;;\n      index index.html index.htm;\n    &#125;\n  &#125;\n&#125;\n\n","slug":"nginx/Nginx常用操作及配置","date":"2022-09-30T15:24:15.000Z","categories_index":"Nginx","tags_index":"Nginx","author_index":"ChrisWood"}]